<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Manjusaka</title>
  
  <subtitle>写代码的香港记者</subtitle>
  <link href="https://manjusaka.blog/atom.xml" rel="self"/>
  
  <link href="https://manjusaka.blog/"/>
  <updated>2023-06-22T16:36:06.203Z</updated>
  <id>https://manjusaka.blog/</id>
  
  <author>
    <name>Manjusaka</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为什么奥特曼是我的信仰</title>
    <link href="https://manjusaka.blog/posts/2023/06/19/why-do-I-love-ultraman/"/>
    <id>https://manjusaka.blog/posts/2023/06/19/why-do-I-love-ultraman/</id>
    <published>2023-06-19T20:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.203Z</updated>
    
    <content type="html"><![CDATA[<p>突然着想写一篇文章，聊聊我所信仰的奥特曼。ウルトラマン大好きだ</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>今年对于我来说其实是挺 tough 的一年，双相的病情反反复复。自残的行为也重新出现。特别是在今年3月之后，我某种意义上的心理防线一度被击穿。</p><p>熟悉我的朋友可能已经反应过来了。没错，3月24日，杰克奥特曼人间体乡秀树扮演者团时郎先生的离世，实际上给了我不小的打击。</p><p>我依旧还记得那天的情景。在一个朋友给我转发了日媒报道乡秀树先生3月22日离世的消息后，当时嘣的一声，我脑子里的弦仿佛断了一根。眼泪就不由自主的流了下来。我甚至一度都没有反应过来我在流泪这件事。直到我妹子发现了我的异常问我怎么了。我才反应过来，原来我在流泪。当天实际上我一度无法正常工作了（即便现在，我回想起来也有点泪目），后面算是勉强打起精神，给当天的工作收尾。</p><p>实际上这件事对我的影响贯穿到现在，导致我4月/5月情绪非常的波动。我曾经给我设置了几道心理的防线，其中一道是和奥特曼相关的，然后这道防线在当时被击穿了。</p><p>实际上团时郎先生的逝世应该是个导火索。早在去年5月份，我最喜欢的奥系列中的一位演员渡边裕之先生（盖亚奥特曼中石室指挥官，我认为特摄史上塑造的最成功的人物之一）在公寓里自杀的消息实际上也深深的刺痛了我。只是当时的我没想到，事隔一年后，我还会迎来另外一位人物的离世。</p><p>很多人可能会很疑惑，为什么我会如此喜欢奥特曼。</p><p>这里我要更正一点，我不是喜欢奥特曼，而是“奥特曼是我的信仰”，或者说，我信仰着奥特精神。</p><p>这样一个信仰的形成，其实要追溯到我的过往。</p><p>我之前在博客上分享过，我在2007年初遭到了同性的强奸。虽然在后续父母对我保护的很好。但是因为事件之初没有进行相应的心理干涉。实际上这件事的诱发的 PTSD 一直持续到了现在。而在初高中，即我人生13-18岁这五年三观的成型期，强奸事件带来的残缺感与孤独感一直伴随着我（我其实是个很怕社交的人，没想到吧）。同时，这样一份残缺感+我并不愿意和父母做太多的沟通，导致我这个时期的阴暗的一面非常严重。你可能能想到的暴戾，自残，嗜血（比如时常扣掉伤疤舔血）的一面都在我身上存在。可能和新闻上人物的区别在于当时的我没去实施。如果这样发展下去，可能现在你们就会在新闻上看到我了。</p><p>所幸，这个世界上真的存在奥特曼</p><p>在这五年的时间里，我时常在苦闷，烦恼，暴戾情绪严重的时候，逃课或请假，找个奶茶店或者网吧（是的，我去网吧不打游戏），点点吃得，然后坐着看一天奥特曼。</p><p>这样一天天过去吗，我心里曾经空掉的东西，被一点点填了回来。某种意义上来说，奥特曼，或者说奥特精神是构成了我这个人现在所表现出来的一切正面元素的基石。</p><p>可能有很多人会问，奥特精神，到底是什么？这里我引用来自艾斯奥特曼最终话的台词，应该就能做出很好的解释</p><blockquote><p>優しさを失わないでくれ。弱い者を労り互いに助け合い。<br>どこの国の人とも友達になろうとする気持ちを失わないでくれ。<br>たとえその気持ちが何百回裏切られようとも。<br>それが私の最後の願いだ。<br>热忱之心不可泯灭。要体恤、帮助弱者。<br>与任何国家的人都能成为朋友，别失去这份热心，纵使它已被背叛了千百回。<br>这就是我最后的愿望。</p></blockquote><p>贯穿奥特曼全系列的，就是这样一份热忱之心，一份坚守的精神，一份不屈不挠的意志。这份精神，也是我一直以来所追求的。</p><p>这里我推荐大家如果有兴趣可以去看一下下面两作</p><ol><li>盖亚奥特曼第39话 悲しみの沼/悲伤的沼泽</li><li>赛文奥特曼98/99 OVA</li></ol><p>我觉得如果大家能看完，实际上会对奥系列一直传达的希望，反战，和平，理解，爱有非常深刻的感触。</p><p>13-18岁，这人生很关键的五年，奥特曼陪伴了我。基本上塑造了我现在的很大一部分人格和认知（我现在依旧坚信着平行世界一定存在的奥特曼的Hhhhh）。也会实际上影响我做事的方式。想做什么坏事的时候，心里想想，这可能不奥特精神。在帮不帮人犹犹豫豫的时候，我想如果做了那么奥特曼一定会替我开心的。</p><p>我一个好友这样评论我的想法（大家别说我幼稚啊）：很多人只是会把你这些想法抽象为佛主，或者上帝。而你只是抽象成奥特曼而已。</p><p>Exactly！</p><p>之前有推特上有懂哥跳出来评价</p><p><img src="https://user-images.githubusercontent.com/7054676/170878363-111b42b2-4471-47d2-8551-0b9b3650493c.png" alt="懂哥"></p><p>没错，我就喜欢了，我就傻逼了，怎么了？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>随便碎碎念了一下，算是让心里一些一直想说的话说了出来（好受了许多）</p><p>谨以此文，献给团时郎先生，献给渡边裕之先生，献给我所深爱并信仰着的奥特曼。</p><p>如果有人能认识历年的主演们，请替我给他们转达一句话：谢谢你们，谢谢你们塑造的奥特曼拯救了我</p><p>最后的最后：ウルトラマン大好きだ</p>]]></content>
    
    
    <summary type="html">優しさを失わないでくれ。弱い者を労り互いに助け合い。</summary>
    
    
    
    <category term="人生" scheme="https://manjusaka.blog/categories/%E4%BA%BA%E7%94%9F/"/>
    
    <category term="杂记" scheme="https://manjusaka.blog/categories/%E4%BA%BA%E7%94%9F/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="人生" scheme="https://manjusaka.blog/tags/%E4%BA%BA%E7%94%9F/"/>
    
    <category term="杂记" scheme="https://manjusaka.blog/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>家庭 Homelab 升级计划</title>
    <link href="https://manjusaka.blog/posts/2023/06/16/how-do-I-build-homelab/"/>
    <id>https://manjusaka.blog/posts/2023/06/16/how-do-I-build-homelab/</id>
    <published>2023-06-16T16:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.199Z</updated>
    
    <content type="html"><![CDATA[<p>最近家庭升级 Homelab 差不多告一段落，来写篇文章记录下我的折腾过程</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>熟悉我的朋友都知道，我是个 SRE，所以吧，对于家里的网络环境质量要求非常高。一直以来，我家的网络环境都在不断的迭代，不过我的网络环境一直围绕三个方向迭代</p><ol><li>稳定性毫无疑问的是第一要素，网络炸了，我就没法工作了</li><li>需要有足够优秀的内网速度，因为我有一些 NAS 之类的服务，承担我流媒体的需求</li><li>需要有一个可靠网关，来根据 GEO 和规则对于不同的流量做处理。</li><li>我家 IoT，电脑等移动设备的数量非常多，那么需要热点有足够的性能来保证网络的质量</li></ol><p>那么围绕这个，从今年开始，我围绕 Homelab 做了一系列的演进</p><h3 id="阶段1-机柜与有线-Mesh"><a href="#阶段1-机柜与有线-Mesh" class="headerlink" title="阶段1: 机柜与有线 Mesh"></a>阶段1: 机柜与有线 Mesh</h3><p>在今年4月搬到新家后，借着要重新安排所有东西的机会，我重新构造了家里的网络</p><p>首先来讲，从全屋的无线热点上，我做了这样的演进</p><ol><li>引入了 TPLink 一个8口的千兆交换机，来扩展端口</li><li>引入了 TPLink XDR 6080 和我原本的 XDR 10280 来做有线 Mesh</li></ol><p>在经过这样的改造后，我家里的网络结构变成了这样的模式</p><ol><li>从光猫往下，一根线走向原本的小米 AX3600 作为家里 IoT 设备的联网端。另一根走向一个 Intel 6305+ 8GRAM 的 x86 机器。在 X86 机器上，我会根据 GEO 规则，对于不同的流量包做一些处理，同时会对 DNS 做 AD 过滤。</li><li>从 x86机器往下，那么接入 交换机+路由器 x3 成为家里的主干网。</li></ol><p>另外，今年六月，好友赠送了我一个 Intel 12代 i7 的满配 NUC ，我自己也采购了两台零刻的机器做为家里的 NUC 集群，上面跑一些 Kubernetes 之类的自己用来测试的服务。</p><p>整体效果如下</p><p><img src="https://i.imgur.com/42S0PH1.jpeg" alt="v1"></p><p>从上往下：</p><ol><li>NUC</li><li>交换机&amp;光猫</li><li>x86 网关 &amp; UPS</li><li>群晖 DS1821+</li></ol><p>但是在现有结构下，还存在一些问题</p><ol><li>TPLink 交换机易用性极差，要设置比如链路聚合之类的非常头疼</li><li>路由器非常不美观，</li><li>x86 网关一旦 crash，如果我需要恢复网络，那么只能物理跳线。</li></ol><p>基于这样一些逻辑，我考虑进行如下改造</p><ol><li>替换交换机</li><li>将无线路由有线 Mesh 的方案切换为 AC+AP 的方案</li><li>将 x86 网关作为旁路网关</li></ol><h3 id="阶段2-更大的机柜，更好的设备"><a href="#阶段2-更大的机柜，更好的设备" class="headerlink" title="阶段2: 更大的机柜，更好的设备"></a>阶段2: 更大的机柜，更好的设备</h3><p>基于上面的一些考虑，在经过多方面选择后，我选择 UBNT 作为我的接入设备</p><p>整体的理由如下：</p><ol><li>性能不错</li><li>易用性极强</li><li>整体的设备美观度极高</li></ol><p>所以最开始设备的选择如下</p><ol><li>UDM-Pro 作为主路由</li><li>USW-24-Pro-POE 作为交换机</li><li>U6-Mesh <em> 2 + U6-IW </em> 2 作为 AP</li></ol><p>然后整体的效果如下</p><p><img src="https://i.imgur.com/kXgbRQa.jpeg" alt="v2"></p><p>但是在使用几天后，我发现了新的问题：我对容量的预估严重不足！</p><p>实际上千兆交换机理论吞吐是 1Gbps，但是实际上来说，刨除协议开销，有效负荷的速率大概在 940Mbps 左右。而这一点实际上对我现在的一些使用场景是有所不足的。比如在 PC 端转码然后回传 NAS 之类的。</p><p>而我目前又没有 10Gbps 常态化的传输需求。经过慎重考虑后，我决定将家中局域网的上限提升至 2.5Gbps。这样能达成性能与易用性的平衡点</p><p>那么我的设备选择如下、</p><ol><li>主路路由替换至 UDM-SE</li><li>交换机替换至 USE-Enterprise-24-POE</li><li>AP 替换两个为 U6-Enterprise-IW</li></ol><p>整体效果如下</p><p><img src="https://i.imgur.com/zIOH0Cr.jpeg" alt="v3"></p><p>当然中间穿插的小插曲是，在升级 2000M/200M 宽带后，我将家里的光猫替换成猫棒直接在主路由上接入光纤</p><p>然后我在网络上划分了三个 vlan</p><ol><li>192.168.0.1/16 作为工作网段，其中网关会指向 x86 机器</li><li>10.0.0.1/16 为日常网段，确保 x86 机器挂了不会影响其余设备</li><li>172.28.0.1/16 为 IoT 网段，给家里的 IOT 设备使用</li><li>中间添加了防火墙策略，确保 IoT 网段无法访问工作网段和日常网段的设备</li></ol><p>最后整体的网速差不多是这样</p><p><img src="https://i.imgur.com/RDmbgjU.png" alt="内网"></p><p><img src="https://i.imgur.com/2uaxhtt.png" alt="公网"></p><p>整体的拓扑如下</p><p><img src="https://i.imgur.com/NdDUnS5.png" alt="拓扑1"></p><p><img src="https://i.imgur.com/Un04brM.png" alt="拓扑2"></p><p>差不多就是这样</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过改造，我相信这样的整体结构能够满足我使用很长时间。当然估计有很多人不理解为啥我租房还要这么折腾。我想除了职业习惯的原因以外，也还是想给自己的日常生活找点乐子。毕竟房子是租的，但是生活不是。</p>]]></content>
    
    
    <summary type="html">人生嘛，Homelab 图个乐子</summary>
    
    
    
    <category term="Homelab" scheme="https://manjusaka.blog/categories/Homelab/"/>
    
    
    <category term="Linux" scheme="https://manjusaka.blog/tags/Linux/"/>
    
    <category term="笔记" scheme="https://manjusaka.blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="水文" scheme="https://manjusaka.blog/tags/%E6%B0%B4%E6%96%87/"/>
    
    <category term="Homelab" scheme="https://manjusaka.blog/tags/Homelab/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊 IaC：Infrastructure as Code</title>
    <link href="https://manjusaka.blog/posts/2023/03/12/a-simple-introduction-about-iac/"/>
    <id>https://manjusaka.blog/posts/2023/03/12/a-simple-introduction-about-iac/</id>
    <published>2023-03-12T13:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.199Z</updated>
    
    <content type="html"><![CDATA[<p>实际上 IaC 这个概念的出现已经很久了，所以写篇水文来简单聊聊 IaC 的过去，现在，和将来</p><span id="more"></span><h2 id="IaC-的过去"><a href="#IaC-的过去" class="headerlink" title="IaC 的过去"></a>IaC 的过去</h2><p>实际上 IaC 的历史其实足够悠久。首先来看一下 IaC 的核心的特征</p><ol><li>最终的产物是 machine readable 的的产物。可能是一份代码，也可能是一份配制文件</li><li>基于 machine readable 的产物，可以进一步依赖已有的 VCS 系统（SVN，Git）等做版本管理</li><li>基于 machine readable 的产物，可以进一步依赖已有的 CI/CD 系统（Jenkins，Travis CI）等做持续集成/持续交付</li><li>状态的一致性，或者称为幂等性。即理论上来讲，基于同样一份 Code，同一套参数构建出的产物，其最终的行为应该是一致的</li></ol><p>实际上通过 IaC 这样的一些核心特征，我们现在能明白 IaC 兴起的原因。IaC 实际上的兴起，大背景是在千禧年之后，互联网世界迭代的速度愈发的快速，这个时候传统的手工式的维护面临着几个问题</p><ol><li>交互式变更所引入的人的因素太大，导致了变更的不可控性</li><li>人工变更面对愈发快速的 Infra 迭代力有不逮</li><li>交互式的变更导致管控的难做，让版本控制之类的手段变为空谈</li></ol><p>在这样的时代背景下，大家都在追求用更技术，更优雅的手段来解决这些问题。于是，IaC 这个概念就出现了</p><p>如果说要将 IaC 分为几个阶段的话，那么我觉得可以分为以下几个阶段</p><ol><li>刀根火种阶段</li><li>现代化的 IaC</li></ol><p>如同前面所说，IaC 实际上是一个自发的驱动，在面对不确定的时候，我们选择用代码来尽可能的消泯掉不确定性（实际上这个原则一直贯穿到现在）</p><p>那么在最早期，人们选择用最基础的代码的形式，来完成 IaC 的工作。其特征是对于之前的各种交互式的手段的精确化，程序化的描述。人们可能会选择直接用 bash 来解决这一切（祖传的来路不明的 bash 脚本.jpg），也可能会基于 Python Fabric 这样的框架进行简单的封装来完成所需的程序化描述的工作。</p><p>但是我们回头去看这一阶段，我们能直观的感受到一些缺陷</p><ol><li>代码复用性较差</li><li>各家都有一套祖传的 IaC 基建，没有统一的行业标准，导致新人入门门槛较高</li></ol><p>所以在面对这样一套的问题的时候。更现代化的 IaC 设施应运而生。其中典型的一些产物是</p><ol><li>Ansible</li><li>Chef</li><li>Puppet</li></ol><p>实际上这些工具，可能设计上各有所取舍（比如 Pull/Push 模型的取舍），但是其核心的特征不会变化</p><ol><li>框架内部提供了常见的比如 SSH 链接管理，多机并行执行，auto retry 等功能</li><li>基于上面描述的这一套基础功能，提供了一套 DSL 封装。让开发者更专注于 IaC 的逻辑，而非基础层面的细节</li><li>其开源开放，并形成了一套完善的插件机制。社区可以基于这一套提供更丰富的生态。比如 SDN 社区基于 ANSIBLE 提供了各种交换机的 playbook 等</li></ol><p>那么截至到现在，实际上 IaC 的发展其实到了一个相对完备的程度。其中不少工具，也依旧贯穿到了现在。</p><h2 id="新生代的-IaC"><a href="#新生代的-IaC" class="headerlink" title="新生代的 IaC"></a>新生代的 IaC</h2><p>从2006年8月25日，Amazon 正式宣布提供了 EC2 服务开始。整个基础设施开始快步向 Cloud 时代迈进。截止到目前，各家云厂商提供了各种各样的服务。通过十多年的演进，也诞生出了诸如 IaaS，PaaS，DaaS，FaaS 等等各种各样的服务模式。这些服务模式，让我们的基础设施的构建，变得更加的简单，更加的快速。但是这些服务模式，也带来了一些新的问题。</p><p>可能写到这里，有同学已经能意识到了问题的所在：在获取算力，获取资源越来越快捷的当下。我们怎么样去管理这样一些资源？</p><p>那么要解决这样的问题，我们似乎又需要去考虑怎么样用代码或者可声明式的配置来管理这些资源。有没有一点眼熟，历史始终就是一个圈圈.jpg</p><p>在起初的时候，我们各自会选择基于各家云厂商提供的 API 与 SDK 自行封装一套 IaC 工具，如同前面所说的一样。这样会带来一些额外的问题：</p><ol><li>代码复用性较差</li><li>各家都有一套祖传的 IaC 基建，没有统一的行业标准，导致新人入门门槛较高</li></ol><p>那么这个时候，云时代的，面向云资源管理的新型 IaC 工具的需求也愈发的迫切。这个时候，Terraform 这样的新型工具应运而生</p><p>在 Terraform 里，可能一台 EC2 Instance 的开启可能就是这样的一段简短的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_vpc&quot; &quot;my_vpc&quot; &#123;</span><br><span class="line">  cidr_block = &quot;172.16.0.0/16&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;tf-example&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_subnet&quot; &quot;my_subnet&quot; &#123;</span><br><span class="line">  vpc_id            = aws_vpc.my_vpc.id</span><br><span class="line">  cidr_block        = &quot;172.16.10.0/24&quot;</span><br><span class="line">  availability_zone = &quot;us-west-2a&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;tf-example&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_network_interface&quot; &quot;foo&quot; &#123;</span><br><span class="line">  subnet_id   = aws_subnet.my_subnet.id</span><br><span class="line">  private_ips = [&quot;172.16.10.100&quot;]</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;primary_network_interface&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;foo&quot; &#123;</span><br><span class="line">  ami           = &quot;ami-005e54dee72cc1d00&quot; # us-west-2</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line"></span><br><span class="line">  network_interface &#123;</span><br><span class="line">    network_interface_id = aws_network_interface.foo.id</span><br><span class="line">    device_index         = 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  credit_specification &#123;</span><br><span class="line">    cpu_credits = &quot;unlimited&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个基础上，我们可以继续将我们诸如 Database，Redis，MQ 等基础设施都进行代码化/描述式配置化，进而提升我们对资源维护的有效性。</p><p>同时，随着各家 SaaS 的发展，研发人员也尝试着将这些 SaaS 服务也进行代码化/描述式配置化。以 Terraform 为例，我们可以通过 Terraform 的 Provider 来进行对接。比如 <a href="https://newrelic.com/">newrelic</a> 提供的 <a href="https://registry.terraform.io/providers/newrelic/newrelic/latest/docs">Provider</a>，<a href="https://www.bytebase.com/">Bytebase</a> 提供的 <a href="https://registry.terraform.io/providers/bytebase/bytebase/latest/docs">Provider</a> 等等</p><p>同时，在 IaC 工具帮助我们完成基础设施描述的标准化之后，我们在此基础上能做更多有趣的事情。比如我们可以基于 <a href="https://www.infracost.io/">Infracost</a> 来计算每次资源变更所带来的资源花费变更。基于 <a href="https://www.runatlantis.io/">atlantis</a> 来完成集中式的资源变更等等进阶的工作。</p><p>那么到现在为止，我们已有的 IaC 产品的选择足够多，能满足我们大部分需求。那么是不是 IaC 整个产品的发展实际上就已经到了一个相对完备的程度呢？答案很明显是否定的</p><h2 id="未来的-IaC"><a href="#未来的-IaC" class="headerlink" title="未来的 IaC"></a>未来的 IaC</h2><p>所以这张主要来聊聊当下 IaC 产品所面临的一些问题，以及我对未来的一些思考吧</p><h3 id="缺陷一：现有基于-DSL-的语法体系的缺陷"><a href="#缺陷一：现有基于-DSL-的语法体系的缺陷" class="headerlink" title="缺陷一：现有基于 DSL 的语法体系的缺陷"></a>缺陷一：现有基于 DSL 的语法体系的缺陷</h3><p>先给大家看一个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  dns_records = &#123;</span><br><span class="line">    # &quot;demo0&quot; : 0,</span><br><span class="line">    &quot;demo1&quot; : 1,</span><br><span class="line">    &quot;demo2&quot; : 2</span><br><span class="line">    &quot;demo3&quot; : 3,</span><br><span class="line">  &#125;</span><br><span class="line">  lb_listener_port  = 80</span><br><span class="line">  instance_rpc_port = 9545</span><br><span class="line"></span><br><span class="line">  default_target_group_attr = &#123;</span><br><span class="line">    backend_protocol     = &quot;HTTP&quot;</span><br><span class="line">    backend_port         = 9545</span><br><span class="line">    target_type          = &quot;instance&quot;</span><br><span class="line">    deregistration_delay = 10</span><br><span class="line">    protocol_version     = &quot;HTTP1&quot;</span><br><span class="line">    health_check = &#123;</span><br><span class="line">      enabled             = true</span><br><span class="line">      interval            = 15</span><br><span class="line">      path                = &quot;/status&quot;</span><br><span class="line">      port                = 9545</span><br><span class="line">      healthy_threshold   = 3</span><br><span class="line">      unhealthy_threshold = 3</span><br><span class="line">      timeout             = 5</span><br><span class="line">      protocol            = &quot;HTTP&quot;</span><br><span class="line">      matcher             = &quot;200-499&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;alb&quot; &#123;</span><br><span class="line">  source  = &quot;terraform-aws-modules/alb/aws&quot;</span><br><span class="line">  version = &quot;~&gt; 6.0&quot;</span><br><span class="line"></span><br><span class="line">  name                       = &quot;alb-demo-internal-rpc&quot;</span><br><span class="line">  load_balancer_type         = &quot;application&quot;</span><br><span class="line">  internal                   = true</span><br><span class="line">  enable_deletion_protection = true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  http_tcp_listeners = [</span><br><span class="line">    &#123;</span><br><span class="line">      protocol           = &quot;HTTP&quot;</span><br><span class="line">      port               = local.lb_listener_port</span><br><span class="line">      target_group_index = 0</span><br><span class="line">      action_type        = &quot;forward&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  http_tcp_listener_rules = concat([</span><br><span class="line">    for rec, pos in local.dns_records : &#123;</span><br><span class="line">      http_tcp_listener_index = 0</span><br><span class="line">      priority                = 105 + tonumber(pos)</span><br><span class="line">      actions = [</span><br><span class="line">        &#123;</span><br><span class="line">          type               = &quot;forward&quot;</span><br><span class="line">          target_group_index = tonumber(pos)</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">      conditions = [</span><br><span class="line">        &#123;</span><br><span class="line">          host_headers = [&quot;$&#123;rec&#125;.manjusaka.me&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ], [&#123;</span><br><span class="line">      http_tcp_listener_index = 0</span><br><span class="line">      priority                = 120</span><br><span class="line">      actions = [</span><br><span class="line">        &#123;</span><br><span class="line">          type = &quot;weighted-forward&quot;</span><br><span class="line">          target_groups = [</span><br><span class="line">            &#123;</span><br><span class="line">              target_group_index = 0</span><br><span class="line">              weight             = 95</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              target_group_index = 5</span><br><span class="line">              weight             = 4</span><br><span class="line">            &#125;,</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">      conditions = [</span><br><span class="line">        &#123;</span><br><span class="line">          host_headers = [&quot;demo0.manjusaka.me&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">  &#125;])</span><br><span class="line"></span><br><span class="line">  target_groups = [</span><br><span class="line">    merge(</span><br><span class="line">      &#123;</span><br><span class="line">        name_prefix = &quot;demo0&quot;</span><br><span class="line">        targets = &#123;</span><br><span class="line">          &quot;demo0-$&#123;module.ec2_instance_demo[0].tags_all[&quot;Name&quot;]&#125;&quot; = &#123;</span><br><span class="line">            target_id = module.ec2_instance_demo[0].id</span><br><span class="line">            port      = local.instance_rpc_port</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      local.default_target_group_attr,</span><br><span class="line">    ),</span><br><span class="line">    merge(</span><br><span class="line">      &#123;</span><br><span class="line">        name_prefix = &quot;demo1&quot;</span><br><span class="line">        targets = &#123;</span><br><span class="line">          &quot;demo1-$&#123;module.ec2_instance_demo[0].tags_all[&quot;Name&quot;]&#125;&quot; = &#123;</span><br><span class="line">            target_id = module.ec2_instance_demo[0].id</span><br><span class="line">            port      = local.instance_rpc_port</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      local.default_target_group_attr,</span><br><span class="line">    ),</span><br><span class="line">    merge(</span><br><span class="line">      &#123;</span><br><span class="line">        name_prefix = &quot;demo2&quot;</span><br><span class="line">        targets = &#123;</span><br><span class="line">          &quot;demo2-$&#123;module.ec2_family_c[0].tags_all[&quot;Name&quot;]&#125;&quot; = &#123;</span><br><span class="line">            target_id = module.ec2_family_c[0].id</span><br><span class="line">            port      = local.instance_rpc_port</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      local.default_target_group_attr,</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    merge(</span><br><span class="line">      &#123;</span><br><span class="line">        name_prefix = &quot;demo3&quot;</span><br><span class="line">        targets = &#123;</span><br><span class="line">          &quot;demo3-$&#123;module.ec2_family_d[0].tags_all[&quot;Name&quot;]&#125;&quot; = &#123;</span><br><span class="line">            target_id = module.ec2_family_d[0].id</span><br><span class="line">            port      = local.instance_rpc_port</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      local.default_target_group_attr,</span><br><span class="line">    ), # target_group_index_3</span><br><span class="line">    merge(</span><br><span class="line">      &#123;</span><br><span class="line">        name_prefix = &quot;demonew&quot;</span><br><span class="line">        targets = &#123;</span><br><span class="line">          &quot;demo0-$&#123;module.ec2_instance_reader[0].tags_all[&quot;Name&quot;]&#125;&quot; = &#123;</span><br><span class="line">            target_id = module.ec2_instance_reader[0].id</span><br><span class="line">            port      = local.instance_rpc_port</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      local.default_target_group_attr,</span><br><span class="line">    ),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段 TF 配置描述虽然看起来长，但是实际上做的事很简单，根据不同的域名 <code>*.manjusaka.me</code> 将流量转发到不同的 instance 上。然后对于 <code>demo0.manjusaka.me</code> 这个域名，进行单独的流量灰度处理。</p><p>我们能发现，Terrafrom 这种 DSL 的解决方案所需要面临的问题就是在对于这种动态灵活的场景下，其表达能力将会有很大的局限性。</p><p>社区也充分意识到了这个问题。所以类似 Pulumi 这种基于 Python/Lua/Go/TS 等完整的编程语言的 IaC 产品就应运而生了。比如我们用 Pulumi + Python 改写上面的例子(此处由 ChatGPT 提供技术支持)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pulumi_aws <span class="keyword">import</span> alb</span><br><span class="line"></span><br><span class="line">dns_records = &#123;</span><br><span class="line">    <span class="comment"># &quot;demo0&quot; : 0,</span></span><br><span class="line">    <span class="string">&quot;demo1&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;demo2&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;demo3&quot;</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">lb_listener_port = <span class="number">80</span></span><br><span class="line">instance_rpc_port = <span class="number">9545</span></span><br><span class="line"></span><br><span class="line">default_target_group_attr = &#123;</span><br><span class="line">    <span class="string">&quot;backend_protocol&quot;</span>: <span class="string">&quot;HTTP&quot;</span>,</span><br><span class="line">    <span class="string">&quot;backend_port&quot;</span>: <span class="number">9545</span>,</span><br><span class="line">    <span class="string">&quot;target_type&quot;</span>: <span class="string">&quot;instance&quot;</span>,</span><br><span class="line">    <span class="string">&quot;deregistration_delay&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">&quot;protocol_version&quot;</span>: <span class="string">&quot;HTTP1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;health_check&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;enabled&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;interval&quot;</span>: <span class="number">15</span>,</span><br><span class="line">        <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/status&quot;</span>,</span><br><span class="line">        <span class="string">&quot;port&quot;</span>: <span class="number">9545</span>,</span><br><span class="line">        <span class="string">&quot;healthy_threshold&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="string">&quot;unhealthy_threshold&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="string">&quot;timeout&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">&quot;protocol&quot;</span>: <span class="string">&quot;HTTP&quot;</span>,</span><br><span class="line">        <span class="string">&quot;matcher&quot;</span>: <span class="string">&quot;200-499&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alb_module = alb.ApplicationLoadBalancer(</span><br><span class="line">    <span class="string">&quot;alb&quot;</span>,</span><br><span class="line">    name=<span class="string">&quot;alb-demo-internal-rpc&quot;</span>,</span><br><span class="line">    load_balancer_type=<span class="string">&quot;application&quot;</span>,</span><br><span class="line">    internal=<span class="literal">True</span>,</span><br><span class="line">    enable_deletion_protection=<span class="literal">True</span>,</span><br><span class="line">    http_tcp_listeners=[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;protocol&quot;</span>: <span class="string">&quot;HTTP&quot;</span>,</span><br><span class="line">            <span class="string">&quot;port&quot;</span>: lb_listener_port,</span><br><span class="line">            <span class="string">&quot;target_group_index&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;action_type&quot;</span>: <span class="string">&quot;forward&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    http_tcp_listener_rules=[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;http_tcp_listener_index&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;priority&quot;</span>: <span class="number">105</span> + pos,</span><br><span class="line">            <span class="string">&quot;actions&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;forward&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;target_group_index&quot;</span>: pos,</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;conditions&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;host_headers&quot;</span>: [<span class="string">f&quot;<span class="subst">&#123;rec&#125;</span>.manjusaka.me&quot;</span>],</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> rec, pos <span class="keyword">in</span> dns_records.items()</span><br><span class="line">    ]</span><br><span class="line">    + [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;http_tcp_listener_index&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;priority&quot;</span>: <span class="number">120</span>,</span><br><span class="line">            <span class="string">&quot;actions&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;weighted-forward&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;target_groups&quot;</span>: [</span><br><span class="line">                        &#123;<span class="string">&quot;target_group_index&quot;</span>: <span class="number">0</span>, <span class="string">&quot;weight&quot;</span>: <span class="number">95</span>&#125;,</span><br><span class="line">                        &#123;<span class="string">&quot;target_group_index&quot;</span>: <span class="number">5</span>, <span class="string">&quot;weight&quot;</span>: <span class="number">4</span>&#125;,</span><br><span class="line">                    ],</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;conditions&quot;</span>: [&#123;<span class="string">&quot;host_headers&quot;</span>: [<span class="string">&quot;demo0.manjusaka.me&quot;</span>]&#125;],</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    target_groups=[</span><br><span class="line">        alb.TargetGroup(</span><br><span class="line">            <span class="string">f&quot;demo0-<span class="subst">&#123;module.ec2_instance_demo[<span class="number">0</span>].tags_all[<span class="string">&#x27;Name&#x27;</span>].apply(<span class="keyword">lambda</span> x: x)&#125;</span>&quot;</span>,</span><br><span class="line">            name_prefix=<span class="string">&quot;demo0&quot;</span>,</span><br><span class="line">            targets=[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;target_id&quot;</span>: module.ec2_instance_demo[<span class="number">0</span>].<span class="built_in">id</span>,</span><br><span class="line">                    <span class="string">&quot;port&quot;</span>: instance_rpc_port,</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            **default_target_group_attr,</span><br><span class="line">        ),</span><br><span class="line">        alb.TargetGroup(</span><br><span class="line">            <span class="string">f&quot;demo1-<span class="subst">&#123;module.ec2_instance_demo[<span class="number">0</span>].tags_all[<span class="string">&#x27;Name&#x27;</span>].apply(<span class="keyword">lambda</span> x: x)&#125;</span>&quot;</span>,</span><br><span class="line">            name_prefix=<span class="string">&quot;demo1&quot;</span>,</span><br><span class="line">            targets=[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;target_id&quot;</span>: module.ec2_instance_demo[<span class="number">0</span>].<span class="built_in">id</span>,</span><br><span class="line">                    <span class="string">&quot;port&quot;</span>: instance_rpc_port,</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            **default_target_group_attr,</span><br><span class="line">        ),</span><br><span class="line">        alb.TargetGroup(</span><br><span class="line">            <span class="string">f&quot;demo2-<span class="subst">&#123;module.ec2_family_c[<span class="number">0</span>].tags_all[<span class="string">&#x27;Name&#x27;</span>].apply(<span class="keyword">lambda</span> x: x)&#125;</span>&quot;</span>,</span><br><span class="line">            name_prefix=<span class="string">&quot;demo2&quot;</span>,</span><br><span class="line">            targets=[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;target_id&quot;</span>: module.ec2_family_c[<span class="number">0</span>].<span class="built_in">id</span>,</span><br><span class="line">                    <span class="string">&quot;port&quot;</span>: instance_rpc_port,</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            **default_target_group_attr,</span><br><span class="line">        ),</span><br><span class="line">        alb.TargetGroup(</span><br><span class="line">            <span class="string">f&quot;demo3-<span class="subst">&#123;module.ec2_family_d[<span class="number">0</span>].tags_all[<span class="string">&#x27;Name&#x27;</span>].apply(<span class="keyword">lambda</span> x: x)&#125;</span>&quot;</span>,</span><br><span class="line">            name_prefix=<span class="string">&quot;demo3&quot;</span>,</span><br><span class="line">            targets=[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;target_id&quot;</span>: module.ec2_family_d[<span class="number">0</span>].<span class="built_in">id</span>,</span><br><span class="line">                    <span class="string">&quot;port&quot;</span>: instance_rpc_port,</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            **default_target_group_attr,</span><br><span class="line">        ),</span><br><span class="line">        alb.TargetGroup(</span><br><span class="line">            <span class="string">f&quot;demo0-<span class="subst">&#123;module.ec2_instance_reader[<span class="number">0</span>].tags_all[<span class="string">&#x27;Name&#x27;</span>].apply(<span class="keyword">lambda</span> x: x)&#125;</span>&quot;</span>,</span><br><span class="line">            name_prefix=<span class="string">&quot;demonew&quot;</span>,</span><br><span class="line">            targets=[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;target_id&quot;</span>: module.ec2_instance_reader[<span class="number">0</span>].<span class="built_in">id</span>,</span><br><span class="line">                    <span class="string">&quot;port&quot;</span>: instance_rpc_port,</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            **default_target_group_attr,</span><br><span class="line">        ),</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你看，整体的用法是不是更贴近于我们的使用习惯，其表达力也更好</p><h3 id="缺陷二：和业务需求之间的-Gap"><a href="#缺陷二：和业务需求之间的-Gap" class="headerlink" title="缺陷二：和业务需求之间的 Gap"></a>缺陷二：和业务需求之间的 Gap</h3><p>实际上在云时代的 IaC 工具，更多的去解决的是基础设施的存在性的问题。而对于已有基础设施的编排与更合理的利用实际上是存在比较大的 Gap 的。我们怎么样将应用部署到这些基础资源上。怎么样去调度这些资源。实际上是个很值得玩味的一个问题。</p><p>实际上可能出乎人们的意料，实际上 Kubernetes/Nomad 实际上就在尝试解决这样的问题。可能有人在思考，什么？这个也算是 IaC 工具？毫无疑问的是嘛，不信你对照一下我们前面列的 IaC 的几个核心特征</p><ol><li>最终的产物是 machine readable 的的产物。可能是一份代码，也可能是一份配制文件（YAML 工程师表示认可）</li><li>基于 machine readable 的产物，可以进一步依赖已有的 VCS 系统（SVN，Git）等做版本管理（manifest 随着仓库走）</li><li>基于 machine readable 的产物，可以进一步依赖已有的 CI/CD 系统（Jenkins，Travis CI）等做持续集成/持续交付（argocd 等平台提供了进一步的支持）</li></ol><p>同时我们在对应的配置文件里，可以声明我们所需要 CPU/Mem，需要的磁盘/远程盘，需要的网关等。同时这一套框架实际上将计算 Infra 进行了一个相对通用性的抽象，让业务百分之八十的场景下并不需要去考虑底层 Infra 的细节。</p><p>但是实际上这套已经存在的方案又会存在一些问题。比如其复杂度的飙升，self-hosted 的运维成本，以及一些抽象泄漏带来的问题。</p><h3 id="缺陷三：质量性的偏差"><a href="#缺陷三：质量性的偏差" class="headerlink" title="缺陷三：质量性的偏差"></a>缺陷三：质量性的偏差</h3><p>云时代新生的 IaC，其 scope 相较于传统的诸如 ansible 之类的 IaC 工具范围更大，野心也更大。所带来的副作用就是其质量的偏差。这个话题可以分为两方面说</p><p>第一点来看，诸如 Terraform 这样的 IaC 工具，通过官方提供的 Provider 实现了对 AWS/Azure/GCP 等平台的支持。但是即便是官方支持，其 Provider 里设计的一些逻辑，和平台侧在交互式界面里的设计逻辑并不一致。比如我之前吐槽过“比如 Aurora DB Instance 的 delete protection 在 Console 创建时默认打开，而 TF 里是默认关闭”。这实际上会在使用的时候，给开发者带来额外的心智负担</p><p>第二点来看，IaC 工具极度依赖社区（此处的社区饱含开源社区和各类商业公司）。不同于 Ansible 等老前辈，其周边设施的质量相对稳定。Terraform 等新生代的 IaC 周边的质量一言难尽。比如国内诸如福报云，华为云，腾讯云等厂商提供的 Provider 一直被人诟病。而不少大型的面向研发者的 SaaS 平台没有官方提供的 Provider 等（比如 Newrelic）</p><p>同时，云厂商所提供的一些功能实际上是和通用性 IaC 工具所冲突的。比如 AWS 的 WAF 工具，其中有一个功能是基于 IPSet 进行拦截，这个时候如果 IPSet 非常大，那么使用通用性的 IaC 工具进行描述将会是一个灾难性的存在。这个时候对于类似的场景，只能基于云厂商自己的 SDK 进行封装，云厂商提供的 SDK 质量合格还好。如果像福报云这样的神奇的 SDK 设计的话，那就只能自求多福了。。</p><h3 id="缺陷四：面对开发者体验的不足"><a href="#缺陷四：面对开发者体验的不足" class="headerlink" title="缺陷四：面对开发者体验的不足"></a>缺陷四：面对开发者体验的不足</h3><p>开发者体验实际上现在是一个比较热门的话题。毕竟没有人愿意将自己宝贵的生命来做重复的工作。就目前而言，主要的 IaC 工具都是 For Production Server 的，而不是 For Developer Experience 的，导致我们用的时候，其体验就很一般。</p><p>比如我们现在有一个场景，我们需要在 AWS 上给研发的同学批量开一批 EC2 Instance 作为开发机。怎么样保证研发同学在这些机器上开箱即用，就是很大的一个问题。</p><p>虽然我们可以通过预制镜像等方式提供相对统一的环境。不过我们可能会需要更进一步的去细调环境的话，那么就会比较蛋疼。</p><p>针对于类似的场景，老一点的有 Nix，新一点的有 <a href="https://github.com/tensorchord/envd">envd</a> 来解决这样一些问题。但是目前来讲，还是和已有的 IaC 产品有一些 gap。后续怎么样进行对接可能会是个很有趣的话题。</p><h3 id="缺陷五：面对新型技术栈的一些不足"><a href="#缺陷五：面对新型技术栈的一些不足" class="headerlink" title="缺陷五：面对新型技术栈的一些不足"></a>缺陷五：面对新型技术栈的一些不足</h3><p>最典型的是 Serverless 的场景。比如我举个例子，我现在有个简单的需求，就是用 Lambda 来实现一个简单的 SSR 的渲染</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">BlogPosts</span>(<span class="params">&#123; posts &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> posts.<span class="title function_">map</span>(<span class="function"><span class="params">post</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">BlogPost</span> <span class="attr">key</span>=<span class="string">&#123;post.id&#125;</span> <span class="attr">post</span>=<span class="string">&#123;post&#125;</span> /&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getServerSideProps</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> <span class="title function_">getBlogPosts</span>();</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123; posts &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数本身非常简单，但是如果我们要将这个函数部署到 Production Enviorment 里将会是一个比较麻烦的事。比如我们来思考下我们现在需要为这个简单的函数准备什么样的 infra</p><ol><li>一个 lambda 实例</li><li>一个 S3 bucket</li><li>一个 APIGateway 及路由规则</li><li>接入 CDN （可选）</li><li>DNS 准备</li></ol><p>那么在 IaC Manifest + 业务代码彼此分离的情况下，我们的变更以及资源的管理将会是一个很大的问题。Vercel 在最近的 Blog <a href="https://vercel.com/blog/framework-defined-infrastructure">Framework-defined infrastructure</a> 也描述了这样的问题。我们怎么样能进一步发展为 Domain Code as Infrastructure 将会是未来的一个挑战</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章写了两天，差不多作为自己对于 IaC 这个事物的一些碎碎念（而不是 Terraform Tutorial！（逃。祝大家读的开心</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;实际上 IaC 这个概念的出现已经很久了，所以写篇水文来简单聊聊 IaC 的过去，现在，和将来&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="杂记" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://manjusaka.blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="水文" scheme="https://manjusaka.blog/tags/%E6%B0%B4%E6%96%87/"/>
    
    <category term="SRE" scheme="https://manjusaka.blog/tags/SRE/"/>
    
    <category term="Tools" scheme="https://manjusaka.blog/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>从一个重构项目中能学到什么东西</title>
    <link href="https://manjusaka.blog/posts/2023/01/26/what-I-can-learn-from-a-refactor-project/"/>
    <id>https://manjusaka.blog/posts/2023/01/26/what-I-can-learn-from-a-refactor-project/</id>
    <published>2023-01-26T16:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.203Z</updated>
    
    <content type="html"><![CDATA[<p>本来这篇文章是要在 2022 最后一个工作日前写完的，但是拖延癌发作，到现在才写完。不过还是发出来，希望里面的内容能帮到大家</p><span id="more"></span><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>这个重构项目如果从我第一个超大型重构 PR 算起（22年12月11日），到现在已经历史一个半月了。目前重构进度已经超过了 80%，超过6+位贡献者集体贡献。这绝对是个不小的工程了</p><p>那问题来了，我为什么要发起这个重构项目呢？</p><p>在重构项目之前，nerdctl 项目存在一个很大的问题，即 command 的入口处，flag 的处理和逻辑耦合的问题，比如用 <code>nerdctl apparmor</code> 系列的代码来举一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;text/tabwriter&quot;</span></span><br><span class="line"><span class="string">&quot;text/template&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/containerd/nerdctl/pkg/apparmorutil&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/spf13/cobra&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newApparmorLsCommand</span><span class="params">()</span></span> *cobra.Command &#123;</span><br><span class="line">cmd := &amp;cobra.Command&#123;</span><br><span class="line">Use:           <span class="string">&quot;ls&quot;</span>,</span><br><span class="line">Aliases:       []<span class="type">string</span>&#123;<span class="string">&quot;list&quot;</span>&#125;,</span><br><span class="line">Short:         <span class="string">&quot;List the loaded AppArmor profiles&quot;</span>,</span><br><span class="line">Args:          cobra.NoArgs,</span><br><span class="line">RunE:          apparmorLsAction,</span><br><span class="line">SilenceUsage:  <span class="literal">true</span>,</span><br><span class="line">SilenceErrors: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">cmd.Flags().BoolP(<span class="string">&quot;quiet&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;Only display profile names&quot;</span>)</span><br><span class="line"><span class="comment">// Alias &quot;-f&quot; is reserved for &quot;--filter&quot;</span></span><br><span class="line">cmd.Flags().String(<span class="string">&quot;format&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Format the output using the given go template&quot;</span>)</span><br><span class="line">cmd.RegisterFlagCompletionFunc(<span class="string">&quot;format&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>, toComplete <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, cobra.ShellCompDirective) &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">string</span>&#123;<span class="string">&quot;json&quot;</span>, <span class="string">&quot;table&quot;</span>, <span class="string">&quot;wide&quot;</span>&#125;, cobra.ShellCompDirectiveNoFileComp</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apparmorLsAction</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">quiet, err := cmd.Flags().GetBool(<span class="string">&quot;quiet&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">w := cmd.OutOrStdout()</span><br><span class="line"><span class="keyword">var</span> tmpl *template.Template</span><br><span class="line">format, err := cmd.Flags().GetString(<span class="string">&quot;format&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> format &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;&quot;</span>, <span class="string">&quot;table&quot;</span>, <span class="string">&quot;wide&quot;</span>:</span><br><span class="line">w = tabwriter.NewWriter(cmd.OutOrStdout(), <span class="number">4</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> !quiet &#123;</span><br><span class="line">fmt.Fprintln(w, <span class="string">&quot;NAME\tMODE&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;raw&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;unsupported format: \&quot;raw\&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> quiet &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;format and quiet must not be specified together&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">tmpl, err = parseTemplate(format)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">profiles, err := apparmorutil.Profiles()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> profiles &#123;</span><br><span class="line"><span class="keyword">if</span> tmpl != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> b bytes.Buffer</span><br><span class="line"><span class="keyword">if</span> err := tmpl.Execute(&amp;b, f); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err = fmt.Fprintf(w, b.String()+<span class="string">&quot;\n&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> quiet &#123;</span><br><span class="line">fmt.Fprintln(w, f.Name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;%s\t%s\n&quot;</span>, f.Name, f.Mode)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> f, ok := w.(Flusher); ok &#123;</span><br><span class="line"><span class="keyword">return</span> f.Flush()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你能看到在函数 <code>apparmorLsAction</code> 的逻辑中包含了两个部分的东西</p><ol><li>flag 的处理（大道至简的 err 处理（XDDDDD</li><li>command logic 的处理</li></ol><p>这样的设计存在很明显的问题</p><ol><li>代码可读性与可维护性的问题，比如我需要添加一个 flag 的时候，那么需要在多处添加。而且满天飞的 flagging process 会导致提升新人进入项目的门槛</li><li>logic 的处理与 flag 的处理耦合在一起，这样会额外导致如果社区在试图基于 nerdctl 封装一套自定义的 CLI 脚手架的时候，那么会出现非常难处理的情况。</li></ol><p>同时 nercdctl 还存在另外一个问题。在 cmd 的入口处，因为同归属于一个 sub package，于是之前的开发过程中为了省事，文件之间为了省事，交叉引用了彼此的 internal helper function</p><p>在 nerdctl 项目最开始只作为 containerd CLI 的一个替代品的时候。之前的设计缺陷实际上暴露的并不明显。但是 nerdctl 完整提供了一套基于 containerd 的容器生命周期及网络管理（base on CNI）及其余进阶特性（比如 cosign，IPFS 等），开始作为 containerd 实质上的一个入口标准的时候。社区无疑会提出更高的需求。比如 <a href="https://github.com/containerd/nerdctl/issues/1631">Move *.go files for subcommand out main package nerdctl#1631</a> 就是一个很典型的例子。</p><p>在这种情况下，对于 nerdctl 的入口进行一个合理的但是大范围的重构，就是一个必须且迫在眉睫的事了。</p><blockquote><p>又到了<del>白色相薄</del>重构的季节 —- 蛮久抚子（Nadeshiko Manju）</p></blockquote><h2 id="重构过程分析"><a href="#重构过程分析" class="headerlink" title="重构过程分析"></a>重构过程分析</h2><p>好了，社区有需要，saka 哦不，蛮久抚子（Nadeshiko Manju）我就得站出来了，重构嘛，很简单嘛，Goland 搞一搞就完事了嘛。好说好说。于是我有了一个超大的 PR ：<a href="https://github.com/containerd/nerdctl/pull/1639">Refactor the package structure in cmd/nerdctl nerdctl#1639</a>。规模 +5000 -4000</p><p><img src="https://user-images.githubusercontent.com/7054676/214850761-da34600d-a9b0-42de-88e8-97643a27d61d.png" alt="よし、気合いが勝っとる!"></p><p>不过，因为这个 PR 太过于惊世骇俗，在我 COVID-19 Positive 后，Suda 开始帮我 carry 这个 PR。但是最后 Suda 也高呼不可 carry（Suda の惊く：ばか saka！）</p><blockquote><p>どうしてこうなるんだろう…初めて、リファクタリングしたいという欲求があり、リファクタリングの必要性がありました。嬉しいことが二つ重なって。その二つの嬉しさが、また、たくさんの嬉しさを連れてきてくれて。夢のように幸せな時間を手に入れたはずなのに…なのに、どうして、こうなっちゃうんだろう…<br>为什么会变成这样呢，第一次有了想重构的欲望，又有了重构的必要。两件快乐事情重合在一起。而这两份快乐，又给我带来更多的快乐。得到的，本该是像梦境一般幸福的时间……但是，为什么，会变成这样呢…… —— 《nerdctl 相薄》</p></blockquote><p>实际上原因很简单 <del>冬马小三</del> ，哦不是，是我小三，哦，不是，是我脑子被门夹了</p><p>言归正传，其实这个 PR 是个教科书式的反面例子</p><ol><li>在启动大型项目之前没有达成社区的共识</li><li>违背了 One PR for One Thing 的基本原则</li><li>重构时的无关的改动太多，导致 review 难度过大</li></ol><p>所以在吸取了 <a href="https://github.com/containerd/nerdctl/pull/1639">Refactor the package structure in cmd/nerdctl nerdctl#1639</a> 的教训后，我正式在社区提出了一个重构 Proposal <a href="https://github.com/containerd/nerdctl/issues/1680">Let’s refactor the nerdctl CLI package nerdctl#1680</a> ，在这个 Proposal 中我做了几个事情</p><ol><li>完整阐述了重构的必要性，方便社区成员后续回溯</li><li>定义了重构的几个 step</li><li>约定好了多人协作重构时所共同遵守的约定</li></ol><p>社区其余几位 maintainer 在这个 Proposal 下额外讨论了一些细节，并达成了一些共识</p><ol><li>将最终的重构范围缩小为仅处理 flagging process</li><li>优化了一些文件结构的设计</li></ol><p>截止到现在，nerdctl 的重构才算开始正式进入了一个快车道的状态。毕竟重构不是乱写，要是写错了，要向社区谢罪的。</p><p>这里面其实还有个插曲，最开始我在 Issue 中创建 TODO Task 之后，为了方便 track project 的进度，我将这些 TODO Task 直接全部转成了 Issue（然后就相当于给 subscribe 了这个 repo 的老哥们来了一个邮箱 DDOS）。这里不得不吐槽一句，GitHub 的项目管理工具真的很弱诶（XDDDDD</p><p>花开两朵，各表一只，在 Proposal 正式通过了之后，整体的重构就开始进入了快车道了，这里列一些有意思的讨论，大家有兴趣可以去看看</p><ol><li><a href="https://github.com/containerd/nerdctl/pull/1774">Refactor the apparmor flagging process nerdctl#1774</a>，Proposal 接收后的一个模板 PR，在这个 PR 下，继续细化了一些在 Proposal 中讨论没有完善的细节</li><li><a href="https://github.com/containerd/nerdctl/pull/1792">[Refactor] Refactor the build subcommand flagging process nerdctl#1792</a>，Proposal 接收后第一个比较大命令的重构，某种意义上也是一个模板 PR 了，里面就讨论了不少参数设计风格的问题</li><li><a href="https://github.com/containerd/nerdctl/pull/1837">refactor: consolidate main logic of volume.List into volume.Volumes</a>, 不属于 Proposal 原本涵盖的范围内，但是里面关于函数语义设计的讨论值得关注一下</li><li><a href="https://github.com/containerd/nerdctl/issues/1889">pkg/cmd: inconsistent arguments ordering nerdctl#1889</a>，关于函数设计风格的问题。</li></ol><p>当然还有很多 PR 中的讨论也是非常有意思的，这里就不完整列出来了。欢迎大家去直接看原始的 PR（当然欢迎加入讨论）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>差不多就这样吧，大概复盘了一下到现在为止重构过程中的得失。希望大家能喜欢</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本来这篇文章是要在 2022 最后一个工作日前写完的，但是拖延癌发作，到现在才写完。不过还是发出来，希望里面的内容能帮到大家&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://manjusaka.blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="杂记" scheme="https://manjusaka.blog/categories/%E6%8A%80%E6%9C%AF/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="https://manjusaka.blog/tags/%E6%9D%82%E8%AE%B0/"/>
    
    <category term="技术" scheme="https://manjusaka.blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>蓝莲花公益小组简报</title>
    <link href="https://manjusaka.blog/posts/2023/01/19/simple-brief-about-blue-lotus-group/"/>
    <id>https://manjusaka.blog/posts/2023/01/19/simple-brief-about-blue-lotus-group/</id>
    <published>2023-01-19T11:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.199Z</updated>
    
    <content type="html"><![CDATA[<p>愿每个人心里，都盛开着永不凋零的蓝莲花</p><p><img src="https://raw.githubusercontent.com/Zheaoli/do-something-right/71724a0e2de9d49bde5a59d4abf20c8ae3cf3710/assets/logo.svg" alt="logo"></p><span id="more"></span><p>从2021年11月第一次发起刷题公益计划，到现在也一年多时间了。起初是为了让大家有一些特殊的动力去刷题，所以有了这样的基础规则</p><ol><li>1题一元人民币，在打卡后向公益基金捐款。</li></ol><p>基金池最开始由群主承担，后续有超过25位+群友集体捐款</p><p>再后来，这个群就发展成了基于技术的各种闲聊群，推荐番毒害群友群。</p><p>到目前也差不多一年多时间了，写个简报回顾一下</p><h2 id="一、刷题公益计划"><a href="#一、刷题公益计划" class="headerlink" title="一、刷题公益计划"></a>一、刷题公益计划</h2><p>截至目前，从2021年11月开始，到2022年6月作为一个阶段的结束。</p><ol><li>共计捐款 1625 元人民币</li></ol><p>在2022年6月，经过群友同意，再经过一轮扩资后，蓝莲花小组向一个村小项目捐款 6000 元人民币</p><p><img src="https://user-images.githubusercontent.com/7054676/213406866-6de061b8-6394-4bf8-a73b-cf5a0f9c8b19.JPG" alt="村小捐款"></p><p>前不久得到反馈，这笔钱已经用在应该用的地方了。开心</p><h2 id="二-技术分享"><a href="#二-技术分享" class="headerlink" title="二. 技术分享"></a>二. 技术分享</h2><p>从2022年6月开始，群友决定在群内以一周两次的频率进行分享，截至目前举行了八次分享</p><ol><li>SRE 二三事</li><li>当前端在讨论字体时，我们在讨论什么</li><li>编译原理入门到出家</li><li>OLAP 入门出家</li><li>简单聊聊家庭网络</li><li>Homelab 101</li><li>稳定性建设101</li><li>物联网简介</li></ol><h2 id="三-开源项目"><a href="#三-开源项目" class="headerlink" title="三. 开源项目"></a>三. 开源项目</h2><p>截至目前，群友的足迹包括不仅限于</p><ol><li>Vue</li><li>SWR</li><li>containerd</li><li>envd</li></ol><p>2022 年群内也新诞生了两位开源项目的 maintainer</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>时间过的很快，转眼这个群就一年多了。很荣幸能在这个浮躁的时代里认识一些很纯粹的人。2023 一起加油</p><p>最后，<strong>愿每个人心中都能盛开着永不凋零的蓝莲花</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;愿每个人心里，都盛开着永不凋零的蓝莲花&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Zheaoli/do-something-right/71724a0e2de9d49bde5a59d4abf20c8ae3cf3710/assets/logo.svg&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://manjusaka.blog/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="总结" scheme="https://manjusaka.blog/categories/%E9%9A%8F%E7%AC%94/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="随笔" scheme="https://manjusaka.blog/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="总结" scheme="https://manjusaka.blog/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>排查一个特殊的 No space left on device</title>
    <link href="https://manjusaka.blog/posts/2023/01/07/special-case-no-space-left-on-device/"/>
    <id>https://manjusaka.blog/posts/2023/01/07/special-case-no-space-left-on-device/</id>
    <published>2023-01-07T15:30:00.000Z</published>
    <updated>2023-06-22T16:36:06.203Z</updated>
    
    <content type="html"><![CDATA[<p>好久没写水文了，新年第一篇水文总得写一下，完成下 OKR，正好最近帮群友查了一个特殊的 No space left on device 问题，记录一下。</p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>半夜接到群友求助，说自己的测试环境遇到了点问题，正好我还没睡，那就来看一下</p><p>问题的情况很简单，</p><blockquote><p>用 <code>docker run -d  --env-file .oss_env --mount type=bind,src=/data1,dst=/cache &#123;image&#125;</code> 启动了一个容器，然后发现在启动后业务代码报错，抛出 <strong>OSError: [Errno 28] No space left on device</strong> 的异常</p></blockquote><p>这个问题其实很典型，但是最终排查出来的结果确实非典型的。不过排查思路其实应该是很典型的线上问题的一步步分析 root casue 的过程。希望能对看官就帮助</p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>首先群友提供了第一个关键信息，空间有余量，但是就 <strong>OSError: [Errno 28] No space left on device</strong> 。那么熟悉 Linux 的同学可能第一步的排查工作就是排查对应的 inode 情况</p><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -ih</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/7054676/211155731-c54b1146-2daa-48b3-8e1e-294040d73201.png" alt="inode"></p><p>我们能看到 /data1 实际上的 inode 和整机的 inode 数量都是足够的（备注：这里是我自己在我自己的机器上复现问题的截图，第一步由群友完成，然后给我提供了信息）</p><p>那么我们继续排查，我们看到了我们使用了 <a href="#refer-anchor-1">mount bind<sup>1</sup></a> 的方式将宿主机的 /data1 挂载到了容器内部的 /cache 目录下, mount bind 可以用下面一张图来表示和 volume 的区别</p><p><img src="https://docs.docker.com/storage/images/types-of-mounts-bind.png" alt="mount bind"></p><p>都在不同版本的内核上，mount bind 的行为有一些特殊的情况，所以我们需要确认下 mount bind 的情况是否正确，我们用 <a href="#refer-anchor-2">fallocate<sup>2</sup></a> 来创建一个 1G 的文件，然后在容器内部查看文件的大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fallocate -l 10G /cache/test</span><br></pre></td></tr></table></figure><p>文件创建没有问题，实际上我们就可以排除掉 mount bind 的缺陷了</p><p>接着，群友提供了这个盘是云厂商的云盘（经过扩容），我让群友确认下是具体的 ESSD 还是 NAS 这种走 NFS 挂载的 Block Device（这块也有坑）。确认是标准的 ESSD 后进入下一步（驱动的问题可以先排除）</p><p>接着，我们需要考虑 mount —bind 在跨文件系统情况下的问题。虽然前面一步我们成功创建了文件。但是为了保险起见，我们执行 <code>fdisk -l</code> 和 <code>tune2fs -l</code> 两个命令，来确认分区和文件系统的正确性，确认文件系统的类型都是 ext4，那么没有问题。具体两个命令的使用方式参见 <a href="#refer-anchor-3">fdisk<sup>3</sup></a> 和 <a href="#refer-anchor-4">tune2fs<sup>4</sup></a></p><p>然后再回顾我们之前直接在 <code>/cache</code> 下创建问题没有问题，那么这个时候我们心里应该大概有底，这个应该不是代码问题，也不是权限问题（这一步我额外排除镜像的构建里没有额外的用户操作），那么我们需要排除一下扩容的问题。我们将 /data1 unmount 之后，重新 mount 后，再执行容器，发现问题依旧存在，那么我们就可以去排除扩容的问题了。</p><p>现在一些常见的问题已经基本排除，那么我们来考虑文件系统本身的问题。我登录到机器上，执行了以下两个操作</p><ol><li>在出问题的目录 <code>/cache/xxx/</code> 下，我用 <code>fallocate -l</code> 创建一个报错的文件（长文件名），失败</li><li>在出问题的目录 <code>/cache/xxx/</code> 下，我用 <code>fallocate -l</code> 创建一个短文件名），成功 </li></ol><p>OK，我们现在排查路径就往文件系统异常的方向上靠了，执行命令 <a href="#refer-anchor-5">dmesg<sup>5</sup></a> 查看内核日志，发现了如下错误</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[13155344.231942] EXT4-fs warning (device sdd): ext4_dx_add_entry:2461: Directory (ino: 3145729) index full, reach max htree level :2</span><br><span class="line">[13155344.231944] EXT4-fs warning (device sdd): ext4_dx_add_entry:2465: Large directory feature is not enabled on this filesystem</span><br></pre></td></tr></table></figure><p>OK，我们期待的异常信息找到了。原因是，ext4 基于的 BTree 索引，默认情况下只允许树的层高为2，实际上就大概限制了目录下的文件数量大概在 2k-3kw 以内。经过确认，这个问题目录下的确有大量小文件。我们再用 <code>tune2fs -l</code> 确认下是否是如我们猜想，得到结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filesystem revision #:    1 (dynamic)</span><br><span class="line">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum</span><br><span class="line">Filesystem flags:         signed_directory_hash</span><br></pre></td></tr></table></figure><p>bingo，的确没有开启 <code>large_dir</code> 的选项。那么我们执行 <code>tune2fs -O large_dir /dev/sdd</code> 开启这个选项，然后再次执行 <code>tune2fs -l</code> 确认下，发现已经开启了。然后我们再次执行容器，发现问题已经解决。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>上面的问题排查看似告一段落。但是实际上并没有闭环。一个问题的闭环有两个特征</p><ol><li>定位到具体的异常代码</li><li>有最小可复现版本确认我们找到 root cause 是符合预期的。</li></ol><p>从上面 dmesg 的信息我们能定位到内核中的函数，其实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ext4_dx_add_entry</span><span class="params">(<span class="type">handle_t</span> *handle, <span class="keyword">struct</span> ext4_filename *fname,</span></span><br><span class="line"><span class="params">     <span class="keyword">struct</span> inode *dir, <span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dx_frame</span> <span class="title">frames</span>[<span class="title">EXT4_HTREE_LEVEL</span>], *<span class="title">frame</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dx_entry</span> *<span class="title">entries</span>, *<span class="title">at</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> dir-&gt;i_sb;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_dir_entry_2</span> *<span class="title">de</span>;</span></span><br><span class="line"><span class="type">int</span> restart;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">restart = <span class="number">0</span>;</span><br><span class="line">frame = dx_probe(fname, dir, <span class="literal">NULL</span>, frames);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(frame))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(frame);</span><br><span class="line">entries = frame-&gt;entries;</span><br><span class="line">at = frame-&gt;at;</span><br><span class="line">bh = ext4_read_dirblock(dir, dx_get_block(frame-&gt;at), DIRENT_HTREE);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(bh)) &#123;</span><br><span class="line">err = PTR_ERR(bh);</span><br><span class="line">bh = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BUFFER_TRACE(bh, <span class="string">&quot;get_write_access&quot;</span>);</span><br><span class="line">err = ext4_journal_get_write_access(handle, sb, bh, EXT4_JTR_NONE);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line"></span><br><span class="line">err = add_dirent_to_buf(handle, fname, dir, inode, <span class="literal">NULL</span>, bh);</span><br><span class="line"><span class="keyword">if</span> (err != -ENOSPC)</span><br><span class="line"><span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* Block full, should compress but for now just split */</span></span><br><span class="line">dxtrace(printk(KERN_DEBUG <span class="string">&quot;using %u of %u node entries\n&quot;</span>,</span><br><span class="line">       dx_get_count(entries), dx_get_limit(entries)));</span><br><span class="line"><span class="comment">/* Need to split index? */</span></span><br><span class="line"><span class="keyword">if</span> (dx_get_count(entries) == dx_get_limit(entries)) &#123;</span><br><span class="line"><span class="type">ext4_lblk_t</span> newblock;</span><br><span class="line"><span class="type">int</span> levels = frame - frames + <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> icount;</span><br><span class="line"><span class="type">int</span> add_level = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dx_entry</span> *<span class="title">entries2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dx_node</span> *<span class="title">node2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh2</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (frame &gt; frames) &#123;</span><br><span class="line"><span class="keyword">if</span> (dx_get_count((frame - <span class="number">1</span>)-&gt;entries) &lt;</span><br><span class="line">    dx_get_limit((frame - <span class="number">1</span>)-&gt;entries)) &#123;</span><br><span class="line">add_level = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">frame--; <span class="comment">/* split higher index block */</span></span><br><span class="line">at = frame-&gt;at;</span><br><span class="line">entries = frame-&gt;entries;</span><br><span class="line">restart = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (add_level &amp;&amp; levels == ext4_dir_htree_level(sb)) &#123;</span><br><span class="line">ext4_warning(sb, <span class="string">&quot;Directory (ino: %lu) index full, &quot;</span></span><br><span class="line"> <span class="string">&quot;reach max htree level :%d&quot;</span>,</span><br><span class="line"> dir-&gt;i_ino, levels);</span><br><span class="line"><span class="keyword">if</span> (ext4_dir_htree_level(sb) &lt; EXT4_HTREE_LEVEL) &#123;</span><br><span class="line">ext4_warning(sb, <span class="string">&quot;Large directory feature is &quot;</span></span><br><span class="line"> <span class="string">&quot;not enabled on this &quot;</span></span><br><span class="line"> <span class="string">&quot;filesystem&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">err = -ENOSPC;</span><br><span class="line"><span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line">icount = dx_get_count(entries);</span><br><span class="line">bh2 = ext4_append(handle, dir, &amp;newblock);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(bh2)) &#123;</span><br><span class="line">err = PTR_ERR(bh2);</span><br><span class="line"><span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line">node2 = (<span class="keyword">struct</span> dx_node *)(bh2-&gt;b_data);</span><br><span class="line">entries2 = node2-&gt;entries;</span><br><span class="line"><span class="built_in">memset</span>(&amp;node2-&gt;fake, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> fake_dirent));</span><br><span class="line">node2-&gt;fake.rec_len = ext4_rec_len_to_disk(sb-&gt;s_blocksize,</span><br><span class="line">   sb-&gt;s_blocksize);</span><br><span class="line">BUFFER_TRACE(frame-&gt;bh, <span class="string">&quot;get_write_access&quot;</span>);</span><br><span class="line">err = ext4_journal_get_write_access(handle, sb, frame-&gt;bh,</span><br><span class="line">    EXT4_JTR_NONE);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line"><span class="keyword">if</span> (!add_level) &#123;</span><br><span class="line"><span class="type">unsigned</span> icount1 = icount/<span class="number">2</span>, icount2 = icount - icount1;</span><br><span class="line"><span class="type">unsigned</span> hash2 = dx_get_hash(entries + icount1);</span><br><span class="line">dxtrace(printk(KERN_DEBUG <span class="string">&quot;Split index %i/%i\n&quot;</span>,</span><br><span class="line">       icount1, icount2));</span><br><span class="line"></span><br><span class="line">BUFFER_TRACE(frame-&gt;bh, <span class="string">&quot;get_write_access&quot;</span>); <span class="comment">/* index root */</span></span><br><span class="line">err = ext4_journal_get_write_access(handle, sb,</span><br><span class="line">    (frame - <span class="number">1</span>)-&gt;bh,</span><br><span class="line">    EXT4_JTR_NONE);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">char</span> *) entries2, (<span class="type">char</span> *) (entries + icount1),</span><br><span class="line">       icount2 * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dx_entry));</span><br><span class="line">dx_set_count(entries, icount1);</span><br><span class="line">dx_set_count(entries2, icount2);</span><br><span class="line">dx_set_limit(entries2, dx_node_limit(dir));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Which index block gets the new entry? */</span></span><br><span class="line"><span class="keyword">if</span> (at - entries &gt;= icount1) &#123;</span><br><span class="line">frame-&gt;at = at - entries - icount1 + entries2;</span><br><span class="line">frame-&gt;entries = entries = entries2;</span><br><span class="line">swap(frame-&gt;bh, bh2);</span><br><span class="line">&#125;</span><br><span class="line">dx_insert_block((frame - <span class="number">1</span>), hash2, newblock);</span><br><span class="line">dxtrace(dx_show_index(<span class="string">&quot;node&quot;</span>, frame-&gt;entries));</span><br><span class="line">dxtrace(dx_show_index(<span class="string">&quot;node&quot;</span>,</span><br><span class="line">       ((<span class="keyword">struct</span> dx_node *) bh2-&gt;b_data)-&gt;entries));</span><br><span class="line">err = ext4_handle_dirty_dx_node(handle, dir, bh2);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line">brelse (bh2);</span><br><span class="line">err = ext4_handle_dirty_dx_node(handle, dir,</span><br><span class="line">   (frame - <span class="number">1</span>)-&gt;bh);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line">err = ext4_handle_dirty_dx_node(handle, dir,</span><br><span class="line">frame-&gt;bh);</span><br><span class="line"><span class="keyword">if</span> (restart || err)</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> dx_root *dxroot;</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">char</span> *) entries2, (<span class="type">char</span> *) entries,</span><br><span class="line">       icount * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dx_entry));</span><br><span class="line">dx_set_limit(entries2, dx_node_limit(dir));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set up root */</span></span><br><span class="line">dx_set_count(entries, <span class="number">1</span>);</span><br><span class="line">dx_set_block(entries + <span class="number">0</span>, newblock);</span><br><span class="line">dxroot = (<span class="keyword">struct</span> dx_root *)frames[<span class="number">0</span>].bh-&gt;b_data;</span><br><span class="line">dxroot-&gt;info.indirect_levels += <span class="number">1</span>;</span><br><span class="line">dxtrace(printk(KERN_DEBUG</span><br><span class="line">       <span class="string">&quot;Creating %d level index...\n&quot;</span>,</span><br><span class="line">       dxroot-&gt;info.indirect_levels));</span><br><span class="line">err = ext4_handle_dirty_dx_node(handle, dir, frame-&gt;bh);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line">err = ext4_handle_dirty_dx_node(handle, dir, bh2);</span><br><span class="line">brelse(bh2);</span><br><span class="line">restart = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">de = do_split(handle, dir, &amp;bh, frame, &amp;fname-&gt;hinfo);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(de)) &#123;</span><br><span class="line">err = PTR_ERR(de);</span><br><span class="line"><span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line">err = add_dirent_to_buf(handle, fname, dir, inode, de, bh);</span><br><span class="line"><span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">journal_error:</span><br><span class="line">ext4_std_error(dir-&gt;i_sb, err); <span class="comment">/* this is a no-op if err == 0 */</span></span><br><span class="line">cleanup:</span><br><span class="line">brelse(bh);</span><br><span class="line">dx_release(frames);</span><br><span class="line"><span class="comment">/* @restart is true means htree-path has been changed, we need to</span></span><br><span class="line"><span class="comment"> * repeat dx_probe() to find out valid htree-path</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (restart &amp;&amp; err == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ext4_dx_add_entry</code> 函数的主要功能是将新的目录项添加到目录索引中，我们能看到这段函数在 <code>add_level &amp;&amp; levels == ext4_dir_htree_level(sb)</code> 这里检查对应的特性是否打开，以及当前 BTree 层高，如果超出限制，则返回 <code>ENOSPC</code> 即 ERROR 28</p><p>好了，在复现异常之前，我们来获取下这个函数的被调用路径。这里我用 eBPF 的 trace 来获取 stacktrace，因为与主体无关，我在这里就不放代码了</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ext4_dx_add_entry</span><br><span class="line">ext4_add_nondir</span><br><span class="line">ext4_create</span><br><span class="line">path_openat</span><br><span class="line">do_filp_open</span><br><span class="line">do_sys_openat2</span><br><span class="line">do_sys_open</span><br><span class="line">__x64_sys_openat</span><br><span class="line">do_syscall_64</span><br><span class="line">entry_SYSCALL_64_after_hwframe</span><br><span class="line">[unknown]</span><br><span class="line">[unknown]</span><br></pre></td></tr></table></figure><p>那么我们怎么验证这个是我们的异常呢</p><p>首先我们利用 eBPF + kretproble 来获取 <code>ext4_dx_add_entry</code> 的返回值，如果返回值是 <code>ENOSPC</code>，则我们就可以确定这个是我们的异常</p><p>代码如下（不要问我这里为啥不用 Python 写，要写 C 了（</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">BPF_RINGBUF_OUTPUT(events, 65536);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">struct event_data_t &#123;</span></span><br><span class="line"><span class="string">    u32 pid;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int trace_ext4_dx_add_entry_return(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">    int ret = PT_REGS_RC(ctx);</span></span><br><span class="line"><span class="string">    if (ret == 0) &#123;</span></span><br><span class="line"><span class="string">        return 0;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    u32 pid=bpf_get_current_pid_tgid()&gt;&gt;32;</span></span><br><span class="line"><span class="string">    struct event_data_t *event_data = events.ringbuf_reserve(sizeof(struct event_data_t));</span></span><br><span class="line"><span class="string">    if (!event_data) &#123;</span></span><br><span class="line"><span class="string">        return 0;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    event_data-&gt;pid = pid;</span></span><br><span class="line"><span class="string">    events.ringbuf_submit(event_data, sizeof(event_data));</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_text)</span><br><span class="line"></span><br><span class="line">bpf.attach_kretprobe(event=<span class="string">&quot;ext4_dx_add_entry&quot;</span>, fn_name=<span class="string">&quot;trace_ext4_dx_add_entry_return&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_event_data</span>(<span class="params">cpu, data, size</span>):</span><br><span class="line">    event =  bpf[<span class="string">&quot;events&quot;</span>].event(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Process <span class="subst">&#123;event.pid&#125;</span> ext4 failed&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf[<span class="string">&quot;events&quot;</span>].open_ring_buffer(process_event_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bpf.ring_buffer_consume()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>然后我们写段很短的 Python 脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200000000</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">100000</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;we have created <span class="subst">&#123;i&#125;</span> files&quot;</span>)</span><br><span class="line">    filename=<span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">    file_name=<span class="string">f&quot;/data1/cache/<span class="subst">&#123;filename&#125;</span>+<span class="subst">&#123;filename&#125;</span>.txt&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后我们看到执行结果</p><p><img src="https://user-images.githubusercontent.com/7054676/211157342-812406e1-45c4-42f0-9ff4-3c4c3d5bcb05.png" alt="执行结果"></p><p>符合预期，那么我们可以说这个问题的排查路径的因果关系链完整了。那么我们也可以正式宣告解决了这个问题了</p><p>那么锦上添花的一点，对于这种上游的问题，我们如果能找到具体在什么时间点进行了修复，那就更好了。就这个 case 而言，ext4 的 large_dir 在 Linux 4.13 中得到引入，具体可以参见 <a href="#refer-anchor-6">88a399955a97fe58ddb2a46ca5d988caedac731b<sup>6</sup></a> 这个 commit。</p><p>OK 这个问题就告一段落</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这个问题比较冷门，但是排查方式其实是挺典型的线上问题的排查方法。对于问题，不要预设结果，一步步的根据现象去逼近最终的结论。以及 eBPF 真的好东西，能帮助做很多内核的事。最后我的 Linux 文件系统方面的底子还是太薄弱了，希望后面能重点加强一下</p><p>差不多就这样</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="refer-anchor-1"></div><ul><li>[1]. <a href="https://docs.docker.com/storage/bind-mounts/">https://docs.docker.com/storage/bind-mounts/</a></li></ul><div id="refer-anchor-2"></div>]- [2]. [https://man7.org/linux/man-pages/man2/fallocate.2.html](https://man7.org/linux/man-pages/man2/fallocate.2.html)<div id="refer-anchor-3"></div><ul><li>[3]. <a href="https://man7.org/linux/man-pages/man8/fdisk.8.html">https://man7.org/linux/man-pages/man8/fdisk.8.html</a></li></ul><div id="refer-anchor-4"></div><ul><li>[4]. <a href="https://linux.die.net/man/8/tune2fs">https://linux.die.net/man/8/tune2fs</a></li></ul><div id="refer-anchor-5"></div><ul><li>[5]. <a href="https://man7.org/linux/man-pages/man1/dmesg.1.html">https://man7.org/linux/man-pages/man1/dmesg.1.html</a></li></ul><div id="refer-anchor-6"></div><ul><li>[6]. <a href="https://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4.git/commit/?h=dev&amp;id=88a399955a97fe58ddb2a46ca5d988caedac731b">https://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4.git/commit/?h=dev&amp;id=88a399955a97fe58ddb2a46ca5d988caedac731b</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;好久没写水文了，新年第一篇水文总得写一下，完成下 OKR，正好最近帮群友查了一个特殊的 No space left on device 问题，记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/Linux/"/>
    
    
    <category term="编程" scheme="https://manjusaka.blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/tags/Linux/"/>
    
    <category term="容器" scheme="https://manjusaka.blog/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Stay Simple, Stay Naive</title>
    <link href="https://manjusaka.blog/posts/2023/01/01/stay-simple-stay-naive/"/>
    <id>https://manjusaka.blog/posts/2023/01/01/stay-simple-stay-naive/</id>
    <published>2023-01-01T19:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.203Z</updated>
    
    <content type="html"><![CDATA[<p>本来想在农历年前交年终总结的，不过想了想，去年的年终总结就因为太懒导致我鸽了。所以这个“双年”怎么也得总结下2022了。不过说起来怎么还没去字节，就开始 ego 了起来。</p><span id="more"></span><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>实际上每年都在觉得这一年很魔幻，但是下一年总会跳出来说“这一年更魔幻”。不过这也是人生的乐趣吧。</p><p>看了下20年总结的标题叫做”但行好事，莫问前程“，去年一下想不起标题，群内求助了下，发现”Stay Simple，Stay Naive“这个标题还不错，挺适合作为去年的总结与展望的。不过在写下这点文字的时候发现当年 +1S 的对象也已经仙去了。怎么说心里也还是有点很奇怪的感觉在里面。</p><p>不过，一日膜法，终身膜法，所以就还是 Naive 的 +1S 吧</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>去年从年初开始，我从太极图形离职后，就开始进入了我数字游民的生活。作为一个 FreeLancer，可能最大的好处就在于说免去了通勤的时间后，我可以有更多的时间做自己的事（睡大觉（不是</p><p>在离职之后，和女朋友一起换了一个新的房子，有着很大的落地窗的露台，采光很好，所以让我在这里有时间安心做一些自己的事情</p><p><img src="https://user-images.githubusercontent.com/7054676/166151791-40f3b47c-a649-4b9e-bb79-c58ccd263fd2.png" alt="老夫的专属少女阳台！"></p><p>所以去年在有自己的时间的情况下，我开始看之前没有怎么涉猎的杂书，印象比较深的有这样几本</p><ol><li>人造美人</li><li>置身事内：中国政府与经济发展</li><li>唐史并不如烟</li><li>最伟大的交易</li><li>病人家属，请来一下</li><li>昨日的世界</li><li>成为一颗星：宇航学员日记</li></ol><p>整体的阅读量在20本左右吧。然后发现，你去慢慢找书，然后发现某个作者的风格很符合你的 XP 是件非常幸福的事。</p><p>在看书之余，我也开始看番了，这个行动一度占据了我 Q3/Q4 很多业余时间（导致我这段时间不去干其余事了（你们这个群害人不浅啊。当然，补剧，看纪录片，也都是这一年的一部分，过这对于我来说实际上也是全新的体验了。技术和睡觉之外的世界也是格外的大啊</p><p>然后家里新入职了两只猫咪，现在家里整整有六只猫，这对于我来说完全是幸福的烦恼。撸猫一时爽，一直撸猫一直爽。（当然铲屎和猫咪集体生病的时候就很不爽了。</p><p>当然好事说了这么多，当然要说点坏事了，去年的减肥计划执行的很不彻底，以及去年的运动计划也没有执行，呜呜呜呜呜。</p><p>从去年开始再次勇敢面对抑郁症的现实后，在药物和整体相对自由的环境的情况下，我自己的精神状态控制的也还不错。不过可能因为这一年是我被性侵到现在第十五个年头的缘故吧，去年的噩梦有点多，希望时间能继续治愈一切吧。（不过说起来，我讨厌药物副作用（真的让人很不爽</p><p>说回来，去年有了自己时间后，家里也添置了不少能极大提升自己生活幸福度的物件</p><ol><li>一个 8*16T 的 NAS，妈妈再也不担心我的动漫没地方放了！</li><li>一个 4090 + i9-13900K 的台式机，工作娱乐都很爽</li><li>Apple TV 4K 配合局域网 NAS，我和妹子一起看了不少的电影（</li><li>一个尺寸合格的 Android 手机，追网络小说（</li><li>一个顶配的 iPad Pro 12.9 寸，轻办公和看微信读书都很好用（我真的没用来盖泡面看爱奇艺！</li></ol><p>另外一提的是，去年公益我也在继续坚持坐着，我自己累计捐款10k+，然后公益群的小伙伴一起凑了点钱给一个村小捐款6K+，另外一点非常开心的是，我也带动了身边的人，去捐助学生。教育是最好的公益.jpg。不知道还能坚持多久，但是还是做一些力所能及的事吧。</p><p>差不多是这样，2022 整体的生活也还算是有滋有味。不过心里还是会隐隐约约有点担心，在整体局势下行的情况下，我这样小确幸的生活又能持续多久呢？</p><h2 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h2><p>感情步入了第四个年头，去年因为北京疫情的原因，和荆澈同学一起朝夕相处（这是真的朝夕相处）了一年了。用我很喜欢的《士兵突击》里的一句台词</p><blockquote><p>常相守是个考验，随时随地，一生。</p></blockquote><p>两个人朝夕相处，因为各种细节上的差异，一定会有一些小的争执与摩擦。这个时候就需要两个人相互包容。相互理解。说道这里我就很庆幸荆澈同学对我的包容与监督了。她经常碎碎念的督促我起床，督促我运动，督促我继续改掉我很多不好的习惯Hhhhhh（mua.jpg</p><p>很多时候，我半夜噩梦醒来，总会下意识的去抱着荆澈同学，她即便迷迷糊糊搞不清情况，也会转过来给我抱抱。某种意义上，荆澈同学的陪伴，是让我不断走下去的勇气的源泉</p><p>说回来，朝夕相处也未必是个坏事，去年和荆澈同学一起去公园散步，一起逛吃逛吃的时间多了很多。也一起去泡了温泉，一起去了环球影城（Remote 万岁！）。</p><p>希望 2023 年也和荆澈同学也能一起顺顺利利的走下去，完成对荆澈同学的承诺（我要有八块腹肌.jpg（以及去旅游，去做更多的手工艺品！</p><p>反正我一如既往的 <strong>感激并享受着荆澈同学的爱</strong> 。</p><h2 id="工作与技术"><a href="#工作与技术" class="headerlink" title="工作与技术"></a>工作与技术</h2><p>首先聊聊我自己的变更，如前面所说，在22年初，因为自己的规划和身体的原因，我正式离开了太极（说实话挺舍不得这群同事的），正式开始了我数字游民的生活。目前来说，我依靠给一些客户做 SRE 方面的能力输出为生。这对于我来讲其实是个蛮大的挑战。因为我之前的定位其实更多的还是偏向于一个 Infra Developer，将 SRE 作为我正式工作方向，其实对于我来讲，也是开天辟地头一回了（感谢客户爸爸的信任</p><p>去年其实工作内容也发生了很大的转变，也让我更多的意识到了自己的不足。如果说自己之前是一个纯粹的 IC 的角色，那么去年我的工作内容的边界实际上有了不少的扩展。我需要去更多的考虑协调的有效性，体系化的建设。很多时候我都在笑称我自己这周写的文档可能比我写的代码还多了（XD</p><p>不过这对于我来说也是一个好事，思路的转变我相信会让我提升很多。</p><p>2022另外一个比较重大的改变就是从2022二月开始，在 Xuanwo 几位好友的启发下，我开始正式的以公开的方式，记录自己每周的生活与技术学习（我老板说会看我周报（摊手。这一点其实对于我自己来说，也是比较好的一个手段吧。用一个锚点，去约束自己的生活（面向周报有内容式学习（不是），去记录自己的一些感悟与心得（输出了不少稳定性与可观测性的东西。希望23年能继续坚持。</p><p>技术方面的话，去年的成长我自己觉得也还是比较明显的。一方面是在开源社区这块。年初因为寻找 Docker 替代品，机缘巧合之下开始为 <a href="https://github.com/containerd/nerdctl">nerdctl</a> 做输出，6月被 Promote 成为 Reviewer，12月被 Promote 成为 Committer。这也是我比较深度的参与开源社区了。同时我自己也会和身边的好友去交流关于开源社区的东西，比如和 Xuanwo 一起聊聊他的 OpenDAL，和 GaoCe GG 一起聊聊/吐槽他的创业项目 envd （他时常因为我比他还看好这个项目而惊讶（这个项目真的是好项目啊！。我自己觉得这一年去给不同社区贡献代码，参与讨论，对于我自己的提升是全方位的，更明确的意识到自己的 naive，也接受来自不同人的帮助与指导。如同我之前在一篇文章中的感悟一样</p><blockquote><p>从互联网诞生之初到现在，开源这一极具理想主义气质的行为事实上的改变了这个世界。世界各地的人都在开源的旗帜下，自由的挥发着自己的创意，尽情的一点点的改变着这个世界。有些时候想到我会有机会去参与到这样一个伟大的活动中，我会不由自主的颤栗。我很庆幸在我最初的职业生涯里就加入到了这个伟大的事业，我也希望我身边会有越来越多的人参与进来，一起挥洒着汗水，一起在这个操蛋但是又美好的世界里，找到自己心灵的应许之地。</p></blockquote><p>另外一方面的话，去年在技术深度这块做的也还算 OK，继续在之前自己积累的可观测性和稳定性方面精进，系统性的提升自己的一些体系化的思考（抽象成方法论），也继续在内核和 eBPF 这块做一些有意思的工作（比如帮助人去做一些小的工具）。希望23年也能继续勇猛精进</p><p>说起来，去年有一个很大的收获不知道算不算技术这块的，姑且算吧。之前组建的刷题群在去年格外的活跃，大家一起刷题，一起捐款，一起推荐番祸害群主（不是），一起做开源（去年群内诞生了两位开源项目的 maintainer），我很多时候遇到各种事情的时候都会在群里和群友们一起吐槽和发泄。很多时候我自己在感叹，在这个人心浮躁的时代，能遇到这样一群热情又纯粹的人，实则人生幸事，当浮一大白（不过我肝不好，就以零度代酒干了这杯）</p><p>差不多就这些，去年也还零零碎碎的做了很多其余的工作，开始翻译人生第一本书,保持了每日一题，读了十多篇论文，组织了好几次群内分享，写自己的 toy，很多很多。很多人觉得程序员是个很枯燥的行业。但是说实话，这一行真的让人迷醉</p><p><img src="https://user-images.githubusercontent.com/7054676/210173110-89ff93d9-9b9d-467c-b8e4-58de1d4a5f50.png" alt="勉强没有虚度的一年"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对比了下年初的目标，然后自评了一下差不多能给自己个3.5的绩效吧<br>优点和缺点都比较明显，聊聊缺点吧</p><ol><li>是自己在开源这块有技术深度的产出还是不够</li><li>自律性还是差了一些，花了不少时间在睡懒觉，玩游戏，看番上了</li><li>专注度上差了一些，一些拟好的目标经常走神</li><li>自己的运动目标没达成</li></ol><p>缺点和改进方向还是比较明确的，希望明年继续努力。我自己目前列好的一些 OKR 差不多是这样</p><ol><li>O1：代码能力<ol><li>学习前端，成为一个前端开源项目的 maintainer</li><li>继续保持 Leetcode 每日一题，确保百分之70以上的 daily 随机 medium 及以上题目能不看题解写出来</li></ol></li><li>O2: 读书<ol><li>重读 TCP 卷一</li><li>读完 CSAPP，并保证每章作业完成率不低于百分之八十</li><li>剩下的书待定</li></ol></li><li>O3：分享<ol><li>参考 xdp-tutorial 写一个 netfilter-tutorial</li><li>全年群内分享5次以上</li><li>六篇有效博客</li></ol></li><li>O4: 努力生活<ol><li>通过运动的方式，将体重降到 145（和某位群友赌了两千块的公益捐款）</li><li>和女朋友去三个以上地方玩</li><li>争取每周超过3点睡觉不超过两天（现在就emmm</li></ol></li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>2022 实际上真的挺魔幻的，不过套用狄更斯的一句老掉牙的话</p><blockquote><p>这是最坏的一年，这也是最好的一年</p></blockquote><p>说实话我也不知道23年会怎么样，未来几年会怎么样。不过无论怎么样，爱与希望总是会支撑我们走过一年年。嗯，Everything is gonna be OK.</p><p>说起来，今年有人问过我我想成为一个怎么样的人，我想了下，这么回答到</p><blockquote><p>我希望身边的人在很多年后，和老头老太太聊天或者给自己孙子提到我的时候会这么说”我之前认识一个叫 saka 的人，是个还不错的人“，那么我心满意足了</p></blockquote><p>Stay Simple，Stay Naive，永远谦逊，敬畏生活，勇敢前行</p><p>再见 2022，你好 2023</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本来想在农历年前交年终总结的，不过想了想，去年的年终总结就因为太懒导致我鸽了。所以这个“双年”怎么也得总结下2022了。不过说起来怎么还没去字节，就开始 ego 了起来。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://manjusaka.blog/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="总结" scheme="https://manjusaka.blog/categories/%E9%9A%8F%E7%AC%94/%E6%80%BB%E7%BB%93/"/>
    
    <category term="秀恩爱" scheme="https://manjusaka.blog/categories/%E9%9A%8F%E7%AC%94/%E6%80%BB%E7%BB%93/%E7%A7%80%E6%81%A9%E7%88%B1/"/>
    
    
    <category term="随笔" scheme="https://manjusaka.blog/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="总结" scheme="https://manjusaka.blog/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>我所热爱的开源社区</title>
    <link href="https://manjusaka.blog/posts/2022/11/22/why-i-love-the-open-source-community/"/>
    <id>https://manjusaka.blog/posts/2022/11/22/why-i-love-the-open-source-community/</id>
    <published>2022-11-22T20:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.203Z</updated>
    
    <content type="html"><![CDATA[<p>今天是个不错的日子，最开始由我带进 <a href="https://github.com/containerd/nerdctl">nerdctl</a> 社区的 <a href="https://twitter.com/realyuchanns">@yuchanns</a> 因为其很活跃的表现被项目的主要维护者 <a href="https://twitter.com/AkihiroSuda">@AkihiroSuda</a> 推荐成为了项目的 maintainer，参见 <a href="https://github.com/containerd/nerdctl/pull/1540">nerdctl#PR1540</a>。而我也在这个项目中被提名成为 committer，参见 <a href="https://github.com/containerd/nerdctl/pull/1539">nerdctl#1539</a>。加上今天的公益群有太多关于开源的讨论，所以我想写篇文章记录下我自己的经历，希望能帮助更多的人热爱开源，拥抱开源。</p><span id="more"></span><h2 id="为什么我会参加开源"><a href="#为什么我会参加开源" class="headerlink" title="为什么我会参加开源"></a>为什么我会参加开源</h2><p>我参与的第一个开源项目，应该是能追溯到16年，我还没有本科毕业的时候，当时的我参加了 <a href="https://github.com/xitu/gold-miner">稀土掘金翻译计划</a>（slogan 里说的最好的英文技术资讯翻译项目，我觉得毫不夸张），在这个项目里我第一次接触到了 Git Workflow，也完整接触到了 GitHub 这个世界最大的同性交友社区（大雾（不过我相交至今对我帮助巨大的几位密友真的是通过这个项目结识的）。而我第一个参与的代码项目，应该可以追溯到17年3月，我给 <a href="https://github.com/sanic-org/sanic">Sanic</a> 这个项目新增了一个 Code Example，参见 <a href="https://github.com/sanic-org/sanic/pull/558">Sanic#PR558</a>。</p><p>在往后，我就一直在不断的参与开源社区，到现在为止，我贡献过不少的开源项目，CPython，Docker/Moby，Taichi，Logseq，Kubernetes，Dubbo，TiDB，nerdctl 等等。我也在不断的学习开源社区的工作方式，我也在不断的学习开源社区的文化，我也在不断的学习开源社区的技术。（最后面这句由 GitHub Copilot 自动完成）（XD</p><p>那么回到这一章的标题，我为什么会参与开源社区？或者更功利的说，开源社区给我带来了什么样的利益？</p><p>无他，对于我自己全方位的成长。</p><p>首先，参与开源社区对于我来讲，对于我自己是一个非常非常棒的提升的过程。你可以在这里面学到很多的东西</p><ol><li>怎么样去有效的说服别人</li><li>怎么样去写好 UT</li><li>怎么样去打磨 code style</li><li>怎么样去帮助同为新人的其余人</li></ol><p>更早的链接先不谈，大家可以看我 2022 年在 <a href="https://github.com/containerd/nerdctl">nerdctl</a> 项目上的贡献 <a href="https://github.com/containerd/nerdctl/pulls?q=is%3Apr+is%3Aclosed+author%3AZheaoli">nerdctl#ZheaoLi</a>，大家可以很明显的看到，我的 PR 从最开始到后面，无论是质量，还是风格都有不少的提升。这实际上就是开源社区所带给我的最直观的成长。我很庆幸有很棒的 Community Mentor 对我的 PR 从不放水，Review 非常严格，促使我不断的成长。</p><p>同时，让我也有机会去表达自己的想法，去发起 Proposal（比如 <a href="https://github.com/containerd/nerdctl">nerdctl#Issue1387</a>），去学会做一个 Owner，去帮助更多的新人参与进来。</p><p>某种意义上，这是日常的工作所给予不了我的特殊的体验，开源社区相对较少的利益纠葛，会让互利互惠的行为变得更纯粹，更加的自然。也会让人收益更大。这里引用 <a href="https://twitter.com/realyuchanns">@yuchanns</a> 今晚的一段发言</p><blockquote><p>我想大家刚学编程的时候都会有这种困境：学完不知道干啥、感觉好像没学，所以就想寻找各种实战教程来加深体会。<br>这种现象会在实际从事工作后迅速消除，因为有了实际应用场景。<br>但是当你对一些其他领域的东西产生兴趣，又会有这种困惑；而这是工作中不太有机会接触到的东西。除非你换了个工作、不然没法再通过工作经验来摆脱困境。<br>这时候参与到一个开放式的社区就很好了。其他人的工作中产生的需求给你提供了实战机（（<br>你不需要自己一一涉足到具体的工作中，只要解决他们延伸出来的需要，就可以有机会运用学到的东西（（</p></blockquote><p>当然，从功利的角度来说，积极的参与开源社区，你能认识很多有意思的人，让你职业生涯更为顺利也是能给你带来的好处就是了（</p><h2 id="那么怎么样去参与开源社区"><a href="#那么怎么样去参与开源社区" class="headerlink" title="那么怎么样去参与开源社区"></a>那么怎么样去参与开源社区</h2><p>参与开源社区无外乎有两种途径，</p><ol><li>自己创立一个项目的开源社区</li><li>加入一个已经存在的开源社区</li></ol><p>我主要会讨论下后者</p><p>很多人会给出开源三问 “我想参与开源社区，但是我不知道怎么做”，“我想参与开源社区，但是我不知道怎么找到一个项目”，“我想参与开源社区，但是我太菜了怎么办啊”</p><p>实际上这些问题解决起来都是没有你想象的那么困难，可能只是需要一点行动能力加一点好奇心。</p><p>实际上发展到现在，开源社区已经极其的庞大了，无论你的技术栈是什么，你都能找到合适的项目去参与。而且，开源社区的参与门槛也越来越低了，你不需要去了解整个项目的代码，你只需要去了解项目的 Issue，然后去解决这些 Issue，就可以参与到开源社区中来了。那么 How to find a project to contribute to ？</p><p>我自己的途径有两个</p><ol><li>通过 GitHub 的 Explore 页面，找一些新的项目，看这个项目是否戳中了我的痛点</li><li>社交媒体上大家的宣传</li></ol><p><a href="https://github.com/containerd/nerdctl">nerdctl</a> 这个项目实际上的来源就是当时好友 <a href="https://twitter.com/junnplus">@Junnplus</a> 在推上的推广</p><p><img src="https://user-images.githubusercontent.com/7054676/203397746-730d4e8c-7576-4652-b736-a4070f9f4516.png" alt="当时的截图"></p><p>然后我去看了下这个项目的定位，发现这个项目实际上戳中了我的痛点，于是我就开始在自己的环境中使用这个项目。</p><p>实际上去找到你感兴趣的项目实际上不是一件难事，可能只是需要一点点好奇心</p><p>那么，我找到一个项目后，我应该怎么样去参与进去？</p><p>实际上这里就需要一点行动力了，我自己大概方法是这样</p><ol><li>扫 Issue 区，以及订阅项目，一个项目的 Issue 能让我一定程度上的去了解这个项目的发展方向</li><li>我会不断的去使用这个项目，将我在使用中的问题转化成 Issue，进而转化成 PR</li><li>我会用我已有的知识进行迁移，尝试是否有可能发现新的潜在的问题</li></ol><p>以 <a href="https://github.com/containerd/nerdctl">nerdctl</a> 为例，Issue 区时不时的会有 <a href="https://github.com/containerd/nerdctl/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22">Good First Issue</a> 的出现，这个时候你可以主动的去认领对应的 Issue 进行贡献（从我的视角来看，项目的维护者对于 Good First Issue 的上心程度将会决定了一个项目的长远发展），<a href="https://twitter.com/realyuchanns">@yuchanns</a> 第一个 PR <a href="https://github.com/containerd/nerdctl/pull/1331">nerdctl#PR1331</a> 实际上就来源于我提的一个 Good First Issue <a href="https://github.com/containerd/nerdctl/issues/1330">nerdctl#1330</a>。当然对于一个已经有一定规模的项目来说，坐着等 Good First Issue 可能需要点运气，那么怎么办，答案就是第二，第三点</p><p>我在 <a href="https://github.com/containerd/nerdctl">nerdctl</a> 第一个贡献的 PR <a href="https://github.com/containerd/nerdctl/pull/790">nerdctl#PR790</a> 来自于我提出的 Issue <a href="https://github.com/containerd/nerdctl/issues/775">nerdctl#Issue775</a> ，这个 Issue 是我在使用过程中发现的 Bug，简而言之就是在私有镜像仓库下鉴权的一些问题。然后将 Issue 转化成对应的 PR 了。我在这个项目中其余的一些贡献也是修我自己遇到的一些问题</p><p>另外一个方法是，我会用我已有的知识去进行迁移，尝试是否能发现有潜在的问题。我在 <a href="https://github.com/toeverything/AFFiNE">Affine</a>(一个非常棒的笔记项目)提的 PR <a href="https://github.com/toeverything/AFFiNE/pull/403">Affine#PR403</a> 是我在本地构建 Affine 的时候，顺手读了一下他们的 Dockerfile（我是 SRE，对这个比较敏感（不然前端项目我去读 Dockerfile 干嘛），发现他们没有高效的利用缓存，然后我就提了 PR，进行了构建加速。这是实际上就是跨领域的去看一个项目能给你带来不一样的视角，进而促进你对项目的贡献。</p><p>那么，开源三问最后一问，”我想参与开源社区，但是我太菜了怎么办啊“</p><p>首先要说一点，开源社区的精髓就在于边做边学边成长，比如 <a href="https://twitter.com/realyuchanns">@yuchanns</a> 在写 <a href="https://github.com/containerd/nerdctl/pull/1407">nerdctl#PR1407</a> 的时候（这个 PR 主要是给容器新增一个可以绑定 MacAddress 的选项），他当时对于 CNI 这块也不是很熟悉，然后边做边学，我和他也在群里讨论过几次方案。最终 PR 合并的非常顺利。这某种意义上也是开源社区的一种乐趣与魅力。</p><p>那如果你说你现在就是背景知识不够，你想等再学学再写代码，那还能贡献吗？可以啊，用 <a href="https://twitter.com/tison1096">@tison</a> 的经典言论”一个社区的活绝对是很多样的“。你看，我给 <a href="https://github.com/bytebase/bytebase">bytebase</a> 提 Bug 的时候，发现他们的 Ticket 模板太难用了，然后我交了<a href="https://github.com/bytebase/bytebase/pull/3050">Bytebase#PR3050</a> 重构了他们的 Issue Template，后面他们基于我的基础上又完善了一波。所以，无论是 Issue，文档完善，帮助完善用例等，都是很棒的参与开源社区的方式。</p><p>当然可能新进来的同学还有个顾虑就是如果被拒绝了怎么办？那其实很常见，你看我拍脑袋给 <a href="https://github.com/lima-vm/lima">lima</a> 提的 <a href="https://github.com/lima-vm/lima/issues/1087">lima#Issue1087</a> 被拒的很惨。但是被拒绝也是一种学习，能让我自己从这个讨论的过程里去回顾到我思考不完善的地方。</p><p>所以看到这，你会发现，参与开源社区，真的没有那么难。需要的真的只是一点点行动力，以及一点点的好奇心而已</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从互联网诞生之初到现在，开源这一极具理想主义气质的行为事实上的改变了这个世界。世界各地的人都在开源的旗帜下，自由的挥发着自己的创意，尽情的一点点的改变着这个世界。有些时候想到我会有机会去参与到这样一个伟大的活动中，我会不由自主的颤栗。我很庆幸在我最初的职业生涯里就加入到了这个伟大的事业，我也希望我身边会有越来越多的人参与进来，一起挥洒着汗水，一起在这个操蛋但是又美好的世界里，找到自己心灵的应许之地。</p><p>Long Live the Open Source！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天是个不错的日子，最开始由我带进 &lt;a href=&quot;https://github.com/containerd/nerdctl&quot;&gt;nerdctl&lt;/a&gt; 社区的 &lt;a href=&quot;https://twitter.com/realyuchanns&quot;&gt;@yuchanns&lt;/a&gt; 因为其很活跃的表现被项目的主要维护者 &lt;a href=&quot;https://twitter.com/AkihiroSuda&quot;&gt;@AkihiroSuda&lt;/a&gt; 推荐成为了项目的 maintainer，参见 &lt;a href=&quot;https://github.com/containerd/nerdctl/pull/1540&quot;&gt;nerdctl#PR1540&lt;/a&gt;。而我也在这个项目中被提名成为 committer，参见 &lt;a href=&quot;https://github.com/containerd/nerdctl/pull/1539&quot;&gt;nerdctl#1539&lt;/a&gt;。加上今天的公益群有太多关于开源的讨论，所以我想写篇文章记录下我自己的经历，希望能帮助更多的人热爱开源，拥抱开源。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://manjusaka.blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="杂记" scheme="https://manjusaka.blog/categories/%E6%8A%80%E6%9C%AF/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="https://manjusaka.blog/tags/%E6%9D%82%E8%AE%B0/"/>
    
    <category term="技术" scheme="https://manjusaka.blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>重回 Windows 之路</title>
    <link href="https://manjusaka.blog/posts/2022/11/12/the-road-back-to-windows/"/>
    <id>https://manjusaka.blog/posts/2022/11/12/the-road-back-to-windows/</id>
    <published>2022-11-12T04:27:15.000Z</published>
    <updated>2023-06-22T16:36:06.203Z</updated>
    
    <content type="html"><![CDATA[<p>最近会回到 Windows 下办公了两周多，简单记录下自己的使用体验</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近刚配置了一台高配的主机（i9-13900k+4090），之前的 MBP 沦为开会本，开始尝试把 PC 作为主力机使用，由于驱动太新没搞上合适的 Linux 发行版，Ubuntu 系动不动又在“Ubuntu 内部错误”，所以我开始使用 Windows 作为自己的工作生活主力机。两周使用下来发现 Windows 的使用体验还是超出我的预期了。下面大概聊聊</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>时隔多年主力使用 Windows，感觉进步还是蛮大的，主要体现在</p><ol><li>系统交互上</li><li>开发者体验上</li></ol><p>系统交互上，Windows 吸收了不少其余的系统和软件的精髓，感觉进步不小，写几个我印象里比较深的吧</p><ol><li>开始菜单栏进行了改进，比之前感觉更好用了</li><li>File Explorer 的改进，比如支持 Tab 什么的，还是很舒服的</li><li>非常优秀的分屏功能，将窗口拖到屏幕上方就能选择不同的分屏比例和应用，同时在切换任务的时候，有 Task Group 的概念。这不比 macOS 高了不知道10个 Linux？</li><li>全局深色主题支持比之前好很多了</li></ol><p>整体使用下来，体验比前面的 Windows 好了不少，给人带来不少惊喜</p><p>然后在开发者体验方面，巨硬这几年拥抱开源的战略在 Windows 的开发者体验的优化体现的很不错</p><ol><li>WSL2 目前实测比 WSL1 时期好用了太多，IDE 以及其余的工具都能很好的支持</li><li>WSL2 的兼容性也出乎我的意料，我搞内核依赖的 BCC/eBPF 等工具都能在 WSL2 上正常运行，很不错</li><li>Visual Studio 对于 CMake 的支持超出了我的意料，非常不错</li></ol><p>果然巨硬现在是开发者的好朋友啊（</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>虽然 Windows 体验上有了很大的提升，但是还是有一些缺点的</p><ol><li>BUG 不少，比如在任务管理器里面重新排序任务之类的会卡界面（也有可能和我用的 dev channel 的 insider preview 有关</li><li>WSL2 的小问题不少，比如内存泄露，比如导出备份失败之类的</li><li>Windows 下面的权限管理始终是个问题，我迄今都没想明白，原神作为一个游戏要 UAC 干什么？检查我电脑上装莉莉丝的游戏了吗？</li><li>虽然有了 scope 这样的工具，Windows 上的软件包的管理还是有点蛋疼</li><li>好像没看到有类似 MacOS 上 setapp 这样的集中的软件分销体系，不知道是不是我没找到。反正买软件太分散了也挺蛋疼的</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近会回到 Windows 下办公了两周多，简单记录下自己的使用体验&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://manjusaka.blog/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="杂记" scheme="https://manjusaka.blog/categories/%E6%8A%80%E6%9C%AF/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="杂记" scheme="https://manjusaka.blog/tags/%E6%9D%82%E8%AE%B0/"/>
    
    <category term="技术" scheme="https://manjusaka.blog/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>容器 CPU 和 Memory 限制行为简述</title>
    <link href="https://manjusaka.blog/posts/2022/08/07/A-simple-introduction-about-cpu-and-memory-limit-in-docker/"/>
    <id>https://manjusaka.blog/posts/2022/08/07/A-simple-introduction-about-cpu-and-memory-limit-in-docker/</id>
    <published>2022-08-07T16:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.195Z</updated>
    
    <content type="html"><![CDATA[<p>这篇是给之前没啥容器经验的选手准备的一篇文章，主要是讲一下容器的 CPU 和 Memory 限制行为。</p><span id="more"></span><h2 id="CPU-限制"><a href="#CPU-限制" class="headerlink" title="CPU 限制"></a>CPU 限制</h2><p>首先 Mac 或者是 Windows 选手在使用 Docker Desktop 的时候，会设置 Docker Desktop 的 CPU 限制，默认是 1，也就是说 Docker Desktop 只能使用 1 个 CPU。这是因为 Docker Desktop 裹了一层虚拟机（Windows 下应该是 WSL2/Hyper-V，Mac 下可能是 QEMU）。这相当于我们在一个特定 CPU 数量的宿主机中跑 Docker</p><p>首先提到 CPU 限制，本质上是限制进程的 CPU 使用的时间片，在 Linux 下，进程存在三种调度优先级</p><ol><li>SCHED_NORMAL</li><li>SCHED_FIFO</li><li>SCHED_RR</li></ol><p>1 用的是 Linux 中 CFS 调度器，而常见普通进程都是 SCHED_NORMAL 。OK 前提知识带过</p><p>说回容器中的 CPU 限制，目前主流语境下，容器特指以 Docker 为代表的一系列的基于 Linux 中 CGroup 和 Namespace 进行隔离的技术方案。那么在这个语境下，CPU 限制的实现利用了Linux CGroup 中三个 CPU Subsystem。我们主要关心的如下四个参数</p><ol><li>cpu.cfs_period_us</li><li>cpu.cfs_quota_us</li><li>cpu.shares</li><li>cpuset.cpus</li></ol><p>现在分别来聊一下</p><p>首先说 cpu.shares，在 Docker 中的使用参数是 —cpu-shares，本质上是一个下限的软限制，用来设定 CPU 的利用率权重。默认值是 1024。这里对于相对值可能理解有点抽象。那么我们来看个例子 假如一个 1core 的主机运行 3 个 container，其中一个 cpu-shares 设置为 1024，而其它 cpu-shares 被设置成 512。当 3 个容器中的进程尝试使用 100% CPU 的时候（因为 cpu.shares 针对的是下限，只有使用 100% CPU 很重要，此时才可以体现设置值），则设置 1024 的容器会占用 50% 的 CPU 时间。那再举个例子，之前这个场景，其余的两个容器如果都没有太多任务，那么空余出来的 CPU 时间，是可以继续被第一个 1024 的容器继续使用的</p><p>接下来聊一下 cpu.cfs_quota_us 和 cpu.cfs_period_us ，这两个是需要组合使用才能生效，本质上含义是在 cpu.cfs_period_us 的单位时间内，进程最多可以利用 cpu.cfs_quota_us （单位都是 us），如果 quota 耗尽，那么进程会被内核 throttle 。在 Docker 下，你可以利用 —cpu-period 和 —cpu-quota 这两个值分别进行设置。也可以通过 —cpu 来进行设置，当我们设置 —cpu 为 2 的时候，容器会保证 cpu.cfs_quota_us 两倍于 cpu.cfs_period_us，剩下的就以此类推了（Docker 默认的 cpu.cfs_period_us 的阈值是 100ms 即 10000us）</p><p>现在已经聊了三个参数了，那么我们什么时候该用什么参数呢。通常来说，对于性能相对敏感的进程，我们可以使用 cpu.shares 来保证进程尽可能多的使用 CPU），业务进程可以利用 cpu.cfs_quota_us 和 cpu.cfs_period_us 来保证相对较好的公平分配。但是这样也带来一个问题，就是对于业务流量比较大的应用，可能会因为频繁被 throtlle 导致我们的 RT 等指标出现毛刺。Linux 5.12 之后有了一个新功能，cpu.cfs_burst_us ，即进程可以在 CPU 利用率比较低的空闲时段积累一定的 credit，然后在密集使用的时候换取一定的 buffer，实现更少的 throttle 和更高的 CPU 利用率（当然这个特性还暂时没有被主流容器所完全支持）</p><p>现在新的问题来了，无论 share 还是 cpu.cfs_quota_us 和 cpu.cfs_period_us 被 throttle 的概率都不少，如果我们想让进程更好的利用 CPU 怎么办？答案就是 cpuset.cpus ，Docker 中的参数是 —cpuset-cpus，可以让进程进行绑核处理</p><p>嗯，CPU 的部分就到这里</p><h2 id="Mem-限制"><a href="#Mem-限制" class="headerlink" title="Mem 限制"></a>Mem 限制</h2><p>还是前提科普</p><p>首先 Mac 或者是 Windows 选手在使用 Docker Desktop 的时候，会设置 Docker Desktop 的 Mem 限制，这相当于我们在一个特定 Mem 数量的宿主机中跑 Docker</p><p>然后在我们今天的语境下，Mem 资源的限制还是依托于 CGroup 的 Memory Subsystem，参数有很多，我们目前只需要关心</p><ol><li>memory.limit_in_bytes</li></ol><p>含义即是容器的最大内存限制，如果设置为 -1，代表着无任何内存的限制。在 Docker 中的参数是 —memory。</p><p>行为的话分为这样两种情况</p><ol><li>如果系统内存还有空余，但是容器内存超过了 Limit, 那么容器进程会被 OOMKiller Kill 掉</li><li>如果系统内存先于容器达到了内核阈值，那么 OOMKiller 会在整个系统范围内根据根据负载等多个因素计算一个 score，然后 rank 后从高到低进行 OOM Kill 的操作</li></ol><p>当然实际上还有一种额外的情况。可以通过 —oom-kill-disable 参数设置 memory.oom_control 的值。如果设置为1，那么容器内存超过 Limit 就不会被 OOM Kill 掉而是会被暂停，如果设置为0，那么容器内存超过 Limit 就会被 OOM Kill 掉</p><p>嗯关于 Mem 的行为差不多就这些</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>差不多就这样吧，纯新手向的文章，水文一篇，大家别介意（</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇是给之前没啥容器经验的选手准备的一篇文章，主要是讲一下容器的 CPU 和 Memory 限制行为。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/Linux/"/>
    
    
    <category term="编程" scheme="https://manjusaka.blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/tags/Linux/"/>
    
    <category term="容器" scheme="https://manjusaka.blog/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode Weekly Contest 287 题解</title>
    <link href="https://manjusaka.blog/posts/2022/04/05/leetcode-weekly-contest-287/"/>
    <id>https://manjusaka.blog/posts/2022/04/05/leetcode-weekly-contest-287/</id>
    <published>2022-04-05T13:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.199Z</updated>
    
    <content type="html"><![CDATA[<p>好久没打周赛了，打了一次周赛，简单的写个题解</p><span id="more"></span><h2 id="2224-Minimum-Number-of-Operations-to-Convert-Time"><a href="#2224-Minimum-Number-of-Operations-to-Convert-Time" class="headerlink" title="2224. Minimum Number of Operations to Convert Time"></a>2224. Minimum Number of Operations to Convert Time</h2><p>题面：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">You are given two strings current and correct representing two 24-hour times.</span><br><span class="line"></span><br><span class="line">24-hour times are formatted as &quot;HH:MM&quot;, where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59.</span><br><span class="line"></span><br><span class="line">In one operation you can increase the time current by 1, 5, 15, or 60 minutes. You can perform this operation any number of times.</span><br><span class="line"></span><br><span class="line">Return the minimum number of operations needed to convert current to correct.</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: current = &quot;02:30&quot;, correct = &quot;04:35&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">We can convert current to correct in 3 operations as follows:</span><br><span class="line">- Add 60 minutes to current. current becomes &quot;03:30&quot;.</span><br><span class="line">- Add 60 minutes to current. current becomes &quot;04:30&quot;.</span><br><span class="line">- Add 5 minutes to current. current becomes &quot;04:35&quot;.</span><br><span class="line">It can be proven that it is not possible to convert current to correct in fewer than 3 operations.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: current = &quot;11:00&quot;, correct = &quot;11:01&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We only have to add one minute to current, so the minimum number of operations needed is 1.</span><br></pre></td></tr></table></figure><p>这题没啥好说的吧，直接暴力计算时间写就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertTime</span>(<span class="params">self, current: <span class="built_in">str</span>, correct: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        correct_time = correct.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">        current_time = current.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">        minutes = <span class="built_in">int</span>(correct_time[<span class="number">1</span>]) - <span class="built_in">int</span>(current_time[<span class="number">1</span>])</span><br><span class="line">        hours = <span class="built_in">int</span>(correct_time[<span class="number">0</span>]) - <span class="built_in">int</span>(current_time[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> correct_time[<span class="number">1</span>] &lt; current_time[<span class="number">1</span>]:</span><br><span class="line">            minutes += <span class="number">60</span></span><br><span class="line">            hours -= <span class="number">1</span></span><br><span class="line">        results = hours</span><br><span class="line">        flag = [<span class="number">15</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">            <span class="keyword">if</span> minutes &gt;= i:</span><br><span class="line">                results += (minutes // i)</span><br><span class="line">                minutes = minutes % i</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><h2 id="2225-Find-Players-With-Zero-or-One-Losses"><a href="#2225-Find-Players-With-Zero-or-One-Losses" class="headerlink" title="2225. Find Players With Zero or One Losses"></a>2225. Find Players With Zero or One Losses</h2><p>题面：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.</span><br><span class="line"></span><br><span class="line">Return a list answer of size 2 where:</span><br><span class="line"></span><br><span class="line">answer[0] is a list of all players that have not lost any matches.</span><br><span class="line">answer[1] is a list of all players that have lost exactly one match.</span><br><span class="line">The values in the two lists should be returned in increasing order.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">You should only consider the players that have played at least one match.</span><br><span class="line">The testcases will be generated such that no two matches will have the same outcome.</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]</span><br><span class="line">Output: [[1,2,10],[4,5,7,8]]</span><br><span class="line">Explanation:</span><br><span class="line">Players 1, 2, and 10 have not lost any matches.</span><br><span class="line">Players 4, 5, 7, and 8 each have lost one match.</span><br><span class="line">Players 3, 6, and 9 each have lost two matches.</span><br><span class="line">Thus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: matches = [[2,3],[1,3],[5,4],[6,4]]</span><br><span class="line">Output: [[1,2,5,6],[]]</span><br><span class="line">Explanation:</span><br><span class="line">Players 1, 2, 5, and 6 have not lost any matches.</span><br><span class="line">Players 3 and 4 each have lost two matches.</span><br><span class="line">Thus, answer[0] = [1,2,5,6] and answer[1] = [].</span><br></pre></td></tr></table></figure><p>这题实际上就遍历统计就行，时间复杂度 O(N) 空间复杂度 O(N)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findWinners</span>(<span class="params">self, matches: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        index = defaultdict(<span class="keyword">lambda</span>: [<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> winner, loser <span class="keyword">in</span> matches:</span><br><span class="line">            index[winner][<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            index[loser][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="built_in">sorted</span>([k <span class="keyword">for</span> k, v <span class="keyword">in</span> index.items() <span class="keyword">if</span> v[<span class="number">0</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> v[<span class="number">1</span>] == <span class="number">0</span>]),</span><br><span class="line">            <span class="built_in">sorted</span>([k <span class="keyword">for</span> k, v <span class="keyword">in</span> index.items() <span class="keyword">if</span> v[<span class="number">1</span>] == <span class="number">1</span>]),</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><h2 id="2226-Maximum-Candies-Allocated-to-K-Children"><a href="#2226-Maximum-Candies-Allocated-to-K-Children" class="headerlink" title="2226. Maximum Candies Allocated to K Children"></a>2226. Maximum Candies Allocated to K Children</h2><p>草，这题题号真有意思，尊。。。。</p><p>题面：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">You are given a 0-indexed integer array candies. Each element in the array denotes a pile of candies of size candies[i]. You can divide each pile into any number of sub piles, but you cannot merge two piles together.</span><br><span class="line"></span><br><span class="line">You are also given an integer k. You should allocate piles of candies to k children such that each child gets the same number of candies. Each child can take at most one pile of candies and some piles of candies may go unused.</span><br><span class="line"></span><br><span class="line">Return the maximum number of candies each child can get.</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: candies = [5,8,6], k = 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: We can divide candies[1] into 2 piles of size 5 and 3, and candies[2] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: candies = [2,5], k = 11</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There are 11 children but only 7 candies in total, so it is impossible to ensure each child receives at least one candy. Thus, each child gets no candy and the answer is 0.</span><br></pre></td></tr></table></figure><p>这题实际上最开始没想清楚，后面仔细想了下，实际上是个二分的题目</p><p>首先假设，我们所有的糖的和为 y, 假设被 k 整除后的值是 z（含义是最大的能够整数分割的数），那么我们题目里孩子能获得的最大的糖果的数量的值域一定是 [0,z]</p><p>这个区间是具备单调性（单调递增），那么就具备了二分的条件。那么我们二分的题目是什么？假设中间值是 mid ，我们计算每推糖果能够按照 mid 分成几份并求和，如果和小于 k ，那么意味着值比我们目标值大，否则则比目标值小。持续逼近即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumCandies</span>(<span class="params">self, candies: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">sum</span>(candies) // k</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="built_in">sum</span>(candy // mid <span class="keyword">for</span> candy <span class="keyword">in</span> candies):</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h2 id="2227-Encrypt-and-Decrypt-Strings"><a href="#2227-Encrypt-and-Decrypt-Strings" class="headerlink" title="2227. Encrypt and Decrypt Strings"></a>2227. Encrypt and Decrypt Strings</h2><p>这题实际上比第三题简单</p><p>题面：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">You are given a character array keys containing unique characters and a string array values containing strings of length 2. You are also given another string array dictionary that contains all permitted original strings after decryption. You should implement a data structure that can encrypt or decrypt a 0-indexed string.</span><br><span class="line"></span><br><span class="line">A string is encrypted with the following process:</span><br><span class="line"></span><br><span class="line">For each character c in the string, we find the index i satisfying keys[i] == c in keys.</span><br><span class="line">Replace c with values[i] in the string.</span><br><span class="line">A string is decrypted with the following process:</span><br><span class="line"></span><br><span class="line">For each substring s of length 2 occurring at an even index in the string, we find an i such that values[i] == s. If there are multiple valid i, we choose any one of them. This means a string could have multiple possible strings it can decrypt to.</span><br><span class="line">Replace s with keys[i] in the string.</span><br><span class="line">Implement the Encrypter class:</span><br><span class="line"></span><br><span class="line">Encrypter(char[] keys, String[] values, String[] dictionary) Initializes the Encrypter class with keys, values, and dictionary.</span><br><span class="line">String encrypt(String word1) Encrypts word1 with the encryption process described above and returns the encrypted string.</span><br><span class="line">int decrypt(String word2) Returns the number of possible strings word2 could decrypt to that also appear in dictionary.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Encrypter&quot;, &quot;encrypt&quot;, &quot;decrypt&quot;]</span><br><span class="line">[[[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;], [&quot;ei&quot;, &quot;zf&quot;, &quot;ei&quot;, &quot;am&quot;], [&quot;abcd&quot;, &quot;acbd&quot;, &quot;adbc&quot;, &quot;badc&quot;, &quot;dacb&quot;, &quot;cadb&quot;, &quot;cbda&quot;, &quot;abad&quot;]], [&quot;abcd&quot;], [&quot;eizfeiam&quot;]]</span><br><span class="line">Output</span><br><span class="line">[null, &quot;eizfeiam&quot;, 2]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Encrypter encrypter = new Encrypter([[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;], [&quot;ei&quot;, &quot;zf&quot;, &quot;ei&quot;, &quot;am&quot;], [&quot;abcd&quot;, &quot;acbd&quot;, &quot;adbc&quot;, &quot;badc&quot;, &quot;dacb&quot;, &quot;cadb&quot;, &quot;cbda&quot;, &quot;abad&quot;]);</span><br><span class="line">encrypter.encrypt(&quot;abcd&quot;); // return &quot;eizfeiam&quot;. </span><br><span class="line">                           // &#x27;a&#x27; maps to &quot;ei&quot;, &#x27;b&#x27; maps to &quot;zf&quot;, &#x27;c&#x27; maps to &quot;ei&quot;, and &#x27;d&#x27; maps to &quot;am&quot;.</span><br><span class="line">encrypter.decrypt(&quot;eizfeiam&quot;); // return 2. </span><br><span class="line">                              // &quot;ei&quot; can map to &#x27;a&#x27; or &#x27;c&#x27;, &quot;zf&quot; maps to &#x27;b&#x27;, and &quot;am&quot; maps to &#x27;d&#x27;. </span><br><span class="line">                              // Thus, the possible strings after decryption are &quot;abad&quot;, &quot;cbad&quot;, &quot;abcd&quot;, and &quot;cbcd&quot;. </span><br><span class="line">                              // 2 of those strings, &quot;abad&quot; and &quot;abcd&quot;, appear in dictionary, so the answer is 2.</span><br></pre></td></tr></table></figure><p>这题加密部分其实直接按照规则写就行了，然后解密部分有个方法就是提前将字典里面的值预计算一次，然后就能 O(1) 计算了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Encrypter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, keys: <span class="type">List</span>[<span class="built_in">str</span>], values: <span class="type">List</span>[<span class="built_in">str</span>], dictionary: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">        self.index = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">zip</span>(keys, values)&#125;</span><br><span class="line">        self.counter = Counter(self.encrypt(item) <span class="keyword">for</span> item <span class="keyword">in</span> dictionary)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">self, word1: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(self.index.get(letter, <span class="string">&quot; &quot;</span>) <span class="keyword">for</span> letter <span class="keyword">in</span> word1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.counter[word2]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;好久没打周赛了，打了一次周赛，简单的写个题解&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="刷题" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/%E5%88%B7%E9%A2%98/"/>
    
    
    <category term="Python" scheme="https://manjusaka.blog/tags/Python/"/>
    
    <category term="编程" scheme="https://manjusaka.blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="leetcode" scheme="https://manjusaka.blog/tags/leetcode/"/>
    
    <category term="刷题" scheme="https://manjusaka.blog/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊在 Linux 内核中的网络质量监控</title>
    <link href="https://manjusaka.blog/posts/2022/01/31/a-simple-introduction-about-network-monitoring-in-linux-kernel/"/>
    <id>https://manjusaka.blog/posts/2022/01/31/a-simple-introduction-about-network-monitoring-in-linux-kernel/</id>
    <published>2022-01-31T13:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.199Z</updated>
    
    <content type="html"><![CDATA[<p>这可能是2021年最后一篇文章（农历年），也可能是2022年第一篇文章，不过这完全取决于我什么时候写完。这次来简单聊聊 Linux 中的网络监控</p><span id="more"></span><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>这篇文章，既是一篇水文，又不是一篇水文。不过还是新手向的一个文章。这篇文章实际上在我的草稿箱里呆了一年多的时间了，灵感最初源自我在阿里的一些工作（某种意义上算是国内领先的（但也是比较小众的工作（XD</p><p>随着技术的发展，大家对于服务的稳定性要求越来越高，而保证服务质量的前提就是有着合格的监控的覆盖面（阿里对于服务稳定性的要求叫做 “1-5-10” 即，一分钟发现，五分钟处理，十分钟自愈，而这样一个对于稳定性的要求没有足够的覆盖面的监控的话，那么一切等于圈圈）。而在这其中，网络质量的监控是重中之重</p><p>在讨论网络质量的监控之前，我们需要来明确网络质量这个定义的覆盖范围。</p><ol><li>网络链路上的异常情况</li><li>服务端网络的处理能力</li></ol><p>在明确这样的覆盖范围后，我们可以来思考什么样的指标代表着网络质量的降低。（注：本文主要分析 TCP 及 over TCP 协议的监控，后续不再赘述）</p><ol><li>毫无疑问，如果我们存在丢包的情况</li><li>发送/接收队列阻塞</li><li>超时</li></ol><p>那么我们可以再来看下具体细节</p><ol><li>如 RFC793<sup>1</sup> 提出的 RTO，RFC6298<sup>2</sup> 提出的 Retransmission Timer 等指标，可以衡量包传送时间。一个粗略的概括是，这两个指标越大代表着网络质量越低</li><li>如 RFC2018<sup>3</sup> 提出的 SACK，一个不精确的概括是 SACK 越多，代表着丢包越多</li><li>如果我们的链接频繁的被 RST，那么也代表着我们的网络质量存在问题</li></ol><p>当然在实际的生产过程中，我们还可以从很多其余的指标来辅助衡量网络质量，不过因为本文主要是介绍思路以 prototype 为主，所以不做过多赘述</p><p>在明确我们这篇文章中要获取什么指标后，我们再来分析一下我们怎么样去获取这些指标</p><h2 id="内核网络质量监控"><a href="#内核网络质量监控" class="headerlink" title="内核网络质量监控"></a>内核网络质量监控</h2><h3 id="暴力版"><a href="#暴力版" class="headerlink" title="暴力版"></a>暴力版</h3><p>从内核中获取网络的 metric ，本质上来说是从内核获取运行状态。说道这点，对 Linux 有所了解的同学第一反应肯定是说从 <strong>The Proc Filesystem</strong><sup>4</sup> 看一下能不能拿到具体的指标。Yep， 不错的思路，实际上的确可以拿到一部分的指标（这也是 <code>netstat</code> 等一些网络工具的原理)</p><p>在 <code>/proc/net/tcp</code> 中，我们可以获取到内核吐出的 Metric，现在包括这样一些</p><ol><li>连接状态</li><li>本地端口，地址</li><li>远程端口，地址</li><li>接收队列长度</li><li>发送队列长度</li><li>慢启动阈值</li><li>RTO 值</li><li>连接所属的 socket 的 inode id</li><li>uid</li><li>delay ack 软时钟</li></ol><p>完整的解释可以参考 <strong>proc_net_tcp.txt</strong><sup>5</sup></p><p>这样的做法针对于 prototype 可能说是可以的，不过其固有的几个弊端限制了在生产上大规模使用</p><ol><li>内核已经明确不推荐使用 <strong>proc_net_tcp.txt</strong><sup>5</sup>，换句话说，并不保证未来的兼容性与维护</li><li>内核直接提供的 metric 信息还是太少，一些关于 RTT，SRTT 这样的指标还是没法获取，也没法获取 SACK 等一些特定事件。</li><li>根据内核输出的 metric。存在的问题是实时性和精度的问题，换句话说，我们在不考虑精度的情况下可以去做这方面的尝试</li><li><strong>proc_net_tcp.txt</strong><sup>5</sup> 是和 network namespace 进行绑定的，换句话说，在容器的场景下，我们需要遍历可能存在的多个 network namespace ，不断的走 <code>nsenter</code> 去获取对应的 Metric</li></ol><p>所以在这样的背景下，<strong>proc_net_tcp.txt</strong><sup>5</sup> 并不太适合比较大规模的使用场景。所以我们需要对其做更近一步的优化</p><h3 id="优化-1-0-版"><a href="#优化-1-0-版" class="headerlink" title="优化 1.0 版"></a>优化 1.0 版</h3><p>在上文里，我们提到了关于直接从 <strong>The Proc Filesystem</strong><sup>4</sup> 中获取数据的弊端。其中一条很重要的是提到了</p><blockquote><p>内核已经明确不推荐使用 <strong>proc_net_tcp.txt</strong><sup>5</sup>，换句话说，并不保证未来的兼容性与维护</p></blockquote><p>那么推荐的做法是什么呢？答案是 <strong>netlink+sock_diag</strong> </p><p>简单介绍下 netlink<sup>6</sup> 是 Linux 2.2 引入的一种 Kernel Space 与 User Space 进行通信的机制，最早由 RFC3549<sup>7</sup> 提出。官方对于 netlink<sup>6</sup> 的描述大概是这样</p><blockquote><p>Netlink is used to transfer information between the kernel anduser-space processes. It consists of a standard sockets-based interface for user space processes and an internal kernel API for kernel modules.<br>The internal kernel interface is not documented in this manual page.  There is also an obsolete netlink interface via netlink character devices; this interface is not documented here and is provided only for backward compatibility.</p></blockquote><p>简而言之大概是用户可以利用 netlink<sup>6</sup> 很方便的与内核中的不同的 Kernel Module 进行数据交互</p><p>而在我们这样的场景下，我们就需要利用到 sock_diag<sup>8</sup>，官方对此的描述是</p><blockquote><p>The sock_diag netlink subsystem provides a mechanism for obtaining information about sockets of various address families from the kernel.  This subsystem can be used to obtain information about individual sockets or request a list of sockets.</p></blockquote><p>这里简而言之是说我们可以利用 sock_diag<sup>7</sup> 来获取不同 socket 的连接状态及相应的指标。（我们能获取到上文提到的所有指标，也能获得更细的 RTT 等指标）啊对了，这里要注意，netlink<sup>6</sup> 可以通过设置参数来从所有的 Network Namespace 获取指标。</p><p>在使用 netlink<sup>6</sup> 时，可能直接用 Pure C 来写比较繁琐。所幸，社区已经有不少封装成熟的 Lib，比如这里我选用 vishvananda 所封装的 netlink 库<sup>8</sup>，这里我给一个 Demo</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/vishvananda/netlink&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">results, err := netlink.SocketDiagTCPInfo(syscall.AF_INET)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> results &#123;</span><br><span class="line"><span class="keyword">if</span> item.TCPInfo != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Source:%s, Dest:%s, RTT:%d\n&quot;</span>, item.InetDiagMsg.ID.Source.String(), item.InetDiagMsg.ID.Destination.String(), item.TCPInfo.Rtt)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行示例大概是这样</p><p><img src="https://user-images.githubusercontent.com/7054676/151838248-eadaacf0-3d7a-4542-a091-9d401c37339c.png" alt="netlink"></p><p>OK，现在我们能用官方推荐的 Best Practice 来获取到更全更细的指标，也无需操心 Network namespace 的问题，但是我们最开始的几个问题还有一个比较棘手，就是实时性的问题。</p><p>因为如果我们选择周期性的轮询，那么如果在我们的轮询间隔中发生了网络波动，我们将丢失掉对应的现场。所以我们怎么样去解决实时性的问题呢？</p><h3 id="优化-2-0-版"><a href="#优化-2-0-版" class="headerlink" title="优化 2.0 版"></a>优化 2.0 版</h3><p>如果要在具体的比如重传，connection reset 等事件发生的时候，直接触发我们的调用。看过我之前博客的同学，可能第一时间考虑使用 eBPF + kprobe 的组合，在一些诸如 <code>tcp_reset</code> ，<code>tcp_retransmit_skb</code> 之类的关键调用上打点来获取实时的数据。Sounds good！</p><p>不过实际上还是有一些小小的问题</p><ol><li>kprobe 的开销在高频的情况下，相对来说会比较大一些</li><li>如果我们仅仅需要一些诸如 source_address, dest_address, source_port, dest_port 之类的信息，我们直接走 kprobe 拿完整地 skb 再来 cast 属实有点浪费</li></ol><p>所以我们有什么更好的方法吗？有的！</p><p>在 Linux 中，对于一系列的类似我们需求这样的特殊事件的触发与回调的场景，有一套基础设施叫做 Tracepoint<sup>9</sup>。这套设施，能够很好的帮我们处理监听事件并回调的需求。而在 Linux 4.15 以及 4.16 之后，Linux 新增了6个 tcp 相关的 Tracepoint<sup>9</sup></p><p>分别是</p><ol><li>tcp:tcp_destroy_sock</li><li>tcp:tcp_probe</li><li>tcp:tcp_receive_reset</li><li>tcp:tcp_retransmit_skb</li><li>tcp:tcp_retransmit_synack</li><li>tcp:tcp_send_reset</li></ol><p>这些 Tracepoint<sup>9</sup> 的含义，大家看名字可能就能明白了</p><p>而在这些 Tracepoint<sup>9</sup> 触发的时候，他们会给注册回调函数传入若干参数，这里我也给大家列一下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">tcp:tcp_retransmit_skb</span><br><span class="line">    const void * skbaddr;</span><br><span class="line">    const void * skaddr;</span><br><span class="line">    __u16 sport;</span><br><span class="line">    __u16 dport;</span><br><span class="line">    __u8 saddr[4];</span><br><span class="line">    __u8 daddr[4];</span><br><span class="line">    __u8 saddr_v6[16];</span><br><span class="line">    __u8 daddr_v6[16];</span><br><span class="line">tcp:tcp_send_reset</span><br><span class="line">    const void * skbaddr;</span><br><span class="line">    const void * skaddr;</span><br><span class="line">    __u16 sport;</span><br><span class="line">    __u16 dport;</span><br><span class="line">    __u8 saddr[4];</span><br><span class="line">    __u8 daddr[4];</span><br><span class="line">    __u8 saddr_v6[16];</span><br><span class="line">    __u8 daddr_v6[16];</span><br><span class="line">tcp:tcp_receive_reset</span><br><span class="line">    const void * skaddr;</span><br><span class="line">    __u16 sport;</span><br><span class="line">    __u16 dport;</span><br><span class="line">    __u8 saddr[4];</span><br><span class="line">    __u8 daddr[4];</span><br><span class="line">    __u8 saddr_v6[16];</span><br><span class="line">    __u8 daddr_v6[16];</span><br><span class="line">tcp:tcp_destroy_sock</span><br><span class="line">    const void * skaddr;</span><br><span class="line">    __u16 sport;</span><br><span class="line">    __u16 dport;</span><br><span class="line">    __u8 saddr[4];</span><br><span class="line">    __u8 daddr[4];</span><br><span class="line">    __u8 saddr_v6[16];</span><br><span class="line">    __u8 daddr_v6[16];</span><br><span class="line">tcp:tcp_retransmit_synack</span><br><span class="line">    const void * skaddr;</span><br><span class="line">    const void * req;</span><br><span class="line">    __u16 sport;</span><br><span class="line">    __u16 dport;</span><br><span class="line">    __u8 saddr[4];</span><br><span class="line">    __u8 daddr[4];</span><br><span class="line">    __u8 saddr_v6[16];</span><br><span class="line">    __u8 daddr_v6[16];</span><br><span class="line">tcp:tcp_probe</span><br><span class="line">    __u8 saddr[sizeof(struct sockaddr_in6)];</span><br><span class="line">    __u8 daddr[sizeof(struct sockaddr_in6)];</span><br><span class="line">    __u16 sport;</span><br><span class="line">    __u16 dport;</span><br><span class="line">    __u32 mark;</span><br><span class="line">    __u16 length;</span><br><span class="line">    __u32 snd_nxt;</span><br><span class="line">    __u32 snd_una;</span><br><span class="line">    __u32 snd_cwnd;</span><br><span class="line">    __u32 ssthresh;</span><br><span class="line">    __u32 snd_wnd;</span><br><span class="line">    __u32 srtt;</span><br><span class="line">    __u32 rcv_wnd;</span><br></pre></td></tr></table></figure><p>嗯，看到这里，大家可能心里应该有个数了，那么我们还是来写一下示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">BPF_RINGBUF_OUTPUT(tcp_event, 65536);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">enum tcp_event_type &#123;</span></span><br><span class="line"><span class="string">    retrans_event,</span></span><br><span class="line"><span class="string">    recv_rst_event,</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">struct event_data_t &#123;</span></span><br><span class="line"><span class="string">    enum tcp_event_type type;</span></span><br><span class="line"><span class="string">    u16 sport;</span></span><br><span class="line"><span class="string">    u16 dport;</span></span><br><span class="line"><span class="string">    u8 saddr[4];</span></span><br><span class="line"><span class="string">    u8 daddr[4];</span></span><br><span class="line"><span class="string">    u32 pid;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TRACEPOINT_PROBE(tcp, tcp_retransmit_skb)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    struct event_data_t event_data=&#123;&#125;;</span></span><br><span class="line"><span class="string">    event_data.type = retrans_event;</span></span><br><span class="line"><span class="string">    event_data.sport = args-&gt;sport;</span></span><br><span class="line"><span class="string">    event_data.dport = args-&gt;dport;</span></span><br><span class="line"><span class="string">    event_data.pid=bpf_get_current_pid_tgid()&gt;&gt;32;</span></span><br><span class="line"><span class="string">    bpf_probe_read_kernel(&amp;event_data.saddr,sizeof(event_data.saddr), args-&gt;saddr);</span></span><br><span class="line"><span class="string">    bpf_probe_read_kernel(&amp;event_data.daddr,sizeof(event_data.daddr), args-&gt;daddr);</span></span><br><span class="line"><span class="string">    tcp_event.ringbuf_output(&amp;event_data, sizeof(struct event_data_t), 0);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TRACEPOINT_PROBE(tcp, tcp_receive_reset)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    struct event_data_t event_data=&#123;&#125;;</span></span><br><span class="line"><span class="string">    event_data.type = recv_rst_event;</span></span><br><span class="line"><span class="string">    event_data.sport = args-&gt;sport;</span></span><br><span class="line"><span class="string">    event_data.dport = args-&gt;dport;</span></span><br><span class="line"><span class="string">    event_data.pid=bpf_get_current_pid_tgid()&gt;&gt;32;</span></span><br><span class="line"><span class="string">    bpf_probe_read_kernel(&amp;event_data.saddr,sizeof(event_data.saddr), args-&gt;saddr);</span></span><br><span class="line"><span class="string">    bpf_probe_read_kernel(&amp;event_data.daddr,sizeof(event_data.daddr), args-&gt;daddr);</span></span><br><span class="line"><span class="string">    tcp_event.ringbuf_output(&amp;event_data, sizeof(struct event_data_t), 0);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_event_data</span>(<span class="params">cpu, data, size</span>):</span><br><span class="line">    event = bpf[<span class="string">&quot;tcp_event&quot;</span>].event(data)</span><br><span class="line">    event_type = <span class="string">&quot;retransmit&quot;</span> <span class="keyword">if</span> event.<span class="built_in">type</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;recv_rst&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">&quot;%s %d %d %s %s %d&quot;</span></span><br><span class="line">        % (</span><br><span class="line">            event_type,</span><br><span class="line">            event.sport,</span><br><span class="line">            event.dport,</span><br><span class="line">            <span class="string">&quot;.&quot;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> event.saddr]),</span><br><span class="line">            <span class="string">&quot;.&quot;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> event.daddr]),</span><br><span class="line">            event.pid,</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf[<span class="string">&quot;tcp_event&quot;</span>].open_ring_buffer(process_event_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    bpf.ring_buffer_consume()</span><br></pre></td></tr></table></figure><p>我这里使用了 <code>tcp_receive_reset</code> 和 <code>tcp_retransmit_skb</code> 来监控我们机器上的程序。为了演示具体的效果，我先用 Go 写了一个访问 Google 的程序，然后通过 <code>sudo iptables -I OUTPUT -p tcp -m string --algo kmp --hex-string &quot;|c02bc02fc02cc030cca9cca8c009c013c00ac014009c009d002f0035c012000a130113021303|&quot; -j REJECT --reject-with tcp-reset</code> 来给这个 Go 程序注入 Connection Reset （这里的注入原理是 Go 默认库的发起 HTTPS 链接的 Client Hello 特征是固定的，我用 iptables 识别出方向流量，然后重置链接）</p><p>效果如下</p><p><img src="https://user-images.githubusercontent.com/7054676/151841316-8c954deb-e7a6-4229-80d6-4134d884a003.png" alt="Tracepoint"></p><p>嗯，写到这里，你可能想明白了，我们可以将 Tracepoint<sup>9</sup> 和 netlink<sup>6</sup> 结合使用来满足我们实时性的需求</p><h3 id="优化-3-0-版"><a href="#优化-3-0-版" class="headerlink" title="优化 3.0 版"></a>优化 3.0 版</h3><p>实际上写到现在，也更多的是讲一些 Prototype 和思路上的介绍。而为了能满足生产上的需要，还有很多的工作要做（这也是我之前所做的工作的一部分），包括不仅限于：</p><ol><li>工程上的性能优化，避免影响服务</li><li>Kubernetes 等容器平台的兼容</li><li>对接 Prometheus 等数据监控平台</li><li>可能需要嵌入 CNI 来获取更简便的监控路径等等</li></ol><p>实际上社区在这一块也有很多很有意思的工作，比如 Cilium 等，大家有兴趣也可以关注下。而我后续拾掇拾掇代码，也会在合适的时候将我之前的一些实现路径给开源出来。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章差不多就写到这里，内核的网络监控终归是比较小众的领域。希望我这里面的一些经验能够帮助上大家。嗯，祝大家新年快乐！虎年大吉！（下一篇文章就是写去年的年终总结了）</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>RFC793: <a href="https://datatracker.ietf.org/doc/html/rfc793">https://datatracker.ietf.org/doc/html/rfc793</a></li><li>RFC6298：<a href="https://datatracker.ietf.org/doc/html/rfc6298">https://datatracker.ietf.org/doc/html/rfc6298</a></li><li>RFC2018：<a href="https://datatracker.ietf.org/doc/html/rfc2018">https://datatracker.ietf.org/doc/html/rfc2018</a></li><li>The /proc Filesystem：<a href="https://www.kernel.org/doc/html/latest/filesystems/proc.html">https://www.kernel.org/doc/html/latest/filesystems/proc.html</a></li><li>proc_net_tcp.txt：<a href="https://www.kernel.org/doc/Documentation/networking/proc_net_tcp.txt">https://www.kernel.org/doc/Documentation/networking/proc_net_tcp.txt</a></li><li>netlink：<a href="https://man7.org/linux/man-pages/man7/netlink.7.html">https://man7.org/linux/man-pages/man7/netlink.7.html</a></li><li>sock_diag：<a href="https://man7.org/linux/man-pages/man7/sock_diag.7.html">https://man7.org/linux/man-pages/man7/sock_diag.7.html</a></li><li>vishvananda/netlink：<a href="https://github.com/vishvananda/netlink">https://github.com/vishvananda/netlink</a><br>9: Linux Tracepoint：<a href="https://www.kernel.org/doc/html/latest/trace/tracepoints.html">https://www.kernel.org/doc/html/latest/trace/tracepoints.html</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;这可能是2021年最后一篇文章（农历年），也可能是2022年第一篇文章，不过这完全取决于我什么时候写完。这次来简单聊聊 Linux 中的网络监控&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/Linux/"/>
    
    
    <category term="编程" scheme="https://manjusaka.blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/tags/Linux/"/>
    
    <category term="笔记" scheme="https://manjusaka.blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="水文" scheme="https://manjusaka.blog/tags/%E6%B0%B4%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊容器中的 UID 中的一点小坑</title>
    <link href="https://manjusaka.blog/posts/2021/12/03/a-simple-introduction-about-uid-docker/"/>
    <id>https://manjusaka.blog/posts/2021/12/03/a-simple-introduction-about-uid-docker/</id>
    <published>2021-12-03T13:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.199Z</updated>
    
    <content type="html"><![CDATA[<p>今天不太舒服，在家请假了一天。突然想起最近因为一些小问题，看了下关于容器中 UID 的东西。所以简单来聊聊这方面的东西。算个新手向的文章</p><span id="more"></span><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>最近帮 FrostMing 把他的 <a href="https://github.com/frostming/tokei-pie-cooker">tokei-pie-cooker</a> 部署到我的 K8S 上做成一个 SaaS 服务。Frost 最开始给我了一个镜像地址。然后我啪的一下复制粘贴了一个 Deployment 出来</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tokei-pie</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">tokei-pie</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tokei-pie</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">12</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tokei-pie</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tokei-pie</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tokei-pie</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">frostming/tokei-pie-cooker:latest</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;2Gi&quot;</span></span><br><span class="line">            <span class="attr">ephemeral-storage:</span> <span class="string">&quot;3Gi&quot;</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;500Mi&quot;</span></span><br><span class="line">            <span class="attr">ephemeral-storage:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">runAsNonRoot:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>啪的一下，很快嘛，很简单对吧，限制下 Storage 用量，限制一下 NonRoot ，以免我被人打穿。Fine，<code>kubectl apply -f</code> 一下。Ops，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: container has runAsNonRoot and image has non-numeric user (tokei), cannot verify user is non-root (pod: &quot;tokei-pie-6c6fd5cb84-s4bz7_tokei-pie(239057ea-fe47-40a9-8041-966c65344a44)&quot;, container: tokei-pie)</span><br></pre></td></tr></table></figure><p>噢，被 K8$ 拦截了，拦截点在 <code>pkg/kubelet/kuberruntime/security_context_others.go</code> 中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyRunAsNonRoot</span><span class="params">(pod *v1.Pod, container *v1.Container, uid *<span class="type">int64</span>, username <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">effectiveSc := securitycontext.DetermineEffectiveSecurityContext(pod, container)</span><br><span class="line"><span class="comment">// If the option is not set, or if running as root is allowed, return nil.</span></span><br><span class="line"><span class="keyword">if</span> effectiveSc == <span class="literal">nil</span> || effectiveSc.RunAsNonRoot == <span class="literal">nil</span> || !*effectiveSc.RunAsNonRoot &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> effectiveSc.RunAsUser != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> *effectiveSc.RunAsUser == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;container&#x27;s runAsUser breaks non-root policy (pod: %q, container: %s)&quot;</span>, format.Pod(pod), container.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> uid != <span class="literal">nil</span> &amp;&amp; *uid == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;container has runAsNonRoot and image will run as root (pod: %q, container: %s)&quot;</span>, format.Pod(pod), container.Name)</span><br><span class="line"><span class="keyword">case</span> uid == <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(username) &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;container has runAsNonRoot and image has non-numeric user (%s), cannot verify user is non-root (pod: %q, container: %s)&quot;</span>, username, format.Pod(pod), container.Name)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简而言之，K8$ 先会从镜像的 manifact 中拿镜像的 Runing Username. 如果你镜像里有设置 Runing Username 且你设置了 runAsNoneRoot ，同时你没设置 Run uid，那么会报错。Make Sense，如果你指定的用户名的 uid 是0，那么实际上还是打穿了 SecurityContext 的限制</p><p>找 Frost 要了下他的 Dockerfile，如下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.10</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -m tokei</span></span><br><span class="line"><span class="keyword">USER</span> tokei</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> templates /app/templates</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.py .</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> gunicorn_config.py .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/home/tokei/.local/bin:$PATH&quot;</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;gunicorn&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;gunicorn_config.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>OK, 平平淡淡，没有异常。OK，那我啪的一下改了 Deployment，新版如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tokei-pie</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">tokei-pie</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tokei-pie</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">12</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tokei-pie</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tokei-pie</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tokei-pie</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">frostming/tokei-pie-cooker:latest</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;2Gi&quot;</span></span><br><span class="line">            <span class="attr">ephemeral-storage:</span> <span class="string">&quot;3Gi&quot;</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;500Mi&quot;</span></span><br><span class="line">            <span class="attr">ephemeral-storage:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">runAsNonRoot:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">runAsUser:</span> <span class="number">10086</span></span><br></pre></td></tr></table></figure><p>这里选了我自己的 Magic Number， 10086，这下总没问题了吧，我又 duang 的一下执行了 <code>kubectl apply -f</code>。Oooops，船新的报错</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/python: can&#x27;t open file &#x27;/home/tokei/.local/bin/gunicorn&#x27;: [Errno 13] Permission denied</span><br></pre></td></tr></table></figure><p>OK，那我抛弃我的 Magic Number，换成传说中的数字，1000 来看一下。OK，Works！</p><p>那么这一切到底是为什么呢？那么接下来小编会来告诉你（XD</p><h2 id="简单的介绍，完整的快乐"><a href="#简单的介绍，完整的快乐" class="headerlink" title="简单的介绍，完整的快乐"></a>简单的介绍，完整的快乐</h2><h3 id="容器中的-UID"><a href="#容器中的-UID" class="headerlink" title="容器中的 UID"></a>容器中的 UID</h3><p>首先讲一点前置的知识。首先在 Linux 中的 UID 分配规律。首先在一个 Linux UserNamespace 中，UID 默认的范围是从 0 - 60000。其中 UID 0 是 Root 的保留 UID。从理论上来讲，用户 UID/GID 的创建的范围是从 1 到 60000</p><p>但是实际上可能会更复杂一些，通常各发行版的内置的一些服务，可能会自带一些特殊的用户，比如经典的 www-data （之前没事喜欢搭博客的同学对这个肯定不陌生）。所以实践中，一个 User Namespace 内，一个 UID 的起始，通常是 500 或者 1000。具体的设置，取决于一个特殊文件的设置，<a href="https://man7.org/linux/man-pages/man5/login.defs.5.html">login.defs</a>，路径是 <code>/etc/login.defs</code></p><p>官方文档中描述如下：</p><blockquote><p>Range of user IDs used for the creation of regular users by useradd or newusers. The default value for UID_MIN (resp.  UID_MAX) is 1000 (resp. 60000).</p></blockquote><p>在我们调用 <a href="https://man7.org/linux/man-pages/man8/useradd.8.html"><code>useradd</code></a> 来在构建 Dockerfile 时添加用户。这个时候，在相关操作执行完毕后，会在 <a href="https://linux.die.net/man/5/passwd"><code>/etc/passwd</code></a> 这个特殊文件中添加对应的用户信息。以 Frost 的 Dockerfile 为例，最终的 passwd 文件内容如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br><span class="line">man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span><br><span class="line">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin</span><br><span class="line">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin</span><br><span class="line">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</span><br><span class="line">uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin</span><br><span class="line">proxy:x:13:13:proxy:/bin:/usr/sbin/nologin</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin</span><br><span class="line">irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin</span><br><span class="line">gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin</span><br><span class="line">nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin</span><br><span class="line">_apt:x:100:65534::/nonexistent:/usr/sbin/nologin</span><br><span class="line">tokei:x:1000:1000::/home/tokei:/bin/sh</span><br></pre></td></tr></table></figure><p>那么构建文件结束后，我们来看一下我们常见的容器运行时之一的 Docker 对此相关的处理。</p><p>这里还要科普一点前置的知识，现在 Docker 实际上只能算一个 Daemon+CLI，它核心的功能是调用其背后的 containerd。而 containerd 最终通过 runc 来创建相关的容器</p><p>那我们这里看一下 runc 对此相关的处理</p><p>在 runc 创建容器的时候，会调用 <code>runc/libcontainer/init_linux.go.finalizeNamespace</code> 这个函数完成一些设置，而在这个函数中，会调用 <code>runc/libcontainer/init_linux.go.setupUser</code> 这个函数来完成 Exec User 的设置，我们来看下源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupUser</span><span class="params">(config *initConfig)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// Set up defaults.</span></span><br><span class="line">defaultExecUser := user.ExecUser&#123;</span><br><span class="line">Uid:  <span class="number">0</span>,</span><br><span class="line">Gid:  <span class="number">0</span>,</span><br><span class="line">Home: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">passwdPath, err := user.GetPasswdPath()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">groupPath, err := user.GetGroupPath()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execUser, err := user.GetExecUserPath(config.User, &amp;defaultExecUser, passwdPath, groupPath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addGroups []<span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(config.AdditionalGroups) &gt; <span class="number">0</span> &#123;</span><br><span class="line">addGroups, err = user.GetAdditionalGroupsPath(config.AdditionalGroups, groupPath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rather than just erroring out later in setuid(2) and setgid(2), check</span></span><br><span class="line"><span class="comment">// that the user is mapped here.</span></span><br><span class="line"><span class="keyword">if</span> _, err := config.Config.HostUID(execUser.Uid); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;cannot set uid to unmapped user in user namespace&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err := config.Config.HostGID(execUser.Gid); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;cannot set gid to unmapped user in user namespace&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.RootlessEUID &#123;</span><br><span class="line"><span class="comment">// We cannot set any additional groups in a rootless container and thus</span></span><br><span class="line"><span class="comment">// we bail if the user asked us to do so. <span class="doctag">TODO:</span> We currently can&#x27;t do</span></span><br><span class="line"><span class="comment">// this check earlier, but if libcontainer.Process.User was typesafe</span></span><br><span class="line"><span class="comment">// this might work.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(addGroups) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;cannot set any additional groups in a rootless container&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Before we change to the container&#x27;s user make sure that the processes</span></span><br><span class="line"><span class="comment">// STDIO is correctly owned by the user that we are switching to.</span></span><br><span class="line"><span class="keyword">if</span> err := fixStdioPermissions(config, execUser); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setgroups, err := ioutil.ReadFile(<span class="string">&quot;/proc/self/setgroups&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This isn&#x27;t allowed in an unprivileged user namespace since Linux 3.19.</span></span><br><span class="line"><span class="comment">// There&#x27;s nothing we can do about /etc/group entries, so we silently</span></span><br><span class="line"><span class="comment">// ignore setting groups here (since the user didn&#x27;t explicitly ask us to</span></span><br><span class="line"><span class="comment">// set the group).</span></span><br><span class="line">allowSupGroups := !config.RootlessEUID &amp;&amp; <span class="type">string</span>(bytes.TrimSpace(setgroups)) != <span class="string">&quot;deny&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> allowSupGroups &#123;</span><br><span class="line">suppGroups := <span class="built_in">append</span>(execUser.Sgids, addGroups...)</span><br><span class="line"><span class="keyword">if</span> err := unix.Setgroups(suppGroups); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := system.Setgid(execUser.Gid); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := system.Setuid(execUser.Uid); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if we didn&#x27;t get HOME already, set it based on the user&#x27;s HOME</span></span><br><span class="line"><span class="keyword">if</span> envHome := os.Getenv(<span class="string">&quot;HOME&quot;</span>); envHome == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := os.Setenv(<span class="string">&quot;HOME&quot;</span>, execUser.Home); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大家看注释应该差不多能理解这段代码在干啥，在这段代码将会调用 <code>runc/libcontainer/user/user.go.GetExecUserPath</code> 和 <code>runc/libcontainer/user/user.go.GetExecUser</code> 来获取 exec 时的 UID，我们来看一下这块的实现（下面代码我精简了一部（</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetExecUser</span><span class="params">(userSpec <span class="type">string</span>, defaults *ExecUser, passwd, group io.Reader)</span></span> (*ExecUser, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> defaults == <span class="literal">nil</span> &#123;</span><br><span class="line">defaults = <span class="built_in">new</span>(ExecUser)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy over defaults.</span></span><br><span class="line">user := &amp;ExecUser&#123;</span><br><span class="line">Uid:   defaults.Uid,</span><br><span class="line">Gid:   defaults.Gid,</span><br><span class="line">Sgids: defaults.Sgids,</span><br><span class="line">Home:  defaults.Home,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sgids slice *cannot* be nil.</span></span><br><span class="line"><span class="keyword">if</span> user.Sgids == <span class="literal">nil</span> &#123;</span><br><span class="line">user.Sgids = []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow for userArg to have either &quot;user&quot; syntax, or optionally &quot;user:group&quot; syntax</span></span><br><span class="line"><span class="keyword">var</span> userArg, groupArg <span class="type">string</span></span><br><span class="line">parseLine([]<span class="type">byte</span>(userSpec), &amp;userArg, &amp;groupArg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert userArg and groupArg to be numeric, so we don&#x27;t have to execute</span></span><br><span class="line"><span class="comment">// Atoi *twice* for each iteration over lines.</span></span><br><span class="line">uidArg, uidErr := strconv.Atoi(userArg)</span><br><span class="line">gidArg, gidErr := strconv.Atoi(groupArg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find the matching user.</span></span><br><span class="line">users, err := ParsePasswdFilter(passwd, <span class="function"><span class="keyword">func</span><span class="params">(u User)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> userArg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="comment">// Default to current state of the user.</span></span><br><span class="line"><span class="keyword">return</span> u.Uid == user.Uid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> uidErr == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// If the userArg is numeric, always treat it as a UID.</span></span><br><span class="line"><span class="keyword">return</span> uidArg == u.Uid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> u.Name == userArg</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; passwd != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> userArg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">userArg = strconv.Itoa(user.Uid)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to find user %s: %v&quot;</span>, userArg, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matchedUserName <span class="type">string</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(users) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// First match wins, even if there&#x27;s more than one matching entry.</span></span><br><span class="line">matchedUserName = users[<span class="number">0</span>].Name</span><br><span class="line">user.Uid = users[<span class="number">0</span>].Uid</span><br><span class="line">user.Gid = users[<span class="number">0</span>].Gid</span><br><span class="line">user.Home = users[<span class="number">0</span>].Home</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> userArg != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="comment">// If we can&#x27;t find a user with the given username, the only other valid</span></span><br><span class="line"><span class="comment">// option is if it&#x27;s a numeric username with no associated entry in passwd.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> uidErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Not numeric.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to find user %s: %v&quot;</span>, userArg, ErrNoPasswdEntries)</span><br><span class="line">&#125;</span><br><span class="line">user.Uid = uidArg</span><br><span class="line"></span><br><span class="line"><span class="comment">// Must be inside valid uid range.</span></span><br><span class="line"><span class="keyword">if</span> user.Uid &lt; minID || user.Uid &gt; maxID &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrRange</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Okay, so it&#x27;s numeric. We can just roll with this.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看着很复杂，实际上总结下来就这样</p><ol><li><p>首先从 <code>/etc/passwd</code> 读取已知的所有的用户</p></li><li><p>如果用户启动时传入的是用户名，那么判断是否有用户名和启动参数传入的相等，没有则启动失败</p></li><li><p>如果用户启动传入的是 UID，那么如果在已知用户中有对应的用户，那么设置为该用户。如果没有，则将进程的 UID 设置为传入的 UID</p></li><li><p>如果用户什么都没传入，那么以 <code>/etc/passwd</code> 中第一个用户来作为 exec 用户。默认情况下第一个用户通常是指 UID 为 0 的 root 用户。</p></li></ol><p>OK 那么回到我们的 Deployment 中，那我们不难得出如下的结论</p><ol><li><p>如果我们没有设置 runAsUser ，且镜像里也没指定启动用户，那么我们容器中的进程将以当前 user namespace 中 uid 为 0 的 root 用户启动</p></li><li><p>如果在 Dockerfile 中设定了启动时的用户，且没有设置 runAsUser，那么将以我们在 Dockerfile 中的用户启动</p></li><li><p>如果我们设置了 runAsUser 且 Dockerfile 中也指定了相关的用户，那么将以 runAsUser 所指定的 UID 启动进程</p></li></ol><p>OK 那么，到这里看似问题解决了。但是这里有个新的疑问。通常来说，我们创建文件之类的操作，默认的权限都是 <code>755</code> ，即对于非当前用户，也非当前用户组内的成员，有可读可执行权限。按道理说不应该出现前文所说的 <code>[Errno 13] Permission denied</code> 情况。</p><p>我进容器看了下报错的文件，的确也和我估计的一样，是 755 权限</p><p><img src="https://user-images.githubusercontent.com/7054676/144605351-630025e7-33a7-421e-b471-cb4cc5a217fe.png" alt="gunicorn.py"></p><p>那么问题出在哪呢？问题出在 <code>~/.local/</code> 这个文件夹，</p><p><img src="https://user-images.githubusercontent.com/7054676/144605509-1caf1ac5-85a9-406d-8a7c-5f6714dca6f3.png" alt="~/.local"></p><p>是的没错，这里的 <code>.local</code> 是 700 权限，即对于非当前用户，也非当前用户组内的成员，没有对当前目录的可执行权限。这里大家可能有点迷惑，目录的可执行权限是什么？这里引用下官方文档 <a href="https://www.linux.com/training-tutorials/understanding-linux-file-permissions/">Understanding Linux File Permissions</a> 中的描述</p><blockquote><p>execute – The Execute permission affects a user’s capability to execute a file or view the contents of a directory.</p></blockquote><p>OK，好吧，如果没有对应的目录的可执行权限，那么我们也没法执行该目录里的文件，即便我们有文件的可执行权限。</p><p>而我这里翻了一下 pip 的源码。发现 pip 在用户态安装的时候，如果不存在 .local 目录，那么会创建 .local 目录并将权限设置为 700。</p><p>OK 到这里我们的整个问题的因果链就已经完全建立了</p><blockquote><p>在 dockerfile 中创建并设置用户 tokei，uid 1000 -&gt; pip 创建了 700 的 .local， .local 归属 UID 1000 的用户-&gt; 我们 runAsUser 设置为 非 1000 的数字 -&gt; 无 .local 的可执行权限 -&gt; 报错</p></blockquote><p>说实话，我能理解 pip 为什么这么设计，但是我觉得这样的设计是有一点 broke 了一些约定俗成的规矩的，其合理性有待商榷</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个问题其实不算难查，但是发生的位置是我有点没有想到的，从我的角度来看，归根结底还是在与 pip 不遵守基本法造成的23333</p><p>这里留个题目大家有兴趣可以思考下。我们都知道 Docker 有个命令是 <code>docker cp</code> 是从宿主机往运行的容器中拷贝文件/从容器中往宿主机中拷贝文件。有个参数是 <code>-a</code> ，即保留原文件的 UID/GID，那么如果我们用这个参数从宿主机/容器往容器/宿主机中拷贝文件，那么我们 ls -lh 时，可以看到怎样的 User/UserGroup 信息。</p><p>OK，这篇水文就先写到这里，写水文真快乐。周末要是有时间的话，可以再写个水文简单聊聊一个关于最近遇到的一个很有趣的根据特征封锁 SSL 流量的手法分析</p><p>好了，溜了溜了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天不太舒服，在家请假了一天。突然想起最近因为一些小问题，看了下关于容器中 UID 的东西。所以简单来聊聊这方面的东西。算个新手向的文章&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/Linux/"/>
    
    
    <category term="编程" scheme="https://manjusaka.blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/tags/Linux/"/>
    
    <category term="笔记" scheme="https://manjusaka.blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="水文" scheme="https://manjusaka.blog/tags/%E6%B0%B4%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>聊聊 sk_buff 中一个冷门字段: nohdr</title>
    <link href="https://manjusaka.blog/posts/2021/11/22/a-litte-introduction-about-nohdr-filed-in-skbuff/"/>
    <id>https://manjusaka.blog/posts/2021/11/22/a-litte-introduction-about-nohdr-filed-in-skbuff/</id>
    <published>2021-11-22T13:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.195Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到一个很有意思的问题，“nohdr 字段到底有什么用”，在这里写个水文简单记录一下</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>首先来说，不管介绍再冷门的字段，既然涉及到 SKBUFF ，那么就得先来对 sk_buff 做个简单的介绍</p><p>简而言之，sk_buff 是 Linux 网络子系统的核心数据结构，从链路层到我们最终对数据包的操作，背后都离不开 sk_buff </p><p>sk_buff 要完全讲解基本就相当于把 Linux 网络系统完全讲解了，所以讲完是不可能讲完的，这辈子都不可能的！</p><p>简单聊几个关键，可能会帮助大家理解我们本文提到的冷门字段 nohdr 的关键字段吧</p><p>首先来讲，最重要的三个字段：<code>data</code> ，<code>mac</code> 和 <code>nh</code> ，分别代表着当前 sk_buff 的数据区的起始地址，L2 header 的起始地址，L3 Header 的起始地址。用一个图方便大家理解</p><p><img src="https://user-images.githubusercontent.com/7054676/142876157-422a2115-15bb-4b9e-8ed7-9335c09b695f.png" alt="sk_buff 三剑客"></p><p>看了图的同学可能会有点明白了，实际上在内核里，也是一层一层的通过指针偏移，不断的添加新的 header 来处理网络请求。和我们直觉相符。可能有同学会问，我既然知道 L3 Header 的起始地址，IP 之类的 L3 协议的 header 长度是固定的。我是不是可以算出 L4 的偏移，然后手动处理。</p><p>Bingo，内核里有 <code>tcphdr</code> 的数据结构（对应 IP 是 <code>iphdr</code> ），你根据偏移，手动 cast 就可以手动处理。不过详细做法以后再聊</p><p>接着两个比较重要的字段，是 <code>len</code> 和 <code>data_len</code> ，这两个字段都是标识数据长度，但是简要来说，len 代表着当前 sk_buff 所有数据的长度（即包含当前协议的 header 和 payload），data_len 代表当前有效数据长度（即当前协议 payload 长度）</p><p>OK，前情提要到此结束</p><h3 id="关于-nohdr"><a href="#关于-nohdr" class="headerlink" title="关于 nohdr"></a>关于 nohdr</h3><p>花开两朵，各表一支。聊了 sk_buff 一些预备知识，我们来聊一下 <code>nohdr</code> 这个字段。说实话这个字段真的很冷门</p><p>首先官方对此有对应描述</p><blockquote><p>The ‘nohdr’ field is used in the support of TCP Segmentation Offload (‘TSO’ for short). Most devices supporting this feature need to make some minor modifications to the TCP and IP headers of an outgoing packet to get it in the right form for the hardware to process. We do not want these modifications to be seen by packet sniffers and the like. So we use this ‘nohdr’ field and a special bit in the data area reference count to keep track of whether the device needs to replace the data area before making the packet header modifications.</p></blockquote><p>嗯，这段属实有点拗口。首先 TSO 大家肯定有所所了解。利用网卡来对大数据包进行分段（具体 Linux 下 GSO/TSO 的实现可以改天鸽一篇文章来聊），那么在这种情况下，网卡可能会需要对 header 部分进行一点小的修改来完成分片的操作。</p><p>但是有些时候，我们对于 L4 这一层的包，我并不需要关心其被修改的 Header ，只需要关心其 payload，那么怎么搞。这个时候就是 <code>nohdr</code> 发挥作用了。</p><p>在这里， <code>nohdr</code> 生效还需要配合另外一个字段，<code>dataref</code> 。 <code>dataref</code> 是一个计数字段，其具体的含义是指当前 data 字段所指向的数据区，被多少个 sk_buff 所引用。在这里有两种情况</p><ol><li><p>在 nohdr 为 0 的情况下，dataref 值为数据区的引用计数</p></li><li><p>在 nohdr 为 1 的情况下，高16位，是数据区中 payload 数据区的引用计数，低16位是数据区的引用计数</p></li></ol><p>对此官方有这样的描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We divide dataref into two halves. The higher 16 bits hold references * to the payload part of skb-&gt;data. The lower 16 bits hold references to * the entire skb-&gt;data. It is up to the users of the skb to agree on * where the payload starts.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* * All users must obey the rule that the skb-&gt;data reference count must be * greater than or equal to the payload reference count.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* * Holding a reference to the payload part means that the user does not * care about modifications to the header part of skb-&gt;data.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SKB_DATAREF_SHIFT 16 #<span class="keyword">define</span> SKB_DATAREF_MASK ((1 &lt;&lt; SKB_DATAREF_SHIFT) - 1)</span></span><br></pre></td></tr></table></figure><p>实际上这里也不太难理解为什么这么设计。首先来说，我们在内核里去获取数据包的时候，有些时候不需要去关心具体的 header，只需要关心具体的 payload。 而我们对于 payload 的引用计数，也需要单独的处理来保证其正确性。这样确保我们的数据还没处理完的时候。数据片不会被内核提前释放。当然这里需要大家在处理这块的时候需要保证数据区的引用计数要大于 payload 的引用计数（感觉这里像约定大于配置的做法？（当然这里不遵守约定的后果就是你内核 dump 了2333</p><p>在最后，我们的内核也通过 dataref 来在合适的时机释放数据区的内存空间，释放条件是满足以下其一即可</p><ol><li>!skb-&gt;cloned: skb 没有 被 clone</li><li>!atomic_sub_return(skb-&gt;nohdr ? (1 &lt;&lt; SKB_DATAREF_SHIFT) + 1 : 1, &amp;skb_shinfo(skb)-&gt;dataref) 即在 nohdr 为 1 的时候通过 dataref-(1 &lt;&lt; SKB_DATAREF_SHIFT) + 1) 判断是否需要释放数据区。而 nohdr 为 0 的时候通过 dataref-1 来决定是否需要释放数据区</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>水文差不多就这样。。<code>nohdr</code> 真的是个很冷门的字段。嗯，因为这篇水文的一些 reference 是在地铁上查的。。我就懒得列在文章里了。。差不多这样。。写题去了。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天遇到一个很有意思的问题，“nohdr 字段到底有什么用”，在这里写个水文简单记录一下&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/Linux/"/>
    
    
    <category term="编程" scheme="https://manjusaka.blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/tags/Linux/"/>
    
    <category term="笔记" scheme="https://manjusaka.blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="水文" scheme="https://manjusaka.blog/tags/%E6%B0%B4%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>关于 Node.js 中 execSync 的一点问题</title>
    <link href="https://manjusaka.blog/posts/2021/08/24/a-little-problem-about-posix-node-js-execsync/"/>
    <id>https://manjusaka.blog/posts/2021/08/24/a-little-problem-about-posix-node-js-execsync/</id>
    <published>2021-08-24T13:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.195Z</updated>
    
    <content type="html"><![CDATA[<p>很久没写水文了，昨天帮人查了一个 Node.js 中 <code>execSync</code> 这个函数特殊行为的问题，很有趣，所以大概记录下来水一篇文章</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>首先老哥给了一张截图</p><p><img src="https://user-images.githubusercontent.com/7054676/130622339-57e6a954-926e-4741-93a9-bc1ba0d155d8.png" alt="问题截图"></p><p>首先基本问题可以抽象为在 Node.js 中利用 <code>execSync</code> 这个函数执行 <code>ps -Af | grep -q -E -c &quot;\\-\\-user-data-dir=\\.+App&quot;</code> 这样一条命令的时候，Node.js 时不时会报错。具体堆栈大概为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Uncaught Error: Command failed: ps -Af | grep -q -E -c &quot;\-\-user-data-dir=\.+App&quot;</span><br><span class="line">    at checkExecSyncError (child_process.js:616:11)</span><br><span class="line">    at Object.execSync (child_process.js:652:15) &#123;</span><br><span class="line">  status: 1,</span><br><span class="line">  signal: null,</span><br><span class="line">  output: [ null, &lt;Buffer &gt;, &lt;Buffer &gt; ],</span><br><span class="line">  pid: 89073,</span><br><span class="line">  stdout: &lt;Buffer &gt;,</span><br><span class="line">  stderr: &lt;Buffer &gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是同样的命令在终端上并不会有类似的现象。所以这个问题有点困扰人</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先先看一下 Node.js 文档中对 <code>execSync</code> 的描述</p><blockquote><p>The child_process.execSync() method is generally identical to child_process.exec() with the exception that the method will not return until the child process has fully closed. When a timeout has been encountered and killSignal is sent, the method won’t return until the process has completely exited. If the child process intercepts and handles the SIGTERM signal and doesn’t exit, the parent process will wait until the child process has exited.<br>If the process times out or has a non-zero exit code, this method will throw. The Error object will contain the entire result from child_process.spawnSync().<br>Never pass unsanitized user input to this function. Any input containing shell metacharacters may be used to trigger arbitrary command execution.</p></blockquote><p>大意就是，这个函数通过子进程来执行一个命令，在命令执行超时之前会一直等待。OK 没有问题。那接下来，我们先来看一下上面提到的报错堆栈以及 <code>execSync</code> 的实现代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">execSync</span>(<span class="params">command, options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> opts = <span class="title function_">normalizeExecArgs</span>(command, options, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> inheritStderr = !opts.<span class="property">options</span>.<span class="property">stdio</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ret = <span class="title function_">spawnSync</span>(opts.<span class="property">file</span>, opts.<span class="property">options</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inheritStderr &amp;&amp; ret.<span class="property">stderr</span>)</span><br><span class="line">    process.<span class="property">stderr</span>.<span class="title function_">write</span>(ret.<span class="property">stderr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> err = <span class="title function_">checkExecSyncError</span>(ret, opts.<span class="property">args</span>, command);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret.<span class="property">stdout</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkExecSyncError</span>(<span class="params">ret, args, cmd</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> err;</span><br><span class="line">  <span class="keyword">if</span> (ret.<span class="property">error</span>) &#123;</span><br><span class="line">    err = ret.<span class="property">error</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret.<span class="property">status</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;Command failed: &#x27;</span>;</span><br><span class="line">    msg += cmd || <span class="title class_">ArrayPrototypeJoin</span>(args, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.<span class="property">stderr</span> &amp;&amp; ret.<span class="property">stderr</span>.<span class="property">length</span> &gt; <span class="number">0</span>)</span><br><span class="line">      msg += <span class="string">`\n<span class="subst">$&#123;ret.stderr.toString()&#125;</span>`</span>;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-restricted-syntax</span></span><br><span class="line">    err = <span class="keyword">new</span> <span class="title class_">Error</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="title class_">ObjectAssign</span>(err, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们能看到，这里 <code>execSync</code> 在执行完命令执行代码后，会进入 <code>checkExecSyncError</code> 来检查子进程的 <code>Exit Status Code</code> 是否为0，不为0则认为命令执行出错，然后抛出异常。</p><p>看起来没有问题，那么也就是我们执行命令的时候出错了？那我们验证下吧</p><p>对于这种涉及 Linux 下 Syscall 问题排查的工具（这个问题在 Mac 等环境下也存在，不过我为了方便排查，跑去 Linux 上复现了），除了 <code>strace</code> 好像也暂时找不到更成熟方便的工具了（虽然基于 eBPF 也能做，但是说实话自己现撸绝对没 <code>strace</code> 的效果好。</p><p>那么上命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo strace -t -f -p <span class="variable">$PID</span> -o error_trace.txt</span><br></pre></td></tr></table></figure><blockquote><p>tips: 在使用 strace 的时候可以利用 -f 参数，可以 trace 被 trace 进程创建的子进程</p></blockquote><p>好了执行命令，成功拿到整个 syscall 的调用链路，OK 开始分析</p><p>首先我们将目光很快定位到了最关键的部分（因为整个文件太长，有将近 4K 行，我就直接挑重点部分分析了）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">894259 13:21:23 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f12d9465a50) = 896940</span><br><span class="line">...</span><br><span class="line">896940 13:21:23 execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ps -Af | grep -E -c \&quot;\\-\\-user-da&quot;...], 0x4aae230 /* 40 vars */ &lt;unfinished ...&gt;</span><br><span class="line">...</span><br><span class="line">896940 13:21:24 &lt;... wait4 resumed&gt;[&#123;WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 1&#125;], 0, NULL) = 896942</span><br><span class="line">896940 13:21:24 --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=896942, si_uid=1000, si_status=1, si_utime=0, si_stime=0&#125; ---</span><br><span class="line">896940 13:21:24 rt_sigreturn(&#123;mask=[]&#125;) = 896942</span><br><span class="line">896940 13:21:24 exit_group(1)           = ?</span><br><span class="line">896940 13:21:24 +++ exited with 1 +++</span><br></pre></td></tr></table></figure><p>首先这里科普一下，Node.js 中没有直接使用 <code>fork</code> 来创建新的进程，而是使用 <code>clone</code> 来创建新的进程，至于两者之间的差别，要详细说的话，可以单独水一篇超长文了（我先立个 flag）这里先用官方的说法大概描述下</p><blockquote><p>These system calls create a new (“child”) process, in a manner similar to fork(2).<br>By contrast with fork(2), these system calls provide more precise control over what pieces of execution context are shared between the calling process and the child process.  For example, using these system calls, the caller can control whether or not the two processes share the virtual address space, the table of file descriptors, and the table of signal handlers.  These system calls also allow the new child process to be placed in separate namespaces(7).</p></blockquote><p>用简短的概括性的话来描述就是,<code>clone</code> 提供了 <code>fork</code> 近似的语义,不过通过 <code>clone</code> ,开发者能更细粒度的控制进程/线程创建过程中的细节</p><p>OK, 这里我们看到 <code>894259</code> 这个主进程通过 <code>clone</code> 创建了 <code>896940</code> 这个进程。在执行过程中, <code>896940</code> 这个进程利用 <code>execve</code> 这个 syscall 通过 sh (这是 <code>execSync</code> 的默认行为)我们的命令 <code>ps -Af | grep -q -E -c &quot;\\-\\-user-data-dir=\\.+App&quot;</code>。 OK，我们也看到了，<code>896940</code> 在退出的时候，的确是以 1 的 exit code 退出的，和我们之前的分析一致。那么换句话说，在我们执行命令的时候，有 error 的出现。那么这里的 error 出现在哪呢？</p><p>我们分析一下命令，如果熟悉常见 shell 的同学可能发现了，我们的命令中实际上使用了管道操作符 | ，不精确的来说，当这个操作符出现的时候，前后两个命令将分别在两个进程执行，然后通过 pipe 进行 IPC。那么换句话说，我们可以很快定位这两个进程，直接快速搜了一下文本</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">896941 13:21:23 execve(&quot;/bin/ps&quot;, [&quot;ps&quot;, &quot;-Af&quot;], 0x564c16f6ec38 /* 40 vars */) = 0</span><br><span class="line">...</span><br><span class="line">896942 13:21:23 execve(&quot;/bin/grep&quot;, [&quot;grep&quot;, &quot;-E&quot;, &quot;-c&quot;, &quot;\\-\\-user-data-dir=\\.*&quot;], 0x564c16f6ecb0 /* 40 vars */ &lt;unfinished ...&gt;</span><br><span class="line">...</span><br><span class="line">896941 13:21:24 &lt;... exit_group resumed&gt;) = ?</span><br><span class="line">896941 13:21:24 +++ exited with 0 +++</span><br><span class="line">...</span><br><span class="line">896942 13:21:24 exit_group(1)           = ?</span><br><span class="line">896942 13:21:24 +++ exited with 1 +++</span><br></pre></td></tr></table></figure><p>OK，我们发现 <code>896942</code> 即执行 <code>grep</code> 的进程直接以 exit code 1 退出了。那么这是为什么呢？？看了下 <code>grep</code> 的官方文档，，卧操，差点吐血</p><blockquote><p>Normally, the exit status is 0 if selected lines are found and 1 otherwise. But the exit status is 2 if an error occurred, unless the -q or —quiet or —silent option is used and a selected line is found. Note, however, that POSIX only mandates, for programs such as grep, cmp, and diff, that the exit status in case of error be greater than 1; it is therefore advisable, for the sake of portability, to use logic that tests for this general condition instead of strict equality with 2.</p></blockquote><p>如果 grep 没有匹配到数据，那么会以 1 作为 exit code 退出进程。。如果匹配到了，则0退出。。但是，但是，卧操，卧操。。按照标准语义，exit code 1 的含义难道不是 <code>Operation not permitted</code> 吗？？完全不按基本法出牌！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上通篇看了下来，我们可以总结出两个原因</p><ol><li>Node.js 在对 POSIX 相关 API 进行抽象封装的时候，直接按照了标准语义，给用户兜底了。虽然从理论上讲这应该是个应用自决的行为</li><li>grep 没有按照基本法办事</li></ol><p>说实话我也不知道怎么去评价这两方面谁更坑一点。按照前面所说么处理子进程的 exit code 从理论上讲这应该是个应用自决的行为，但是 Node.js 自己做了一层封装，在节省用户心智的同时，遇到一些非标场景，也会有不小的隐患了。。</p><p>只能说不断根据不同的场景做 trade-off 吧</p><p>好了，这篇文章就到这里了，因为是临时起义，所以我就懒得将相关 Reference 列在文里了。差不多这样吧，水文目标达成.jpg</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很久没写水文了，昨天帮人查了一个 Node.js 中 &lt;code&gt;execSync&lt;/code&gt; 这个函数特殊行为的问题，很有趣，所以大概记录下来水一篇文章&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/Linux/"/>
    
    
    <category term="编程" scheme="https://manjusaka.blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/tags/Linux/"/>
    
    <category term="笔记" scheme="https://manjusaka.blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="水文" scheme="https://manjusaka.blog/tags/%E6%B0%B4%E6%96%87/"/>
    
    <category term="Node.js" scheme="https://manjusaka.blog/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>关于我自己被性侵经历的访谈记录</title>
    <link href="https://manjusaka.blog/posts/2021/05/07/something-I-want-to-share-about-sex-assault1/"/>
    <id>https://manjusaka.blog/posts/2021/05/07/something-I-want-to-share-about-sex-assault1/</id>
    <published>2021-05-07T13:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.199Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是我 2020 年 12 月接受华中师范大学关于儿童性侵的采访所产生采访稿。在这次采访中，我完整的复盘了在我12岁那年发生在我身上的强奸事件。在这次采访中，我完整回顾了当时我和我家庭的一些反应，也表达了我一些关于性侵这件事的看法。我希望每个人都能平安顺利的过完一生，但是如果有不好的事情发生的时候，我希望这篇文章能帮到你。Everything is gonna be OK。</p><span id="more"></span><h2 id="采访稿"><a href="#采访稿" class="headerlink" title="采访稿"></a>采访稿</h2><div class="table-container"><table><thead><tr><th><strong>时间标签</strong></th><th><strong>说话人</strong></th><th><strong>逐字稿</strong></th><th><strong>备忘录</strong></th></tr></thead><tbody><tr><td></td><td>访谈对象：</td><td>Hello，你好。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>Hi，你好啊。好，那在开始之前我再说一下我们的知情同意书吧，就是前面也发给你过。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，对，我看了，啊，签名我忘了签了。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>没事，等一下发给我也行。知情同意书主要包括研究目标：就是聚焦于探索儿童期性创伤经历者的创伤应对和表露过程。然后你说的话对于我来说，都很重要，所以需要录音，我们的访谈大概持续是三十到六十分钟。如果说这次访谈中断或者没有完成的话，可以协商下一次。参与这个研究，你随时都有权利选择退出，访谈过程中或遇到一些你不想回答的问题，你都可以选择拒绝回答。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，没问题没问题。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>还有一些小小的风险，就是可能会谈到一些触动你情绪的这件事的时候，可能就会引起你的情绪有些波动。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，没事儿，快乐水我已经准备好了（笑）。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，好，但是呢我会就是照顾到你的情绪，因为我是有做过心理咨询的经验的。嗯，然后还有就是你的个人隐私处理问题。首先就是这个录音我会给它变进行一个变音，我处理好逐字稿之后就会把它删除。然后还有就是你的一些能够辨认出你个人信息的内容，我会进行一个匿名化的处理。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>之后你生成的就说是paper，我能够拿到一份拷贝吗？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，你是说论文吗？可以。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，是的是的是的，没错，就是你的相关研究结果。因为我其实对这个事情很好奇，因为我我其实一直是在做性侵这方面公益的。但是据我所知的话，其实国内这方面对于专门性侵受害者的研究，其实我觉得好像还是一个很偏门的领域。我其实挺好奇的。对，因为当时你在这个过程中说的时候，我其实也挺好奇的你为啥会选择这个方向。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>这个通过我看论文的时候我就发现了，因为国内真的很少，就是比较权威的论文，真的非常少。我参考的文献全部都是英文的，就看论文的时候还是挺痛苦的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>就是因为我自己亲身经历，还有我去跟就是给别人做。因为我之前在做公益嘛，就是校园暴力，其实校园性侵属于校园暴力一种嘛。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>然后的话做的时候，我发现其实国内对于这方面，研究特别少。包括就是说起因、结果的研究，包括怎么样去做进行一个系统性的，就是说是受创伤后的心理干涉的介入。我觉得这方面研究好像都很少，我其实挺好奇的。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，确实很少。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哎，你们导师也是专门做这一块的？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>没有，我们导师主要是做危机干预和自杀预防的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>啊，对，自杀干预前几年好像也是比较少。做自杀干预很有必要，我的好朋友八月份就离世了，就因为这抑郁症。来吧，我们现在就开始吧。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，行，好，那开始之前我再做一个自我介绍吧。尽管前面已经介绍过了，我是来自河南信阳，然后今年26岁，是现在是在华中师范心理学院的在读研究生。然后很高兴，也很感谢你能够愿意支持，然后参与这个研究。好，在开始之前你也就是简单做一个自我介绍，包括年龄啊，职业还有居住地和婚姻状况。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>啊，我现在很明显未婚，然后的话成都人，然后年龄的话，我九四年的跟你同岁。然后但是不知道我们月份谁大谁小。然后现在程序员然后在阿里。嗯，对，就是差不多这个情况。我受侵犯的年纪。我想想具体年份，啊，零七年到现在已经是快14年了，已经是十多年了。所以当时应该是我13岁的时候。13岁未满，07年2月，我没记错的话。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>还是能够记得很清楚的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，因为我其实我自己是选择把我很多事情公开出来。因为我觉得国内对于同性……因为我其实是比较，呃，在常规的…（遭遇性侵）这样是比较少见的，我是同性的性侵。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对对，然后然后大家可能更focus 在就是说我异性的性侵。但是国内的性侵的话，对于同性性侵其实这一块比异性的研究更少，而且是什么，法律也不完善。所以说我是会刻意的记忆，然后把这个事情分享出来。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>这比一般女生更需要勇气。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>啊，其实还好，其实还好。对，我觉得其实男生来讲，就拿我自己的亲身经历来讲，其实男生受创伤它是一个持续的过程，它是一个持续的过程，可能你小时候觉得做出这个事情有点无所谓。但是当你大了之后，潜意识了，因为我之前抑郁过嘛，我之前抑郁过，去做过心理诊断。然后当时就是说是心理咨询师就确定了诱因，有一个其中的诱因可能就是这件事引发了一个长期性的一个p t s d 。然后，对，然后可能说比女性来得更猛一些。但是可能说，但是在社会舆论氛围上相对能够获得就更多的，就是说可能说宽容一些，或者说是我也不知道怎么界定啊。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，好，那现在我们就开始吧，就按照我的访谈提纲。我们就像讲故事那样的方式，以时间发展顺序来讲一下。就是当时遭遇侵犯的背景，然后还有你当时是怎么去应对处理的。在这个过程中你经历了怎么样的一个心路历程。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，o k ，其实我的话当时是在住宿学校，然后的话，因为就是这个事情可能就比较长。就是我在住宿学校，然后我当时也不算太合群的一个人。然后就是可能就说校官就界定了，界定了就是说这个是一个小孩子，而且他可能也是有性需求嘛。然后现在我想起来他部队退役的，然后就这是一个性需求。嗯，那么他会长期的培养我一个服服从。就比如说平时就因为我当时是就是有点不听话的小孩子嘛。然后就比如说训练军姿啊训练或者其他的，那么服从之后呢，然后就在事发当天晚上，然后把我拉到一个卧室去，然后去喝了一些酒，然后这个事情。就是我彻底就失去了反抗的这个意识了，就是说，那么这个事情就发生了。至于发生之后的话，就是说发生之后，我第二天早上回去，然后我爸请我吃香肠，当时刚过年不久嘛，我们家还有香肠，然后我就回家，因为那个时候是晚上是周五晚上，然后第二天周六回家，然后当时就觉得不太对劲，然后就很不爽，然后跟我爸说了这事。然后我家里人就发现，就可能说知道我被性侵了，然后就赶紧去报警，然后做了就是精液采集，然后做了笔录。然后后面的话，在大概在一年之后，他定罪之前，又重新做了一次我的d n a 鉴定。因为体液采集是从我身上采集的嘛，然后做了一次d n a 鉴定。然后你要说心路历程的话，其实，嗯，跟女孩子不同的是，男孩子其实可能最开始在小时候，最开始可能他并不会认识到这是一次强奸。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>其实女孩子也不知道。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>呃，女孩子可能最开始知道，因为女孩子可能从小父母就教育她，说你那个地方很羞羞的嘛，然后你就，然后不能让男孩子碰。然后或者碰到这个地方对你不好，可能是有这样一个介绍。那么女孩子最开始会就会觉得这个地方是有个耻辱感，就有个很明确的耻辱感，很明确的被侵犯感。而男孩子可能说，就我自己的亲身经验来讲，你最开始其实反应可能可能并不会太强烈。就可能你最开始都不知道这发生了什么，就觉得很不舒服很不爽。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>然后你第二天早上就跟你父亲说了？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，因为当时我觉得就很不爽。对，然后又因为香肠那个诱因嘛，然后这个东西大家都理解，然后就是加上香肠这个诱因。然后的话就我父亲就发现我的异样，然后就去报警。对。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>那你父亲还挺细致的一个人。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，我父亲，其实这一件事情我一直很感谢我父亲。因为如果说是传统家长，可能就会考虑说，啊，出于名誉考虑遮盖子嘛，对，遮盖子，然后就说或者说：哎，事情发生就发生了，过。然后就报警了，然后最后那个哥们儿是以猥亵儿童罪被判4年，我就记得没错。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>4年。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，因为因为男生很尴尬的一点，就是说他不是…因為國內的法律的性侵，它强奸是针对于女性的一个性器官的插入说，而对于男生来讲它其实是没有强奸这个说法的，而我当时凑巧的是我年龄小于十四岁，然后所以说他以那个侵犯儿童、猥亵儿童罪，刑法二百三十几条，我记得没错的话，然后他就入刑了。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，就是这样看来的话，家庭关系其实也很重要。你和父亲的交流……</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>非常的重要，非常的重要，我觉得其实很……就是说我自己身边也有被性侵的。其实这个事情的伤害程度很取决于家庭对这个事情的处理。如果你家庭觉得说：这是一个性侵。那么我及时报警，然后寻求公权或者说警察的帮助。那么这个事情呢受伤害或者说再配合再更开明一点，配合及时的心理介入干涉。那么这个伤害会控制到非常小的点。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，就是你父亲知道之后，他当时的一个反应是什么样的，还有包括你的家里人反应？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>呃，我其实我父亲他在我面前其实没有表现太多的焦虑。嗯，对我父亲懂得，家长嘛，就是可能说再天大的事，可能也不能在孩子面前（焦虑，不淡定）…我母亲当时是在成都，然后我在小地方，我小时候出生在小地方，这个钢铁城市嘛，然后，对，我父亲然后当时其实是很淡定的，当时他做了两件事，我没记错的话，第一个他给他朋友打电话，就是说他怕警察不认这个事情。于是他找他朋友咨询：我能不能去其他的诊所？先将精液或者说其他的体液部分固定下来，然后后面发现这些事情好像并不合规。然后我父亲就当时把我带到了那个住宿学校的辖区的派出所去做了那个就是说笔录，包括第一波的体液采集，对。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>你父亲真的很厉害。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，对。然后就是后面的话，然后出于其他考虑，然后他就将我带来成都了嘛。对，然后的话就说是和那个环境做隔离。因为这个事情整个公开报道出去其实还是会对你的成长造成一个影响，因为这个特别是教育系统，就是基本上是教育系统，你一出去，一转学，大家一打听就知道这孩子不太对劲（笑）。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯。就是那你对于你父亲当时那个处理，你当时心里面就是有一个什么样的状态？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，其实我当时还是懵懂的状态，其实还是懵懂的状态。就是说，包括体液采集，做笔录的时候，我当时其实并没有意识到这个事情是一个强奸。我当时其实心里没有很明确的这个词，这个是对于男生的一个强奸。然后我其实就觉得这可能是个不好的事情。嗯，然后呢那么我就配合警察，把这个事情完全记录、说出来。然后做笔录，其实还是小孩子对于，就是说当时去做这一套，我父亲替我拍了板之后，我当时做这一套核心的一个动机，更可能还是说，呃，小孩子对于长辈，对于就是说是或者说其他的一个服从，就是我当时并没有意识到这个东西发生了什么。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，那你后来什么时候开始意识到这件事情它的一个性质是什么的？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>唔，其实初步意识到应该是在高中，然后完整的去复盘我自己的这件事儿的话，应该是在大学。应该是在快毕业的时候，当时其实，呃，我完整的复盘其实诱因应该是国内的me too 运动。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，实际上是应该是me too 运动。然后诱因…，我其实之前有个粗浅的复盘，但是真正的去重新的就是从头到尾的去审视这件事是就应该是me too，对，然后的话对，差不多就是这样一个情况。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>就是这件事情对你有什么影响？就是从它发生一直到现在的话，对你有什么影响？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>呃，其实我觉得你要说真正的影响很难量化。因为就是说很多东西就包括我去做心理咨询之后，其实医生的看法就是说这个事情是潜移默化的，就是说潜移默化的一个伤害，就是说是长期性的一个p t s d。然后当时我去医院去确诊，然后就因为我当时是确诊抑郁症嘛，然后重度抑郁，然后是伴自杀焦虑，然后的话就是自杀倾向。然后的话，呃，当时其实医生当时听我把这个事情清理完整描述过之后，医生的评价就是说是你这个抑郁的有一部分其实就是来源于你这件事儿。嗯，就说，对，对，因为就是什么，因为我是抑郁需要吃药并伴做那个心理干涉嘛，然后，对，但是就是说你要说这件事情有什么明显的，就是说后遗（症），一个就是要很量化的，就是说你觉得这个事情对你影响有多大，我觉得这没量化。我觉得这个东西是一个潜移默化的过程。因为我当时是在受侵害的，最开始他是没有做到一个系统的心理干涉，我是没有做到的。对，可能对于同性的时候，可能说最开始你觉得没什么，但是越想越想觉得有事儿。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>那你诊断为抑郁症的时候，大概是多大？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>啊，应该是在17年。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，在三年前。就是在此之前就没有表现出来一些具体的症状？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>有，其实有我一直神经衰弱，但是我其实在大学的时候应该是有，但是我是没有去确诊的，因为就是说没有确诊。对，但是正式确认是在17年。对，然后的话，所以说我觉得这个事情可能更可能来讲还是一个长期的一个潜移默化的。就是说它并不会对你就是说你一下子觉得：哎，你自己不是一个干净的人，你一下子觉得你想跳楼了。我觉得这个不存在，但是可能就是说潜移默化的过程。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>那你觉得这种潜移默化主要是来自于哪里呢？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>我觉得可能最开始就是打破你自己的，就说是一个完整感。就是说你自己觉得自己是一个不完整，或者说是你觉得你自己是…用这种传统的话来讲呢，就是你自己是个不干净的，懂我意思吧？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，就是我自己猜的话，潜意识可能会给自己加一个这样的，其实我觉得可能说。呃，然后你就会觉得你自己说话会比别人低一头或者是其他。对，我觉得这个可能还是一个社会氛围所造成的吧。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，就是在高中之后慢慢的开始有这种意识。那其实对是小一点的话，你其实还是不太知道这件事情是什么性质？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，对，对，男生其实很麻烦的一件事就在这个地方，最开始如果你是被性侵的那个男生，男生你在小时候你可能会觉得这是一个游戏，你可能会去更觉得这是一个游戏。但是你在大了之后，你会发现慢慢觉得这不是…（一个词，听不清）欸？怎么这么不太对劲啊？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，就是慢慢的意识到的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，是的，没错。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>你就是最开始就已经选择，也不是说你主动告诉你父亲，就是你父亲他自己觉察到这件事情。那再后来你有没有再表露过这件事情？嗯，再一次向别人说这件事情的时候是什么时候，然后是什么原因？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>我其实应该是还是在大学吧。然后我其实之前其实只跟几个好朋友说过，然后我正式选择公开这件事情，应该还是在大学或者说快毕业，me too事件之后，因为我觉得可能说我的经（历），因为我当时其实有个背景是我也是在做公益，我之前是救援队的。然后的话我之前大学在救援队服务，然后是以私人身份去做一些，然后就包括啊校园校园暴力和校园性侵，资助我也在做。呃，我可能觉得，更觉得这件事的话，可能就是说，我需要让这件事变得有意义。然后于是我选择就是说公开的把我这个经历分享出来。因为我觉得可能说，呃，一个事情如果只能变成你自己的痛苦，或者说你自己的建议，那么你自己是否痛苦其实是没有太大意义的。对，而且我这个事情又是相对来说对别人更容易产生帮助的，因为其实你知道儿童期间的性侵其实是很常见的一个事情。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，其实是，然后家庭，就是说父母的干涉又是非常重要的。我选择的在知乎，你看到我的那个答案，包括我选择的一些社群里面把这个事情，呃，就是说我自己的当时的经历，以及我家庭所做的一些手段，包括我家庭当时做的不足的地方，就因为认知的关系嘛，没有给我寻求及时的心理介入，这些事情分享出来我就是希望说，我自己能够把这些，啊，把我自己的经历能够变得更为有意义一点，然后不仅限于我自己所受到的伤害。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>做的真的很好。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>唉，（深深叹一口气）对，这也是我参加你的这个研究的原因吧。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，我也看到，你说这就是你分享的意义。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯嗯，对，对，我觉得其实就是说你自己每个人受伤害嘛，然后要怎么样去把自己受到的创伤，受到的伤害变得让它具备除了伤害以外更多的意义。我觉得这是一个很好玩的话题。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，很有意义，很有价值的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，对，这就是我自己选择的，我自己披露出来的一个啊，心理活动。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>好，还有就是你刚才提到也告诉过好朋友，那你是在什么时候告诉好朋友，然后他们又是怎么回应你，他们当时的这个态度和反应是什么样的？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>他们其实就觉得就是说：不可思议。就是这样子，然后就觉得就觉得说，出于保护我，就告诉我这件事情还是不要跟别人说。出于好意，就是让我这件事情不要跟别人说。然后这个事情不要跟别人说，其实后面相处也是没有什么太大的变化，因为好朋友嘛，对。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>那也是因为你非常的信任他们。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，因为其实是在闲聊的时候嘛，就是闲聊的时候就说了这事。这个没有什么可以防备的，就说了这事儿，虽然我父母我一直在告诉我说：这个事情你千万不要给别人说啊。但是我从小都不是个好小孩。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，就是在朋友那里，其实也是得到了一定的支持。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，是的，没错。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>还有很多小孩就是选择告诉父母的话，他还会造成二次伤害。所以就是说你父亲的这种处理真的特别可贵。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，对，是的，我觉得其实是被性侵伤害的（人），从我自己打过交道来看，其实是很大一部分伤害是来自原生家庭。这个我们毫不避讳的讲的是其实很多包括就觉得说可能说女孩子就觉得说：啊，你嫁不出去了，就直接原生家庭给的压力，就“你嫁不出去了，你怎么这样？”就受害者有罪推定嘛，是吧，受害者有罪推定。“哎，当时谁叫你穿那么少干嘛，然后叫你再穿这么少？”其实我父母也有，我母亲也有一点这种就说：哎，叫你当时不合群，你要是合群，你教官就不会挑上你了嘛！”我觉得这种东西其实是没有必要的那个谴（责），苛责。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>对对对，明明就是加害者的错，反过来还要去揪你的毛病。对，所以面对母亲的那种那种责怪，你其实感觉怎么样？。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>我母亲其实也不是恶意的嘛。她其实就是说教育我要去合群嘛。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，其实我小时候我一直不太想去为了合群而合群，但是他们长辈嘛，她为了教育我去合群，就是说可能说举了一个不恰当的例子。但是不恰当的例子其实呢也是说，目前我跟你说性侵的伤害，就是说遇到了一个现状，很多时候的压力和伤害其实是更多的是，就是说比性侵这件事情伤害更大的，可能说是来自于原生家庭的一个苛责。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，对，确实是。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>好，你觉得有什么是促进你来表述这件事情，有什么是阻碍你来表述这件事情的？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>哦，其实阻碍我去表述这件事情的因素并不多。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，我也发现了。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>对，因为我觉得你们说“关我吊事儿”，就是用术语来说就是就是“关我什么事儿”。然后我说我的，你们看的惯就看，看不惯就不看，你们又不给我发钱，发工资是不是？我这个人的性格是比较，就是比较那个就怎么说，就反常规的吧，所以说我觉得还好。再一个就是说促进我表露的话，可能就还是说，呃，国内就是说是目前就是说是对于性侵受害者态度的一个变化。嗯，就说是一个……就是因为之前，可能说在零几年或者说前几年或者更早的时候，觉得性侵它是一个非常shame的事情，就是说你不光彩。就是说“how shame you “就是说你怎么能这样，就是就刚才我举的例子吧，你被性侵了，你一定是穿的太少了，你一定是穿的太骚了，或者说你一定是穿的太浪了。啊，这种就是受害者有罪论。这几年国内其实是对性侵受害者态度其实是逐渐变好了。而且就是我刚才说了嘛，另外一个契机可能就是说是me too。然后我觉得可能说，啊，把这个事情公布出来，然后让别人，能够帮到别人，我觉得是能够去抚慰自己被性侵。就特别说如果有一些人告诉你说：我孩子，呃，但是我不希望有这样一天，啊，但是就是如果说有一天跟你说，有个当父亲或当母亲跟你说：我孩子被性侵性了，我按照你说的做了。其实我觉得如果说是有这样一件事情，它其实是能够治愈很多东西的。但是我不希望有一天会出现这种情况。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>对，然后我觉得这可能说是，呃，一个是算是一个自我的拯救吧。第二个就是说可能说还是希望就是说能够帮…就说是用自己的一些东西去回馈一些什么。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯。当你回忆了整个的这样的一个经历之后，你现在是有什么感受？用一个词来概括一下。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>啊！还好。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>还好？用一个词来概括的话？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>啊，还好，就是跟产品经理撕完逼之后的，怎么说，啊，轻松。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>轻松？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>对，轻松吧，我觉得其实，我觉得怎么说呢？我觉得其实这样面对面聊这个问题，其实聊完之后其实还是会有些轻松感的，对，就像跟产品经理撕完批之后，然后你会觉得：哇，爽死了。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>程序员的快乐。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>啊，是的。那能再具体一点说一下，为什么是这种感觉呢？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>因为我觉得其实你在网上以一个虚拟的身份去说，可能说大家都知道迈克萨卡的i d 是我。因为我可能说我觉得我在这个社区比较活跃，大家可能觉得迈克萨卡的i d 是我，我也会在微信群里面说，大家看到啊，这个啊微信i d是迈克萨卡的人是我。但是我觉得可能说跟你就是一个真人的去one on one的去说，就是相对来说是一个陌生人。我跟我女朋友其实是很深入地聊过这件事儿的。就是说，呃，跟你一个陌生人去one on one的去聊这件事儿，其实也是在治愈自己那个心里面的一个东西，对，其实是因为，因为潜意识来讲可能最开始我觉得这还是一件shame的事情。所以我想的是在网上以一个虚拟的身份去做。那我去给你做访谈，就其实说我有一些枷锁，其实还是（非常大的？）（没听清楚）。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯嗯，你刚才我联系你时你说去抽根烟，我就觉得，嗯，可能就是就觉得又要去面对这个事情，情绪上需要准备一下。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，其实你是第一个就是说以一个相对陌生人的身份去忘one on one的去聊这件事儿。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>那个单词是怎么你能说慢点吗？one什么？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>就是one on one，就是一对一，就是一对一，面对面。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>哦哦。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，我们这边应该就是叫one on one，然后就是跟老板one on one的聊天。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>哦哦，在我打断你之前，你刚才要说什么，你接着说吧。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，没有没有，其实我觉得，对，就是说你自己以一个虚拟的身份去说这个事情，就是说是有温度的去说这个事情，我觉得其实是两种体验吧。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，确实是。你刚才提到你女朋友，因为你女朋友毕竟是你除了爸妈之外关系最亲密的人嘛，你告诉了她这件事情，那你再具体说一下，就是你告诉她的这个经过吧，还有你做了什么思想工作？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>就是在晚上休息之前，我给她就聊到了小时候这件事情，其实也没什么，因为我的事情她都知道，她其实没有什么，我就只是在去聊一些东西。她其实也没什么反应，就是觉得很心疼心疼。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，心疼。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，对，对，然后其实我觉得跟亲密的人聊这个事情，其实是没有什么。当然前提是你亲密的人不会再苛责你：你当时为什么穿的那么少，那么浪？对，就是……（没听清楚）其实我觉得去聊这种事情，我觉得是，嗯，也是能够促进感情的一种比较好的方式吧。就是说是互相剖析嘛。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，就是那种完全信任的那种状态。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>是的，没错。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>你对于儿童性侵犯的一个现状有什么样的认识？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>很严重，非常严重，因为性侵其实它是一个很大的概念。我可能下面的话会说的比较露骨一点，不要介意啊。就是说性侵，它可能并不仅仅限于就是说，呃，一个强奸的一个行为。就是插入了，它可能是边缘性的一个性侵，可说搂搂抱抱，对于小女孩或小男孩的一个搂搂抱抱，乃至于说是对于性器官的一个接触，对。然后而且这个，其实现在是越发多样了。可能往常的人来说，我觉得就是说，往常的人来说，就觉得说啊，男生对于女的是一个性侵。后面可能就是说，大家发现男的对于男的其实是一个性侵。但是可能现在这些情况可能会更加多样，就可能说，呃，我并不会去做一些实质性的侵入的工作。我可能就只是说，哎，我见到一个萝莉，我去搂搂抱抱，或者说我心生邪念了，我去做一些性器官的接触。或者说我，或者说是…因为我其实见到，如果你有关注，其实见到很多案例，就可能说，呃，我叫一个小女孩用棒棒糖让她来帮我口一次，也就是说是口交一次，对吧，嗯，其实见过这种案例的，对，然后或者说是，呃，或者说是叫一个小男孩来给口一次，或者说是其他，而且这个他身份可能是会有变化的。可能后面会多样的，就是说我一个二十多岁的女生，或者说就是我自己的生活比较开放。嗯，对，然后我去我去勾搭一个小孩，然后我去跟他发生性关系。其实在我看来这种其实也是一种性侵。因为在小男孩性观念没有成熟之前，你这个操作是会对他造成很大影响的，他的性取向或者性操作会有很大影响吧。包括现在其实同性恋也放到台面上来讲了，就是说我同性恋去强行掰弯一个人，或者说我去性侵一个小男孩，其实也是一个，就是说性侵它其实是现在很严重，儿童性侵其实是很严重的一件事。而且现在是多样化。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，但是相关的法律确实还没有跟得上。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>是的，没错。对，就比如说，呃，我一个，呃就比如说我一个二十多岁三十多岁的女生，我去性侵一个男生，一个十多岁的男生，如果说我是有其他身份的，我是一个老师，或者说是一个在其他国家，他是能够得到一个，就可能说是更重的处罚。而国内的话，其实这一块的法律行为是没有完善的。就可能说如果这个男生小于14岁，你可能会以侵犯儿童，猥亵儿童罪的名义去入刑。然后就比如说小于14岁是强奸这种，其实仅限于女性，没有男性，因为国内强奸它采取的还是一个插入的说法，性器官男生对于女生的一个侵犯。所以说我觉得其实我国法律有其实还有很大的空间要走。包括就是说是在被性侵之后的及时的心理介入。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，对对对，真的是急需完善的一个状态。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，其实是国内，其实现在性侵其实是多样化的。比如说是儿童性侵，其实多样化。因为其实生活好了嘛，大家其实会想怎么回事？而且其实比如说同性同龄之间的性侵，其实也是非常严重的。就比如说校园暴力的凌辱的行为，就由凌辱转化为性侵，这种事情其实都没有被重视的。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>还有很长的路要要走。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>是的，没错，是的，没错。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>然后你觉得对于遭遇过儿童期性侵犯的受害者来说，他需要哪些力量的介入和帮助？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，我觉得最强力的是公权力。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>什么？公权力？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，公权力的介入，就是政府部门的介入。就我当时其实这个事情实际上还没有太大，是因为派出所的人给我留下很深的印象。对，当时因为没来得及吃晚饭嘛，然后我当时我还记得就是说那个派出所当时应该和我父亲那边还在联系……（信号原因，没听清）因为一般像这种小地方的警察，可能觉得这种事情就很不耐烦：没事没事，你们先回家自己处理嘛。和稀泥嘛，基层的传统玩法，和稀泥嘛。然后那个警察叔叔就很尽责，然后我记得当时我还没吃早饭，然后录笔录录到下午两点多，还没采体液。小孩子嘛，饿嘛，然后我记得我还在当时他办公室吃了一袋苹果片，然后我现在还记得，然后，对，我觉得这种东西，公权力的及时的介入，其实是能够在第一时间对小孩子就说是一个很贴切的保障。因为大家都从小都得到一个认识嘛：警察叔叔是好人。你受到欺负，警察叔叔会来帮你，对吧？然后，对，这个东西公权力的介入一定是第一优先的，就是说家庭和公权力的及时介入第一是优先。第二个其实我觉得很重要的就说是在性侵的一个月以内，就说是我觉得不管他当时有没有表现出异样啊，一定是要寻求及时的心理干涉。对，就是说因为性侵其实跟其他一样，就是你学心理的肯定比我清楚，就是说性侵跟其他的一样，就是说受伤害的这个东西，他或多或少的一定会有p t sd 相关的东西。如果说是你没有去寻求心理的介入，那么你这个东西可能就是说你心里始终是有个梗儿在这儿。就比如说台湾有个作家叫张苑，就是台湾那个作家自杀的那一位我忘了。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>林奕含。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>啊，对，林奕含，然后她其实她其实就是这种，呃，就可能说像我这样皮实的人，可能说会选择自我开导，但是选择像她那样的人，可能就是一个p t s d，然后再加上其他各种事情的不理解，抑郁，然后自杀。其实我觉得所以说第一时间的公权力介入，第一时间的心理干涉一定是非常必要的且非常重要的。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯嗯，确实是的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>但是我觉得国内其实好像专门做儿童性侵心理干涉的好像很少。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>确实很少。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，我觉得就这个东西其实是亟待完善的。因为其实用成人的那套心理干涉的做法去做儿童心理，其实是（一个词，没听清）不同的。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，首先心理学在中国就刚刚发展起来，就是处于起步的那种朝阳状态。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>啊，就是说这些东西还得需要时间去完善吧。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>对，确实它需要一个过程。不过也在慢慢的变好。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>其实说实话，我觉得短期之内其实是不一定能看到太好的变好。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>是的是的是的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>唉，任重道远吧。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>路漫漫。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，其实是我一个（没听清），我觉得对于小孩子来讲，就是说及时的、周边的帮助非常的重要。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>对于预防和干预儿童性侵犯你有什么建议？其实这个问题和刚才那个问题是一个性质的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>预防其实你这个事情没法解，你预防不了，你预防不了。因为你其实性侵它一定是意味着一个事情，就是说是有一方的呃，就是说是，呃，不管是体力还是其他的，他一定是凌驾于另外一方的。对吧？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>是的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对。我就举这么一个不太恰当的例子，就是说性侵，它这个事情其实你只能从就是说是一些呃去打一些预防针。就比如说女孩子就是现在常见的：女孩子啊，你不来让男孩子摸啊，然后这种东西。但是如果说，比如说我，就是说我要采取暴力手段了，我举一个不恰当的例子，希望你不要介意。就是比如说我见到一个萝莉了，对，我采取暴力手段，我去搂搂抱抱，来做一个就是说是，呃，过分的事情，你觉得她有抵抗力吗？没有，对吧？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，然后你觉得这件事情能预防吗？没有办法。对，所以说我觉得预防其实，其实它一部分其实是个很奢侈的事情，因为它是需要一个去体系化的一个建设，很奢侈的事情。我觉得更重要的可能却需要去告诉孩子说：这个事情不是一个shame的事情。如果你被侵犯了，这不是你的错误，你需要告诉及时告诉爸爸。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯嗯，对。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>我觉得这个事情其实是比预防更重要的事情。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>很中肯，嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对对，因为，呃，知乎上你应该也能看到很多匿名的，就觉得说家里人觉得丢脸，很多，特别是女孩子，然后家里人就不告诉她这些。对吧？然后我觉得这个可能说是因为很多事情预防预防不了。因为就比如说走在路上，突然有人心生歹念，就是你怎么预防？防也防不动啊。除非你随身身上带把刀，然后谁敢碰我我割了他。这种事情当然也都是说笑话，然后我觉得这种事情就一定去培养一个观念：就是说这个事情它不是一个shame的事情，不是你的错，你需要（告诉家里人？没听清，不确定）。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，主要是家庭方面影响特别大。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>是的，其实我觉得公权力方面也影响非常大。因为其实很多就是基层嘛，就是其实很多他虽然说他是警察，但是可能他的法律意识没有吧。然后他可能就会下意识的，就是说，因为这种地方是个小地方，可能就会说：啊，为了你女儿着想，这个事情和了吧。咱们就不走中间法吧，你们就都妥一下对吧。我觉得就是说基层，就说是可能就觉得说，呃，反正就觉得，呃，就千万不要和稀泥，就不要受害者有罪推定，就这个事情不是他的错误。我觉得就是建立一个系统的认知，这个事情是非常重要的。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，就是现在来看的话，你回头去看你的那些应对方式，你会有一个什么样的感受？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>我父亲做很帮，啊，然后但是可能说他可以做的更棒，但是这个东西其实是马后炮的，我也没法去跟07年的时候，那个时候他……啊，对不起，我去看一下吧，可能有人在敲门。反正我觉得他当时做的很棒，那一套行云流水，其实也很感激他。对，但是的话我觉得可能说，如果说我自己从现在一个事后的角度去复盘，我觉得可能还缺了就我刚刚说的心理干涉。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，那包括你自己的应对方式呢，就是你选择把它给说出来。你觉得如果不说的话，你会怎么样？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，其实我这个东西很多事情没法做假设呀。我也不知道我不说会怎么样。其实这个东西我觉得其实没法做没法。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，那你去看你的这种应对方式的话，你是什么感受？你怎么看待？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>我其实也没什么特别的感受。我只是觉得我做了一件应该做的事情。没什么特别的感受。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，我还设计了一个问题，就是如果说你可以回到当初那件事情发生的时候，你会做什么？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>其实说实话，我觉得这个问题其实没有太大意义。因为其实。你像刚才我说的很多时候，他其实是处于弱势的一个地位，校园性侵他其实是对于性一个很懵懂的这个东西，你没法去假设去说你具备一个完全的性知识人。穿越回去附身到他身上，然后说当时会怎么做，我觉得其实这个东西，这个假设其实是没有意义的。我说的比较直白啊。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，因为可能就是男生比较理性嘛，但是就是对我自己而言，我是希望我能够回去的，就是我假想过这样的一个场景，我如果可以回去，那我就可以避免这所有的一切的发生，就是有一个情绪的宣泄口嘛，这就是我问这个问题的原因。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>是，是一个情绪的宣泄口，但是就是可能说，呃，对于更大多数人来讲，其实这个东西其实没有意义。我们只能往前看，就是就像刚才我说的。其实我知道你意思，你其实想说我去总结一套经验出来，就是说避免当时发生。但是其实就像我刚才说的，很多时候儿童性侵的受害者他其实是面对的是成年人，他其实是面对的是成年人，而且是多种多样的成年人。他其实留给他的选择余地不多。我感觉你情绪好像有点波动啊。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>没有，是因为我想到我前面访谈的那些女生，加害者全部都不是成年人，啊，有一个是成年人，其余的全都是中学生，十四岁左右的小男生。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，唉，其实我觉得这个事情吧，其实这个事情其实说实话，这种东西就是纯粹就是属于飞来横祸的。对，因为这个东西，就比如我走在路上，然后被突然十二楼掉下来一个东西砸死了。然后我也没法说我提前预知到今天三点十分楼上要掉东西，避开它。这个东西没法预测，除非我直接具备超能力。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，好，再追加一个问题呢，就整个访谈下来你有什么感受，还有你对于我这个访谈的感受吧？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，我觉得其实反正我觉得其实感觉还好吧。我最开始想的就是你的态度会push一些，就稍微有侵略性一些，学院性一点，其实我觉得整个聊下来感觉还不错。然后的话，对，但是我觉得自己更希望就是说我自己希望是能越来越多的人有来做你这方面的研究的。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>我也有这样的希望啊。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，我觉得可能是我自己更希望说是有更多人来做这个研究。其实我不介意去做访谈，但是我希望能有更多人。其实说实话我也很好奇，为什么你是第一个找我的？为什么没有其他人找我？其实我也很好奇这个问题。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>你是觉得在很早之前就应该有人去做这样的一个研究？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，我觉得其实它并不是一个新鲜事儿，它其实并不是一个新鲜事儿。其实我觉得虽然说国内心理学就是说这方面的研究起步晚吧，但是也不至于到了2020年的今天才有人来开始去做这个，马上都要2021年了，才有人来去找当时的事儿。但是也有可能是我不是在圈子内啊，我不知道啊，也有可能我不在圈子内，我不知道。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>其实我很早就想写这个，但是我不太敢跟我导师说，怕被否决。他们会说这是一个特别特别敏感的话题，可行性特别低。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>o k ，o k ，o k 明白，我其实很好奇，那你最终决定去做这个话题的时候，你导师你老板什么看法？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>我老师就支持我啊。但是他说你要考虑一个问题，就是你可能找不到被试，你找不够，因为这是一个非常敏感的问题，你找研究对象是非常困难的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>啊，是的。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>还有就是我没有提到的，而你想要说的，想要表达的一些东西？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，其实我当时想聊的，其实基本上你这个题做的还不错。其实我想聊的其实基本上都聊到了。就是说反正我觉得其实我更希望的就是说是国内这方面的研究能够跟上，其实先不提法律层面上了，因为法律必定是滞后于社会发展。对，然后对，我先不提法律上，我就希望心理干涉这一块儿能够及时跟上，就包括大家的观点，就千万不要去面对一个性侵受害者说：你当时穿的太少了，你太骚，你太浪了…这种东西，就被害者有罪论你千万不要再去讲。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>对对对。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>就是这些吧，我就是只想说“去你丫的”！反正我觉得其实这个东西，反正我觉得你做这个事情是比较有意义的。就我刚才说，我很好奇为啥为啥会2020年才有人找。当然我不在圈内，可能更早有人做了，我没知道而已，就翻到了我而已。但是我觉得的确应该是非常少见。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，13年、14年也是有人做的，因为我看到一些相关的硕士论文。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，反正希望你这边的研究一切顺利吧，反正就是说我自己还是觉得就是其实是反正如果说你对这个，我不知道你对做这个事情有怀疑没有。如果有的话，反正我还明确告诉你：做这个事情非常有意义。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，谢谢，谢谢。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，行，看你这边还有啥想问的没？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>目前是没有了。你做的一切也非常非常有意义。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>谢谢。那要不然就先这样？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，好，那你忙吧，拜拜。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>拜拜。</td></tr></tbody></table></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实想说的话有很多，但是一下不知道怎么说吧。在这里先引用我的采访者在论文中写的一句话作为结尾吧</p><blockquote><p>我始终相信星星之火，可以燎原。</p></blockquote><p>Everything is gonna be OK</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章是我 2020 年 12 月接受华中师范大学关于儿童性侵的采访所产生采访稿。在这次采访中，我完整的复盘了在我12岁那年发生在我身上的强奸事件。在这次采访中，我完整回顾了当时我和我家庭的一些反应，也表达了我一些关于性侵这件事的看法。我希望每个人都能平安顺利的过完一生，但是如果有不好的事情发生的时候，我希望这篇文章能帮到你。Everything is gonna be OK。&lt;/p&gt;</summary>
    
    
    
    <category term="人生" scheme="https://manjusaka.blog/categories/%E4%BA%BA%E7%94%9F/"/>
    
    <category term="杂记" scheme="https://manjusaka.blog/categories/%E4%BA%BA%E7%94%9F/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="人生" scheme="https://manjusaka.blog/tags/%E4%BA%BA%E7%94%9F/"/>
    
    <category term="杂记" scheme="https://manjusaka.blog/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>利用动态 tracing 技术来 trace 内核中的网络请求</title>
    <link href="https://manjusaka.blog/posts/2021/04/17/how-to-tracing-package-in-the-linux-kernel/"/>
    <id>https://manjusaka.blog/posts/2021/04/17/how-to-tracing-package-in-the-linux-kernel/</id>
    <published>2021-04-17T09:09:00.000Z</published>
    <updated>2023-06-22T16:36:06.199Z</updated>
    
    <content type="html"><![CDATA[<p>这周帮朋友用 eBPF/SystemTap 这样的动态 tracing 工具做了一些很有趣的功能。这篇文章算是一个总结</p><span id="more"></span><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>实际上这周的一些想法，最开始是实际上来源于某天一个朋友问我的一个问题</p><blockquote><p>我们能不能监控机器上哪些进程在发出 ICMP 请求？需要拿到 PID，ICMP 包出口地址，目标地址，进程启动命令</p></blockquote><p>很有趣的问题。实际上首先拿到这个问题时候，我们第一反应肯定是 “让机器上的进程在发 ICMP 包的时候”直接往一个地方写日志不就好了，emmmm，用一个 meme 镇楼吧</p><p><img src="https://user-images.githubusercontent.com/7054676/115106820-68ae5400-9f99-11eb-8dbd-772d18f6b039.png" alt="鸡生蛋蛋生鸡"></p><p>嗯，可能大家都知道我想说什么了，我们这种场景实际上只能选择旁路，无侵入的方式去做。</p><p>那么涉及到包的旁路的 trace，大家第一反应肯定是 <a href="https://www.tcpdump.org/manpages/tcpdump.1.html">tcpdump</a> 去抓包。但是在我们今天的问题下，tcpdump 只能拿到包信息， 但是拿不到具体的 PID，启动命令等信息。</p><p>所以我们可能需要用另外一些方式去实现我们的需求</p><p>在需求最开始之初，我们还可能的选择的方式有这样一些</p><ol><li><p>走 <a href="https://www.kernel.org/doc/Documentation/networking/proc_net_tcp.txt">/proc/net/tcp</a> 去拿具体的 socket 的 <strong>inode</strong> 信息，然后反查 pid 关联</p></li><li><p>eBPF + kprobe 内核打点做监控</p></li><li><p>SystemTap + kprobe 内核打点做监控</p></li></ol><p>第一种方式，实际上只能拿到 TCP 一层的信息，但是 ICMP 并不是 TCP 协议啊（衰（虽然同属 L4 </p><p>那么看到最后，我们貌似就只有用 eBPF/SystemTap 配合 kprobe 的一条路可以走了</p><h2 id="基础的-trace"><a href="#基础的-trace" class="headerlink" title="基础的 trace"></a>基础的 trace</h2><h3 id="Kprobe"><a href="#Kprobe" class="headerlink" title="Kprobe"></a>Kprobe</h3><p>在继续下面的代码实际操作之前，我们首先要来认识一下 <a href="https://www.kernel.org/doc/html/latest/trace/kprobes.html">Kprobe</a></p><p>先引用一段官方文档的介绍</p><blockquote><p>Kprobes enables you to dynamically break into any kernel routine and collect debugging and performance information non-disruptively. You can trap at almost any kernel code address 1, specifying a handler routine to be invoked when the breakpoint is hit.<br>There are currently two types of probes: kprobes, and kretprobes (also called return probes). A kprobe can be inserted on virtually any instruction in the kernel. A return probe fires when a specified function returns.<br>In the typical case, Kprobes-based instrumentation is packaged as a kernel module. The module’s init function installs (“registers”) one or more probes, and the exit function unregisters them. A registration function such as register_kprobe() specifies where the probe is to be inserted and what handler is to be called when the probe is hit.</p></blockquote><p>简单来说，kprobe 是内核的一个提供的一个 trace 机制，在执行我们所设定特定的内核函数时/后，会按照我们所设定的规则触发我们的回调函数。用官方的话来说，“You can trap at almost any kernel code address”</p><p>在我们今天的场景下，不管利用 eBPF 还是 SystemTap 都需要依赖 Kprobe 并选择合适的 hook 点来完成我们内核调用的 trace</p><p>那么，在我们今天的场景下，我们应该选择在什么函数上加上对应的 hook 呢？</p><p>首先我们来想一下，ICMP 是一个四层的包，最终封装在一个 IP 报文中分发出去，那么我们来看一下，内核中 IP 报文发送中的关键调用，参见下图</p><p><img src="https://user-images.githubusercontent.com/7054676/115108292-37865180-9fa2-11eb-920f-dada0463ea10.png" alt="IP Layer 关键系统调用"></p><p>在这里我选择将 ip_finish_output 作为我们的 hook 点。</p><p>OK，Hook 点确认后，在开始正式编码前，我们来大概介绍下 <code>ip_finish_output</code></p><h3 id="ip-finish-output"><a href="#ip-finish-output" class="headerlink" title="ip_finish_output"></a>ip_finish_output</h3><p>首先来看下这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_finish_output</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = BPF_CGROUP_RUN_PROG_INET_EGRESS(sk, skb);</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> NET_XMIT_SUCCESS:</span><br><span class="line"><span class="keyword">return</span> __ip_finish_output(net, sk, skb);</span><br><span class="line"><span class="keyword">case</span> NET_XMIT_CN:</span><br><span class="line"><span class="keyword">return</span> __ip_finish_output(net, sk, skb) ? : ret;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体细节先不在这里展开（因为实在是太多了Orz），在系统调用 <code>ip_finish_output</code> 时，会触发我们设定的 kprobe 的钩子，在我们所设定的 hook 函数中会收到 <code>net</code>, <code>sk</code>, <code>skb</code> 三个参数（这三个参数也是调用 <code>ip_finish_output</code> 时的值。</p><p>在这三个参数中，我们主要来将视线放在 <code>struct sk_buff *skb</code> 上。</p><p>熟悉 Linux Kernel 协议栈实现的同学肯定对 <code>sk_buff</code> 这个数据结构非常非常熟悉了。这个数据结构是 Linux Kernel 中网络相关的核心数据结构。通过不断的偏移指针，这个数据结构能够很方便帮助我们确认我们待发送/已接收的数据在内存中所存放的位置。</p><p>空口直说好像有点抽象，我们来看个图</p><p><img src="https://user-images.githubusercontent.com/7054676/115132085-9514af80-a02f-11eb-9434-3bf085714817.png" alt="sk_buff"></p><p>以发送一个 TCP 包为例，我们能看到这个图中，sk_buff 经历了六个阶段</p><p>a. 根据 TCP 中的一些选项如 MSS 等，分配一个 buffer<br>b. 根据 MAX_TCP_HEADER 在我们申请好的内存 buffer 中预留一段足够容纳所有网络层的 header 的空间（TCP/IP/Link等）<br>c. 填入 TCP 的 payload<br>d. 填入 TCP header<br>e. 填入 IP header<br>d. 填入 link header</p><p>可以参照一下 TCP 报文结构，这样大家会有一个更直观的理解</p><p><img src="https://user-images.githubusercontent.com/7054676/115132279-6c8db500-a031-11eb-9fd3-1ea346015cdb.png" alt="TCP Segement Format"></p><p>大家能看到，通过 sk_buff 的一些指针的操作，我们就能很方便的获取到其中不同 layer 的 header 和具体的 payload</p><p>OK，现在让我们正式的来开始实现我们所需要的功能</p><h3 id="eBPF-KProbe"><a href="#eBPF-KProbe" class="headerlink" title="eBPF + KProbe"></a>eBPF + KProbe</h3><p>首先简单介绍下 eBPF。BPF 指 Berkeley Packet Filter ，最早期是用来设计在内核中实现一些网络包过滤的功能。但是后续社区对其做了非常多的强化增强，使其不仅能应用于网络目地。这也是名字中 e 的来历（extend）</p><p>本质上而言，eBPF 在内核维护了一层 VM，可以加载特定规则生成的代码，让内核变得更具有可编程性（后面我争取写一篇 eBPF 从入门到入土的介绍文章）</p><blockquote><p>Tips: Tcpdump 的背后就是 BPF</p></blockquote><p>然后在这次实现中，我们使用了 <a href="https://github.com/iovisor/bcc">BCC</a> 来简化我们 eBPF 相关的编写难度</p><p>OK，先上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">bpf_text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">#include &lt;linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/sched.h&gt;        /* For TASK_COMM_LEN */</span></span><br><span class="line"><span class="string">#include &lt;linux/icmp.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/ip.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/netdevice.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">struct probe_icmp_sample &#123;</span></span><br><span class="line"><span class="string">    u32 pid;</span></span><br><span class="line"><span class="string">    u32 daddress;</span></span><br><span class="line"><span class="string">    u32 saddress;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">BPF_PERF_OUTPUT(probe_events);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">static inline unsigned char *custom_skb_network_header(const struct sk_buff *skb)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">return skb-&gt;head + skb-&gt;network_header;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">static inline struct iphdr *get_iphdr_in_icmp(const struct sk_buff *skb)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    return (struct iphdr *)custom_skb_network_header(skb);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int probe_icmp(struct pt_regs *ctx, struct net *net, struct sock *sk, struct sk_buff *skb)&#123;</span></span><br><span class="line"><span class="string">    struct iphdr * ipdata=get_iphdr_in_icmp(skb);</span></span><br><span class="line"><span class="string">    if (ipdata-&gt;protocol!=1)&#123;</span></span><br><span class="line"><span class="string">        return 1;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    u64 __pid_tgid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">    u32 __pid = __pid_tgid;</span></span><br><span class="line"><span class="string">    struct probe_icmp_sample __data = &#123;0&#125;;</span></span><br><span class="line"><span class="string">    __data.pid = __pid;</span></span><br><span class="line"><span class="string">    u32 daddress;</span></span><br><span class="line"><span class="string">    u32 saddress;</span></span><br><span class="line"><span class="string">    bpf_probe_read(&amp;daddress, sizeof(ipdata-&gt;daddr), &amp;ipdata-&gt;daddr);</span></span><br><span class="line"><span class="string">    bpf_probe_read(&amp;saddress, sizeof(ipdata-&gt;daddr), &amp;ipdata-&gt;saddr);</span></span><br><span class="line"><span class="string">    __data.daddress=daddress;</span></span><br><span class="line"><span class="string">    __data.saddress=saddress;</span></span><br><span class="line"><span class="string">    probe_events.perf_submit(ctx, &amp;__data, sizeof(__data));</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IcmpSamples</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;pid&quot;</span>, ctypes.c_uint32),</span><br><span class="line">        (<span class="string">&quot;daddress&quot;</span>, ctypes.c_uint32),</span><br><span class="line">        (<span class="string">&quot;saddress&quot;</span>, ctypes.c_uint32),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_text)</span><br><span class="line"></span><br><span class="line">filters = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_ip_address</span>(<span class="params">data</span>):</span><br><span class="line">    results = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    results[<span class="number">3</span>] = data &amp; <span class="number">0xFF</span></span><br><span class="line">    results[<span class="number">2</span>] = (data &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    results[<span class="number">1</span>] = (data &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    results[<span class="number">0</span>] = (data &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;.&quot;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> results[::-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_icmp_event</span>(<span class="params">cpu, data, size</span>):</span><br><span class="line">    <span class="comment"># event = b[&quot;probe_icmp_events&quot;].event(data)</span></span><br><span class="line">    event = ctypes.cast(data, ctypes.POINTER(IcmpSamples)).contents</span><br><span class="line">    daddress = parse_ip_address(event.daddress)</span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">f&quot;pid:<span class="subst">&#123;event.pid&#125;</span>, daddress:<span class="subst">&#123;daddress&#125;</span>, saddress:<span class="subst">&#123;parse_ip_address(event.saddress)&#125;</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf.attach_kprobe(event=<span class="string">&quot;ip_finish_output&quot;</span>, fn_name=<span class="string">&quot;probe_icmp&quot;</span>)</span><br><span class="line"></span><br><span class="line">bpf[<span class="string">&quot;probe_events&quot;</span>].open_perf_buffer(print_icmp_event)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bpf.kprobe_poll()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>OK，这段代码严格意义上来说是混编的，一部分是 C，一部分是 Python，。Python 部分大家肯定都很熟悉，BCC 帮我们加载我们的 C 代码，并 attch 到 kprobe 上。然后不断输出我们从内核中往外传输的数据</p><p>那我们重点来看看 C 部分的代码（实际上这严格来说不算标准 C，算是 BCC 封装的一层 DSL）</p><p>首先看一下我们辅助的两个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">custom_skb_network_header</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> skb-&gt;head + skb-&gt;network_header;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> iphdr *<span class="title function_">get_iphdr_in_icmp</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> iphdr *)custom_skb_network_header(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如前面所说，我们可以根据 sk_buff 中的 head 和 network_header 就能计算出我们 IP 头部在内存中的地址，然后我们将其 cast 成一个 <code>iphdr</code> 结构体指针</p><p>我们还得再来看一下 iphdr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LITTLE_ENDIAN_BITFIELD)</span></span><br><span class="line">__u8ihl:<span class="number">4</span>,</span><br><span class="line">version:<span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (__BIG_ENDIAN_BITFIELD)</span></span><br><span class="line">__u8version:<span class="number">4</span>,</span><br><span class="line">  ihl:<span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span><span class="string">&quot;Please fix &lt;asm/byteorder.h&gt;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">__u8tos;</span><br><span class="line">__be16tot_len;</span><br><span class="line">__be16id;</span><br><span class="line">__be16frag_off;</span><br><span class="line">__u8ttl;</span><br><span class="line">__u8protocol;</span><br><span class="line">__sum16check;</span><br><span class="line">__be32saddr;</span><br><span class="line">__be32daddr;</span><br><span class="line"><span class="comment">/*The options start here. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>熟悉 IP 报文结构的同学肯定就很眼熟了对吧，其中 <code>saddr</code> 和 <code>daddr</code> 就是我们的源地址和目标地址，<code>protocol</code> 代表着我们 L4 协议的类型，其中为1的时候代表着 ICMP 协议</p><p>OK 然后来看一下我们的 trace 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">probe_icmp</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx, <span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> * <span class="title">ipdata</span>=</span>get_iphdr_in_icmp(skb);</span><br><span class="line">    <span class="keyword">if</span> (ipdata-&gt;protocol!=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    u64 __pid_tgid = bpf_get_current_pid_tgid();</span><br><span class="line">    u32 __pid = __pid_tgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">probe_icmp_sample</span> __<span class="title">data</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    __data.pid = __pid;</span><br><span class="line">    u32 daddress;</span><br><span class="line">    u32 saddress;</span><br><span class="line">    bpf_probe_read(&amp;daddress, <span class="keyword">sizeof</span>(ipdata-&gt;daddr), &amp;ipdata-&gt;daddr);</span><br><span class="line">    bpf_probe_read(&amp;saddress, <span class="keyword">sizeof</span>(ipdata-&gt;daddr), &amp;ipdata-&gt;saddr);</span><br><span class="line">    __data.daddress=daddress;</span><br><span class="line">    __data.saddress=saddress;</span><br><span class="line">    probe_events.perf_submit(ctx, &amp;__data, <span class="keyword">sizeof</span>(__data));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如前面所说，kprobe 触发调用时，会将 <code>ip_finish_output</code> 的三个参数传入到我们的 trace 函数中来，那我们就可以根据传入的数据做很多的事了，现在来介绍下上面的代码中所做的事</p><ol><li>将 sk_buff 转换成对应的 iphdr</li><li>判断当前报文是否为 ICMP 协议</li><li>利用内核 BPF 提供的 helper <code>bpf_get_current_pid_tgid</code> 获取当前调用 <code>ip_finish_output</code> 进程的 pid</li><li>获取 saddr 和 daddr。注意我们这里用的 bpf_probe_read 也是 BPF 提供的 helper function，原则上来讲，在 eBPF 中为了保证安全，我们所有从内核中读取数据的行为都应该利用 <code>bpf_probe_read</code> 或 <code>bpf_probe_read_kernel</code> 来实现</li><li>通过 perf 将数据提交出去</li></ol><p>这样一来，我们就能排查到机器上具体什么进程在发送 ICMP 请求了</p><p>来看下效果</p><p><img src="https://user-images.githubusercontent.com/7054676/115132783-db6d0d00-a035-11eb-952a-3fcf33c86690.png" alt="image"></p><p>OK，我们的需求基本上达到了，不过这里算是留了一个小问题，大家可以思考下，我们怎么样根据 pid 获取启动进程时的 cmdline ?</p><h3 id="SystemTap-kprobe"><a href="#SystemTap-kprobe" class="headerlink" title="SystemTap + kprobe"></a>SystemTap + kprobe</h3><p>eBPF 的版本实现了，但是有个问题啊，eBPF 只能在高版本的内核中使用。一般而言，在 xb86_64 上，Linux 3.16 中支持了 eBPF。而我们依赖的 kprobe 对于 eBPF 的支持则是在 Linux 4.1 中实现的。通常而言，我们一般推荐使用 4.9 及以上内核来配合 eBPF 使用</p><p>那么问题来了。实际上我们现在有很多 Centos 7 + Linux 3.10 这样的传统的搭配，那么他们怎么办呢？</p><blockquote><p>Linux 3.10 live’s matter! Centos 7 live’s matter!</p></blockquote><p>那没办法，只能换一个技术栈来做了。这个时候，我们就首先考虑由 RedHat 开发，贡献进入社区，低版本可用的 SystemTap</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="comment">#include&lt;linux/byteorder/generic.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;linux/if_ether.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;linux/skbuff.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;linux/ip.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;linux/in.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;linux/tcp.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/list.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/pid.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/mm.h&gt;</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> isicmp:long (data:long)</span><br><span class="line">%&#123;</span><br><span class="line">    struct iphdr *ip;</span><br><span class="line">    struct sk_buff *skb;</span><br><span class="line">    int tmp = 0;</span><br><span class="line"></span><br><span class="line">    skb = (struct sk_buff *) STAP_ARG_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;protocol == htons(ETH_P_IP))&#123;</span><br><span class="line">            ip = (struct iphdr *) skb-&gt;data;</span><br><span class="line">            tmp = (ip-&gt;protocol == 1);</span><br><span class="line">    &#125;</span><br><span class="line">    STAP_RETVALUE = tmp;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> task_execname_by_pid:string (pid:long) %&#123;</span><br><span class="line">    struct task_struct *task;</span><br><span class="line"></span><br><span class="line">    task = pid_task(find_vpid(STAP_ARG_pid), PIDTYPE_PID);</span><br><span class="line"></span><br><span class="line">//     proc_pid_cmdline(p, STAP_RETVALUE);</span><br><span class="line">    snprintf(STAP_RETVALUE, MAXSTRINGLEN, <span class="string">&quot;%s&quot;</span>, task-&gt;<span class="built_in">comm</span>);</span><br><span class="line">    </span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> ipsource:long (data:long)</span><br><span class="line">%&#123;</span><br><span class="line">    struct sk_buff *skb;</span><br><span class="line">    struct iphdr *ip;</span><br><span class="line">    __be32 src;</span><br><span class="line"></span><br><span class="line">    skb = (struct sk_buff *) STAP_ARG_data;</span><br><span class="line"></span><br><span class="line">    ip = (struct iphdr *) skb-&gt;data;</span><br><span class="line">    src = (__be32) ip-&gt;saddr;</span><br><span class="line"></span><br><span class="line">    STAP_RETVALUE = src;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">/* Return ip destination address */</span><br><span class="line"><span class="keyword">function</span> ipdst:long (data:long)</span><br><span class="line">%&#123;</span><br><span class="line">    struct sk_buff *skb;</span><br><span class="line">    struct iphdr *ip;</span><br><span class="line">    __be32 dst;</span><br><span class="line"></span><br><span class="line">    skb = (struct sk_buff *) STAP_ARG_data;</span><br><span class="line"></span><br><span class="line">    ip = (struct iphdr *) skb-&gt;data;</span><br><span class="line">    dst = (__be32) ip-&gt;daddr;</span><br><span class="line"></span><br><span class="line">    STAP_RETVALUE = dst;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> parseIp:string (data:long) %&#123; </span><br><span class="line">    sprintf(STAP_RETVALUE,<span class="string">&quot;%d.%d,%d.%d&quot;</span>,(int)STAP_ARG_data &amp;0xFF,(int)(STAP_ARG_data&gt;&gt;8)&amp;0xFF,(int)(STAP_ARG_data&gt;&gt;16)&amp;0xFF,(int)(STAP_ARG_data&gt;&gt;24)&amp;0xFF);</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">probe kernel.function(<span class="string">&quot;ip_finish_output&quot;</span>).call &#123;</span><br><span class="line">    <span class="keyword">if</span> (isicmp(<span class="variable">$skb</span>)) &#123;</span><br><span class="line">        pid_data = pid()</span><br><span class="line">        /* IP */</span><br><span class="line">        ipdst = ipdst(<span class="variable">$skb</span>)</span><br><span class="line">        ipsrc = ipsource(<span class="variable">$skb</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid is:%d,source address is:%s, destination address is %s, command is: &#x27;%s&#x27;\n&quot;</span>,pid_data,parseIp(ipsrc),parseIp(ipdst),task_execname_by_pid(pid_data))</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上大家可以看到，我们思路还是一样，利用 <code>ip_finish_output</code> 来作为 kprobe 的 hook 点，然后我们获取对应的 iphdr 然后进行操作。</p><p>嗯，我们的需求的基础功能差不多就是这样了，大家可以在额外进行一些功能增强，比如获取完整的进程 cmdline 等等</p><h2 id="更近一步的想法和实验"><a href="#更近一步的想法和实验" class="headerlink" title="更近一步的想法和实验"></a>更近一步的想法和实验</h2><p>大家可能对于 ICMP 这样的冷门协议没有太明显的感觉，那么我们换个需求大家可能就更为有感觉了</p><blockquote><p>监控机器上哪些进程在发出 HTTP 1.1 请求</p></blockquote><p>嗯，一如往的，我们先来看一下系统中的关键调用</p><p><img src="https://user-images.githubusercontent.com/7054676/115133429-baf38180-a03a-11eb-903f-f2cf46f3edd0.png" alt="TCP"></p><p>嗯，这里我们选择 <code>tcp_sendmsg</code> 来作为我们的切入点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_sendmsg</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> msghdr *msg, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">lock_sock(sk);</span><br><span class="line">ret = tcp_sendmsg_locked(sk, msg, size);</span><br><span class="line">release_sock(sk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，其中 <code>sock</code> 是包含我们一些关键元数据的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now struct inet_timewait_sock also uses sock_common, so please just</span></span><br><span class="line"><span class="comment"> * don&#x27;t add nothing before this first member (__sk_common) --acme</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_common</span>__<span class="title">sk_common</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_common</span> &#123;</span></span><br><span class="line"><span class="comment">/* skc_daddr and skc_rcv_saddr must be grouped on a 8 bytes aligned</span></span><br><span class="line"><span class="comment"> * address on 64bit arches : cf INET_MATCH()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__addrpairskc_addrpair;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__be32skc_daddr;</span><br><span class="line">__be32skc_rcv_saddr;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span>  &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>skc_hash;</span><br><span class="line">__u16skc_u16hashes[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* skc_dport &amp;&amp; skc_num must be grouped as well */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__portpairskc_portpair;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__be16skc_dport;</span><br><span class="line">__u16skc_num;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以看到，我们能在 <code>sock</code> 中获取到我们端口的五元组数据，然后我们从 <code>msghdr</code> 中能获取到具体的数据</p><p>那么，以我们需求中的 HTTP 为例，我们实际上只需要判断，我们获取到的 TCP 包中是否包含 <strong>HTTP/1.1</strong> ，便可粗略判断，这个请求是否是 HTTP 1.1 请求（很暴力的做法Hhhhh</p><p>OK，我们来看下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">bpf_text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">#include &lt;linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/ip.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/tcp.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;net/sock.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;bcc/proto.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/socket.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">struct ipv4_data_t &#123;</span></span><br><span class="line"><span class="string">    u32 pid;</span></span><br><span class="line"><span class="string">    u64 ip;</span></span><br><span class="line"><span class="string">    u32 saddr;</span></span><br><span class="line"><span class="string">    u32 daddr;</span></span><br><span class="line"><span class="string">    u16 lport;</span></span><br><span class="line"><span class="string">    u16 dport;</span></span><br><span class="line"><span class="string">    u64 state;</span></span><br><span class="line"><span class="string">    u64 type;</span></span><br><span class="line"><span class="string">    u8 data[300];</span></span><br><span class="line"><span class="string">    u16 data_size;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">BPF_PERF_OUTPUT(ipv4_events);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int trace_event(struct pt_regs *ctx,struct sock *sk, struct msghdr *msg, size_t size)&#123;</span></span><br><span class="line"><span class="string">    if (sk == NULL)</span></span><br><span class="line"><span class="string">        return 0;</span></span><br><span class="line"><span class="string">    u32 pid = bpf_get_current_pid_tgid() &gt;&gt; 32;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // pull in details</span></span><br><span class="line"><span class="string">    u16 family = sk-&gt;__sk_common.skc_family;</span></span><br><span class="line"><span class="string">    u16 lport = sk-&gt;__sk_common.skc_num;</span></span><br><span class="line"><span class="string">    u16 dport = sk-&gt;__sk_common.skc_dport;</span></span><br><span class="line"><span class="string">    char state = sk-&gt;__sk_common.skc_state;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (family == AF_INET) &#123;</span></span><br><span class="line"><span class="string">        struct ipv4_data_t data4 = &#123;&#125;;</span></span><br><span class="line"><span class="string">        data4.pid = pid;</span></span><br><span class="line"><span class="string">        data4.ip = 4;</span></span><br><span class="line"><span class="string">        //data4.type = type;</span></span><br><span class="line"><span class="string">        data4.saddr = sk-&gt;__sk_common.skc_rcv_saddr;</span></span><br><span class="line"><span class="string">        data4.daddr = sk-&gt;__sk_common.skc_daddr;</span></span><br><span class="line"><span class="string">        // lport is host order</span></span><br><span class="line"><span class="string">        data4.lport = lport;</span></span><br><span class="line"><span class="string">        data4.dport = ntohs(dport);</span></span><br><span class="line"><span class="string">        data4.state = state;</span></span><br><span class="line"><span class="string">        struct iov_iter temp_iov_iter=msg-&gt;msg_iter;</span></span><br><span class="line"><span class="string">        struct iovec *temp_iov=temp_iov_iter.iov;</span></span><br><span class="line"><span class="string">        bpf_probe_read_kernel(&amp;data4.data_size, 4, &amp;temp_iov-&gt;iov_len);</span></span><br><span class="line"><span class="string">        u8 * temp_ptr;</span></span><br><span class="line"><span class="string">        bpf_probe_read_kernel(&amp;temp_ptr, sizeof(temp_ptr), &amp;temp_iov-&gt;iov_base);</span></span><br><span class="line"><span class="string">        bpf_probe_read_kernel(&amp;data4.data, sizeof(data4.data), temp_ptr);</span></span><br><span class="line"><span class="string">        ipv4_events.perf_submit(ctx, &amp;data4, sizeof(data4));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_text)</span><br><span class="line"></span><br><span class="line">filters = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_ip_address</span>(<span class="params">data</span>):</span><br><span class="line">    results = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    results[<span class="number">3</span>] = data &amp; <span class="number">0xFF</span></span><br><span class="line">    results[<span class="number">2</span>] = (data &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    results[<span class="number">1</span>] = (data &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    results[<span class="number">0</span>] = (data &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;.&quot;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> results[::-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_http_payload</span>(<span class="params">cpu, data, size</span>):</span><br><span class="line">    <span class="comment"># event = b[&quot;probe_icmp_events&quot;].event(data)</span></span><br><span class="line">    <span class="comment"># event = ctypes.cast(data, ctypes.POINTER(IcmpSamples)).contents</span></span><br><span class="line">    event= bpf[<span class="string">&quot;ipv4_events&quot;</span>].event(data)</span><br><span class="line">    daddress = parse_ip_address(event.daddr)</span><br><span class="line">    <span class="comment"># data=list(event.data)</span></span><br><span class="line">    <span class="comment"># temp=binascii.hexlify(data) </span></span><br><span class="line">    body = <span class="built_in">bytearray</span>(event.data).<span class="built_in">hex</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;48 54 54 50 2f 31 2e 31&quot;</span>.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>) <span class="keyword">in</span> body:</span><br><span class="line">        <span class="comment"># if &quot;68747470&quot; in temp.decode():</span></span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">f&quot;pid:<span class="subst">&#123;event.pid&#125;</span>, daddress:<span class="subst">&#123;daddress&#125;</span>, saddress:<span class="subst">&#123;parse_ip_address(event.saddr)&#125;</span>, <span class="subst">&#123;event.lport&#125;</span>, <span class="subst">&#123;event.dport&#125;</span>, <span class="subst">&#123;event.data_size&#125;</span>&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf.attach_kprobe(event=<span class="string">&quot;tcp_sendmsg&quot;</span>, fn_name=<span class="string">&quot;trace_event&quot;</span>)</span><br><span class="line"></span><br><span class="line">bpf[<span class="string">&quot;ipv4_events&quot;</span>].open_perf_buffer(print_http_payload)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bpf.perf_buffer_poll()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>OK，我们来看下效果</p><p><img src="https://user-images.githubusercontent.com/7054676/115135218-4ecc4a00-a049-11eb-899b-baecffdb6268.png" alt="效果"></p><p>实际上这个我们还可以再扩展一下。比如针对 Go 这样，所发出的 HTTPS 连接有着固定特征的语言，我们也可以用相对简单的做法去完成机器上的包来源的溯源（大家可以参考下无辄的这篇文章，<a href="https://www.imwzk.com/posts/2021-03-14-why-i-always-get-503-with-golang/#%E5%B0%BE%E5%A3%B0">为什么用 Go 访问某网站始终会 503 Service Unavailable ？</a>)</p><p>我自己也做了一个测试，大家可以参考下代码：<a href="https://github.com/Zheaoli/linux-traceing-script/blob/main/ebpf/go-https-tracing.py">https://github.com/Zheaoli/linux-traceing-script/blob/main/ebpf/go-https-tracing.py</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上无论是 eBPF 还是 SystemTap ，这类动态 tracing 技术可以 Linux Kernel 变得更具被可编程性。相较于传统的 recompile kernel 这些手段来说，更为方便快捷。而 BCC/BPFTrace 这类的更进一步的封装框架的出现，更进一步的降低了我们去观测内核的难度</p><p>很多时候我们很多需求都可以选择旁路的方式去更快捷的实现。但是要注意的一点是，动态 tracing 技术的引入势必增加了内核的不稳定性，而且一定程度上会影响性能。所以我们需要根据具体的场景去做 trade-off</p><p>好了，这篇文章差不多就水到这里，后面有时间争取出一个 eBPF 从入门到入土的系列文章（flag++</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这周帮朋友用 eBPF/SystemTap 这样的动态 tracing 工具做了一些很有趣的功能。这篇文章算是一个总结&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/Linux/"/>
    
    <category term="Kernel" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/Linux/Kernel/"/>
    
    
    <category term="编程" scheme="https://manjusaka.blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/tags/Linux/"/>
    
    <category term="笔记" scheme="https://manjusaka.blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="水文" scheme="https://manjusaka.blog/tags/%E6%B0%B4%E6%96%87/"/>
    
    <category term="eBPF" scheme="https://manjusaka.blog/tags/eBPF/"/>
    
    <category term="SystemTap" scheme="https://manjusaka.blog/tags/SystemTap/"/>
    
  </entry>
  
  <entry>
    <title>当我们在聊 CI/CD 时，我们在聊什么？</title>
    <link href="https://manjusaka.blog/posts/2021/04/11/a-simple-introduce-about-ci-cd/"/>
    <id>https://manjusaka.blog/posts/2021/04/11/a-simple-introduce-about-ci-cd/</id>
    <published>2021-04-11T07:09:00.000Z</published>
    <updated>2023-06-22T16:36:06.199Z</updated>
    
    <content type="html"><![CDATA[<p>本文实际上是在群内第二次分享的内容。这次其实想来聊聊，关于 CI/CD 的一些破事和演进过程中我们所需要遇到的一些问题，当然本文中是一个偏新手向的文章和一点点爆论，随便看看就好。</p><span id="more"></span><h2 id="开宗明义，定义先行"><a href="#开宗明义，定义先行" class="headerlink" title="开宗明义，定义先行"></a>开宗明义，定义先行</h2><p>在我们谈论一个事物之前，我们需要对这个事物给出一个定义，那我们先来看一下我们今天要聊的 CI 与 CD 的定义。</p><p>首先，CI 指 Continuous Integration ，在中文语境中的表述是<strong>持续集成</strong>。而 CD 在常见语境下可能是两种意思：Continuous Delivery 或 Continuous Deployment，与之对应的表述是<strong>持续交付/持续部署</strong>。这里借用一下 Brent Laster 在 <strong>What is CI/CD?</strong><a href="#refer-anchor-1"><sup>1</sup></a> 中给出的定义</p><blockquote><p>Continuous integration (CI) is the process of automatically detecting, pulling, building, and (in most cases) doing unit testing as source code is changed for a product. CI is the activity that starts the pipeline (although certain pre-validations—often called “pre-flight checks”—are sometimes incorporated ahead of CI).<br>The goal of CI is to quickly make sure a new change from a developer is “good” and suitable for further use in the code base.<br>Continuous deployment (CD) refers to the idea of being able to automatically take a release of code that has come out of the CD pipeline and make it available for end users. Depending on the way the code is “installed” by users, that may mean automatically deploying something in a cloud, making an update available (such as for an app on a phone), updating a website, or simply updating the list of available releases.</p></blockquote><p>光看定义，可能大家还是会很懵逼，那么下面我们用一些实际的例子来给大家从头捋一遍 CI/CD 那些事</p><h2 id="Re：从0开始构建流程"><a href="#Re：从0开始构建流程" class="headerlink" title="Re：从0开始构建流程"></a>Re：从0开始构建流程</h2><p>这个标题好像起的有点草，不过不管了。首先我们假定这样一个最简单的需求</p><blockquote><p>我们基于 Hexo 构建了一个个人的博客系统。其中包含我们所需要发布的文章，我们配置的主题。我们需要将其发布到具体的 Repo 上。</p></blockquote><p>好了，基于这个需求，我们来从0到0玩一圈吧（笑（</p><h3 id="构建原生之初"><a href="#构建原生之初" class="headerlink" title="构建原生之初"></a>构建原生之初</h3><p>可能这里有很多人会问，为啥会选择 Hexo 来作为我们的切入点。原因很简单啊！因为它够简单啊！</p><p>言归正传，首先 Hexo 有两个命令 <code>hexo g</code> &amp;&amp; <code>hexo d</code> ，分别是根据当前目录下的 Markdown 文件来生成静态的网页。然后将生成的产物根据配置推送到对应的 repo 上</p><p>OK，那么我们在最原始的阶段一个构建的流程就是这样</p><ol><li>用一个编辑器，开开心心的写文章</li><li>然后在本地终端执行 <code>hexo g &amp;&amp; hexo d</code></li></ol><p>问题来了，现在有些时候提交了博客，但是忘了执行生成命令怎么办？或者是我每次都需要敲重复的命令很麻烦怎么办？那就让我们把整个过程自动化一下吧。Let’s rock!</p><h3 id="更进一步的构建"><a href="#更进一步的构建" class="headerlink" title="更进一步的构建"></a>更进一步的构建</h3><p>OK，我们先来假设一下，我们如果完成了自动化，我们现在发布一个博客的工作流应该编程什么样的</p><ol><li>我们编写一个 Markdown 文件，推送到 GitHub 仓库里的 Master 分支上</li><li>我们的自动任务开始构建我们博客，生成一系列静态文件和样式</li><li>将我们的静态文件和样式推送到我们的站点 Repo/CDN 等目标位置</li></ol><p>好了，那么这里有两个核心的问题</p><ol><li>在我们推送代码的时候，自动开始构建</li><li>在构建完成后，推送产物</li></ol><p>那我们现在基于 GitHub Action 来配置一套我们的自动化构建任务</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">And</span> <span class="string">Publish</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;12.x&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Package</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">Html</span> <span class="string">File</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">🚀</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@3.7.1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PUBLSH_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">gh-pages</span> <span class="comment"># The branch the action should deploy to.</span></span><br><span class="line">          <span class="attr">FOLDER:</span> <span class="string">public</span> <span class="comment"># The folder the action should deploy.</span></span><br></pre></td></tr></table></figure><p>我们能看到这段配置实际上完成了这样一些事情</p><ol><li>在我们往 master 分支提交代码的时候触发构建</li><li>拉取代码</li><li>安装构建所需依赖</li><li>构建生成静态文件</li><li>推送静态文件</li></ol><p>如果上面任何一个步骤失败了，都将取消后面步骤的执行。实际上这样一个简单的任务已经包含了一个 CI &amp;&amp; CD 所包含的基础要素（这里 CD 我并未严格区分 Continuous Delivery/Continuous Deployment)</p><ol><li>与已有的代码持续的构建与集成</li><li>集成中区分多个 phase。每个 phase 将依赖上个 phase 结果。</li><li>将构建产物交付/部署出去。交付/部署的成功依赖于集成的成功</li></ol><p>那么在这里，我们将博客系统换成一个我们工程中的例子。将 Hexo 换成我们的 Python 服务。将新增博文换成我们的新增的代码。将构建命令换成 mypy/pylint 等检查工具。你看，CI/CD 实际上和你想象的复杂的系统，是不是有很大差别？</p><p>这里可能有很多人会提出这样一个问题，如果说这里我们将这些命令，不用线上的形式触发。而在本地用 Git Hook 等形式进行实现。那么这算不算一种 CI 与 CD 呢？我觉得毫无疑问算的，从我的视角来看，CI/CD 核心的要素在于通过可以重复，自动化的任务，来尽早暴露缺陷，减轻人为因素所带来的不必要的事故发生。</p><h2 id="这个开发过份傻逼却不谨慎"><a href="#这个开发过份傻逼却不谨慎" class="headerlink" title="这个开发过份傻逼却不谨慎"></a>这个开发过份傻逼却不谨慎</h2><p>首先抛出一个最基础的爆论，然后我们接着往下谈</p><blockquote><p>所有人都有傻逼的时候，而且这个傻逼的时候可能还会很多。</p></blockquote><p>在这样一个爆论的情况下，我们来回顾一下上面举<strong>基于 Hexo 去构建一个个人博客系统</strong>的例子中，如果我们不选择通过一种收敛的，自动化的系统去解决我们的构建，发布需求。那么我们哪些环节会出现风险</p><ol><li>最基础的，写完博客，忘了构建，忘了发布</li><li>比如我们升级一下依赖中的 Hexo 版本或者主题版本，我们没有测试，导致构建出来的样式失效</li><li>我们的 Markdown 有问题，导致构建失败</li><li>比如多个人维护一个博客的情况下，我们每个人都需要保存目标仓库/CDN的密钥等信息。导致信息泄漏等</li></ol><p>将<strong>基于 Hexo 去构建一个个人博客系统</strong>的例子切换成我们日常开发的场景，那么我们可能遇到的问题会更多。简单举几个</p><ol><li>没法很快速的回滚</li><li>没法溯源具体的构建/发布记录</li><li>没有自动化的任务，研发懒得跑测试或者 lint 导致代码腐化</li><li>高峰期上线导致事故</li></ol><p>嗯，这些问题大家是不是都很熟悉？大概就是，我起了，构建了，出事故了，有啥好说的23333</p><p><img src="https://user-images.githubusercontent.com/7054676/114294469-75cacf00-9ad1-11eb-8853-20e5a50bacce.png" alt="image"></p><p>讲到这里的大家实际上有没有发现一个问题？我在这篇文章中，没有对 CI 与 CD 进行区分？从我的视角来看，CI/CD 本质上是践行的同一个事。即 <strong>对于研发流程与交付流程的收敛</strong></p><p>从我的视角来看，去构建一个 CI/CD 系统核心的目标在于</p><ol><li>通过收敛入口以及自动化的任务触发，尽可能减轻人为因素所带来的系统不稳定性</li><li>通过快速，多次，可重复，无感知的任务，尽可能的在较早阶段暴露系统中的问题</li></ol><p>在这样两个大目标的前提下，我们便会根据不同的业务场景，采用不同的手段与形式丰富我们 CI/CD 中的内容，包括不仅限于</p><ol><li>在 CI 阶段自动化的单元测试，E2E 测试等</li><li>在 CI 阶段周期性的 Nighty Build 等</li><li>在 CD 阶段进行发布管控等</li></ol><p>不过无论我们怎么样去构建一个 CI/CD 系统，或者选择什么样的粒度去进行 CI/CD。我觉得一个合格的 CI/CD 系统与机制 都需要遵照这样几个原则（个人向总结）</p><ol><li>入口的收敛，SOP 的建立。如果不达成这点共识，研发能够通过技术手段绕过 CI/CD 系统那么便又回到的了我们本章的标题（这个研发过份傻逼却不谨慎）</li><li>对于业务代码无侵入</li><li>集成任务/发布任务一定要是自动化，可重复的</li><li>可回溯的历史记录与结果</li><li>可回溯的构建集成产物</li><li>从上到下的支持</li></ol><p>那么遵照我总结的这样几个原则，我们来迭代一下我们之前的博客的发布过程</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">And</span> <span class="string">Publish</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;12.x&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Package</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">Html</span> <span class="string">File</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">To</span> <span class="string">Repo🚀</span></span><br><span class="line">        <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.ref</span> <span class="string">==</span> <span class="string">&#x27;refs/heads/master&#x27;</span><span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@3.7.1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PUBLSH_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">gh-pages</span> <span class="comment"># The branch the action should deploy to.</span></span><br><span class="line">          <span class="attr">FOLDER:</span> <span class="string">public</span> <span class="comment"># The folder the action should deploy.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">to</span> <span class="string">Collect</span> <span class="string">Repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@3.7.1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PUBLSH_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">build-$&#123;&#123;</span> <span class="string">github.run_id</span> <span class="string">&#125;&#125;</span> <span class="comment"># The branch the action should deploy to.</span></span><br><span class="line">          <span class="attr">FOLDER:</span> <span class="string">public</span> <span class="comment"># The folder the action should deploy.</span></span><br></pre></td></tr></table></figure><p>在这段更改后的构建流程中，我选择以 PR 为粒度去触发 CI 流程，并将历史产物进行存储，而在合并主分支后，新增发布流程。在这样一来，我在博客构建发布的时候，便能够通过回溯的历史产物来验证我框架升级，新增博文等操作的正确性。同时依托 GitHub Action，我能很好的完成历史构建的回溯</p><p><img src="https://user-images.githubusercontent.com/7054676/114294865-f38fda00-9ad3-11eb-938b-c25b7a4ca6bf.png" alt="image"></p><p>嗯，这样便可以尽可能避免我傻逼的操作所带来的各种副作用（逃</p><h2 id="进击的构建：终章"><a href="#进击的构建：终章" class="headerlink" title="进击的构建：终章"></a>进击的构建：终章</h2><p>好了，啥都没有，傻眼了吧<br>。<br>。<br>。<br>。</p><p>只是开个玩笑。实际上本文到这差不多就可以告一段落了。实际上大家通过这篇文章可以发现一个问题。就是实际上构建一个 CI/CD 系统可能并不会涉及很多，很高深的技术问题(极少数的场景除外）无论是传统的 Jenkins，还是新生的 GitHub Action，GitLab-CI，亦或者是云厂商提供的服务都能很好的帮助我们去构建一套贴合业务的 CI/CD 系统。但我之前在推特上发表了的一个爆论“CI/CD 的建立往往不是一个技术问题，而是一个制度问题，更可以称为是一个想法问题”。</p><p>所以，我希望我们每个人都能认识到我们都会犯错这样一个事实。然后尽可能的将自己所负责的系统的开发流程与交付流程尽可能的收敛与自动化。让一个 CI/CD 真正称为我们日常工作中的一部分。</p><p>差不多这样，溜了，溜了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文实际上是在群内第二次分享的内容。这次其实想来聊聊，关于 CI/CD 的一些破事和演进过程中我们所需要遇到的一些问题，当然本文中是一个偏新手向的文章和一点点爆论，随便看看就好。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="杂记" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://manjusaka.blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="笔记" scheme="https://manjusaka.blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="水文" scheme="https://manjusaka.blog/tags/%E6%B0%B4%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>继续爆论容器中的一号进程</title>
    <link href="https://manjusaka.blog/posts/2021/02/27/damn-the-init-process/"/>
    <id>https://manjusaka.blog/posts/2021/02/27/damn-the-init-process/</id>
    <published>2021-02-27T19:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.199Z</updated>
    
    <content type="html"><![CDATA[<p>上周的文章聊了关于容器中的一号进程的一些概况后，在我师父某川(可以去 GitHub 找他玩，<a href="https://github.com/jschwinger23">jschwinger23</a>) 的指导与配合下，我们一起对目前主流的被广泛使用的两个容器中一号进程的实现 dumb-init 和 tini 做了一番探究，继续写个水文来爆论一番。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="我们为什么需要一个一号进程，我们希望的一号进程需要承担怎样的职责？"><a href="#我们为什么需要一个一号进程，我们希望的一号进程需要承担怎样的职责？" class="headerlink" title="我们为什么需要一个一号进程，我们希望的一号进程需要承担怎样的职责？"></a>我们为什么需要一个一号进程，我们希望的一号进程需要承担怎样的职责？</h3><p>在继续聊关于 dumb-init 和 tini 的相关爆论之前，我们需要来 review 一个问题。我们为什么需要一个一号进程？以及我们所选择的一号进程需要承担怎么样的职责</p><p>其实我们在容器场景下需要一号进程托管在前面实际上有两种主要的场景，</p><ol><li><p>对于容器内 Graceful Upgrade 二进制这种场景，主流的一种做法之一是 fork 一个新的进程，exec 新的二进制文件，新进程处理新链接，老进程处理老链接。（Nginx 就采用这种方案）</p></li><li><p>没有正确的处理信号转发以及进程回收的情况</p></li><li><p>一些如同 calico-node 的场景么，我们出于方便打包的考虑，将多个二进制运行在同一容器中</p></li></ol><p>对于第一种其实需要说的没有太多，我们来看一下第二点的测试</p><p>我们先准备一个最简单 Python 文件，<strong>demo1.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">10000</span>)</span><br></pre></td></tr></table></figure><p>然后依照常规，我们开始用一个 bash 脚本裹一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">python /root/demo1.py</span><br></pre></td></tr></table></figure><p>最后编写 Dockerfile </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> demo1.py /root/demo1.py</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> demo1.sh /root/demo1.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;/root/demo1.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>构建后开始执行，我们先来看一下进程结构</p><p><img src="https://user-images.githubusercontent.com/7054676/109394863-29ce2b80-7964-11eb-88aa-4e1f6e2e3e00.png" alt="进程结构"></p><p>没有问题，现在我们用 <strong>strace</strong> 来 trace 一下，2049962、2050009 这两个进程，然后对 2049962 这个 bash 进程发 <em>*SIGTERM</em>＊ 信号</p><p>我们来看下结果</p><p><img src="https://user-images.githubusercontent.com/7054676/109394942-a9f49100-7964-11eb-8fa5-5d676e512081.png" alt="2049962进程的 trace 结果"></p><p><img src="https://user-images.githubusercontent.com/7054676/109394966-d8726c00-7964-11eb-9e18-f99a0a64b5cd.png" alt="2050009进程的 trace 结果"></p><p>我们能清晰看到 2049962 进程在接到 <strong>SIGTERM</strong> 的时候，没有将其转发给 2050009 进程。在我们手动 SIGKILL 2049962 后， 2050009 也随即退出，这里可能有人会有点疑惑，为什么 2049962 退出后，2050009 也会退出呢？</p><p>这里是由于 pid namespace 本身的特性，我们来看看，<a href="https://man7.org/linux/man-pages/man7/pid_namespaces.7.html">pid_namespaces</a> 中的相关介绍</p><blockquote><p>If the “init” process of a PID namespace terminates, the kernel terminates all of the processes in the namespace via a SIGKILL signal.  </p></blockquote><p>当当前 pid ns 内的一号进程退出的时候，内核直接 SIGKILL 伺候该 pid ns 内的剩余进程</p><p>OK，在我们结合容器调度框架后，那么在生产上实际会出现很多的坑，来看一段我之前的吐槽</p><blockquote><p>我们一个测试服务，Spring Cloud 的，在下线后，节点无法从注册中心摘除，然后百思不得其解，最后查到问题，，<br>本质上是这样，POD 被摘除的时候，K8S Scheduler 会给 POD 的 ENTRYPOINT 发一个 SIGTERM 信号，然后等待三十秒（默认的 graceful shutdown 超时实践)，还没响应就会 SIGKILL 直接杀<br>问题在于，我们 Eureka 版的服务是通过 start.sh 来启动的，ENTRYPOINT [“/home/admin/start.sh”]，容器里默认是 /bin/sh 是 fork/exec 模式，导致我服务进程没法正确的收到 SIGTERM 信号，然后一直没结束就被 SIGKILL 了</p></blockquote><p>刺激不刺激。除了信号转发无法正常处理以外，我们应用程序常见的一个常见处理的问题就是 Z 进程的出现，即子进程结束之后，无法正确的回收。比如早期 puppeteer 臭名昭著的 Z 进程问题。 在这种情况下，除了应用程序本身的问题以外，另外可能的原因是在守护进程这样的场景下，孤儿进程 re-parent 之后的进程，不具备回收子进程的功能</p><p>OK 在回顾完上面我们常见的问题后，我们来 review 一下我们对于容器内一号进程所需要承担的职责</p><ol><li><p>信号的转发</p></li><li><p>Z 进程的回收</p></li></ol><p>而在目前，在容器场景下，大家主要使用两个方案来作为自己的容器内一号进程，<a href="https://github.com/Yelp/dumb-init">dumb-init</a> 和 <a href="https://github.com/krallin/tini">tini</a>。这两个方案对于容器内孤儿与 Z 进程的处理都算是 OK。但是信号转发的实现上一言难尽。那么接下来</p><p>爆论时间！</p><h3 id="拉跨的-dumb-init"><a href="#拉跨的-dumb-init" class="headerlink" title="拉跨的 dumb-init"></a>拉跨的 dumb-init</h3><p>某种程度上来说，<strong>dumb-init</strong> 这货完全是属于虚假宣传的典范。代码实现非常糙</p><p>来看看官方的宣传</p><blockquote><p>dumb-init runs as PID 1, acting like a simple init system. It launches a single process and then proxies all received signals to a session rooted at that child process.</p></blockquote><p>这里，dumb-init 说自己使用了 Linux 中的进程 Session，我们都知道，一个进程 Session 在默认情况下，共享一个 Process Group Id 。那么我们这里可以理解为，dumb-init 能将信号完全转发到进程组中的每个进程上。听起来很美好是不是？</p><p>我们先来测试一下吧</p><p>测试代码如下，<strong>demo2.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    cpid = os.fork()</span><br><span class="line">time.sleep(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>Dockerfile 如下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/dumb-init https://github.com/Yelp/dumb-init/releases/download/v1.2.5/dumb-init_1.2.5_x86_64</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /usr/local/bin/dumb-init</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> demo2.py /root/demo2.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/local/bin/dumb-init&quot;</span>, <span class="string">&quot;--&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/root/demo2.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>构建，开跑，先来看下进程结构</p><p><img src="https://user-images.githubusercontent.com/7054676/109396500-dca28780-796c-11eb-9ae1-37be10affbb0.png" alt="demo2 的进程结构"></p><p>然后老规矩，strace 2103908、2103909、2103910 这三个进程，然后我们对 <strong>dumb-init</strong> 的进程做一下发送 SIGTERM 的操作吧</p><p><img src="https://user-images.githubusercontent.com/7054676/109396545-1f645f80-796d-11eb-9205-7735e5fd3685.png" alt="strace 2103908"></p><p><img src="https://user-images.githubusercontent.com/7054676/109396563-3440f300-796d-11eb-82ed-94693d49cfc8.png" alt="strace 2103909"></p><p><img src="https://user-images.githubusercontent.com/7054676/109397059-c649fb00-796f-11eb-8206-02af6d9dc02b.png" alt="strace 2103910"></p><p>诶？dumb-init 老师，发生了甚么事？为什么 2103909 直接被 SIGKILL 了，而没有收到 SIGTERM</p><p>这里我们要来看下 dumb-init 的关键实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_signal</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    DEBUG(<span class="string">&quot;Received signal %d.\n&quot;</span>, signum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal_temporary_ignores[signum] == <span class="number">1</span>) &#123;</span><br><span class="line">        DEBUG(<span class="string">&quot;Ignoring tty hand-off signal %d.\n&quot;</span>, signum);</span><br><span class="line">        signal_temporary_ignores[signum] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (signum == SIGCHLD) &#123;</span><br><span class="line">        <span class="type">int</span> status, exit_status;</span><br><span class="line">        <span class="type">pid_t</span> killed_pid;</span><br><span class="line">        <span class="keyword">while</span> ((killed_pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">                exit_status = WEXITSTATUS(status);</span><br><span class="line">                DEBUG(<span class="string">&quot;A child with PID %d exited with exit status %d.\n&quot;</span>, killed_pid, exit_status);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                assert(WIFSIGNALED(status));</span><br><span class="line">                exit_status = <span class="number">128</span> + WTERMSIG(status);</span><br><span class="line">                DEBUG(<span class="string">&quot;A child with PID %d was terminated by signal %d.\n&quot;</span>, killed_pid, exit_status - <span class="number">128</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (killed_pid == child_pid) &#123;</span><br><span class="line">                forward_signal(SIGTERM);  <span class="comment">// send SIGTERM to any remaining children</span></span><br><span class="line">                DEBUG(<span class="string">&quot;Child exited with status %d. Goodbye.\n&quot;</span>, exit_status);</span><br><span class="line">                <span class="built_in">exit</span>(exit_status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        forward_signal(signum);</span><br><span class="line">        <span class="keyword">if</span> (signum == SIGTSTP || signum == SIGTTOU || signum == SIGTTIN) &#123;</span><br><span class="line">            DEBUG(<span class="string">&quot;Suspending self due to TTY signal.\n&quot;</span>);</span><br><span class="line">            kill(getpid(), SIGSTOP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 dumb-init 老师处理信号的代码，在收到信号后，将除 SIGCHLD 的信号做转发（注意 SIGKILL 是不可 handle 信号），我们来看看信号转发的逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">forward_signal</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    signum = translate_signal(signum);</span><br><span class="line">    <span class="keyword">if</span> (signum != <span class="number">0</span>) &#123;</span><br><span class="line">        kill(use_setsid ? -child_pid : child_pid, signum);</span><br><span class="line">        DEBUG(<span class="string">&quot;Forwarded signal %d to children.\n&quot;</span>, signum);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DEBUG(<span class="string">&quot;Not forwarding signal %d to children (ignored).\n&quot;</span>, signum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下直接 kill 发送信号，其中 -child_pid 是这样一个特性：</p><blockquote><p>If pid is less than -1, then sig is sent to every process in the process group whose ID is -pid.</p></blockquote><p>直接转发进程组，看起来没啥问题啊？那么上面是甚么原因呢？我们再来复习下上一段话，kill 给进程组发信号的逻辑是 <strong>sig is sent to every process</strong> ，懂了，一个 O(N) 的遍历嘛。没啥问题啊？好了，不卖关子，这里 dumb-init 的实现存在一个 race-condition</p><p>我们刚刚说了，kill 进程组的行为是一个 O(N) 的遍历，那么必然会有进程先收到信号，而有进程后收到信号。以 SIGTERM 为例，假设我们 dumb-init 的子进程先收到 SIGTERM，优雅退出后，dumb-init 收到 SIGCHLD 的信号，然后 wait_pid 拿到子进程 ID，判断是自己直接托管的进程后，自杀退出。好了，由于 dumb-init 是我们当前 pid ns 内的 init 进程，再来复习下 pid ns 的特性。</p><blockquote><p>If the “init” process of a PID namespace terminates, the kernel terminates all of the processes in the namespace via a SIGKILL signal. </p></blockquote><p>在 dumb-init 自杀以后，剩余进程将直接被内核 SIGKILL 伺候。也就导致了我们上面看到的，子进程没有收到转发的信号！</p><p>所以这里加粗处理一下，<strong>dumb-init 所承诺的，能将信号转发到所有进程上，完全是虚假宣传！</strong></p><p>而且请注意，dumb-init 宣称自己能管理一个 Session 内的进程！但是实际上他们只做了一个进程组的信号转发！完全是虚假宣称！Fake News！</p><p>而且如上面所提到的，在我们热更新二进制这样的场景下，dumb-init 在进程退出后直接自杀。和不使用一号进程完全没有差别！</p><p>我们可以来测试一下，测试代码 demo3.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">pid = os.fork()</span><br><span class="line">time.sleep(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>fork 一个进程，总共两个进程</p><p>Dockerfile 如下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/dumb-init https://github.com/Yelp/dumb-init/releases/download/v1.2.5/dumb-init_1.2.5_x86_64</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /usr/local/bin/dumb-init</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> demo3.py /root/demo3.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/local/bin/dumb-init&quot;</span>, <span class="string">&quot;--&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/root/demo3.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>构建，执行，先看看进程结构</p><p><img src="https://user-images.githubusercontent.com/7054676/109397207-9818eb00-7970-11eb-8dbb-35ccbe5d26cf.png" alt="demo3 进程结构"></p><p>然后模拟老进程退出，我们直接 SIGKILL 掉 2134836，然后我们看看 2134837 的 strace 的结果</p><p><img src="https://user-images.githubusercontent.com/7054676/109397254-d31b1e80-7970-11eb-9bf2-fcc3e12ca77c.png" alt="strace 2134837"></p><p>如预期一样，在 dumb-init 自杀后，2134837 被内核 SIGKILL 了</p><p>所以跟我复习一遍 <strong>dumb-init</strong> 拉跨！好了，我们接着聊 tini 的实现</p><h3 id="态度友好的聊聊-tini"><a href="#态度友好的聊聊-tini" class="headerlink" title="态度友好的聊聊 tini"></a>态度友好的聊聊 tini</h3><p>平心而论，tini 的实现，虽然也还有坑，但是比 <strong>dumb-init</strong> 细腻到不知道哪里去了，我们直接来先看下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">/* Wait for one signal, and forward it */</span></span><br><span class="line"><span class="keyword">if</span> (wait_and_forward_signal(&amp;parent_sigset, child_pid)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now, reap zombies */</span></span><br><span class="line"><span class="keyword">if</span> (reap_zombies(child_pid, &amp;child_exitcode)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child_exitcode != <span class="number">-1</span>) &#123;</span><br><span class="line">PRINT_TRACE(<span class="string">&quot;Exiting: child has exited&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> child_exitcode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 tini 没有设置 signal handler ，不断循环 <code>wait_and_forward_signal</code> 和 <code>reap_zombies</code> 这两个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">wait_and_forward_signal</span><span class="params">(<span class="type">sigset_t</span> <span class="type">const</span>* <span class="type">const</span> parent_sigset_ptr, <span class="type">pid_t</span> <span class="type">const</span> child_pid)</span> &#123;</span><br><span class="line"><span class="type">siginfo_t</span> sig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigtimedwait(parent_sigset_ptr, &amp;sig, &amp;ts) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (errno) &#123;</span><br><span class="line"><span class="keyword">case</span> EAGAIN:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EINTR:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;Unexpected error in sigtimedwait: &#x27;%s&#x27;&quot;</span>, strerror(errno));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* There is a signal to handle here */</span></span><br><span class="line"><span class="keyword">switch</span> (sig.si_signo) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGCHLD:</span><br><span class="line"><span class="comment">/* Special-cased, as we don&#x27;t forward SIGCHLD. Instead, we&#x27;ll</span></span><br><span class="line"><span class="comment"> * fallthrough to reaping processes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PRINT_DEBUG(<span class="string">&quot;Received SIGCHLD&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">PRINT_DEBUG(<span class="string">&quot;Passing signal: &#x27;%s&#x27;&quot;</span>, strsignal(sig.si_signo));</span><br><span class="line"><span class="comment">/* Forward anything else */</span></span><br><span class="line"><span class="keyword">if</span> (kill(kill_process_group ? -child_pid : child_pid, sig.si_signo)) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == ESRCH) &#123;</span><br><span class="line">PRINT_WARNING(<span class="string">&quot;Child was dead when forwarding signal&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;Unexpected error when forwarding signal: &#x27;%s&#x27;&quot;</span>, strerror(errno));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>sigtimedwait</code> 这个函数来接收信号，然后过滤掉 <code>SIGCHLD</code> 转发。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">reap_zombies</span><span class="params">(<span class="type">const</span> <span class="type">pid_t</span> child_pid, <span class="type">int</span>* <span class="type">const</span> child_exitcode_ptr)</span> &#123;</span><br><span class="line"><span class="type">pid_t</span> current_pid;</span><br><span class="line"><span class="type">int</span> current_status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">current_pid = waitpid(<span class="number">-1</span>, &amp;current_status, WNOHANG);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (current_pid) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"><span class="keyword">if</span> (errno == ECHILD) &#123;</span><br><span class="line">PRINT_TRACE(<span class="string">&quot;No child to wait&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;Error while waiting for pids: &#x27;%s&#x27;&quot;</span>, strerror(errno));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">PRINT_TRACE(<span class="string">&quot;No child to reap&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* A child was reaped. Check whether it&#x27;s the main one. If it is, then</span></span><br><span class="line"><span class="comment"> * set the exit_code, which will cause us to exit once we&#x27;ve reaped everyone else.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PRINT_DEBUG(<span class="string">&quot;Reaped child with pid: &#x27;%i&#x27;&quot;</span>, current_pid);</span><br><span class="line"><span class="keyword">if</span> (current_pid == child_pid) &#123;</span><br><span class="line"><span class="keyword">if</span> (WIFEXITED(current_status)) &#123;</span><br><span class="line"><span class="comment">/* Our process exited normally. */</span></span><br><span class="line">PRINT_INFO(<span class="string">&quot;Main child exited normally (with status &#x27;%i&#x27;)&quot;</span>, WEXITSTATUS(current_status));</span><br><span class="line">*child_exitcode_ptr = WEXITSTATUS(current_status);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(current_status)) &#123;</span><br><span class="line"><span class="comment">/* Our process was terminated. Emulate what sh / bash</span></span><br><span class="line"><span class="comment"> * would do, which is to return 128 + signal number.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PRINT_INFO(<span class="string">&quot;Main child exited with signal (with signal &#x27;%s&#x27;)&quot;</span>, strsignal(WTERMSIG(current_status)));</span><br><span class="line">*child_exitcode_ptr = <span class="number">128</span> + WTERMSIG(current_status);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;Main child exited for unknown reason&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Be safe, ensure the status code is indeed between 0 and 255.</span></span><br><span class="line">*child_exitcode_ptr = *child_exitcode_ptr % (STATUS_MAX - STATUS_MIN + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If this exitcode was remapped, then set it to 0.</span></span><br><span class="line">INT32_BITFIELD_CHECK_BOUNDS(expect_status, *child_exitcode_ptr);</span><br><span class="line"><span class="keyword">if</span> (INT32_BITFIELD_TEST(expect_status, *child_exitcode_ptr)) &#123;</span><br><span class="line">*child_exitcode_ptr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (warn_on_reap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">PRINT_WARNING(<span class="string">&quot;Reaped zombie process with pid=%i&quot;</span>, current_pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if other childs have been reaped.</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we make it here, that&#x27;s because we did not continue in the switch case. */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>reap_zombies</code> 函数中，不断利用 <code>waitpid</code> 这个函数来处理进程，在没有子进程等待处理或者遇到其余系统错误时退出循环。</p><p>注意这里 tini 和 dumb-init 的的实现差异，dumb-init 在回收自己的入口子进程后便会自杀。而 tini 将会在所有自己的子进程退出之后，结束循环，然后判断是否自杀。</p><p>那么我们这里来测试一下</p><p>还是 demo2 的例子，我们来测试一下孙进程的例子</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> demo2.py /root/demo2.py</span></span><br><span class="line"><span class="keyword">ENV</span> TINI_VERSION v0.<span class="number">19.0</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://github.com/krallin/tini/releases/download/<span class="variable">$&#123;TINI_VERSION&#125;</span>/tini /tini</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /tini</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;/tini&quot;</span>,<span class="string">&quot;-s&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;--&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/root/demo2.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>然后构建，执行，进程结构如下</p><p><img src="https://user-images.githubusercontent.com/7054676/109397971-b54fb880-7974-11eb-9899-0d71af5ad835.png" alt="demo2-tini 进程结构图"></p><p>然后，老规矩，strace , kill 发 SIGTERM 看一下，</p><p><img src="https://user-images.githubusercontent.com/7054676/109398085-648c8f80-7975-11eb-8b08-21fb0c0399fa.png" alt="strace 2160093"></p><p><img src="https://user-images.githubusercontent.com/7054676/109398094-75d59c00-7975-11eb-8d42-ee062609e152.png" alt="strace 2160094"></p><p><img src="https://user-images.githubusercontent.com/7054676/109398106-871ea880-7975-11eb-94a8-0b25374fa79e.png" alt="strace 2160095"></p><p>嗯，如预期一样，那么 tini 的实现是不是没有问题了呢，我们再来准备一个例子,demo4.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    signal.signal(<span class="number">15</span>, <span class="keyword">lambda</span> _, __: time.sleep(<span class="number">1</span>))</span><br><span class="line">    cpid = os.fork()</span><br><span class="line">time.sleep(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>这里我们用 <code>time.sleep(1)</code> 来模拟，程序接到 SIGTERM 后需要优雅处理，然后我们还是准备下 dockefile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> demo4.py /root/demo4.py</span></span><br><span class="line"><span class="keyword">ENV</span> TINI_VERSION v0.<span class="number">19.0</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://github.com/krallin/tini/releases/download/<span class="variable">$&#123;TINI_VERSION&#125;</span>/tini /tini</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /tini</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;/tini&quot;</span>,<span class="string">&quot;-s&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;--&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/root/demo4.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>然后构建，允许，看进程结构，啪的一下很快啊</p><p><img src="https://user-images.githubusercontent.com/7054676/109398222-83d7ec80-7976-11eb-88e9-4e7231b2c90d.png" alt="demo4 进程结构"></p><p>然后 strace ，发 SIGTERM 一条龙服务，</p><p><img src="https://user-images.githubusercontent.com/7054676/109398244-aa962300-7976-11eb-9c4f-7ca7dbe1b833.png" alt="strace 2173315"></p><p><img src="https://user-images.githubusercontent.com/7054676/109398251-bc77c600-7976-11eb-8b24-d5bb60c1ce96.png" alt="strace 2173316"></p><p><img src="https://user-images.githubusercontent.com/7054676/109398257-cac5e200-7976-11eb-9921-457195ee052c.png" alt="strace 2173317"></p><p>然后我们发现，2173316 和 2173317 这两个进程，成功接收到 SIGTERM 的信号后，在处理中，被 SIGKILL 了。那么这是为甚么呢？实际上这里也存在一个潜在的 race condition</p><p>当我们开启 tini 的使用。2173315 退出后，2173316 将被 re-parent ，</p><p>按照内核的 re-parent 流程，2173317 re-parent 到 tini 进程。</p><p>但是，tini 在使用 <code>waitpid</code> 的时候，使用了 <code>WNOHANG</code> 这个选项，那么这里如果在执行 waitpid 时，子进程还未结束，那么将立刻返回0。从而退出循环，开始自杀流程。</p><p>刺激不刺激，关于这点，我师父和我提了一个 issue: <a href="https://github.com/krallin/tini/issues/180">tini Exits Too Early Leading to Graceful Termination Failure</a></p><p>然后，我也做了一版修复，具体可以参考<a href="https://github.com/Zheaoli/tini/commit/f5286c205d948a6cbb07fa8dca9e763bdb3ebe61">use new threading to run waipid</a>（还在 PoC，没写单测，处理也有点糙）</p><p>实际上思路很简单 ，我们不使用 <code>waitpid</code> 中的 <code>WNOHANG</code> 选项，将其变为阻塞的调用，然后用一个新的线程来做 <code>waitpid</code> 的处理</p><p>构建一版测试效果如下</p><p><img src="https://user-images.githubusercontent.com/7054676/109398735-96075a00-7979-11eb-85e9-f8ab99c3d5f5.png" alt="demo5 进程结构"></p><p><img src="https://user-images.githubusercontent.com/7054676/109398751-b1726500-7979-11eb-8398-0069c4f3a2aa.png" alt="strace 1808102"></p><p><img src="https://user-images.githubusercontent.com/7054676/109398764-c4853500-7979-11eb-981f-a5ea65ae7572.png" alt="strace 1808104"></p><p><img src="https://user-images.githubusercontent.com/7054676/109398777-d666d800-7979-11eb-972a-37cf82e371d4.png" alt="strace 1808105"></p><p>嗯，如预期一样，测试没有问题。</p><p>当然这里实际上可能细心的朋友发现，原本的 tini 也没法处理二进制更新的情况，原因和 demo5 里的原因一致。这里大家可以去测试一下</p><p>实际上这里我的处理很过于粗糙和暴力，我们实际上只要保证让 tini 的退出条件变成<strong>一定要等到 waitpid()=-1 &amp;&amp; errno==EHILD再退出</strong>。具体的实现手段大家可以一起来思考（实际上还不少</p><p>最后来总结一下问题的核心：</p><p>无论是 dumb-init 还是 tini 在现行的实现里，都犯了同一个错误，即在容器这个特殊的场景下，都没有等待所有子孙进程的退出再退出。其实解决方案很简单，退出条件一定要是 <strong>waitpid()=-1 &amp;&amp; errno==EHILD</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文吐槽了 dumb-init 和 tini。dumb—init 实现属实拉跨，tini 的实现细腻了很多。但是 tini 依旧存在不可靠的行为，以及我们所期待的 fork 二进制更新这种使用一号进程的场景在 dumb-init 和 tini 上都没法实现。而且 dumb-init 和 tini 目前也还有一个共通的局限性。即无法处理子进程进程组逃逸的情况。（比如十个子进程各自逃逸到一个进程组中）。</p><p>而且在文中的测试中，我们用 <code>time.sleep(1)</code> 来模拟 Graceful Shutdown 的行为，tini 也已经无法满足需求了。。So。。。。</p><p>所以归根到底一句话，应用的信号，进程回收这些基础行为应该应用自决。任何管杀不管埋而寄托于一号进程的行为，都是对于生产的不负责任。（如果你们实在想要一个一号进程，还是用 tini 吧，千万别用 dumb-init)</p><p>所以 exec 裸起大法好，不用一号进程平安保！</p><p>差不多水文就这样吧，这篇水文从提出问题到验证结论，到 patch PoC 报销了我快一个星期的业余时间（本文初稿在凌晨4点过写完）。最后感谢某川同学和我一起搞了几个凌晨三点过。最后，祝大家看的愉快。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上周的文章聊了关于容器中的一号进程的一些概况后，在我师父某川(可以去 GitHub 找他玩，&lt;a href=&quot;https://github.com/jschwinger23&quot;&gt;jschwinger23&lt;/a&gt;) 的指导与配合下，我们一起对目前主流的被广泛使用的两个容器中一号进程的实现 dumb-init 和 tini 做了一番探究，继续写个水文来爆论一番。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/Linux/"/>
    
    
    <category term="编程" scheme="https://manjusaka.blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/tags/Linux/"/>
    
    <category term="笔记" scheme="https://manjusaka.blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="水文" scheme="https://manjusaka.blog/tags/%E6%B0%B4%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊容器中的一号进程</title>
    <link href="https://manjusaka.blog/posts/2021/02/13/a-simple-introduction-about-the-init-process-in-container/"/>
    <id>https://manjusaka.blog/posts/2021/02/13/a-simple-introduction-about-the-init-process-in-container/</id>
    <published>2021-02-13T09:00:00.000Z</published>
    <updated>2023-06-22T16:36:06.199Z</updated>
    
    <content type="html"><![CDATA[<p>新年了，决定趁着有时间的时候多写几篇技术水文。今天的话，准备来简单聊聊容器中我们每天都会接触，但是时常又会被我们忽略的一号进程</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>容器技术发展到现在，其实形态上已经发生了很大的变化。根据不同的场景，既有传统的 <strong>Docker</strong><a href="#refer-anchor-1"><sup>1</sup></a>, <strong>containterd</strong><a href="#refer-anchor-2"><sup>2</sup></a> 这样传统基于 CGroup + Namespace 的容器形态，也有像 <strong>Kata</strong><a href="#refer-anchor-3"><sup>3</sup></a> 这样基于 VM 的新型的容器形态。本文主要着眼在传统容器中一号进程上。</p><p>我们都知道，传统容器依赖的 CGroup + Namespace 进行资源隔离，本质上来说，还是 OS 内的一个进程。所以在继续往下聊容器相关的内容之前，我们需要先来简单聊聊 Linux 中的进程管理</p><h3 id="Linux-中的进程管理"><a href="#Linux-中的进程管理" class="headerlink" title="Linux 中的进程管理"></a>Linux 中的进程管理</h3><h4 id="简单聊聊进程"><a href="#简单聊聊进程" class="headerlink" title="简单聊聊进程"></a>简单聊聊进程</h4><p>Linux 中的进程实际上是个非常大的话题，如果要展开聊，实际上这个话题可以聊一整本书= =，所以为了时间着想，我们还是把目光聚集在最核心的一部分上面（实际上是因为很多东西我也不懂。</p><p>首先来讲，在内核中利用一个特殊的结构体来维护进程有关的相关信息，比如常见的 PID，进程状态，打开的文件描述符等信息。在内核代码中，这个结构体是 <strong>task_struct</strong><a href="#refer-anchor-4"><sup>4</sup></a>, 其大概结构大家可以看一下下图</p><p><img src="https://user-images.githubusercontent.com/7054676/107845716-b4694380-6e18-11eb-9d19-ebfb9927b1ac.png" alt="task_struct"></p><p>而通常而言，我们会在系统上跑很多个进程。所以内核用一个进程表(实际上 Linux 中管理进程表的有多个数据结构，这里我们用 PID Hash Map 来举例）来维护所有 Process Descriptor 相关的信息，详见下图</p><p><img src="https://user-images.githubusercontent.com/7054676/107845790-30638b80-6e19-11eb-951e-7fdfa86a0234.png" alt="PID Hash Table"></p><p>OK， 这里我们大概了解了进程中的基本结构，现在我们来看我们常见使用进程的一个场景：父子进程。我们都知道，我们有时会在一个进程中，通过 <strong>fork</strong><a href="#refer-anchor-5"><sup>5</sup></a> 这个 sys call 来创建出一个新的进程。通常来说，我们创建的新的进程是当前进程的子进程。那么在内核中怎么表达这种父子关系呢？</p><p>回到刚刚提到 <strong>task_struct</strong>, 在这个结构体中存在这样几个字段来描述父子关系</p><ol><li><p>real_parent：一个 task_struct 指针，指向父进程</p></li><li><p>parent: 一个 task_struct 指针，指向父进程。在大多数情况下，这个字段的值和 <code>real_parent</code> 一致。在有进程对当前进程使用 <strong>ptrace</strong><a href="#refer-anchor-6"><sup>6</sup></a> 等情况的时候，和 <code>real_parent</code> 字段不一致</p></li><li><p>children：list_head, 其指向一个由当前进程所创建的所有子进程的双向链表</p></li></ol><p>这里大家可能还有点抽象的话，给大家一个图就能看清楚了</p><p><img src="https://user-images.githubusercontent.com/7054676/107846739-f8604680-6e20-11eb-939c-f033909570c3.png" alt="Relation Between Process"></p><p>实际上，我们发现，不同进程之间的父子关系，反应到具体的数据结构之上，就形成了一个完整的树形结构（先记住这点，我们稍后会再提到这里）</p><p>到现在为止，我们已经对 Linux 中的进程，有了最简单一个概念，那么接下来，我们会聊聊我们在进程使用中常遇到的两个问题：孤儿进程&amp;&amp;僵尸进程</p><h4 id="孤儿进程-amp-amp-僵尸进程"><a href="#孤儿进程-amp-amp-僵尸进程" class="headerlink" title="孤儿进程 &amp;&amp; 僵尸进程"></a>孤儿进程 &amp;&amp; 僵尸进程</h4><p>首先来聊聊 <strong>僵尸进程</strong> 这个概念。</p><p>如前面所说，我们内核有进程表来维护 Process Descriptor 相关信息。那么在 Linux 的设计中，当一个子进程退出后，将保存自己的进程相关的状态以供父进程使用。而父进程将调用 <strong>waitpid</strong><a href="#refer-anchor-7"><sup>7</sup></a> 来获取子进程状态，并清理相关资源。</p><p>那么如上所说，父进程是有可能需要拿到子进程相关的状态的。那么也就导致为了满足这一设计，内核中的进程表将一直保存相关资源。当僵尸进程多了以后，那么将造成很大的资源浪费。</p><p>首先来看一个简单的僵尸进程的例子 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s child process\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the child process pid is %d\n&quot;</span>, pid);</span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们编译执行这段代码，然后配合 <code>ps</code> 命令查看一下，发现我们的确造了一个 z 进程</p><p><img src="https://user-images.githubusercontent.com/7054676/107847485-0e710580-6e27-11eb-977c-678a7fa4b362.png" alt="Z Process Demo"></p><p>OK 我们再来看一个正确处理子进程退出的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signalfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEVENTS 64</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deletejob</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;delete task %d\n&quot;</span>, pid); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addjob</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;add task %d\n&quot;</span>, pid); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line">  <span class="type">sigset_t</span> mask;</span><br><span class="line">  sigemptyset(&amp;mask);</span><br><span class="line">  sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">  <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;mask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> sfd = signalfd(<span class="number">-1</span>, &amp;mask, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> epoll_fd = epoll_create(MAXEVENTS);</span><br><span class="line">  event.events = EPOLLIN | EPOLLEXCLUSIVE | EPOLLET;</span><br><span class="line">  event.data.fd = sfd;</span><br><span class="line">  <span class="type">int</span> s = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sfd, &amp;event);</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  events = <span class="built_in">calloc</span>(MAXEVENTS, <span class="keyword">sizeof</span>(event));</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> n = epoll_wait(epoll_fd, events, MAXEVENTS, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll EINTR error\n&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINVAL) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll EINVAL error\n&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EFAULT) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll EFAULT error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EBADF) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll EBADF error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) ||</span><br><span class="line">          (!(events[i].events &amp; EPOLLIN))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll err\n&quot;</span>);</span><br><span class="line">        close(events[i].data.fd);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sfd == events[i].data.fd) &#123;</span><br><span class="line">        <span class="keyword">struct</span> signalfd_siginfo si;</span><br><span class="line">        <span class="type">ssize_t</span> res = read(sfd, &amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="keyword">sizeof</span>(si)) &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Something wrong\n&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (si.ssi_signo == SIGCHLD) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Got SIGCHLD\n&quot;</span>);</span><br><span class="line">          <span class="type">int</span> child_pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">          deletejob(child_pid);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">      execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    addjob(pid);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK, 我们现在都知道了，子进程退出后需要由父进程正确的回收相关的资源。那么问题来了，我们父进程先于子进程退出了怎么办。实际上这是一个很常见的场景。比如说大家去用两次 fork 实现守护进程。</p><p>我们常规的认知来说，我们父进程退出后，这个进程所属的所有子进程会进行 re-parent 到当前 PID Namespace 的一号进程上，那么这样的答案是正确的么？对，也不对，我们首先来看一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  <span class="type">int</span> err = prctl(PR_SET_CHILD_SUBREAPER, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s child process1\n&quot;</span>);</span><br><span class="line">      sleep(<span class="number">20</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;the child process pid is %d\n&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sleep(<span class="number">40</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个很典型的两次 fork 创建守护进程的代码（除了我没写 SIGCHLD 处理（逃）。我们来看下这段代码的输出</p><p><img src="https://user-images.githubusercontent.com/7054676/107848258-ebe1eb00-6e2c-11eb-8c72-e4c5915ffa3f.png" alt="Daemon Process Output1"></p><p>我们能看到守护进程的 PID 是 449920</p><p>然后我们执行 <code>ps -efj</code> 和 <code>ps auf</code> 两个命令看一下结果</p><p><img src="https://user-images.githubusercontent.com/7054676/107848296-32cfe080-6e2d-11eb-943f-0efb9975b7ee.png" alt="Daemon Process Output2"></p><p>我们能看到，449920 这个进程在父进程退出后没有 re-parent 到当前空间的一号进程上。这是为什么呢？可能眼尖的同学已经注意到，这段代码中一个特殊的 sys call <strong>prctl</strong><a href="#refer-anchor-8"><sup>8</sup></a>。我们给当前进程设置了 <strong>PR_SET_CHILD_SUBREAPER</strong> 的属性。</p><p>这里我们来看一下内核里的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When we die, we re-parent all our children, and try to:</span></span><br><span class="line"><span class="comment"> * 1. give them to another thread in our thread group, if such a member exists</span></span><br><span class="line"><span class="comment"> * 2. give it to the first ancestor process which prctl&#x27;d itself as a</span></span><br><span class="line"><span class="comment"> *    child_subreaper for its children (like a service manager)</span></span><br><span class="line"><span class="comment"> * 3. give it to the init process (PID 1) in our pid namespace</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_struct *<span class="title function_">find_new_reaper</span><span class="params">(<span class="keyword">struct</span> task_struct *father,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> task_struct *child_reaper)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span>, *<span class="title">reaper</span>;</span></span><br><span class="line"></span><br><span class="line">thread = find_alive_thread(father);</span><br><span class="line"><span class="keyword">if</span> (thread)</span><br><span class="line"><span class="keyword">return</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (father-&gt;signal-&gt;has_child_subreaper) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ns_level = task_pid(father)-&gt;level;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find the first -&gt;is_child_subreaper ancestor in our pid_ns.</span></span><br><span class="line"><span class="comment"> * We can&#x27;t check reaper != child_reaper to ensure we do not</span></span><br><span class="line"><span class="comment"> * cross the namespaces, the exiting parent could be injected</span></span><br><span class="line"><span class="comment"> * by setns() + fork().</span></span><br><span class="line"><span class="comment"> * We check pid-&gt;level, this is slightly more efficient than</span></span><br><span class="line"><span class="comment"> * task_active_pid_ns(reaper) != task_active_pid_ns(father).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (reaper = father-&gt;real_parent;</span><br><span class="line">     task_pid(reaper)-&gt;level == ns_level;</span><br><span class="line">     reaper = reaper-&gt;real_parent) &#123;</span><br><span class="line"><span class="keyword">if</span> (reaper == &amp;init_task)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (!reaper-&gt;signal-&gt;is_child_subreaper)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">thread = find_alive_thread(reaper);</span><br><span class="line"><span class="keyword">if</span> (thread)</span><br><span class="line"><span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> child_reaper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们总结一下，当父进程退出后，所属的子进程，将按照如下顺序进行 re-parent</p><ol><li><p>线程组里其余可用线程（这里的线程有所不一样，可以暂时忽略）</p></li><li><p>在当前所属的进程树上不断寻找设置了 <strong>PR_SET_CHILD_SUBREAPER</strong> 进程</p></li><li><p>在前面两者都无效的情况下，re-parent 到当前 PID Namespace 中的 1 号进程上</p></li></ol><p>到这里，我们关于 Linux 中进程管理的基础介绍就完成了。那么我们将来聊聊容器中的情况</p><h3 id="容器中的一号进程"><a href="#容器中的一号进程" class="headerlink" title="容器中的一号进程"></a>容器中的一号进程</h3><p>这里，我们将利用，Docker 作为背景聊聊这个话题。首先，在 Docker 1.11 之后，其架构发生了比较大的变化，如下图所示</p><p><img src="https://user-images.githubusercontent.com/7054676/107848502-cf46b280-6e2e-11eb-8a69-f9eaf9d155a8.png" alt="Docker Arch since version 1.11"></p><p>那么我们拉起一个容器的的流程如下</p><ol><li><p>Docker Daemon 向 containerd 发送指令</p></li><li><p>containerd 创建一个 containterd-shim 进程</p></li><li><p>containerd-shim 创建一个 runc 进程</p></li><li><p>runc 进程将根据 OCI 标准，设置相关环境（创建 cgroup，创建 ns 等），然后执行 <code>entrypoint</code> 中的设定的命令</p></li><li><p>runc 在执行完相关设置后，将自我退出，此时其子进程（即容器命名空间内的1号进程）将被 re-parent 给 containerd-shim 进程。</p></li></ol><p>OK，上面 step 5 操作，就需要依赖我们上节中讲到的 <strong>prctl</strong> 和 <strong>PR_SET_CHILD_SUBREAPER</strong> 。</p><p>自此，containerd-shim 将承担容器内进程相关的操作，即便其父进程退出，子进程也会根据 re-parent 的流程托管到 containerd-shim 进程上。</p><p>那么，这样是不是就没有问题了呢？</p><p>答案很明显不是。来给大家举一个实际上的场景：假设我一个服务需要实现一个需求叫做优雅下线。通常而言，我们会在暴力杀死进程之前，利用 SIGTERM 信号实现这个功能。但是在容器时期有个问题，我们一号进程，可能不是程序本身（比如大家习惯性的会考虑在 entrypoint 中用 bash 去裹一层），或者经过一些特殊场景，容器中的进程，全部已经托管在 containerd-shim 上了。而 contaninerd-shim 是不具备信号转发的能力的。</p><p>所以在这样一些场景下，我们就需要考虑额外引入一些组件来完成我们的需求。这里以一个非常轻量级的专门针对容器的设计的一号进程项目 <strong>tini</strong><a href="#refer-anchor-9"><sup>9</sup></a> 来作为介绍</p><p>我们这里看一下核心的一些代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_subreaper</span> <span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (subreaper &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (prctl(PR_SET_CHILD_SUBREAPER, <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINVAL) &#123;</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;PR_SET_CHILD_SUBREAPER is unavailable on this platform. Are you using Linux &gt;= 3.4?&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;Failed to register as child subreaper: %s&quot;</span>, strerror(errno))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">PRINT_TRACE(<span class="string">&quot;Registered as child subreaper&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">wait_and_forward_signal</span><span class="params">(<span class="type">sigset_t</span> <span class="type">const</span>* <span class="type">const</span> parent_sigset_ptr, <span class="type">pid_t</span> <span class="type">const</span> child_pid)</span> &#123;</span><br><span class="line"><span class="type">siginfo_t</span> sig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigtimedwait(parent_sigset_ptr, &amp;sig, &amp;ts) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (errno) &#123;</span><br><span class="line"><span class="keyword">case</span> EAGAIN:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EINTR:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;Unexpected error in sigtimedwait: &#x27;%s&#x27;&quot;</span>, strerror(errno));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* There is a signal to handle here */</span></span><br><span class="line"><span class="keyword">switch</span> (sig.si_signo) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGCHLD:</span><br><span class="line"><span class="comment">/* Special-cased, as we don&#x27;t forward SIGCHLD. Instead, we&#x27;ll</span></span><br><span class="line"><span class="comment"> * fallthrough to reaping processes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PRINT_DEBUG(<span class="string">&quot;Received SIGCHLD&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">PRINT_DEBUG(<span class="string">&quot;Passing signal: &#x27;%s&#x27;&quot;</span>, strsignal(sig.si_signo));</span><br><span class="line"><span class="comment">/* Forward anything else */</span></span><br><span class="line"><span class="keyword">if</span> (kill(kill_process_group ? -child_pid : child_pid, sig.si_signo)) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == ESRCH) &#123;</span><br><span class="line">PRINT_WARNING(<span class="string">&quot;Child was dead when forwarding signal&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;Unexpected error when forwarding signal: &#x27;%s&#x27;&quot;</span>, strerror(errno));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们能很清楚看到两个核心点</p><ol><li><p>tini 会通过 <strong>prctl</strong> 和 <strong>PR_SET_CHILD_SUBREAPER</strong> 来接管容器内的孤儿进程</p></li><li><p>tini 在收到信号后，会将信号转发给子进程或者是所属的子进程组</p></li></ol><p>当然其实 tini 本身也有一些小问题（不过比较冷门）这里留一个讨论题：假设我们有这样一个服务，在创建10个守护进程后自己退出。在这十个守护进程中，我们都会设置一个全新的进程组 ID （所谓进程组逃逸）。那么我们怎么样将信号转发到这十个进程上（仅供讨论，生产上这么干的人早被打死了）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可能看到这里，可能有人要喷我不讲武德，说好的容器内一号进程，但是花了大半篇幅来讲 Linux 进程233333.</p><p>实际上传统容器基本可以认为是在 OS 中执行的一个完整进程。讨论容器中的一号进程离不开讨论 Linux 中进程管理的相关知识点。</p><p>希望通过这篇技术水文能帮大家对容器中一号进程有个大概的认知，并能正确的使用和管理他。</p><p>最后祝大家新年快乐！（希望新年我能不以写水文为生，呜呜呜呜）</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="refer-anchor-1"></div><ul><li>[1]. <a href="https://www.docker.com/">Docker</a></li></ul><div id="refer-anchor-2"></div><ul><li>[2]. <a href="https://containerd.io/">containerd</a></li></ul><div id="refer-anchor-3"></div><ul><li>[3]. <a href="https://katacontainers.io/">kata</a></li></ul><div id="refer-anchor-4"></div><ul><li>[4]. <a href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h#L649">task_struct</a></li></ul><div id="refer-anchor-5"></div><ul><li>[5]. <a href="https://man7.org/linux/man-pages/man2/fork.2.html">Linux Man Page: fork</a></li></ul><div id="refer-anchor-6"></div><ul><li>[6]. <a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">Linux Man Page: ptrace</a></li></ul><div id="refer-anchor-7"></div><ul><li>[7]. <a href="https://linux.die.net/man/2/waitpid">Linux man page: waitpid</a></li></ul><div id="refer-anchor-8"></div><ul><li>[8]. <a href="https://man7.org/linux/man-pages/man2/prctl.2.html">Linux man page: prctl</a></li></ul><div id="refer-anchor-9"></div><ul><li>[9]. <a href="https://github.com/krallin/tini">tini</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;新年了，决定趁着有时间的时候多写几篇技术水文。今天的话，准备来简单聊聊容器中我们每天都会接触，但是时常又会被我们忽略的一号进程&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/categories/%E7%BC%96%E7%A8%8B/Linux/"/>
    
    
    <category term="编程" scheme="https://manjusaka.blog/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Linux" scheme="https://manjusaka.blog/tags/Linux/"/>
    
    <category term="笔记" scheme="https://manjusaka.blog/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="水文" scheme="https://manjusaka.blog/tags/%E6%B0%B4%E6%96%87/"/>
    
  </entry>
  
</feed>
