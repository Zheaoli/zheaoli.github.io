<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于 CPU Burst 在 K8s 中的一些设计想法</title>
      <link href="//posts/2023/08/26/a-little-bit-design-about-cpu-burst-in-k8s/"/>
      <url>//posts/2023/08/26/a-little-bit-design-about-cpu-burst-in-k8s/</url>
      
        <content type="html"><![CDATA[<p>深夜看群友聊的焦虑，起来写个水文压压惊</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>写这篇文章的原因是之前给 runc 提的 CPU Burst 支持的 PR <a href="https://github.com/opencontainers/runc/pull/3749">[Carry #3205] libct/cg: add CFS bandwidth burst for CPU</a> 终于开始有了新的动静了，这次换了一个国人的 reviewer，感觉要是运气好能在9月开始合并这个 PR。</p><p>如果这个 PR 被合并了，那么在 containerd/nerdctl 等其余项目上支持 CPU Burst 的工作就可以开始了。所以这篇文章就是想记录下我对于 CPU Burst 在 Kubernetes 内实现的一些想法，差不多可以当作自己写正式的 KEP(Kubernetes Enhancement Proposal) 草稿</p><p>主要分为两个部分来聊一下</p><ol><li>CPU Burst 的一些背景</li><li>目前 Kubernetes 对于 CPU 资源切分的设计概要</li><li>CPU Burst 在 Kubernetes 中的一些设计想法</li></ol><h3 id="CPU-Burst-的一些背景"><a href="#CPU-Burst-的一些背景" class="headerlink" title="CPU Burst 的一些背景"></a>CPU Burst 的一些背景</h3><p>聊 CPU Burst 之前必须要先聊一下 Linux 里面关于 CGroup 的一些背景知识</p><p>提到 CPU 限制，本质上是限制进程的 CPU 使用的时间片，在 Linux 下，进程存在三种调度优先级</p><ol><li>SCHED_NORMAL</li><li>SCHED_FIFO</li><li>SCHED_RR</li></ol><p>1 用的是 Linux 中 CFS 调度器，而常见普通进程都是 SCHED_NORMAL 。OK 前提知识带过</p><p>说回容器中的 CPU 限制，目前主流语境下，容器特指以基于 CGroup 的容器方案为代表的一系列的基于 Linux 中 CGroup 和 Namespace 进行隔离的技术方案。那么在这个语境下，CPU 限制的实现利用了Linux CGroup 中三个 CPU Subsystem。我们主要关心的如下四个参数</p><ol><li>cpu.cfs_period_us</li><li>cpu.cfs_quota_us</li><li>cpu.shares</li><li>cpuset.cpus</li></ol><p>现在分别来聊一下</p><p>首先说 cpu.shares，在基于 CGroup 的容器方案中的使用参数是 —cpu-shares，本质上是一个下限的软限制，用来设定 CPU 的利用率权重。默认值是 1024。这里对于相对值可能理解有点抽象。那么我们来看个例子 假如一个 1core 的主机运行 3 个 container，其中一个 cpu-shares 设置为 1024，而其它 cpu-shares 被设置成 512。当 3 个容器中的进程尝试使用 100% CPU 的时候（因为 cpu.shares 针对的是下限，只有使用 100% CPU 很重要，此时才可以体现设置值），则设置 1024 的容器会占用 50% 的 CPU 时间。那再举个例子，之前这个场景，其余的两个容器如果都没有太多任务，那么空余出来的 CPU 时间，是可以继续被第一个 1024 的容器继续使用的</p><p>接下来聊一下 cpu.cfs_quota_us 和 cpu.cfs_period_us ，这两个是需要组合使用才能生效，本质上含义是在 cpu.cfs_period_us 的单位时间内，进程最多可以利用 cpu.cfs_quota_us （单位都是 us），如果 quota 耗尽，那么进程会被内核 throttle 。在基于 CGroup 的容器方案下，你可以利用 —cpu-period 和 —cpu-quota 这两个值分别进行设置。也可以通过 —cpu 来进行设置，当我们设置 —cpu 为 2 的时候，容器会保证 cpu.cfs_quota_us 两倍于 cpu.cfs_period_us，剩下的就以此类推了（Docker 默认的 cpu.cfs_period_us 的阈值是 100ms 即 10000us）</p><p>在这种模式下，CPU 的时间片按照时间维度基于 period 进行切分，那么在我们实际的生产应用中，我们将会遇到这样的情况，突然来了一波流量/一个任务，进程消耗完了所有的 quota 后，那么将会进入 throttle 的状态。这会导致我们整个响应的 P99 出现很大的毛刺。</p><p>CPU Burst 这个特性就是为了解决这个问题而生，它的原理是在已有的语义基础上，新增一个参数 cpu.cfs_burst_us （在 CGroup V2 中 cpu.max.burst），即进程可以在 CPU 利用率比较低的空闲时段积累一定的 credit，然后在密集使用的时候换取一定的 buffer，实现更少的 throttle 和更高的 CPU 利用率（当然这个特性还暂时没有被主流容器所完全支持）</p><p>这里可能有人会问，这样不会导致 CPU 限制失效吗？虽然本文不会讨论 burst 的实现（可以单开一篇文章聊），但是可以先给一个结论，目前来看，暂时从数学的角度上利用 WECT(Worst-case Execution Time) 没法给出一个证明说 CPU Burst 是完全可靠的，但是根据已有的测试结果来看，在 CGroup 数量比较多 &amp; CPU 利用率整体不高的情况下，边界是收敛的，具体可以参见相关的讨论<a href="#refer-anchor-1"><sup>1</sup></a></p><p>OK，关于 CPU Burst 的背景先聊到这里</p><h3 id="Kubernetes-对于-CPU-资源切分的设计概要"><a href="#Kubernetes-对于-CPU-资源切分的设计概要" class="headerlink" title="Kubernetes 对于 CPU 资源切分的设计概要"></a>Kubernetes 对于 CPU 资源切分的设计概要</h3><p>聊完 CPU Burst 的背景，我们需要来聊一下 Kubernetes 对于 CPU 资源怎么做的分割</p><p>首先我们起手一段祖传 YAML</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">50m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">50Mi</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">100Mi</span></span><br></pre></td></tr></table></figure><p>抛去内存的部分，我们先讨论 CPU 的部分，这个地方很容易理解，我这个 Pod 需要百分之5核的 CPU，最多允许使用10%核的 CPU。</p><p>然后在这里，m 是指千分之一核，也就是说 1000m = 1核，那么这里的 50m 就是 5% 核，100m 就是 10% 核。OK 接着往下聊</p><p>首先对于我们 requests 部分，Kubernetes 在调度的时候，会利用我们之前提到的 cpu.shares 来设置</p><p>而对于我们 limits 的部分，Kubernetes 在调度的时候，会利用我们之前提到的 cpu.cfs_quota_us 和 cpu.cfs_period_us 来设置，在 Kubernetes 中，cpu.cfs_period_us 的默认值是 100ms 即 10000us，那么在我们的例子中，cpu.cfs_quota_us 的值就是 100ms * 10% = 10ms。</p><p>OK，大家可能都比较熟悉 Kubernetes 里面的资源的一些基础概念了。那么我们接着回到本文的正题部分：如何在 Kubernetes 中实现 CPU Burst</p><h3 id="如何在-Kubernetes-中实现-CPU-Burst"><a href="#如何在-Kubernetes-中实现-CPU-Burst" class="headerlink" title="如何在 Kubernetes 中实现 CPU Burst"></a>如何在 Kubernetes 中实现 CPU Burst</h3><p>在 Kubernetes 中实现 CPU Burst 核心的两个问题</p><ol><li>语义怎么设计</li><li>我怕们节点可能是混部的，换句话说内核版本不一定大于 5.14</li></ol><p>这个地方我会考虑三种方案</p><ol><li>在 resources 中新增字段</li><li>通过 annotation 以及 CRD 来实现</li><li>通过 kubelet config 来实现</li></ol><p>在聊这三种方案之前，社区其实已经有了一些实现，也是阿里做的，我们先来看一下阿里的实现</p><h4 id="koordinator-中-CPU-Burst-的实现"><a href="#koordinator-中-CPU-Burst-的实现" class="headerlink" title="koordinator 中 CPU Burst 的实现"></a>koordinator 中 CPU Burst 的实现</h4><p>首先我们来看一下阿里的实现，这个实现是在 koordinator 中实现的，具体的实现可以参见<a href="#refer-anchor-2"><sup>2</sup></a></p><p>他们通过 CRD/configmap/annotation 多种方式都可以实现对于 Burst 的支持，比如看一个例子</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">apache-demo</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">koordinator.sh/cpuBurst:</span> <span class="string">&#x27;&#123;&quot;policy&quot;: &quot;auto&quot;&#125;&#x27;</span>   <span class="comment"># 增加了Cpu Burst策略的开关。</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">httpd</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-D</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FOREGROUND</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry.cn-zhangjiakou.aliyuncs.com/acs/apache-2-4-51-for-slo-test:v0.1</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">apache</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;4&quot;</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">10Gi</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;4&quot;</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">10Gi</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">$nodeName</span> <span class="comment"># 注意修改模板中指定节点的nodeName。</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">False</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br></pre></td></tr></table></figure><p>那么问题来了，现在 Kubernetes 中还不支持 burst，那么怎么做的呢，我们直接看下他们核心代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *cpuBurst)</span></span> applyContainerCFSQuota(podMeta *statesinformer.PodMeta, containerStat *corev1.ContainerStatus,</span><br><span class="line">curContaienrCFS, deltaContainerCFS <span class="type">int64</span>) <span class="type">error</span> &#123;</span><br><span class="line">podDir := podMeta.CgroupDir</span><br><span class="line">curPodCFS, podPathErr := b.cgroupReader.ReadCPUQuota(podDir)</span><br><span class="line"><span class="keyword">if</span> podPathErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;get pod %v/%v current cfs quota failed, error: %v&quot;</span>,</span><br><span class="line">podMeta.Pod.Namespace, podMeta.Pod.Name, podPathErr)</span><br><span class="line">&#125;</span><br><span class="line">containerDir, containerPathErr := koordletutil.GetContainerCgroupParentDir(podMeta.CgroupDir, containerStat)</span><br><span class="line"><span class="keyword">if</span> containerPathErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;get container %v/%v/%v cgroup path failed, error: %v&quot;</span>,</span><br><span class="line">podMeta.Pod.Namespace, podMeta.Pod.Name, containerStat.Name, containerPathErr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updatePodCFSQuota := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// no need to adjust pod cpu.cfs_quota if it is already -1</span></span><br><span class="line"><span class="keyword">if</span> curPodCFS &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">targetPodCFS := curPodCFS + deltaContainerCFS</span><br><span class="line">podCFSValStr := strconv.FormatInt(targetPodCFS, <span class="number">10</span>)</span><br><span class="line">eventHelper := audit.V(<span class="number">3</span>).Pod(podMeta.Pod.Namespace, podMeta.Pod.Name).Reason(<span class="string">&quot;CFSQuotaBurst&quot;</span>).Message(<span class="string">&quot;update pod CFSQuota: %v&quot;</span>, podCFSValStr)</span><br><span class="line">updater, _ := resourceexecutor.DefaultCgroupUpdaterFactory.New(system.CPUCFSQuotaName, podDir, podCFSValStr, eventHelper)</span><br><span class="line"><span class="keyword">if</span> _, err := b.executor.Update(<span class="literal">true</span>, updater); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;update pod cgroup %v failed, error %v&quot;</span>, podMeta.CgroupDir, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateContainerCFSQuota := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">targetContainerCFS := curContaienrCFS + deltaContainerCFS</span><br><span class="line">containerCFSValStr := strconv.FormatInt(targetContainerCFS, <span class="number">10</span>)</span><br><span class="line">eventHelper := audit.V(<span class="number">3</span>).Container(containerStat.Name).Reason(<span class="string">&quot;CFSQuotaBurst&quot;</span>).Message(<span class="string">&quot;update container CFSQuota: %v&quot;</span>, containerCFSValStr)</span><br><span class="line">updater, _ := resourceexecutor.DefaultCgroupUpdaterFactory.New(system.CPUCFSQuotaName, containerDir, containerCFSValStr, eventHelper)</span><br><span class="line"><span class="keyword">if</span> _, err := b.executor.Update(<span class="literal">true</span>, updater); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;update container cgroup %v failed, reason %v&quot;</span>, containerDir, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cfs scale down, order: container-&gt;pod</span></span><br><span class="line">sortOfUpdateQuota := []<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span>&#123;updateContainerCFSQuota, updatePodCFSQuota&#125;</span><br><span class="line"><span class="keyword">if</span> deltaContainerCFS &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// cfs scale up, order: pod-&gt;container</span></span><br><span class="line">sortOfUpdateQuota = []<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span>&#123;updatePodCFSQuota, updateContainerCFSQuota&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, update := <span class="keyword">range</span> sortOfUpdateQuota &#123;</span><br><span class="line"><span class="keyword">if</span> err := update(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set cpu.cfs_burst_us for containers</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *cpuBurst)</span></span> applyCPUBurst(burstCfg *slov1alpha1.CPUBurstConfig, podMeta *statesinformer.PodMeta) &#123;</span><br><span class="line">pod := podMeta.Pod</span><br><span class="line">containerMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*corev1.Container)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pod.Spec.Containers &#123;</span><br><span class="line">container := &amp;pod.Spec.Containers[i]</span><br><span class="line">containerMap[container.Name] = container</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">podCFSBurstVal := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pod.Status.ContainerStatuses &#123;</span><br><span class="line">containerStat := &amp;pod.Status.ContainerStatuses[i]</span><br><span class="line">container, exist := containerMap[containerStat.Name]</span><br><span class="line"><span class="keyword">if</span> !exist || container == <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Warningf(<span class="string">&quot;container %s/%s/%s not found in pod spec&quot;</span>, pod.Namespace, pod.Name, containerStat.Name)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> containerStat.ContainerID == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">&quot;container %s/%s/%s got empty id, skip since it may not start&quot;</span>,</span><br><span class="line">pod.Namespace, pod.Name, containerStat.Name)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">containerCFSBurstVal := calcStaticCPUBurstVal(container, burstCfg)</span><br><span class="line">containerDir, burstPathErr := koordletutil.GetContainerCgroupParentDir(podMeta.CgroupDir, containerStat)</span><br><span class="line"><span class="keyword">if</span> burstPathErr != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.Warningf(<span class="string">&quot;get container dir %s/%s/%s failed, dir %v, error %v&quot;</span>,</span><br><span class="line">pod.Namespace, pod.Name, containerStat.Name, containerDir, burstPathErr)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">podCFSBurstVal += containerCFSBurstVal</span><br><span class="line">containerCFSBurstValStr := strconv.FormatInt(containerCFSBurstVal, <span class="number">10</span>)</span><br><span class="line">eventHelper := audit.V(<span class="number">3</span>).Container(containerStat.Name).Reason(<span class="string">&quot;CPUBurst&quot;</span>).Message(<span class="string">&quot;update container CPUBurst: %v&quot;</span>, containerCFSBurstValStr)</span><br><span class="line">updater, err := resourceexecutor.DefaultCgroupUpdaterFactory.New(system.CPUBurstName, containerDir, containerCFSBurstValStr, eventHelper)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// normally cpu burst resource not supported on current system</span></span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">&quot;get cpu burst updater for container %s/%s/%s failed, maybe system unsupported, err: %v&quot;</span>,</span><br><span class="line">pod.Namespace, pod.Name, containerStat.Name, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">updated, err := b.executor.Update(<span class="literal">true</span>, updater)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; system.IsResourceUnsupportedErr(err) &#123;</span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">&quot;update container %v/%v/%v cpu burst failed, cfs burst not supported, dir %v, info %v&quot;</span>,</span><br><span class="line">pod.Namespace, pod.Name, containerStat.Name, containerDir, err)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;update container %v/%v/%v cpu burst failed, dir %v, updated %v, err %v&quot;</span>,</span><br><span class="line">pod.Namespace, pod.Name, containerStat.Name, containerDir, updated, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">metrics.RecordContainerScaledCFSBurstUS(pod.Namespace, pod.Name, containerStat.ContainerID, containerStat.Name, <span class="type">float64</span>(containerCFSBurstVal))</span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">&quot;apply container %v/%v/%v cpu burst value successfully, dir %v, value %v&quot;</span>,</span><br><span class="line">pod.Namespace, pod.Name, containerStat.Name, containerDir, containerCFSBurstVal)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// end for containers</span></span><br><span class="line"></span><br><span class="line">podDir := podMeta.CgroupDir</span><br><span class="line">podCFSBurstValStr := strconv.FormatInt(podCFSBurstVal, <span class="number">10</span>)</span><br><span class="line">eventHelper := audit.V(<span class="number">3</span>).Pod(podMeta.Pod.Namespace, podMeta.Pod.Name).Reason(<span class="string">&quot;CPUBurst&quot;</span>).Message(<span class="string">&quot;update pod CFSQuota: %v&quot;</span>, podCFSBurstValStr)</span><br><span class="line">updater, err := resourceexecutor.DefaultCgroupUpdaterFactory.New(system.CPUBurstName, podDir, podCFSBurstValStr, eventHelper)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123; <span class="comment">// normally cpu burst resource not supported on current system</span></span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">&quot;get cpu burst updater for pod %s/%s failed, maybe system unsupported, err: %v&quot;</span>,</span><br><span class="line">pod.Namespace, pod.Name, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">updated, err := b.executor.Update(<span class="literal">true</span>, updater)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; system.IsResourceUnsupportedErr(err) &#123;</span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">&quot;update pod %v/%v cpu burst failed, cfs burst not supported, dir %v, info %v&quot;</span>,</span><br><span class="line">pod.Namespace, pod.Name, podDir, err)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">klog.V(<span class="number">4</span>).Infof(<span class="string">&quot;update pod %v/%v cpu burst failed, dir %v, updated %v, err %v&quot;</span>,</span><br><span class="line">pod.Namespace, pod.Name, podDir, updated, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">klog.V(<span class="number">5</span>).Infof(<span class="string">&quot;apply pod %v/%v cpu burst value successfully, dir %v, value %v&quot;</span>,</span><br><span class="line">pod.Namespace, pod.Name, podDir, podCFSBurstValStr)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段逻辑其实很简单，他们的做法很暴力，直接将 koordinator 跑了 daemon，直接更新了 CGroup 的值，然后通过 CRD/configmap/annotation 来控制是否开启 CPU Burst。同时对于低版本的内核，通过调整 period 和 quota 来实现类似 burst 的效果。。</p><p>不得不说，的确是实现了目标，但是缺点也很明显，实际上是破坏了 Kubernetes 对于资源的调度。路子很野。</p><p>那么我们接下来来聊聊我们的几种实现的思路</p><h4 id="在-kubelet-config-中新增配置来实现"><a href="#在-kubelet-config-中新增配置来实现" class="headerlink" title="在 kubelet config 中新增配置来实现"></a>在 kubelet config 中新增配置来实现</h4><p>首先大家肯定清楚，在 Kubelet 中存在两种 CPU Manager Policy</p><ol><li>None</li><li>Static</li></ol><p>后者对于 Guaranteed 类型 QoS 的 Pod 可以进行绑核操作，我们可以通过在 Node 打上 Label ，然后利用 NodeSelector 和亲和反亲和之类的工具来完成 Pod 的调度</p><p>那么同理，我们可以类似在 Kubernetes 中新增一个 CPU Manager Policy 的策略，叫作 Burst，然后新增一个配置字段 BurstQuotaPercentage。这个字段决定了我们为 Burstable 类型的 Pod，新增 BurstQuotaPercentage * cpu.cfs_quota_us 的 cpu.cfs_burst_us 的时间。</p><p>这样的好处有这样几个</p><ol><li>语义清晰，和 Kubelet 的 CPU Manager Policy 保持了一致</li><li>实现相对简单，而且对于混合节点（多版本内核，多 containerd 版本）支持较好（可以在启动时候进行检查，如果不支持，就不启动这个策略）</li></ol><p>但是缺点也很明显</p><ol><li>和 Static 的策略一样，使用起来并不方便，需要用户自己去做 NodeSelector 的调度，实际上是破坏了一部分 Kubernetes 对于底层细节的封装</li></ol><h4 id="在-resources-中新增字段来实现"><a href="#在-resources-中新增字段来实现" class="headerlink" title="在 resources 中新增字段来实现"></a>在 resources 中新增字段来实现</h4><p>这个方案核心在于调整 Resources 的语义，使其可以使用这样的方式来实现 CPU Burst</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">50m</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">50Mi</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">        <span class="attr">cpuBurst:</span> <span class="number">20</span><span class="string">%</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">100Mi</span></span><br></pre></td></tr></table></figure><p>这个方案的好处有这样几个</p><ol><li>使用起来足够简单，非常清晰明了</li><li>调度粒度够细</li></ol><p>但是缺点也很明显</p><ol><li>语义上的不对称，因为 CPUBurst 是对于 limits 的限制，而不是 requests 的限制，那么这实际上破坏了现有语义的对称性。</li><li>调度上存在一个歧义：对于混合部署的场景，如果内核或者 containerd 版本不支持的话，那么我们这个 Pod 是放弃 Burst 还是调度失败？同时我们的调度器是否应该去感知底层内核和 CPU 版本？这又会带来一个抽象泄漏的问题、</li><li>只支持 Pod 级别的 Burst 太细了</li></ol><h4 id="通过-annotation-以及-CRD-来实现"><a href="#通过-annotation-以及-CRD-来实现" class="headerlink" title="通过 annotation 以及 CRD 来实现"></a>通过 annotation 以及 CRD 来实现</h4><p>实际上类似于阿里已有的方案，我们已知 Kubernetes 存在一个 PodDistruptionBudget 的 CRD</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodDisruptionBudget</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zk-pdb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">minAvailable:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">zookeeper</span></span><br></pre></td></tr></table></figure><p>那么我们实际上也可以设计一个类似的 CPUBurstConfig 的 CRD 来实现</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">policy/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CPUBurstConfig</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zk-pdb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">QuotaPercentage:</span> <span class="number">20</span><span class="string">%</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">zookeeper</span></span><br></pre></td></tr></table></figure><p>同时我们也支持通过 annotation 来进行配置（因为 namespace crd 最终会转化为 Pod 上的 annotation）</p><p>那么这样的方案很明显</p><ol><li>规避了 resources 方案带来的语义不对称问题</li><li>我们既可以实现 namespace 级别的多种 Burst 策略，也可以基于 Pod annotation 来实现更细粒度的配置</li></ol><p>但是缺点很明显，和 resources 方案差不多，会带来一个抽象泄漏的问题</p><ol><li>我们的调度器是否应该去感知底层内核和 CPU 版本？</li><li>我们 kubelet 是否应该去读取 Pod 的 annotation 来进行操作？</li></ol><p>差不多就这些吧</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇水文差不多就到这里了，算是对于我自己想做的一个 KEP 的一些设计思考吧。不过有一说一，各种 tradeoff 实在太难做了。属实麻了。差不多就这样吧。改天有空再水点其余的文章吧。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="refer-anchor-1"></div><ul><li>[1]. <a href="https://lore.kernel.org/lkml/5371BD36-55AE-4F71-B9D7-B86DC32E3D2B@linux.alibaba.com/">https://lore.kernel.org/lkml/5371BD36-55AE-4F71-B9D7-B86DC32E3D2B@linux.alibaba.com/</a></li></ul><div id="refer-anchor-2"></div><ul><li>[2]. <a href="https://github.com/koordinator-sh/koordinator">https://github.com/koordinator-sh/koordinator</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 水文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于用户态栈回溯（Unwind）的一些杂记和想法</title>
      <link href="//posts/2023/08/22/a-little-bit-idea-about-unwind/"/>
      <url>//posts/2023/08/22/a-little-bit-idea-about-unwind/</url>
      
        <content type="html"><![CDATA[<p>随手记录一些关于用户态栈回溯（Unwind）的一些杂记和想法。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>昨晚三点过刚吃完药躺在床上休息的时候，突然想到了 @yihong0618 的之前在群里的一个想法</p><blockquote><p>我在想 eBPF 能不能 trace libpq 的协议，好像还没有人做过</p></blockquote><p>我最开始的一个想法是</p><blockquote><p>现在主流做法还是 ptrace 系的东西（gdb 那套），你要用 eBPF 去 trace libpq 肯定没问题，就和 Grey 用 uprobe 去 trace go 一样，手算 cast。但是这里另外一个问题是 libpq 的符号信息不一定够。我倾向你可以这样试一下，你改一下 libpq 源码，关键地方走 USDT（我看你之前用过）</p></blockquote><p>不过后续我师父出来有了一个提醒</p><blockquote><p>如果目标是 trace libpq.so 的调用情况，那应该目前就可以做到。<br>.so 相比 executable 有几个优势：</p><ol><li>它一定有动态符号表</li><li>它一定有 .eh_frame<br>uprobe 恰好又是 attach to the binary offset 而不是 process address，所以第一个优势完美匹配 uprobe，甚至绕开了 executable 本身如果是 PIE 的复杂情况。<br>栈回溯则完美利用了第二个优势。举例来说，默认的 libc.so 里的函数都是 -fomit-frame-pointer 所以不能用 bp = *bp 来回溯，但是可以用 FDE (Frame Description Entry) 来回溯。DWARF 的 .debug_frame 和 .so 的 .eh_frame 就包含了这样的信息，所以足够让我们从 .so 回溯回 executable。<br>所以目前的基建已经完全足够做一个 libpq.so 的 bpf tracer，而不需要任何前提假设。</li></ol></blockquote><p>的确是。。LSB 规定的信息足够多，我之前忽略了这点。一般发行版都是带了 .eh_frame, 里面的 CFI 是可以做栈回溯的，而且我看了下 PG 默认的编译是没开 no-asynchronous-unwind-tables 的，基本上可以确保一定会带这 eh_frame。（注：这个选项用来控制是否生成 .eh_frame）</p><p>所以说做就做，爬起来想先做一个 PoC。先去 Review 了一下手上的工具，发现可能 systemtap 是比较适合的工具，他内部已经实现了一套 DWARF，符号表相关信息解析的功能，所以可以直接复用，先写了一个 Demo 的 PG 代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libpq-fe.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_exit</span><span class="params">(PGconn *conn)</span> &#123;</span><br><span class="line">    PQfinish(conn);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demo2</span><span class="params">()</span> &#123;</span><br><span class="line">    PGconn *conn = PQconnectdb(<span class="string">&quot;host=127.0.0.1 user=postgres password=example&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PQstatus(conn) == CONNECTION_BAD) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Connection to database failed: %s\n&quot;</span>, PQerrorMessage(conn));</span><br><span class="line">        do_exit(conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PGresult *res = PQexec(conn, <span class="string">&quot;SELECT VERSION()&quot;</span>);    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PQresultStatus(res) != PGRES_TUPLES_OK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No data retrieved\n&quot;</span>);        </span><br><span class="line">        PQclear(res);</span><br><span class="line">        do_exit(conn);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, PQgetvalue(res, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    PQclear(res);</span><br><span class="line">    PQfinish(conn);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demo1</span><span class="params">()</span> &#123;</span><br><span class="line">    demo2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    demo1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后起起 systemtap 写个钩子</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">probe process(&quot;/lib64/libpq.so&quot;).function(&quot;PQconnectdb&quot;) &#123;</span><br><span class="line">    print_ubacktrace()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe process(&quot;/lib64/libpq.so&quot;).function(&quot;PQexec&quot;) &#123;</span><br><span class="line">    print_ubacktrace()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe process(&quot;/lib64/libpq.so&quot;).function(&quot;PQresultStatus&quot;) &#123;</span><br><span class="line">    print_ubacktrace()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe process(&quot;/lib64/libpq.so&quot;).function(&quot;PQclear&quot;) &#123;</span><br><span class="line">    print_ubacktrace()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">probe process(&quot;/lib64/libpq.so&quot;).function(&quot;PQfinish&quot;) &#123;</span><br><span class="line">    print_ubacktrace()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效果是这样</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">probe process(&quot;/lib64/libpq.so&quot;).function(&quot;PQconnectdb&quot;) &#123;</span><br><span class="line">    print_ubacktrace()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe process(&quot;/lib64/libpq.so&quot;).function(&quot;PQexec&quot;) &#123;</span><br><span class="line">    print_ubacktrace()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe process(&quot;/lib64/libpq.so&quot;).function(&quot;PQresultStatus&quot;) &#123;</span><br><span class="line">    print_ubacktrace()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe process(&quot;/lib64/libpq.so&quot;).function(&quot;PQclear&quot;) &#123;</span><br><span class="line">    print_ubacktrace()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">probe process(&quot;/lib64/libpq.so&quot;).function(&quot;PQfinish&quot;) &#123;</span><br><span class="line">    print_ubacktrace()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没什么问题，心满意足的准备去睡觉</p><p>起来后顺便复习了一些用户态栈回溯的细节</p><h2 id="一些杂记"><a href="#一些杂记" class="headerlink" title="一些杂记"></a>一些杂记</h2><p>用户态栈回溯核心的一个要解决的点就是增强程序的可追踪性。</p><p>在传统 X86 模式下，我们有这样的栈帧结构</p><p><img src="https://github.com/Zheaoli/zheaoli.github.io/assets/7054676/a1015149-4160-4f3c-b2da-dab8ff4ad2a4" alt="X86 栈帧"></p><p>大体概括就是利用 ebp 寄存器保存栈帧地址，esp 保存栈顶指针，在调用过程里，将上一个栈帧地址入栈保存</p><p>在这种情况下，我们不管是调试器还是其他的工具，都可以通过 ebp 和 esp 来进行栈回溯，这种方式优缺点都很明显</p><p>优点就是足够的简单，缺点的话大概有这样一些方面</p><ol><li>浪费一个固定的通用寄存器</li><li>保存回溯信息时有额外的指令跳转开销</li><li>回溯出来的信息上下文不够，通常只能恢复堆栈寄存器的内容</li></ol><p>所以在这种情况下，进入64位时代后，这种栈帧结构被放弃，gcc 在64位编译下默认不使用 rbp 寄存器来保存栈帧地址了（不过可以通过 -fno-omit-frame-pointer 选项打开）</p><p>在栈帧结构变化后，我们现在要进行栈回溯，就需要依赖额外的一些调试信息了。</p><p>说到调试信息，大家第一反应肯定是 DWARF (aka Debugging With Attributed Record Formats)，在这一套信息中，定义了一套 CFI (Call Frame Information) 的规范，用来描述栈帧的结构，这套规范在 GCC 和 LLVM 中都有实现。目前 CFI 相关信息存放在程序的 .debug_frame 和 ,.eh_frame 段中。我们可以用一下 readelf 来查看，这里以我们上面的 C 代码的编译结果为例</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">000000b4 000000000000001c 000000b8 FDE cie=00000000 pc=00000000000012fc..0000000000001311</span><br><span class="line">   LOC           CFA      rbp   ra    </span><br><span class="line">00000000000012fc rsp+8    u     c-8   </span><br><span class="line">00000000000012fd rsp+16   c-16  c-8   </span><br><span class="line">0000000000001300 rbp+16   c-16  c-8   </span><br><span class="line">0000000000001310 rsp+8    c-16  c-8   </span><br></pre></td></tr></table></figure><p>这里的 FDE (Frame Description Entry) 就是一条 CFI 信息，里面包含了一些寄存器的信息，比如 rsp, rbp, ra 等等，这些信息可以用来进行栈回溯。</p><p>整个过程差不多如下</p><ol><li>根据当前 PC 指针值，遍历 .eh_frame ，找到对应的 FDE，然后计算便宜</li><li>根据 CFA (Canonical Frame Address) 计算出当前栈帧的地址（比如 rsp+8），然后计算出通用寄存器地址和返回地址在栈中的位置</li><li>比如这里一个通用寄存器的地址是 rsp-16</li><li>返回地址 ra 的地址是 rsp-8</li><li>然后根据 ra 值重复以上部分，就可以进行栈回溯</li></ol><p>当然这里还有很多工程的部分要去做，比如你需要走 auxv 去拿到进程加载后的 ELF，你需要去遍历符号表之类的东西（XD</p><p>现在有一些成套的基础设施可以用，列一下仅供参考</p><ol><li>GCC 自带的宏， __buildin_return_address,</li><li>libunwind</li></ol><h2 id="总结下"><a href="#总结下" class="headerlink" title="总结下"></a>总结下</h2><p>实际上这个工作还有很多的内容要去做，比如你通过 FFI 调用 so 后，你直接进行 native 的栈回溯得到的结果是这样</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x7f641a21aea0 : PQsendQuery+0x0/0x10 [/usr/lib/libpq.so.5.15]</span><br><span class="line">0x7f641ba874f6 [/usr/lib/libffi.so.8.1.2+0x74f6/0xb000]</span><br></pre></td></tr></table></figure><p>如果你想拿到 FFI 另外一侧的信息，那又是一翻额外的工作量（比如 Python）</p><p>以及 unwind 下还有很多噩梦级别的 case 要去处理，比如 PIE，比如 strip 信息后的二进制。如果想用 eBPF 重写 libunwind 的话，我觉得跳楼可能更快一些（不是</p><p>所以遇到问题的时候，可能优先考虑编译一些带着埋点的二进制文件。有可能你搞 print 大法都比 unwind 更好用（XD</p><p>差不多这样</p><p>最后，推荐一个雄文</p><p><a href="https://maskray.me/blog/2020-11-08-stack-unwinding">https://maskray.me/blog/2020-11-08-stack-unwinding</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 水文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子进程退出后，父进程有可能会收不到信号吗？</title>
      <link href="//posts/2023/08/10/is-it-possible-to-lose-the-signal-in-linux/"/>
      <url>//posts/2023/08/10/is-it-possible-to-lose-the-signal-in-linux/</url>
      
        <content type="html"><![CDATA[<p>最近工作强度有点大，写篇 Linux 相关的水文放松下</p><span id="more"></span><p>这个问题实际上是来源于在群里和人的一个讨论。一个基本常识是，子进程退出后，父进程会收到 <code>SIGCHLD</code> 信号，然后父进程可以通过 <code>wait</code> 或者 <code>waitpid</code> 等系统调用来获取子进程的退出状态。那么，子进程退出后，父进程有可能会收不到信号吗？答案毫无疑问是 yes 的</p><p>本文就来聊个其中一个比较好理解的场景 BTW 本文代码都基于最新分支的 Linux 源码</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="先来看一段代码"><a href="#先来看一段代码" class="headerlink" title="先来看一段代码"></a>先来看一段代码</h3><p>Fuck，哦不，Shut up，我们先来看一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"></span><br><span class="line">count = <span class="number">20</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(os.getpid())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigc_handler</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">global</span> result</span><br><span class="line">    result+=<span class="number">1</span></span><br><span class="line">    os.waitpid(-<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sig_int</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">abc</span>():</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        <span class="keyword">if</span> os.fork()==<span class="number">0</span>:</span><br><span class="line">            time.sleep(<span class="number">15</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line">signal.signal(signal.SIGCHLD, sigc_handler)</span><br><span class="line"></span><br><span class="line">abc()</span><br></pre></td></tr></table></figure><p>小学生级别的代码，那么这段代码我们预期是什么？很简单嘛对嘛，最后 result 和 count 相等。那么我们来看一下这段代码的执行结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@kernel-dev-1:~/demo-script# python3 fork-demo.py </span><br><span class="line">33774</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>emmmm？？？？，然后我们发现机器上也出现了 Z 进程</p><p><img src="https://github.com/Zheaoli/zheaoli.github.io/assets/7054676/d399f99a-9a69-4631-9800-8c8f4fe69e36" alt="Z进程"></p><p>为啥捏？这一切都是为啥捏</p><p>要聊清楚这个问题，就得从两方面入手</p><ol><li>进程退出后，内核里做了什么</li><li>信号是怎么处理的</li></ol><p>那就继续聊</p><h3 id="进程退出后，内核里做了什么"><a href="#进程退出后，内核里做了什么" class="headerlink" title="进程退出后，内核里做了什么"></a>进程退出后，内核里做了什么</h3><p>进程退出后，内核核心的一个函数调用是 do_exit, 位于 <code>/kernel/exit.c</code>，看一下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">do_exit</span><span class="params">(<span class="type">long</span> code)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">exit_signals(tsk);  <span class="comment">/* sets PF_EXITING */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sync mm&#x27;s RSS info before statistics gathering */</span></span><br><span class="line"><span class="keyword">if</span> (tsk-&gt;mm)</span><br><span class="line">sync_mm_rss(tsk-&gt;mm);</span><br><span class="line">acct_update_integrals(tsk);</span><br><span class="line">group_dead = atomic_dec_and_test(&amp;tsk-&gt;signal-&gt;live);</span><br><span class="line"><span class="keyword">if</span> (group_dead) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the last thread of global init has exited, panic</span></span><br><span class="line"><span class="comment"> * immediately to get a useable coredump.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(is_global_init(tsk)))</span><br><span class="line">panic(<span class="string">&quot;Attempted to kill init! exitcode=0x%08x\n&quot;</span>,</span><br><span class="line">tsk-&gt;signal-&gt;group_exit_code ?: (<span class="type">int</span>)code);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tsk-&gt;mm)</span><br><span class="line">setmax_mm_hiwater_rss(&amp;tsk-&gt;signal-&gt;maxrss, tsk-&gt;mm);</span><br><span class="line">&#125;</span><br><span class="line">acct_collect(code, group_dead);</span><br><span class="line"><span class="keyword">if</span> (group_dead)</span><br><span class="line">tty_audit_exit();</span><br><span class="line">audit_free(tsk);</span><br><span class="line"></span><br><span class="line">tsk-&gt;exit_code = code;</span><br><span class="line">taskstats_exit(tsk, group_dead);</span><br><span class="line"></span><br><span class="line">exit_mm();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (group_dead)</span><br><span class="line">acct_process();</span><br><span class="line">trace_sched_process_exit(tsk);</span><br><span class="line"></span><br><span class="line">exit_sem(tsk);</span><br><span class="line">exit_shm(tsk);</span><br><span class="line">exit_files(tsk);</span><br><span class="line">exit_fs(tsk);</span><br><span class="line"><span class="keyword">if</span> (group_dead)</span><br><span class="line">disassociate_ctty(<span class="number">1</span>);</span><br><span class="line">exit_task_namespaces(tsk);</span><br><span class="line">exit_task_work(tsk);</span><br><span class="line">exit_thread(tsk);</span><br><span class="line">    exit_notify(tsk, group_dead);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码其实看着很轻松，基本上看调用函数名就能知道在干啥，比如 <code>exit_fs</code> 卸载文件系统啊，<code>exit_files</code> 清理关联文件啊，<code>exit_notify</code> 进行 reap 之类的操作啊，然后我们能一眼到一个函数 <code>exit_signals</code>，这个函数是干啥的呢？看一下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit_signals</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> group_stop = <span class="number">0</span>;</span><br><span class="line"><span class="type">sigset_t</span> unblocked;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @tsk is about to have PF_EXITING set - lock out users which</span></span><br><span class="line"><span class="comment"> * expect stable threadgroup.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cgroup_threadgroup_change_begin(tsk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (thread_group_empty(tsk) || (tsk-&gt;signal-&gt;flags &amp; SIGNAL_GROUP_EXIT)) &#123;</span><br><span class="line">sched_mm_cid_exit_signals(tsk);</span><br><span class="line">tsk-&gt;flags |= PF_EXITING;</span><br><span class="line">cgroup_threadgroup_change_end(tsk);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;tsk-&gt;sighand-&gt;siglock);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * From now this task is not visible for group-wide signals,</span></span><br><span class="line"><span class="comment"> * see wants_signal(), do_signal_stop().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sched_mm_cid_exit_signals(tsk);</span><br><span class="line">tsk-&gt;flags |= PF_EXITING;</span><br><span class="line"></span><br><span class="line">cgroup_threadgroup_change_end(tsk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!task_sigpending(tsk))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">unblocked = tsk-&gt;blocked;</span><br><span class="line">signotset(&amp;unblocked);</span><br><span class="line">retarget_shared_pending(tsk, &amp;unblocked);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(tsk-&gt;jobctl &amp; JOBCTL_STOP_PENDING) &amp;&amp;</span><br><span class="line">    task_participate_group_stop(tsk))</span><br><span class="line">group_stop = CLD_STOPPED;</span><br><span class="line">out:</span><br><span class="line">spin_unlock_irq(&amp;tsk-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If group stop has completed, deliver the notification.  This</span></span><br><span class="line"><span class="comment"> * should always go to the real parent of the group leader.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(group_stop)) &#123;</span><br><span class="line">read_lock(&amp;tasklist_lock);</span><br><span class="line">do_notify_parent_cldstop(tsk, <span class="literal">false</span>, group_stop);</span><br><span class="line">read_unlock(&amp;tasklist_lock);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实前面都是一些准备操作，比如加锁准备操作，cgroup 的前置操作啊，在这些完成后，<code>do_notify_parent_cldstop</code> 将是我们最终执行信号发送的地方，看一下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_notify_parent_cldstop</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk,</span></span><br><span class="line"><span class="params">     <span class="type">bool</span> for_ptracer, <span class="type">int</span> why)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_siginfo</span> <span class="title">info</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span></span><br><span class="line">u64 utime, stime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (for_ptracer) &#123;</span><br><span class="line">parent = tsk-&gt;parent;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tsk = tsk-&gt;group_leader;</span><br><span class="line">parent = tsk-&gt;real_parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clear_siginfo(&amp;info);</span><br><span class="line">info.si_signo = SIGCHLD;</span><br><span class="line">info.si_errno = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * see comment in do_notify_parent() about the following 4 lines</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rcu_read_lock();</span><br><span class="line">info.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));</span><br><span class="line">info.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">task_cputime(tsk, &amp;utime, &amp;stime);</span><br><span class="line">info.si_utime = <span class="type">nsec_to_clock_t</span>(utime);</span><br><span class="line">info.si_stime = <span class="type">nsec_to_clock_t</span>(stime);</span><br><span class="line"></span><br><span class="line"> info.si_code = why;</span><br><span class="line"> <span class="keyword">switch</span> (why) &#123;</span><br><span class="line"> <span class="keyword">case</span> CLD_CONTINUED:</span><br><span class="line"> info.si_status = SIGCONT;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> CLD_STOPPED:</span><br><span class="line"> info.si_status = tsk-&gt;signal-&gt;group_exit_code &amp; <span class="number">0x7f</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> CLD_TRAPPED:</span><br><span class="line"> info.si_status = tsk-&gt;exit_code &amp; <span class="number">0x7f</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line"> BUG();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">sighand = parent-&gt;sighand;</span><br><span class="line">spin_lock_irqsave(&amp;sighand-&gt;siglock, flags);</span><br><span class="line"><span class="keyword">if</span> (sighand-&gt;action[SIGCHLD<span class="number">-1</span>].sa.sa_handler != SIG_IGN &amp;&amp;</span><br><span class="line">    !(sighand-&gt;action[SIGCHLD<span class="number">-1</span>].sa.sa_flags &amp; SA_NOCLDSTOP))</span><br><span class="line">send_signal_locked(SIGCHLD, &amp;info, parent, PIDTYPE_TGID);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Even if SIGCHLD is not generated, we must wake up wait4 calls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__wake_up_parent(tsk, parent);</span><br><span class="line">spin_unlock_irqrestore(&amp;sighand-&gt;siglock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数稍晚有点长，我们依次来解析下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (for_ptracer) &#123;</span><br><span class="line">parent = tsk-&gt;parent;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tsk = tsk-&gt;group_leader;</span><br><span class="line">parent = tsk-&gt;real_parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 task_struct 的定义，查找父进程，准备下面的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clear_siginfo(&amp;info);</span><br><span class="line">info.si_signo = SIGCHLD;</span><br><span class="line">info.si_errno = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>设置 info 中的信号为 SIGCHLD</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sighand-&gt;action[SIGCHLD<span class="number">-1</span>].sa.sa_handler != SIG_IGN &amp;&amp;</span><br><span class="line">    !(sighand-&gt;action[SIGCHLD<span class="number">-1</span>].sa.sa_flags &amp; SA_NOCLDSTOP))</span><br><span class="line">send_signal_locked(SIGCHLD, &amp;info, parent, PIDTYPE_TGID);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Even if SIGCHLD is not generated, we must wake up wait4 calls.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__wake_up_parent(tsk, parent);</span><br><span class="line">spin_unlock_irqrestore(&amp;sighand-&gt;siglock, flags);</span><br></pre></td></tr></table></figure><p>发送信号，然后唤醒父进程，最后释放锁。</p><p>现在我们差不多搞清楚了在进程退出时，内核怎么发信号的。</p><p>但是一个问题还是没解决，为什么在我们的 case 里有信号没拿到？</p><p>那么接着聊</p><h3 id="信号是怎么处理的"><a href="#信号是怎么处理的" class="headerlink" title="信号是怎么处理的"></a>信号是怎么处理的</h3><p>花开两朵，各表一支，我们上文看到，最后我们在进程回收的时候，调用 <code>send_signal_locked</code> 发送信号。在继续聊这个问题之前，我们需要来了解一些简单的 Linux 信号的知识</p><p>在 Linux 中，Linux 将进程分为了 real-time 和 standard 信号。后者通常又有一个别名叫作不可靠信号。通常来讲，信号值小于 SIGTMIN 的为不可靠信号，信号值大于 SIGTMIN 的为 RT 信号。Linux 对于 RT 信号的特性有如下描述</p><blockquote><ol><li>Multiple instances of real-time signals can be queued.  By contrast, if multiple instances of a standard signal are delivered while that signal is currently blocked, then only one instance is queued.</li><li>If the signal is sent using sigqueue(3), an accompanying value (either an integer or a pointer) can be sent with the signal. If the receiving process establishes a handler for this signal using the SA_SIGINFO flag to sigaction(2), then it can obtain this data via the si_value field of the siginfo_t structure passed as the second argument to the handler.  Furthermore, the si_pid and si_uid fields of this structure can be used to obtain the PID and real user ID of the process sending the signal.</li><li>Real-time signals are delivered in a guaranteed order. Multiple real-time signals of the same type are delivered in the order they were sent.  If different real-time signals are sent to a process, they are delivered starting with the lowest-numbered signal.  (I.e., low-numbered signals have highest priority.)  By contrast, if multiple standard signals are pending for a process, the order in which they are delivered is unspecified.</li></ol></blockquote><p>简单来说，RT 信号是可靠且有序的，在内核中，task 的解构包含了两个关键结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="type">sigset_t</span> signal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="type">int</span> flags;</span><br><span class="line"><span class="type">kernel_siginfo_t</span> info;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很明显，这两个结构体是内存中的链表，sigpending 中的 sigset_t signal 是个 64位整数，每个结构体占据一位，标注是否有信号触发。</p><p>我们来看下=<code>send_signal_locked</code> 的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">send_signal_locked</span><span class="params">(<span class="type">int</span> sig, <span class="keyword">struct</span> kernel_siginfo *info,</span></span><br><span class="line"><span class="params">       <span class="keyword">struct</span> task_struct *t, <span class="keyword">enum</span> pid_type type)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */</span></span><br><span class="line"><span class="type">bool</span> force = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (info == SEND_SIG_NOINFO) &#123;</span><br><span class="line"><span class="comment">/* Force if sent from an ancestor pid namespace */</span></span><br><span class="line">force = !task_pid_nr_ns(current, task_active_pid_ns(t));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (info == SEND_SIG_PRIV) &#123;</span><br><span class="line"><span class="comment">/* Don&#x27;t ignore kernel generated signals */</span></span><br><span class="line">force = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (has_si_pid_and_uid(info)) &#123;</span><br><span class="line"><span class="comment">/* SIGKILL and SIGSTOP is special or has ids */</span></span><br><span class="line"><span class="keyword">struct</span> user_namespace *t_user_ns;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">t_user_ns = task_cred_xxx(t, user_ns);</span><br><span class="line"><span class="keyword">if</span> (current_user_ns() != t_user_ns) &#123;</span><br><span class="line"><span class="type">kuid_t</span> uid = make_kuid(current_user_ns(), info-&gt;si_uid);</span><br><span class="line">info-&gt;si_uid = from_kuid_munged(t_user_ns, uid);</span><br><span class="line">&#125;</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A kernel generated signal? */</span></span><br><span class="line">force = (info-&gt;si_code == SI_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* From an ancestor pid namespace? */</span></span><br><span class="line"><span class="keyword">if</span> (!task_pid_nr_ns(current, task_active_pid_ns(t))) &#123;</span><br><span class="line">info-&gt;si_pid = <span class="number">0</span>;</span><br><span class="line">force = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> __send_signal_locked(sig, info, t, type, force);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面又是一堆准备操作，我们直接把目光转向 <code>__send_signal_locked</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __send_signal_locked(<span class="type">int</span> sig, <span class="keyword">struct</span> kernel_siginfo *info,</span><br><span class="line"><span class="keyword">struct</span> task_struct *t, <span class="keyword">enum</span> pid_type type, <span class="type">bool</span> force)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> *<span class="title">pending</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">q</span>;</span></span><br><span class="line"><span class="type">int</span> override_rlimit;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>, result;</span><br><span class="line"></span><br><span class="line">lockdep_assert_held(&amp;t-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">result = TRACE_SIGNAL_IGNORED;</span><br><span class="line"><span class="keyword">if</span> (!prepare_signal(sig, t, force))</span><br><span class="line"><span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line">pending = (type != PIDTYPE_PID) ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Short-circuit ignored signals and support queuing</span></span><br><span class="line"><span class="comment"> * exactly one non-rt signal, so that we can get more</span></span><br><span class="line"><span class="comment"> * detailed information about the cause of the signal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">result = TRACE_SIGNAL_ALREADY_PENDING;</span><br><span class="line"><span class="keyword">if</span> (legacy_queue(pending, sig))</span><br><span class="line"><span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line">result = TRACE_SIGNAL_DELIVERED;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Skip useless siginfo allocation for SIGKILL and kernel threads.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((sig == SIGKILL) || (t-&gt;flags &amp; PF_KTHREAD))</span><br><span class="line"><span class="keyword">goto</span> out_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Real-time signals must be queued if sent by sigqueue, or</span></span><br><span class="line"><span class="comment"> * some other real-time mechanism.  It is implementation</span></span><br><span class="line"><span class="comment"> * defined whether kill() does so.  We attempt to do so, on</span></span><br><span class="line"><span class="comment"> * the principle of least surprise, but since kill is not</span></span><br><span class="line"><span class="comment"> * allowed to fail with EAGAIN when low on memory we just</span></span><br><span class="line"><span class="comment"> * make sure at least one signal gets delivered and don&#x27;t</span></span><br><span class="line"><span class="comment"> * pass on the info struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (sig &lt; SIGRTMIN)</span><br><span class="line">override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">override_rlimit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">q = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (q) &#123;</span><br><span class="line">list_add_tail(&amp;q-&gt;<span class="built_in">list</span>, &amp;pending-&gt;<span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">switch</span> ((<span class="type">unsigned</span> <span class="type">long</span>) info) &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="type">unsigned</span> <span class="type">long</span>) SEND_SIG_NOINFO:</span><br><span class="line">clear_siginfo(&amp;q-&gt;info);</span><br><span class="line">q-&gt;info.si_signo = sig;</span><br><span class="line">q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">q-&gt;info.si_code = SI_USER;</span><br><span class="line">q-&gt;info.si_pid = task_tgid_nr_ns(current,</span><br><span class="line">task_active_pid_ns(t));</span><br><span class="line">rcu_read_lock();</span><br><span class="line">q-&gt;info.si_uid =</span><br><span class="line">from_kuid_munged(task_cred_xxx(t, user_ns),</span><br><span class="line"> current_uid());</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> (<span class="type">unsigned</span> <span class="type">long</span>) SEND_SIG_PRIV:</span><br><span class="line">clear_siginfo(&amp;q-&gt;info);</span><br><span class="line">q-&gt;info.si_signo = sig;</span><br><span class="line">q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">q-&gt;info.si_code = SI_KERNEL;</span><br><span class="line">q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line">q-&gt;info.si_uid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">copy_siginfo(&amp;q-&gt;info, info);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_si_special(info) &amp;&amp;</span><br><span class="line">   sig &gt;= SIGRTMIN &amp;&amp; info-&gt;si_code != SI_USER) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Queue overflow, abort.  We may abort if the</span></span><br><span class="line"><span class="comment"> * signal was rt and sent by user using something</span></span><br><span class="line"><span class="comment"> * other than kill().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">result = TRACE_SIGNAL_OVERFLOW_FAIL;</span><br><span class="line">ret = -EAGAIN;</span><br><span class="line"><span class="keyword">goto</span> ret;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a silent loss of information.  We still</span></span><br><span class="line"><span class="comment"> * send the signal, but the *info bits are lost.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">result = TRACE_SIGNAL_LOSE_INFO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_set:</span><br><span class="line">signalfd_notify(t, sig);</span><br><span class="line">sigaddset(&amp;pending-&gt;signal, sig);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Let multiprocess signals appear after on-going forks */</span></span><br><span class="line"><span class="keyword">if</span> (type &gt; PIDTYPE_TGID) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">multiprocess_signals</span> *<span class="title">delayed</span>;</span></span><br><span class="line">hlist_for_each_entry(delayed, &amp;t-&gt;signal-&gt;multiprocess, node) &#123;</span><br><span class="line"><span class="type">sigset_t</span> *signal = &amp;delayed-&gt;signal;</span><br><span class="line"><span class="comment">/* Can&#x27;t queue both a stop and a continue signal */</span></span><br><span class="line"><span class="keyword">if</span> (sig == SIGCONT)</span><br><span class="line">sigdelsetmask(signal, SIG_KERNEL_STOP_MASK);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sig_kernel_stop(sig))</span><br><span class="line">sigdelset(signal, SIGCONT);</span><br><span class="line">sigaddset(signal, sig);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">complete_signal(sig, t, type);</span><br><span class="line">ret:</span><br><span class="line">trace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们核心关注这样一些地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (legacy_queue(pending, sig))</span><br><span class="line"><span class="keyword">goto</span> ret;</span><br></pre></td></tr></table></figure><p>这里是判断当前发送的信号，是否已经在 sigpending 中的 sigset_t signal 中注册，如果注册了，就直接进入返回流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">legacy_queue</span><span class="params">(<span class="keyword">struct</span> sigpending *signals, <span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (sig &lt; SIGRTMIN) &amp;&amp; sigismember(&amp;signals-&gt;signal, sig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯这段逻辑就很清晰了，继续回到 <code>__send_signal_locked</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sig &lt; SIGRTMIN)</span><br><span class="line">override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">override_rlimit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">q = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (q) &#123;</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure><p>这里判断是否需要强制超出系统 SIGNAL QUEUE 的长度限制，然后调用 <code>__sigqueue_alloc</code> 函数，这个函数的作用是分配一个 sigqueue 结构体，然后将其加入到 sigpending 的链表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *</span></span><br><span class="line"><span class="class">__<span class="title">sigqueue_alloc</span>(<span class="title">int</span> <span class="title">sig</span>, <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>, <span class="title">gfp_t</span> <span class="title">gfp_flags</span>,</span></span><br><span class="line"><span class="class"> <span class="title">int</span> <span class="title">override_rlimit</span>, <span class="title">const</span> <span class="title">unsigned</span> <span class="title">int</span> <span class="title">sigqueue_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">q</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">long</span> sigpending;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Protect access to @t credentials. This can go away when all</span></span><br><span class="line"><span class="comment"> * callers hold rcu read lock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE! A pending signal will hold on to the user refcount,</span></span><br><span class="line"><span class="comment"> * and we get/put the refcount only when the sigpending count</span></span><br><span class="line"><span class="comment"> * changes from/to zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rcu_read_lock();</span><br><span class="line">ucounts = task_ucounts(t);</span><br><span class="line">sigpending = inc_rlimit_get_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);</span><br><span class="line">rcu_read_unlock();</span><br><span class="line"><span class="keyword">if</span> (!sigpending)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (override_rlimit || likely(sigpending &lt;= task_rlimit(t, RLIMIT_SIGPENDING))) &#123;</span><br><span class="line">q = kmem_cache_alloc(sigqueue_cachep, gfp_flags);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">print_dropped_signal(sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(q == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">dec_rlimit_put_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">INIT_LIST_HEAD(&amp;q-&gt;<span class="built_in">list</span>);</span><br><span class="line">q-&gt;flags = sigqueue_flags;</span><br><span class="line">q-&gt;ucounts = ucounts;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑就很清晰了，分配内存，返回指针。这里系统中 RLIMIT_SIGPENDING 的配置决定了我们 pending 队列的长度。各个发行版不同</p><p>差不多这样</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回到我们最开始的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"></span><br><span class="line">count = <span class="number">20</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(os.getpid())</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigc_handler</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">global</span> result</span><br><span class="line">    result+=<span class="number">1</span></span><br><span class="line">    os.waitpid(-<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sig_int</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">abc</span>():</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        <span class="keyword">if</span> os.fork()==<span class="number">0</span>:</span><br><span class="line">            time.sleep(<span class="number">15</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line">signal.signal(signal.SIGCHLD, sigc_handler)</span><br><span class="line"></span><br><span class="line">abc()</span><br></pre></td></tr></table></figure><p>这段代码，在我们的回调函数中存在 block 行为，导致后续进程在 SIGCHLD 信号发送后，在 <code>legacy_queue</code> 处判断当前队列有同样的非可靠信号未被处理完，于是没有完成后续的信号处理流程</p><p>嗯，差不多就这样。简单写篇入门水文，希望大家看的开心</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 水文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊公益和助学</title>
      <link href="//posts/2023/06/25/love-and-hope-is-all-we-need/"/>
      <url>//posts/2023/06/25/love-and-hope-is-all-we-need/</url>
      
        <content type="html"><![CDATA[<p>没什么特别的原因，就突然想来聊聊公益和助学。对了，感谢橘子酱同学深夜帮我做的本篇博客的 cover，我自己对设计实际上一窍不通。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先，今天毫无疑问是个 big day，接到了一个超好的消息。我资助的来自大凉山的一位女生，在父母都大部分失去劳动力，国家级贫困县的极度贫困家庭的情况下，在高考中拿下了550的成绩。超出一本线30分，算上凉山地区的加分，她应该可以去一个合格的公立学校接受完整的高等教育了。</p><p>当时接到消息的时候，我简直开心炸裂，我和女朋友都兴奋的跳了起来。原因很简单。她这一路走来太过不容易。</p><p>我是从她高一下学期开始资助她的，那时她的成绩仅仅排在年级中游，本科很悬。在后面的只言片语以及机构每学期的回访中。我都能看到她的迷茫，与坚持。她一步步的，一点点的努力着。然后在今天，终于圆梦。虽然这个梦对于很多网友来说微不足道。</p><p>我在推特和朋友圈分享这对我来说也是意义重大的喜讯后。迎来了很多的懂王。发表了一些典型的爹味和傻逼言论，“她研究生和博士你也帮吗”，“过去的贫困让她有心理疾病，没治愈之前没法说改变人生”，“出来还是当韭菜的命”</p><p>分开聊聊吧</p><p>“她研究生和博士你也帮吗”，对啊，我帮。咋了？</p><p>“过去的贫困让她有心理疾病，没治愈之前没法说改变人生”，她比你想的坚强，也比你想的阳光。三年里，我见证了她的蜕变于进步。她从未想过放弃自己，一步步的走了出来。我从未质疑过她面对未来的勇气，我相信包括我在内的所有人亦没有资格去质疑她面对未来的勇气与坚强</p><p>“出来还是当韭菜的命”，我自己也算是大凉山出来的（攀枝花），小时候家对面山上都能看到吸毒死亡的人，更别说凉山了，吸毒贩毒到处都是。上不了高中是常态中的常态。我资助的女孩子，父母都失去劳动能力，家里极度贫困。但是一步步的上了当地最好的高中，又一步步的超出一本线这么多（算上加分，超一本线能40），她的命运已经改变了。今后的她即便在城市里996，当着你们高等人所谓的韭菜。过着你们高等人所看不上，所觉得淡然无味的生活。但是这种生活远比她之前过的生活要强出千百倍，她不用担心家门口是不是有吸毒的人，也不用担心自己是不是要十五六嫁人换彩礼。然后如果她愿意，找个丈夫，结婚，生子，相守平淡一生。你们所看不上的生活，是她梦寐以求的生活。</p><p>说实话，公益和助学的意义永远不在于说一步到位，让人飞黄腾达。而是一点点的，让更多经历苦难的人，能够脱离环境桎梏。</p><p>我从大学时期进入救援队做公益，到现在也有11年了。后续历经2013雅安，2017年北京等大型事件。而且捐款助学的话，从2017年开始进行捐助。到现在也快7年了。说实话，很难去具体的描述我做公益的动机。不过强行解释的话，那么其实大概能概括成这几点</p><ol><li>奥特曼叫我去做的</li><li>这件事很酷</li><li>想做的时候就做了</li></ol><p>能从上面看出来，其实我没有太强的目的性去做这件事。实际上这也是我所推荐的状态。我个人觉得如果具有太强的功利心是做不好这件事的。</p><p>而从16年后，我整体的公益主要以线上为主了（因为我实在没时间和体能跑现场了，除了17年北京还跑了一次现场），剩下的主要有以下几个方面了</p><ol><li>日常的献血（18年身体状况转弱之前，我基本保持了一年一到两次献血）</li><li>罕见病项目捐款</li><li>助学捐款</li><li>号召身边人去一起做公益</li></ol><p>这里我想先说说4。实际上这是一件非常非常非常重要的事。很多同学可能会发现，我自己很喜欢在推上和朋友圈里分享自己的公益日常。开心的，不开心的。我估计有不少人实际上会认为这什么鸟人，这么喜欢秀。实际上不然，我是想通过分享我做公益的细节与瞬间，能让更多的人去发现公益的乐趣。然后投入到这件事。实际上效果不错。从18年到现在，我至少号召了四位身边的朋友助学捐款，还有一位成为了公益组织的义工。是不是很酷！</p><p>然后回到公益资助本身。2的话，我实际上没有很挑选过公益机构。在腾讯公益或者支付宝上捐个三五百的就完事（当然累计也有一定数额了）。我自己投入精力比较多的部分，也是大家比较关注的部分还是在3，即助学捐款上。我认为这是一件非常意义的事，如本篇博客 cover 中所记录的。教育是最好的公益</p><p>通常来说，目前我觉得比较靠谱的渠道有两个，一个是鲲鹏公益计划，一个是壹个村小，前者在支付宝公益和微信公益上都能找到，我目前捐款了几次，差不多一次2000以内。这个项目是典型的一对一项目。定期会有学生情况更新。所以相对来说更有保障。而我自己一直很喜欢的团队是<a href="http://one-school.org/">壹个村小</a>，他们的微信公众号是 cunxiao4u。这个团队我觉得很特殊，主要在以下几点</p><ol><li>本身自己的运作不依赖向学生捐款的抽成，包括人员薪资在内的费用由额外定向捐助承担。比如你们从他们的<a href="http://one-school.org/news/newsshow.asp?new_id=109">壹个村小2022年终工作简报</a> 上能看到，他们自己的薪资总计在五十万左右，和面向学生的捐款分开。</li><li>对于学生的资助不会过他们的账户，而是直接由捐款人每学期打款到学生账户</li><li>随访做的很及时，能定期让捐款人看到学生的近况。同时他们也鼓励捐款人和学生直接接触，来鼓励帮助学生</li><li>他们有额外的项目，来负责被资助的学生如果出现捐款人断捐，学生突发疾病的情况。</li></ol><p>每个学生的资助金额以学期计算，差不多1000-3000不等。具体金额是根据学生具体情况计算出来，每学期都会更新与你同步</p><p>那么他们有没有缺点？有，非常大的缺点，超级大的缺点，我怨念深重的缺点！就是他们学生<strong>太太太太太难抢了</strong>。真的。。说起来就是一把泪。。每次抢学生都需要八点过起来。然后到点一刷秒没。属实是人麻了。</p><p>这些差不多是我自己关于助学公益的一些建议。那么回到做公益这件事本身，可能会有人问你有没有自我怀疑的时候，那毫无疑问，有啊，非常有，常见不仅限于</p><ol><li>被人质疑的时候（第一次遇到是做雅安地震的义卖的时候，有个人过来说你们做这些有什么用。然后很温暖的是一个广东口语的大叔操着粤普直接说“你这个傻逼衰仔管人家学生娃娃做什么，不买就滚”，然后买了我们一本书，给我们了一个大拇指）</li><li>比如你看到你的付出被人滥用的时候</li><li>比如你看到各种公益基金会贪污的新闻的时候</li><li>比如你看到有很多人需要帮助，你会有一种无力感。</li></ol><p>这些我都有过，但是我后面想通了，可能说看淡了</p><p>继续聊之前，我先给大家科普一个知识，首先我们定义超长心肺复苏是指时间大于半小时的心肺复苏。即便在现代高度发达的医学下，根据现有的数据,一般在两百例超长心肺复苏才能遇见一位能痊愈出院的患者。这个比例很低对吧？但是大家换个角度想，如果全球每年有2000万例超长心肺复苏，那么意味着会有10w名患者获得新生。数字又不小了对吧。如果说，我们放弃了这2000万次超长心肺复苏，那么意味着有10w条本应该能救回来的生命再次逝去。</p><p>公益和心肺复苏一样</p><p>有很多钱没法用到正途，没错</p><p>有很多人骗取同情心，没错</p><p>很多重男轻女家庭用姐姐出来博同情心，给弟弟赚钱，太他妈对了</p><p>各种公益组织贪污情况太严重了，fucking right</p><p>有太多的人需要帮，我们帮不过来，damn right</p><p>但是这些都不是我们不去做，和犹豫的理由</p><p>我一直坚信只要我们做的事足够多，那么就一定有足够多的人获取帮助</p><p>水坑里的鱼太多？我救不完，fucking right，but so what？这绝不是我一条都不救的理由</p><p>所以我希望我们还是能一点点的尽力帮助所需要帮助的人。这个世界足够操蛋，我们也没有办法改变这个世界，但是我们可以让这个世界多那么一丝色彩</p><p>最后一起复习一下艾特奥特曼的愿望</p><blockquote><p>優しさを失わないでくれ。弱い者を労り互いに助け合い。<br>どこの国の人とも友達になろうとする気持ちを失わないでくれ。<br>たとえその気持ちが何百回裏切られようとも。<br>それが私の最後の願いだ。<br>热忱之心不可泯灭。要体恤、帮助弱者。<br>与任何国家的人都能成为朋友，别失去这份热心，纵使它已被背叛了千百回。<br>这就是我最后的愿望。</p></blockquote><p>To love, to lose, to give without expectation</p><p>Yeah, 其实公益很简单的，不需要有那么多顾虑，也不需要有那么多成本，我们随手捐一点，帮一点，我们所有人的力量就能够一定帮到足够多的人。就如同超长 CPR 里那10w条被拯救的生命</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这个世界越来越操蛋，也越来越混沌了。这个时代是否如狄更斯所说“这是一个最好的时代，也是一个最坏的时代”，我对前半句抱有怀疑。</p><p>但是我依旧愿意去相信爱，光和奥特曼，人生苦短，总得做点什么，让这个 fucking ridiculous 的世界变得有那么彩色一点。</p><p>Love and Hope is all we need.</p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么奥特曼是我的信仰</title>
      <link href="//posts/2023/06/19/why-do-I-love-ultraman/"/>
      <url>//posts/2023/06/19/why-do-I-love-ultraman/</url>
      
        <content type="html"><![CDATA[<p>突然着想写一篇文章，聊聊我所信仰的奥特曼。ウルトラマン大好きだ</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>今年对于我来说其实是挺 tough 的一年，双相的病情反反复复。自残的行为也重新出现。特别是在今年3月之后，我某种意义上的心理防线一度被击穿。</p><p>熟悉我的朋友可能已经反应过来了。没错，3月24日，杰克奥特曼人间体乡秀树扮演者团时郎先生的离世，实际上给了我不小的打击。</p><p>我依旧还记得那天的情景。在一个朋友给我转发了日媒报道乡秀树先生3月22日离世的消息后，当时嘣的一声，我脑子里的弦仿佛断了一根。眼泪就不由自主的流了下来。我甚至一度都没有反应过来我在流泪这件事。直到我妹子发现了我的异常问我怎么了。我才反应过来，原来我在流泪。当天实际上我一度无法正常工作了（即便现在，我回想起来也有点泪目），后面算是勉强打起精神，给当天的工作收尾。</p><p>实际上这件事对我的影响贯穿到现在，导致我4月/5月情绪非常的波动。我曾经给我设置了几道心理的防线，其中一道是和奥特曼相关的，然后这道防线在当时被击穿了。</p><p>实际上团时郎先生的逝世应该是个导火索。早在去年5月份，我最喜欢的奥系列中的一位演员渡边裕之先生（盖亚奥特曼中石室指挥官，我认为特摄史上塑造的最成功的人物之一）在公寓里自杀的消息实际上也深深的刺痛了我。只是当时的我没想到，事隔一年后，我还会迎来另外一位人物的离世。</p><p>很多人可能会很疑惑，为什么我会如此喜欢奥特曼。</p><p>这里我要更正一点，我不是喜欢奥特曼，而是“奥特曼是我的信仰”，或者说，我信仰着奥特精神。</p><p>这样一个信仰的形成，其实要追溯到我的过往。</p><p>我之前在博客上分享过，我在2007年初遭到了同性的强奸。虽然在后续父母对我保护的很好。但是因为事件之初没有进行相应的心理干涉。实际上这件事的诱发的 PTSD 一直持续到了现在。而在初高中，即我人生13-18岁这五年三观的成型期，强奸事件带来的残缺感与孤独感一直伴随着我（我其实是个很怕社交的人，没想到吧）。同时，这样一份残缺感+我并不愿意和父母做太多的沟通，导致我这个时期的阴暗的一面非常严重。你可能能想到的暴戾，自残，嗜血（比如时常扣掉伤疤舔血）的一面都在我身上存在。可能和新闻上人物的区别在于当时的我没去实施。如果这样发展下去，可能现在你们就会在新闻上看到我了。</p><p>所幸，这个世界上真的存在奥特曼</p><p>在这五年的时间里，我时常在苦闷，烦恼，暴戾情绪严重的时候，逃课或请假，找个奶茶店或者网吧（是的，我去网吧不打游戏），点点吃得，然后坐着看一天奥特曼。</p><p>这样一天天过去吗，我心里曾经空掉的东西，被一点点填了回来。某种意义上来说，奥特曼，或者说奥特精神是构成了我这个人现在所表现出来的一切正面元素的基石。</p><p>可能有很多人会问，奥特精神，到底是什么？这里我引用来自艾斯奥特曼最终话的台词，应该就能做出很好的解释</p><blockquote><p>優しさを失わないでくれ。弱い者を労り互いに助け合い。<br>どこの国の人とも友達になろうとする気持ちを失わないでくれ。<br>たとえその気持ちが何百回裏切られようとも。<br>それが私の最後の願いだ。<br>热忱之心不可泯灭。要体恤、帮助弱者。<br>与任何国家的人都能成为朋友，别失去这份热心，纵使它已被背叛了千百回。<br>这就是我最后的愿望。</p></blockquote><p>贯穿奥特曼全系列的，就是这样一份热忱之心，一份坚守的精神，一份不屈不挠的意志。这份精神，也是我一直以来所追求的。</p><p>这里我推荐大家如果有兴趣可以去看一下下面两作</p><ol><li>盖亚奥特曼第39话 悲しみの沼/悲伤的沼泽</li><li>赛文奥特曼98/99 OVA</li></ol><p>我觉得如果大家能看完，实际上会对奥系列一直传达的希望，反战，和平，理解，爱有非常深刻的感触。</p><p>13-18岁，这人生很关键的五年，奥特曼陪伴了我。基本上塑造了我现在的很大一部分人格和认知（我现在依旧坚信着平行世界一定存在的奥特曼的Hhhhh）。也会实际上影响我做事的方式。想做什么坏事的时候，心里想想，这可能不奥特精神。在帮不帮人犹犹豫豫的时候，我想如果做了那么奥特曼一定会替我开心的。</p><p>我一个好友这样评论我的想法（大家别说我幼稚啊）：很多人只是会把你这些想法抽象为佛主，或者上帝。而你只是抽象成奥特曼而已。</p><p>Exactly！</p><p>之前有推特上有懂哥跳出来评价</p><p><img src="https://user-images.githubusercontent.com/7054676/170878363-111b42b2-4471-47d2-8551-0b9b3650493c.png" alt="懂哥"></p><p>没错，我就喜欢了，我就傻逼了，怎么了？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>随便碎碎念了一下，算是让心里一些一直想说的话说了出来（好受了许多）</p><p>谨以此文，献给团时郎先生，献给渡边裕之先生，献给我所深爱并信仰着的奥特曼。</p><p>如果有人能认识历年的主演们，请替我给他们转达一句话：谢谢你们，谢谢你们塑造的奥特曼拯救了我</p><p>最后的最后：ウルトラマン大好きだ</p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>家庭 Homelab 升级计划</title>
      <link href="//posts/2023/06/16/how-do-I-build-homelab/"/>
      <url>//posts/2023/06/16/how-do-I-build-homelab/</url>
      
        <content type="html"><![CDATA[<p>最近家庭升级 Homelab 差不多告一段落，来写篇文章记录下我的折腾过程</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>熟悉我的朋友都知道，我是个 SRE，所以吧，对于家里的网络环境质量要求非常高。一直以来，我家的网络环境都在不断的迭代，不过我的网络环境一直围绕三个方向迭代</p><ol><li>稳定性毫无疑问的是第一要素，网络炸了，我就没法工作了</li><li>需要有足够优秀的内网速度，因为我有一些 NAS 之类的服务，承担我流媒体的需求</li><li>需要有一个可靠网关，来根据 GEO 和规则对于不同的流量做处理。</li><li>我家 IoT，电脑等移动设备的数量非常多，那么需要热点有足够的性能来保证网络的质量</li></ol><p>那么围绕这个，从今年开始，我围绕 Homelab 做了一系列的演进</p><h3 id="阶段1-机柜与有线-Mesh"><a href="#阶段1-机柜与有线-Mesh" class="headerlink" title="阶段1: 机柜与有线 Mesh"></a>阶段1: 机柜与有线 Mesh</h3><p>在今年4月搬到新家后，借着要重新安排所有东西的机会，我重新构造了家里的网络</p><p>首先来讲，从全屋的无线热点上，我做了这样的演进</p><ol><li>引入了 TPLink 一个8口的千兆交换机，来扩展端口</li><li>引入了 TPLink XDR 6080 和我原本的 XDR 10280 来做有线 Mesh</li></ol><p>在经过这样的改造后，我家里的网络结构变成了这样的模式</p><ol><li>从光猫往下，一根线走向原本的小米 AX3600 作为家里 IoT 设备的联网端。另一根走向一个 Intel 6305+ 8GRAM 的 x86 机器。在 X86 机器上，我会根据 GEO 规则，对于不同的流量包做一些处理，同时会对 DNS 做 AD 过滤。</li><li>从 x86机器往下，那么接入 交换机+路由器 x3 成为家里的主干网。</li></ol><p>另外，今年六月，好友赠送了我一个 Intel 12代 i7 的满配 NUC ，我自己也采购了两台零刻的机器做为家里的 NUC 集群，上面跑一些 Kubernetes 之类的自己用来测试的服务。</p><p>整体效果如下</p><p><img src="https://i.imgur.com/42S0PH1.jpeg" alt="v1"></p><p>从上往下：</p><ol><li>NUC</li><li>交换机&amp;光猫</li><li>x86 网关 &amp; UPS</li><li>群晖 DS1821+</li></ol><p>但是在现有结构下，还存在一些问题</p><ol><li>TPLink 交换机易用性极差，要设置比如链路聚合之类的非常头疼</li><li>路由器非常不美观，</li><li>x86 网关一旦 crash，如果我需要恢复网络，那么只能物理跳线。</li></ol><p>基于这样一些逻辑，我考虑进行如下改造</p><ol><li>替换交换机</li><li>将无线路由有线 Mesh 的方案切换为 AC+AP 的方案</li><li>将 x86 网关作为旁路网关</li></ol><h3 id="阶段2-更大的机柜，更好的设备"><a href="#阶段2-更大的机柜，更好的设备" class="headerlink" title="阶段2: 更大的机柜，更好的设备"></a>阶段2: 更大的机柜，更好的设备</h3><p>基于上面的一些考虑，在经过多方面选择后，我选择 UBNT 作为我的接入设备</p><p>整体的理由如下：</p><ol><li>性能不错</li><li>易用性极强</li><li>整体的设备美观度极高</li></ol><p>所以最开始设备的选择如下</p><ol><li>UDM-Pro 作为主路由</li><li>USW-24-Pro-POE 作为交换机</li><li>U6-Mesh <em> 2 + U6-IW </em> 2 作为 AP</li></ol><p>然后整体的效果如下</p><p><img src="https://i.imgur.com/kXgbRQa.jpeg" alt="v2"></p><p>但是在使用几天后，我发现了新的问题：我对容量的预估严重不足！</p><p>实际上千兆交换机理论吞吐是 1Gbps，但是实际上来说，刨除协议开销，有效负荷的速率大概在 940Mbps 左右。而这一点实际上对我现在的一些使用场景是有所不足的。比如在 PC 端转码然后回传 NAS 之类的。</p><p>而我目前又没有 10Gbps 常态化的传输需求。经过慎重考虑后，我决定将家中局域网的上限提升至 2.5Gbps。这样能达成性能与易用性的平衡点</p><p>那么我的设备选择如下、</p><ol><li>主路路由替换至 UDM-SE</li><li>交换机替换至 USE-Enterprise-24-POE</li><li>AP 替换两个为 U6-Enterprise-IW</li></ol><p>整体效果如下</p><p><img src="https://i.imgur.com/zIOH0Cr.jpeg" alt="v3"></p><p>当然中间穿插的小插曲是，在升级 2000M/200M 宽带后，我将家里的光猫替换成猫棒直接在主路由上接入光纤</p><p>然后我在网络上划分了三个 vlan</p><ol><li>192.168.0.1/16 作为工作网段，其中网关会指向 x86 机器</li><li>10.0.0.1/16 为日常网段，确保 x86 机器挂了不会影响其余设备</li><li>172.28.0.1/16 为 IoT 网段，给家里的 IOT 设备使用</li><li>中间添加了防火墙策略，确保 IoT 网段无法访问工作网段和日常网段的设备</li></ol><p>最后整体的网速差不多是这样</p><p><img src="https://i.imgur.com/RDmbgjU.png" alt="内网"></p><p><img src="https://i.imgur.com/2uaxhtt.png" alt="公网"></p><p>整体的拓扑如下</p><p><img src="https://i.imgur.com/NdDUnS5.png" alt="拓扑1"></p><p><img src="https://i.imgur.com/Un04brM.png" alt="拓扑2"></p><p>差不多就是这样</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过改造，我相信这样的整体结构能够满足我使用很长时间。当然估计有很多人不理解为啥我租房还要这么折腾。我想除了职业习惯的原因以外，也还是想给自己的日常生活找点乐子。毕竟房子是租的，但是生活不是。</p>]]></content>
      
      
      <categories>
          
          <category> Homelab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 水文 </tag>
            
            <tag> Homelab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单聊聊 IaC：Infrastructure as Code</title>
      <link href="//posts/2023/03/12/a-simple-introduction-about-iac/"/>
      <url>//posts/2023/03/12/a-simple-introduction-about-iac/</url>
      
        <content type="html"><![CDATA[<p>实际上 IaC 这个概念的出现已经很久了，所以写篇水文来简单聊聊 IaC 的过去，现在，和将来</p><span id="more"></span><h2 id="IaC-的过去"><a href="#IaC-的过去" class="headerlink" title="IaC 的过去"></a>IaC 的过去</h2><p>实际上 IaC 的历史其实足够悠久。首先来看一下 IaC 的核心的特征</p><ol><li>最终的产物是 machine readable 的的产物。可能是一份代码，也可能是一份配制文件</li><li>基于 machine readable 的产物，可以进一步依赖已有的 VCS 系统（SVN，Git）等做版本管理</li><li>基于 machine readable 的产物，可以进一步依赖已有的 CI/CD 系统（Jenkins，Travis CI）等做持续集成/持续交付</li><li>状态的一致性，或者称为幂等性。即理论上来讲，基于同样一份 Code，同一套参数构建出的产物，其最终的行为应该是一致的</li></ol><p>实际上通过 IaC 这样的一些核心特征，我们现在能明白 IaC 兴起的原因。IaC 实际上的兴起，大背景是在千禧年之后，互联网世界迭代的速度愈发的快速，这个时候传统的手工式的维护面临着几个问题</p><ol><li>交互式变更所引入的人的因素太大，导致了变更的不可控性</li><li>人工变更面对愈发快速的 Infra 迭代力有不逮</li><li>交互式的变更导致管控的难做，让版本控制之类的手段变为空谈</li></ol><p>在这样的时代背景下，大家都在追求用更技术，更优雅的手段来解决这些问题。于是，IaC 这个概念就出现了</p><p>如果说要将 IaC 分为几个阶段的话，那么我觉得可以分为以下几个阶段</p><ol><li>刀根火种阶段</li><li>现代化的 IaC</li></ol><p>如同前面所说，IaC 实际上是一个自发的驱动，在面对不确定的时候，我们选择用代码来尽可能的消泯掉不确定性（实际上这个原则一直贯穿到现在）</p><p>那么在最早期，人们选择用最基础的代码的形式，来完成 IaC 的工作。其特征是对于之前的各种交互式的手段的精确化，程序化的描述。人们可能会选择直接用 bash 来解决这一切（祖传的来路不明的 bash 脚本.jpg），也可能会基于 Python Fabric 这样的框架进行简单的封装来完成所需的程序化描述的工作。</p><p>但是我们回头去看这一阶段，我们能直观的感受到一些缺陷</p><ol><li>代码复用性较差</li><li>各家都有一套祖传的 IaC 基建，没有统一的行业标准，导致新人入门门槛较高</li></ol><p>所以在面对这样一套的问题的时候。更现代化的 IaC 设施应运而生。其中典型的一些产物是</p><ol><li>Ansible</li><li>Chef</li><li>Puppet</li></ol><p>实际上这些工具，可能设计上各有所取舍（比如 Pull/Push 模型的取舍），但是其核心的特征不会变化</p><ol><li>框架内部提供了常见的比如 SSH 链接管理，多机并行执行，auto retry 等功能</li><li>基于上面描述的这一套基础功能，提供了一套 DSL 封装。让开发者更专注于 IaC 的逻辑，而非基础层面的细节</li><li>其开源开放，并形成了一套完善的插件机制。社区可以基于这一套提供更丰富的生态。比如 SDN 社区基于 ANSIBLE 提供了各种交换机的 playbook 等</li></ol><p>那么截至到现在，实际上 IaC 的发展其实到了一个相对完备的程度。其中不少工具，也依旧贯穿到了现在。</p><h2 id="新生代的-IaC"><a href="#新生代的-IaC" class="headerlink" title="新生代的 IaC"></a>新生代的 IaC</h2><p>从2006年8月25日，Amazon 正式宣布提供了 EC2 服务开始。整个基础设施开始快步向 Cloud 时代迈进。截止到目前，各家云厂商提供了各种各样的服务。通过十多年的演进，也诞生出了诸如 IaaS，PaaS，DaaS，FaaS 等等各种各样的服务模式。这些服务模式，让我们的基础设施的构建，变得更加的简单，更加的快速。但是这些服务模式，也带来了一些新的问题。</p><p>可能写到这里，有同学已经能意识到了问题的所在：在获取算力，获取资源越来越快捷的当下。我们怎么样去管理这样一些资源？</p><p>那么要解决这样的问题，我们似乎又需要去考虑怎么样用代码或者可声明式的配置来管理这些资源。有没有一点眼熟，历史始终就是一个圈圈.jpg</p><p>在起初的时候，我们各自会选择基于各家云厂商提供的 API 与 SDK 自行封装一套 IaC 工具，如同前面所说的一样。这样会带来一些额外的问题：</p><ol><li>代码复用性较差</li><li>各家都有一套祖传的 IaC 基建，没有统一的行业标准，导致新人入门门槛较高</li></ol><p>那么这个时候，云时代的，面向云资源管理的新型 IaC 工具的需求也愈发的迫切。这个时候，Terraform 这样的新型工具应运而生</p><p>在 Terraform 里，可能一台 EC2 Instance 的开启可能就是这样的一段简短的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">resource &quot;aws_vpc&quot; &quot;my_vpc&quot; &#123;</span><br><span class="line">  cidr_block = &quot;172.16.0.0/16&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;tf-example&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_subnet&quot; &quot;my_subnet&quot; &#123;</span><br><span class="line">  vpc_id            = aws_vpc.my_vpc.id</span><br><span class="line">  cidr_block        = &quot;172.16.10.0/24&quot;</span><br><span class="line">  availability_zone = &quot;us-west-2a&quot;</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;tf-example&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_network_interface&quot; &quot;foo&quot; &#123;</span><br><span class="line">  subnet_id   = aws_subnet.my_subnet.id</span><br><span class="line">  private_ips = [&quot;172.16.10.100&quot;]</span><br><span class="line"></span><br><span class="line">  tags = &#123;</span><br><span class="line">    Name = &quot;primary_network_interface&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource &quot;aws_instance&quot; &quot;foo&quot; &#123;</span><br><span class="line">  ami           = &quot;ami-005e54dee72cc1d00&quot; # us-west-2</span><br><span class="line">  instance_type = &quot;t2.micro&quot;</span><br><span class="line"></span><br><span class="line">  network_interface &#123;</span><br><span class="line">    network_interface_id = aws_network_interface.foo.id</span><br><span class="line">    device_index         = 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  credit_specification &#123;</span><br><span class="line">    cpu_credits = &quot;unlimited&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个基础上，我们可以继续将我们诸如 Database，Redis，MQ 等基础设施都进行代码化/描述式配置化，进而提升我们对资源维护的有效性。</p><p>同时，随着各家 SaaS 的发展，研发人员也尝试着将这些 SaaS 服务也进行代码化/描述式配置化。以 Terraform 为例，我们可以通过 Terraform 的 Provider 来进行对接。比如 <a href="https://newrelic.com/">newrelic</a> 提供的 <a href="https://registry.terraform.io/providers/newrelic/newrelic/latest/docs">Provider</a>，<a href="https://www.bytebase.com/">Bytebase</a> 提供的 <a href="https://registry.terraform.io/providers/bytebase/bytebase/latest/docs">Provider</a> 等等</p><p>同时，在 IaC 工具帮助我们完成基础设施描述的标准化之后，我们在此基础上能做更多有趣的事情。比如我们可以基于 <a href="https://www.infracost.io/">Infracost</a> 来计算每次资源变更所带来的资源花费变更。基于 <a href="https://www.runatlantis.io/">atlantis</a> 来完成集中式的资源变更等等进阶的工作。</p><p>那么到现在为止，我们已有的 IaC 产品的选择足够多，能满足我们大部分需求。那么是不是 IaC 整个产品的发展实际上就已经到了一个相对完备的程度呢？答案很明显是否定的</p><h2 id="未来的-IaC"><a href="#未来的-IaC" class="headerlink" title="未来的 IaC"></a>未来的 IaC</h2><p>所以这张主要来聊聊当下 IaC 产品所面临的一些问题，以及我对未来的一些思考吧</p><h3 id="缺陷一：现有基于-DSL-的语法体系的缺陷"><a href="#缺陷一：现有基于-DSL-的语法体系的缺陷" class="headerlink" title="缺陷一：现有基于 DSL 的语法体系的缺陷"></a>缺陷一：现有基于 DSL 的语法体系的缺陷</h3><p>先给大家看一个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">locals &#123;</span><br><span class="line">  dns_records = &#123;</span><br><span class="line">    # &quot;demo0&quot; : 0,</span><br><span class="line">    &quot;demo1&quot; : 1,</span><br><span class="line">    &quot;demo2&quot; : 2</span><br><span class="line">    &quot;demo3&quot; : 3,</span><br><span class="line">  &#125;</span><br><span class="line">  lb_listener_port  = 80</span><br><span class="line">  instance_rpc_port = 9545</span><br><span class="line"></span><br><span class="line">  default_target_group_attr = &#123;</span><br><span class="line">    backend_protocol     = &quot;HTTP&quot;</span><br><span class="line">    backend_port         = 9545</span><br><span class="line">    target_type          = &quot;instance&quot;</span><br><span class="line">    deregistration_delay = 10</span><br><span class="line">    protocol_version     = &quot;HTTP1&quot;</span><br><span class="line">    health_check = &#123;</span><br><span class="line">      enabled             = true</span><br><span class="line">      interval            = 15</span><br><span class="line">      path                = &quot;/status&quot;</span><br><span class="line">      port                = 9545</span><br><span class="line">      healthy_threshold   = 3</span><br><span class="line">      unhealthy_threshold = 3</span><br><span class="line">      timeout             = 5</span><br><span class="line">      protocol            = &quot;HTTP&quot;</span><br><span class="line">      matcher             = &quot;200-499&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module &quot;alb&quot; &#123;</span><br><span class="line">  source  = &quot;terraform-aws-modules/alb/aws&quot;</span><br><span class="line">  version = &quot;~&gt; 6.0&quot;</span><br><span class="line"></span><br><span class="line">  name                       = &quot;alb-demo-internal-rpc&quot;</span><br><span class="line">  load_balancer_type         = &quot;application&quot;</span><br><span class="line">  internal                   = true</span><br><span class="line">  enable_deletion_protection = true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  http_tcp_listeners = [</span><br><span class="line">    &#123;</span><br><span class="line">      protocol           = &quot;HTTP&quot;</span><br><span class="line">      port               = local.lb_listener_port</span><br><span class="line">      target_group_index = 0</span><br><span class="line">      action_type        = &quot;forward&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  http_tcp_listener_rules = concat([</span><br><span class="line">    for rec, pos in local.dns_records : &#123;</span><br><span class="line">      http_tcp_listener_index = 0</span><br><span class="line">      priority                = 105 + tonumber(pos)</span><br><span class="line">      actions = [</span><br><span class="line">        &#123;</span><br><span class="line">          type               = &quot;forward&quot;</span><br><span class="line">          target_group_index = tonumber(pos)</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">      conditions = [</span><br><span class="line">        &#123;</span><br><span class="line">          host_headers = [&quot;$&#123;rec&#125;.manjusaka.me&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ], [&#123;</span><br><span class="line">      http_tcp_listener_index = 0</span><br><span class="line">      priority                = 120</span><br><span class="line">      actions = [</span><br><span class="line">        &#123;</span><br><span class="line">          type = &quot;weighted-forward&quot;</span><br><span class="line">          target_groups = [</span><br><span class="line">            &#123;</span><br><span class="line">              target_group_index = 0</span><br><span class="line">              weight             = 95</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              target_group_index = 5</span><br><span class="line">              weight             = 4</span><br><span class="line">            &#125;,</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">      conditions = [</span><br><span class="line">        &#123;</span><br><span class="line">          host_headers = [&quot;demo0.manjusaka.me&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">  &#125;])</span><br><span class="line"></span><br><span class="line">  target_groups = [</span><br><span class="line">    merge(</span><br><span class="line">      &#123;</span><br><span class="line">        name_prefix = &quot;demo0&quot;</span><br><span class="line">        targets = &#123;</span><br><span class="line">          &quot;demo0-$&#123;module.ec2_instance_demo[0].tags_all[&quot;Name&quot;]&#125;&quot; = &#123;</span><br><span class="line">            target_id = module.ec2_instance_demo[0].id</span><br><span class="line">            port      = local.instance_rpc_port</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      local.default_target_group_attr,</span><br><span class="line">    ),</span><br><span class="line">    merge(</span><br><span class="line">      &#123;</span><br><span class="line">        name_prefix = &quot;demo1&quot;</span><br><span class="line">        targets = &#123;</span><br><span class="line">          &quot;demo1-$&#123;module.ec2_instance_demo[0].tags_all[&quot;Name&quot;]&#125;&quot; = &#123;</span><br><span class="line">            target_id = module.ec2_instance_demo[0].id</span><br><span class="line">            port      = local.instance_rpc_port</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      local.default_target_group_attr,</span><br><span class="line">    ),</span><br><span class="line">    merge(</span><br><span class="line">      &#123;</span><br><span class="line">        name_prefix = &quot;demo2&quot;</span><br><span class="line">        targets = &#123;</span><br><span class="line">          &quot;demo2-$&#123;module.ec2_family_c[0].tags_all[&quot;Name&quot;]&#125;&quot; = &#123;</span><br><span class="line">            target_id = module.ec2_family_c[0].id</span><br><span class="line">            port      = local.instance_rpc_port</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      local.default_target_group_attr,</span><br><span class="line">    ),</span><br><span class="line"></span><br><span class="line">    merge(</span><br><span class="line">      &#123;</span><br><span class="line">        name_prefix = &quot;demo3&quot;</span><br><span class="line">        targets = &#123;</span><br><span class="line">          &quot;demo3-$&#123;module.ec2_family_d[0].tags_all[&quot;Name&quot;]&#125;&quot; = &#123;</span><br><span class="line">            target_id = module.ec2_family_d[0].id</span><br><span class="line">            port      = local.instance_rpc_port</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      local.default_target_group_attr,</span><br><span class="line">    ), # target_group_index_3</span><br><span class="line">    merge(</span><br><span class="line">      &#123;</span><br><span class="line">        name_prefix = &quot;demonew&quot;</span><br><span class="line">        targets = &#123;</span><br><span class="line">          &quot;demo0-$&#123;module.ec2_instance_reader[0].tags_all[&quot;Name&quot;]&#125;&quot; = &#123;</span><br><span class="line">            target_id = module.ec2_instance_reader[0].id</span><br><span class="line">            port      = local.instance_rpc_port</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      local.default_target_group_attr,</span><br><span class="line">    ),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段 TF 配置描述虽然看起来长，但是实际上做的事很简单，根据不同的域名 <code>*.manjusaka.me</code> 将流量转发到不同的 instance 上。然后对于 <code>demo0.manjusaka.me</code> 这个域名，进行单独的流量灰度处理。</p><p>我们能发现，Terrafrom 这种 DSL 的解决方案所需要面临的问题就是在对于这种动态灵活的场景下，其表达能力将会有很大的局限性。</p><p>社区也充分意识到了这个问题。所以类似 Pulumi 这种基于 Python/Lua/Go/TS 等完整的编程语言的 IaC 产品就应运而生了。比如我们用 Pulumi + Python 改写上面的例子(此处由 ChatGPT 提供技术支持)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pulumi_aws <span class="keyword">import</span> alb</span><br><span class="line"></span><br><span class="line">dns_records = &#123;</span><br><span class="line">    <span class="comment"># &quot;demo0&quot; : 0,</span></span><br><span class="line">    <span class="string">&quot;demo1&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;demo2&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;demo3&quot;</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">lb_listener_port = <span class="number">80</span></span><br><span class="line">instance_rpc_port = <span class="number">9545</span></span><br><span class="line"></span><br><span class="line">default_target_group_attr = &#123;</span><br><span class="line">    <span class="string">&quot;backend_protocol&quot;</span>: <span class="string">&quot;HTTP&quot;</span>,</span><br><span class="line">    <span class="string">&quot;backend_port&quot;</span>: <span class="number">9545</span>,</span><br><span class="line">    <span class="string">&quot;target_type&quot;</span>: <span class="string">&quot;instance&quot;</span>,</span><br><span class="line">    <span class="string">&quot;deregistration_delay&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">&quot;protocol_version&quot;</span>: <span class="string">&quot;HTTP1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;health_check&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;enabled&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&quot;interval&quot;</span>: <span class="number">15</span>,</span><br><span class="line">        <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/status&quot;</span>,</span><br><span class="line">        <span class="string">&quot;port&quot;</span>: <span class="number">9545</span>,</span><br><span class="line">        <span class="string">&quot;healthy_threshold&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="string">&quot;unhealthy_threshold&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="string">&quot;timeout&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">&quot;protocol&quot;</span>: <span class="string">&quot;HTTP&quot;</span>,</span><br><span class="line">        <span class="string">&quot;matcher&quot;</span>: <span class="string">&quot;200-499&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alb_module = alb.ApplicationLoadBalancer(</span><br><span class="line">    <span class="string">&quot;alb&quot;</span>,</span><br><span class="line">    name=<span class="string">&quot;alb-demo-internal-rpc&quot;</span>,</span><br><span class="line">    load_balancer_type=<span class="string">&quot;application&quot;</span>,</span><br><span class="line">    internal=<span class="literal">True</span>,</span><br><span class="line">    enable_deletion_protection=<span class="literal">True</span>,</span><br><span class="line">    http_tcp_listeners=[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;protocol&quot;</span>: <span class="string">&quot;HTTP&quot;</span>,</span><br><span class="line">            <span class="string">&quot;port&quot;</span>: lb_listener_port,</span><br><span class="line">            <span class="string">&quot;target_group_index&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;action_type&quot;</span>: <span class="string">&quot;forward&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    http_tcp_listener_rules=[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;http_tcp_listener_index&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;priority&quot;</span>: <span class="number">105</span> + pos,</span><br><span class="line">            <span class="string">&quot;actions&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;forward&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;target_group_index&quot;</span>: pos,</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;conditions&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;host_headers&quot;</span>: [<span class="string">f&quot;<span class="subst">&#123;rec&#125;</span>.manjusaka.me&quot;</span>],</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> rec, pos <span class="keyword">in</span> dns_records.items()</span><br><span class="line">    ]</span><br><span class="line">    + [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;http_tcp_listener_index&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;priority&quot;</span>: <span class="number">120</span>,</span><br><span class="line">            <span class="string">&quot;actions&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;weighted-forward&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;target_groups&quot;</span>: [</span><br><span class="line">                        &#123;<span class="string">&quot;target_group_index&quot;</span>: <span class="number">0</span>, <span class="string">&quot;weight&quot;</span>: <span class="number">95</span>&#125;,</span><br><span class="line">                        &#123;<span class="string">&quot;target_group_index&quot;</span>: <span class="number">5</span>, <span class="string">&quot;weight&quot;</span>: <span class="number">4</span>&#125;,</span><br><span class="line">                    ],</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;conditions&quot;</span>: [&#123;<span class="string">&quot;host_headers&quot;</span>: [<span class="string">&quot;demo0.manjusaka.me&quot;</span>]&#125;],</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    target_groups=[</span><br><span class="line">        alb.TargetGroup(</span><br><span class="line">            <span class="string">f&quot;demo0-<span class="subst">&#123;module.ec2_instance_demo[<span class="number">0</span>].tags_all[<span class="string">&#x27;Name&#x27;</span>].apply(<span class="keyword">lambda</span> x: x)&#125;</span>&quot;</span>,</span><br><span class="line">            name_prefix=<span class="string">&quot;demo0&quot;</span>,</span><br><span class="line">            targets=[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;target_id&quot;</span>: module.ec2_instance_demo[<span class="number">0</span>].<span class="built_in">id</span>,</span><br><span class="line">                    <span class="string">&quot;port&quot;</span>: instance_rpc_port,</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            **default_target_group_attr,</span><br><span class="line">        ),</span><br><span class="line">        alb.TargetGroup(</span><br><span class="line">            <span class="string">f&quot;demo1-<span class="subst">&#123;module.ec2_instance_demo[<span class="number">0</span>].tags_all[<span class="string">&#x27;Name&#x27;</span>].apply(<span class="keyword">lambda</span> x: x)&#125;</span>&quot;</span>,</span><br><span class="line">            name_prefix=<span class="string">&quot;demo1&quot;</span>,</span><br><span class="line">            targets=[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;target_id&quot;</span>: module.ec2_instance_demo[<span class="number">0</span>].<span class="built_in">id</span>,</span><br><span class="line">                    <span class="string">&quot;port&quot;</span>: instance_rpc_port,</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            **default_target_group_attr,</span><br><span class="line">        ),</span><br><span class="line">        alb.TargetGroup(</span><br><span class="line">            <span class="string">f&quot;demo2-<span class="subst">&#123;module.ec2_family_c[<span class="number">0</span>].tags_all[<span class="string">&#x27;Name&#x27;</span>].apply(<span class="keyword">lambda</span> x: x)&#125;</span>&quot;</span>,</span><br><span class="line">            name_prefix=<span class="string">&quot;demo2&quot;</span>,</span><br><span class="line">            targets=[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;target_id&quot;</span>: module.ec2_family_c[<span class="number">0</span>].<span class="built_in">id</span>,</span><br><span class="line">                    <span class="string">&quot;port&quot;</span>: instance_rpc_port,</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            **default_target_group_attr,</span><br><span class="line">        ),</span><br><span class="line">        alb.TargetGroup(</span><br><span class="line">            <span class="string">f&quot;demo3-<span class="subst">&#123;module.ec2_family_d[<span class="number">0</span>].tags_all[<span class="string">&#x27;Name&#x27;</span>].apply(<span class="keyword">lambda</span> x: x)&#125;</span>&quot;</span>,</span><br><span class="line">            name_prefix=<span class="string">&quot;demo3&quot;</span>,</span><br><span class="line">            targets=[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;target_id&quot;</span>: module.ec2_family_d[<span class="number">0</span>].<span class="built_in">id</span>,</span><br><span class="line">                    <span class="string">&quot;port&quot;</span>: instance_rpc_port,</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            **default_target_group_attr,</span><br><span class="line">        ),</span><br><span class="line">        alb.TargetGroup(</span><br><span class="line">            <span class="string">f&quot;demo0-<span class="subst">&#123;module.ec2_instance_reader[<span class="number">0</span>].tags_all[<span class="string">&#x27;Name&#x27;</span>].apply(<span class="keyword">lambda</span> x: x)&#125;</span>&quot;</span>,</span><br><span class="line">            name_prefix=<span class="string">&quot;demonew&quot;</span>,</span><br><span class="line">            targets=[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;target_id&quot;</span>: module.ec2_instance_reader[<span class="number">0</span>].<span class="built_in">id</span>,</span><br><span class="line">                    <span class="string">&quot;port&quot;</span>: instance_rpc_port,</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            **default_target_group_attr,</span><br><span class="line">        ),</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你看，整体的用法是不是更贴近于我们的使用习惯，其表达力也更好</p><h3 id="缺陷二：和业务需求之间的-Gap"><a href="#缺陷二：和业务需求之间的-Gap" class="headerlink" title="缺陷二：和业务需求之间的 Gap"></a>缺陷二：和业务需求之间的 Gap</h3><p>实际上在云时代的 IaC 工具，更多的去解决的是基础设施的存在性的问题。而对于已有基础设施的编排与更合理的利用实际上是存在比较大的 Gap 的。我们怎么样将应用部署到这些基础资源上。怎么样去调度这些资源。实际上是个很值得玩味的一个问题。</p><p>实际上可能出乎人们的意料，实际上 Kubernetes/Nomad 实际上就在尝试解决这样的问题。可能有人在思考，什么？这个也算是 IaC 工具？毫无疑问的是嘛，不信你对照一下我们前面列的 IaC 的几个核心特征</p><ol><li>最终的产物是 machine readable 的的产物。可能是一份代码，也可能是一份配制文件（YAML 工程师表示认可）</li><li>基于 machine readable 的产物，可以进一步依赖已有的 VCS 系统（SVN，Git）等做版本管理（manifest 随着仓库走）</li><li>基于 machine readable 的产物，可以进一步依赖已有的 CI/CD 系统（Jenkins，Travis CI）等做持续集成/持续交付（argocd 等平台提供了进一步的支持）</li></ol><p>同时我们在对应的配置文件里，可以声明我们所需要 CPU/Mem，需要的磁盘/远程盘，需要的网关等。同时这一套框架实际上将计算 Infra 进行了一个相对通用性的抽象，让业务百分之八十的场景下并不需要去考虑底层 Infra 的细节。</p><p>但是实际上这套已经存在的方案又会存在一些问题。比如其复杂度的飙升，self-hosted 的运维成本，以及一些抽象泄漏带来的问题。</p><h3 id="缺陷三：质量性的偏差"><a href="#缺陷三：质量性的偏差" class="headerlink" title="缺陷三：质量性的偏差"></a>缺陷三：质量性的偏差</h3><p>云时代新生的 IaC，其 scope 相较于传统的诸如 ansible 之类的 IaC 工具范围更大，野心也更大。所带来的副作用就是其质量的偏差。这个话题可以分为两方面说</p><p>第一点来看，诸如 Terraform 这样的 IaC 工具，通过官方提供的 Provider 实现了对 AWS/Azure/GCP 等平台的支持。但是即便是官方支持，其 Provider 里设计的一些逻辑，和平台侧在交互式界面里的设计逻辑并不一致。比如我之前吐槽过“比如 Aurora DB Instance 的 delete protection 在 Console 创建时默认打开，而 TF 里是默认关闭”。这实际上会在使用的时候，给开发者带来额外的心智负担</p><p>第二点来看，IaC 工具极度依赖社区（此处的社区饱含开源社区和各类商业公司）。不同于 Ansible 等老前辈，其周边设施的质量相对稳定。Terraform 等新生代的 IaC 周边的质量一言难尽。比如国内诸如福报云，华为云，腾讯云等厂商提供的 Provider 一直被人诟病。而不少大型的面向研发者的 SaaS 平台没有官方提供的 Provider 等（比如 Newrelic）</p><p>同时，云厂商所提供的一些功能实际上是和通用性 IaC 工具所冲突的。比如 AWS 的 WAF 工具，其中有一个功能是基于 IPSet 进行拦截，这个时候如果 IPSet 非常大，那么使用通用性的 IaC 工具进行描述将会是一个灾难性的存在。这个时候对于类似的场景，只能基于云厂商自己的 SDK 进行封装，云厂商提供的 SDK 质量合格还好。如果像福报云这样的神奇的 SDK 设计的话，那就只能自求多福了。。</p><h3 id="缺陷四：面对开发者体验的不足"><a href="#缺陷四：面对开发者体验的不足" class="headerlink" title="缺陷四：面对开发者体验的不足"></a>缺陷四：面对开发者体验的不足</h3><p>开发者体验实际上现在是一个比较热门的话题。毕竟没有人愿意将自己宝贵的生命来做重复的工作。就目前而言，主要的 IaC 工具都是 For Production Server 的，而不是 For Developer Experience 的，导致我们用的时候，其体验就很一般。</p><p>比如我们现在有一个场景，我们需要在 AWS 上给研发的同学批量开一批 EC2 Instance 作为开发机。怎么样保证研发同学在这些机器上开箱即用，就是很大的一个问题。</p><p>虽然我们可以通过预制镜像等方式提供相对统一的环境。不过我们可能会需要更进一步的去细调环境的话，那么就会比较蛋疼。</p><p>针对于类似的场景，老一点的有 Nix，新一点的有 <a href="https://github.com/tensorchord/envd">envd</a> 来解决这样一些问题。但是目前来讲，还是和已有的 IaC 产品有一些 gap。后续怎么样进行对接可能会是个很有趣的话题。</p><h3 id="缺陷五：面对新型技术栈的一些不足"><a href="#缺陷五：面对新型技术栈的一些不足" class="headerlink" title="缺陷五：面对新型技术栈的一些不足"></a>缺陷五：面对新型技术栈的一些不足</h3><p>最典型的是 Serverless 的场景。比如我举个例子，我现在有个简单的需求，就是用 Lambda 来实现一个简单的 SSR 的渲染</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">BlogPosts</span>(<span class="params">&#123; posts &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> posts.<span class="title function_">map</span>(<span class="function"><span class="params">post</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">BlogPost</span> <span class="attr">key</span>=<span class="string">&#123;post.id&#125;</span> <span class="attr">post</span>=<span class="string">&#123;post&#125;</span> /&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getServerSideProps</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> <span class="title function_">getBlogPosts</span>();</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123; posts &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数本身非常简单，但是如果我们要将这个函数部署到 Production Enviorment 里将会是一个比较麻烦的事。比如我们来思考下我们现在需要为这个简单的函数准备什么样的 infra</p><ol><li>一个 lambda 实例</li><li>一个 S3 bucket</li><li>一个 APIGateway 及路由规则</li><li>接入 CDN （可选）</li><li>DNS 准备</li></ol><p>那么在 IaC Manifest + 业务代码彼此分离的情况下，我们的变更以及资源的管理将会是一个很大的问题。Vercel 在最近的 Blog <a href="https://vercel.com/blog/framework-defined-infrastructure">Framework-defined infrastructure</a> 也描述了这样的问题。我们怎么样能进一步发展为 Domain Code as Infrastructure 将会是未来的一个挑战</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章写了两天，差不多作为自己对于 IaC 这个事物的一些碎碎念（而不是 Terraform Tutorial！（逃。祝大家读的开心</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 水文 </tag>
            
            <tag> SRE </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从一个重构项目中能学到什么东西</title>
      <link href="//posts/2023/01/26/what-I-can-learn-from-a-refactor-project/"/>
      <url>//posts/2023/01/26/what-I-can-learn-from-a-refactor-project/</url>
      
        <content type="html"><![CDATA[<p>本来这篇文章是要在 2022 最后一个工作日前写完的，但是拖延癌发作，到现在才写完。不过还是发出来，希望里面的内容能帮到大家</p><span id="more"></span><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>这个重构项目如果从我第一个超大型重构 PR 算起（22年12月11日），到现在已经历史一个半月了。目前重构进度已经超过了 80%，超过6+位贡献者集体贡献。这绝对是个不小的工程了</p><p>那问题来了，我为什么要发起这个重构项目呢？</p><p>在重构项目之前，nerdctl 项目存在一个很大的问题，即 command 的入口处，flag 的处理和逻辑耦合的问题，比如用 <code>nerdctl apparmor</code> 系列的代码来举一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;text/tabwriter&quot;</span></span><br><span class="line"><span class="string">&quot;text/template&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/containerd/nerdctl/pkg/apparmorutil&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/spf13/cobra&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newApparmorLsCommand</span><span class="params">()</span></span> *cobra.Command &#123;</span><br><span class="line">cmd := &amp;cobra.Command&#123;</span><br><span class="line">Use:           <span class="string">&quot;ls&quot;</span>,</span><br><span class="line">Aliases:       []<span class="type">string</span>&#123;<span class="string">&quot;list&quot;</span>&#125;,</span><br><span class="line">Short:         <span class="string">&quot;List the loaded AppArmor profiles&quot;</span>,</span><br><span class="line">Args:          cobra.NoArgs,</span><br><span class="line">RunE:          apparmorLsAction,</span><br><span class="line">SilenceUsage:  <span class="literal">true</span>,</span><br><span class="line">SilenceErrors: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line">cmd.Flags().BoolP(<span class="string">&quot;quiet&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;Only display profile names&quot;</span>)</span><br><span class="line"><span class="comment">// Alias &quot;-f&quot; is reserved for &quot;--filter&quot;</span></span><br><span class="line">cmd.Flags().String(<span class="string">&quot;format&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Format the output using the given go template&quot;</span>)</span><br><span class="line">cmd.RegisterFlagCompletionFunc(<span class="string">&quot;format&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>, toComplete <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, cobra.ShellCompDirective) &#123;</span><br><span class="line"><span class="keyword">return</span> []<span class="type">string</span>&#123;<span class="string">&quot;json&quot;</span>, <span class="string">&quot;table&quot;</span>, <span class="string">&quot;wide&quot;</span>&#125;, cobra.ShellCompDirectiveNoFileComp</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> cmd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apparmorLsAction</span><span class="params">(cmd *cobra.Command, args []<span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">quiet, err := cmd.Flags().GetBool(<span class="string">&quot;quiet&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">w := cmd.OutOrStdout()</span><br><span class="line"><span class="keyword">var</span> tmpl *template.Template</span><br><span class="line">format, err := cmd.Flags().GetString(<span class="string">&quot;format&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> format &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;&quot;</span>, <span class="string">&quot;table&quot;</span>, <span class="string">&quot;wide&quot;</span>:</span><br><span class="line">w = tabwriter.NewWriter(cmd.OutOrStdout(), <span class="number">4</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> !quiet &#123;</span><br><span class="line">fmt.Fprintln(w, <span class="string">&quot;NAME\tMODE&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;raw&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;unsupported format: \&quot;raw\&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> quiet &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;format and quiet must not be specified together&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">tmpl, err = parseTemplate(format)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">profiles, err := apparmorutil.Profiles()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> profiles &#123;</span><br><span class="line"><span class="keyword">if</span> tmpl != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> b bytes.Buffer</span><br><span class="line"><span class="keyword">if</span> err := tmpl.Execute(&amp;b, f); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err = fmt.Fprintf(w, b.String()+<span class="string">&quot;\n&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> quiet &#123;</span><br><span class="line">fmt.Fprintln(w, f.Name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;%s\t%s\n&quot;</span>, f.Name, f.Mode)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> f, ok := w.(Flusher); ok &#123;</span><br><span class="line"><span class="keyword">return</span> f.Flush()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你能看到在函数 <code>apparmorLsAction</code> 的逻辑中包含了两个部分的东西</p><ol><li>flag 的处理（大道至简的 err 处理（XDDDDD</li><li>command logic 的处理</li></ol><p>这样的设计存在很明显的问题</p><ol><li>代码可读性与可维护性的问题，比如我需要添加一个 flag 的时候，那么需要在多处添加。而且满天飞的 flagging process 会导致提升新人进入项目的门槛</li><li>logic 的处理与 flag 的处理耦合在一起，这样会额外导致如果社区在试图基于 nerdctl 封装一套自定义的 CLI 脚手架的时候，那么会出现非常难处理的情况。</li></ol><p>同时 nercdctl 还存在另外一个问题。在 cmd 的入口处，因为同归属于一个 sub package，于是之前的开发过程中为了省事，文件之间为了省事，交叉引用了彼此的 internal helper function</p><p>在 nerdctl 项目最开始只作为 containerd CLI 的一个替代品的时候。之前的设计缺陷实际上暴露的并不明显。但是 nerdctl 完整提供了一套基于 containerd 的容器生命周期及网络管理（base on CNI）及其余进阶特性（比如 cosign，IPFS 等），开始作为 containerd 实质上的一个入口标准的时候。社区无疑会提出更高的需求。比如 <a href="https://github.com/containerd/nerdctl/issues/1631">Move *.go files for subcommand out main package nerdctl#1631</a> 就是一个很典型的例子。</p><p>在这种情况下，对于 nerdctl 的入口进行一个合理的但是大范围的重构，就是一个必须且迫在眉睫的事了。</p><blockquote><p>又到了<del>白色相薄</del>重构的季节 —- 蛮久抚子（Nadeshiko Manju）</p></blockquote><h2 id="重构过程分析"><a href="#重构过程分析" class="headerlink" title="重构过程分析"></a>重构过程分析</h2><p>好了，社区有需要，saka 哦不，蛮久抚子（Nadeshiko Manju）我就得站出来了，重构嘛，很简单嘛，Goland 搞一搞就完事了嘛。好说好说。于是我有了一个超大的 PR ：<a href="https://github.com/containerd/nerdctl/pull/1639">Refactor the package structure in cmd/nerdctl nerdctl#1639</a>。规模 +5000 -4000</p><p><img src="https://user-images.githubusercontent.com/7054676/214850761-da34600d-a9b0-42de-88e8-97643a27d61d.png" alt="よし、気合いが勝っとる!"></p><p>不过，因为这个 PR 太过于惊世骇俗，在我 COVID-19 Positive 后，Suda 开始帮我 carry 这个 PR。但是最后 Suda 也高呼不可 carry（Suda の惊く：ばか saka！）</p><blockquote><p>どうしてこうなるんだろう…初めて、リファクタリングしたいという欲求があり、リファクタリングの必要性がありました。嬉しいことが二つ重なって。その二つの嬉しさが、また、たくさんの嬉しさを連れてきてくれて。夢のように幸せな時間を手に入れたはずなのに…なのに、どうして、こうなっちゃうんだろう…<br>为什么会变成这样呢，第一次有了想重构的欲望，又有了重构的必要。两件快乐事情重合在一起。而这两份快乐，又给我带来更多的快乐。得到的，本该是像梦境一般幸福的时间……但是，为什么，会变成这样呢…… —— 《nerdctl 相薄》</p></blockquote><p>实际上原因很简单 <del>冬马小三</del> ，哦不是，是我小三，哦，不是，是我脑子被门夹了</p><p>言归正传，其实这个 PR 是个教科书式的反面例子</p><ol><li>在启动大型项目之前没有达成社区的共识</li><li>违背了 One PR for One Thing 的基本原则</li><li>重构时的无关的改动太多，导致 review 难度过大</li></ol><p>所以在吸取了 <a href="https://github.com/containerd/nerdctl/pull/1639">Refactor the package structure in cmd/nerdctl nerdctl#1639</a> 的教训后，我正式在社区提出了一个重构 Proposal <a href="https://github.com/containerd/nerdctl/issues/1680">Let’s refactor the nerdctl CLI package nerdctl#1680</a> ，在这个 Proposal 中我做了几个事情</p><ol><li>完整阐述了重构的必要性，方便社区成员后续回溯</li><li>定义了重构的几个 step</li><li>约定好了多人协作重构时所共同遵守的约定</li></ol><p>社区其余几位 maintainer 在这个 Proposal 下额外讨论了一些细节，并达成了一些共识</p><ol><li>将最终的重构范围缩小为仅处理 flagging process</li><li>优化了一些文件结构的设计</li></ol><p>截止到现在，nerdctl 的重构才算开始正式进入了一个快车道的状态。毕竟重构不是乱写，要是写错了，要向社区谢罪的。</p><p>这里面其实还有个插曲，最开始我在 Issue 中创建 TODO Task 之后，为了方便 track project 的进度，我将这些 TODO Task 直接全部转成了 Issue（然后就相当于给 subscribe 了这个 repo 的老哥们来了一个邮箱 DDOS）。这里不得不吐槽一句，GitHub 的项目管理工具真的很弱诶（XDDDDD</p><p>花开两朵，各表一只，在 Proposal 正式通过了之后，整体的重构就开始进入了快车道了，这里列一些有意思的讨论，大家有兴趣可以去看看</p><ol><li><a href="https://github.com/containerd/nerdctl/pull/1774">Refactor the apparmor flagging process nerdctl#1774</a>，Proposal 接收后的一个模板 PR，在这个 PR 下，继续细化了一些在 Proposal 中讨论没有完善的细节</li><li><a href="https://github.com/containerd/nerdctl/pull/1792">[Refactor] Refactor the build subcommand flagging process nerdctl#1792</a>，Proposal 接收后第一个比较大命令的重构，某种意义上也是一个模板 PR 了，里面就讨论了不少参数设计风格的问题</li><li><a href="https://github.com/containerd/nerdctl/pull/1837">refactor: consolidate main logic of volume.List into volume.Volumes</a>, 不属于 Proposal 原本涵盖的范围内，但是里面关于函数语义设计的讨论值得关注一下</li><li><a href="https://github.com/containerd/nerdctl/issues/1889">pkg/cmd: inconsistent arguments ordering nerdctl#1889</a>，关于函数设计风格的问题。</li></ol><p>当然还有很多 PR 中的讨论也是非常有意思的，这里就不完整列出来了。欢迎大家去直接看原始的 PR（当然欢迎加入讨论）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>差不多就这样吧，大概复盘了一下到现在为止重构过程中的得失。希望大家能喜欢</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝莲花公益小组简报</title>
      <link href="//posts/2023/01/19/simple-brief-about-blue-lotus-group/"/>
      <url>//posts/2023/01/19/simple-brief-about-blue-lotus-group/</url>
      
        <content type="html"><![CDATA[<p>愿每个人心里，都盛开着永不凋零的蓝莲花</p><p><img src="https://raw.githubusercontent.com/Zheaoli/do-something-right/71724a0e2de9d49bde5a59d4abf20c8ae3cf3710/assets/logo.svg" alt="logo"></p><span id="more"></span><p>从2021年11月第一次发起刷题公益计划，到现在也一年多时间了。起初是为了让大家有一些特殊的动力去刷题，所以有了这样的基础规则</p><ol><li>1题一元人民币，在打卡后向公益基金捐款。</li></ol><p>基金池最开始由群主承担，后续有超过25位+群友集体捐款</p><p>再后来，这个群就发展成了基于技术的各种闲聊群，推荐番毒害群友群。</p><p>到目前也差不多一年多时间了，写个简报回顾一下</p><h2 id="一、刷题公益计划"><a href="#一、刷题公益计划" class="headerlink" title="一、刷题公益计划"></a>一、刷题公益计划</h2><p>截至目前，从2021年11月开始，到2022年6月作为一个阶段的结束。</p><ol><li>共计捐款 1625 元人民币</li></ol><p>在2022年6月，经过群友同意，再经过一轮扩资后，蓝莲花小组向一个村小项目捐款 6000 元人民币</p><p><img src="https://user-images.githubusercontent.com/7054676/213406866-6de061b8-6394-4bf8-a73b-cf5a0f9c8b19.JPG" alt="村小捐款"></p><p>前不久得到反馈，这笔钱已经用在应该用的地方了。开心</p><h2 id="二-技术分享"><a href="#二-技术分享" class="headerlink" title="二. 技术分享"></a>二. 技术分享</h2><p>从2022年6月开始，群友决定在群内以一周两次的频率进行分享，截至目前举行了八次分享</p><ol><li>SRE 二三事</li><li>当前端在讨论字体时，我们在讨论什么</li><li>编译原理入门到出家</li><li>OLAP 入门出家</li><li>简单聊聊家庭网络</li><li>Homelab 101</li><li>稳定性建设101</li><li>物联网简介</li></ol><h2 id="三-开源项目"><a href="#三-开源项目" class="headerlink" title="三. 开源项目"></a>三. 开源项目</h2><p>截至目前，群友的足迹包括不仅限于</p><ol><li>Vue</li><li>SWR</li><li>containerd</li><li>envd</li></ol><p>2022 年群内也新诞生了两位开源项目的 maintainer</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>时间过的很快，转眼这个群就一年多了。很荣幸能在这个浮躁的时代里认识一些很纯粹的人。2023 一起加油</p><p>最后，<strong>愿每个人心中都能盛开着永不凋零的蓝莲花</strong></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排查一个特殊的 No space left on device</title>
      <link href="//posts/2023/01/07/special-case-no-space-left-on-device/"/>
      <url>//posts/2023/01/07/special-case-no-space-left-on-device/</url>
      
        <content type="html"><![CDATA[<p>好久没写水文了，新年第一篇水文总得写一下，完成下 OKR，正好最近帮群友查了一个特殊的 No space left on device 问题，记录一下。</p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>半夜接到群友求助，说自己的测试环境遇到了点问题，正好我还没睡，那就来看一下</p><p>问题的情况很简单，</p><blockquote><p>用 <code>docker run -d  --env-file .oss_env --mount type=bind,src=/data1,dst=/cache &#123;image&#125;</code> 启动了一个容器，然后发现在启动后业务代码报错，抛出 <strong>OSError: [Errno 28] No space left on device</strong> 的异常</p></blockquote><p>这个问题其实很典型，但是最终排查出来的结果确实非典型的。不过排查思路其实应该是很典型的线上问题的一步步分析 root casue 的过程。希望能对看官就帮助</p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>首先群友提供了第一个关键信息，空间有余量，但是就 <strong>OSError: [Errno 28] No space left on device</strong> 。那么熟悉 Linux 的同学可能第一步的排查工作就是排查对应的 inode 情况</p><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -ih</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/7054676/211155731-c54b1146-2daa-48b3-8e1e-294040d73201.png" alt="inode"></p><p>我们能看到 /data1 实际上的 inode 和整机的 inode 数量都是足够的（备注：这里是我自己在我自己的机器上复现问题的截图，第一步由群友完成，然后给我提供了信息）</p><p>那么我们继续排查，我们看到了我们使用了 <a href="#refer-anchor-1">mount bind<sup>1</sup></a> 的方式将宿主机的 /data1 挂载到了容器内部的 /cache 目录下, mount bind 可以用下面一张图来表示和 volume 的区别</p><p><img src="https://docs.docker.com/storage/images/types-of-mounts-bind.png" alt="mount bind"></p><p>都在不同版本的内核上，mount bind 的行为有一些特殊的情况，所以我们需要确认下 mount bind 的情况是否正确，我们用 <a href="#refer-anchor-2">fallocate<sup>2</sup></a> 来创建一个 1G 的文件，然后在容器内部查看文件的大小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fallocate -l 10G /cache/test</span><br></pre></td></tr></table></figure><p>文件创建没有问题，实际上我们就可以排除掉 mount bind 的缺陷了</p><p>接着，群友提供了这个盘是云厂商的云盘（经过扩容），我让群友确认下是具体的 ESSD 还是 NAS 这种走 NFS 挂载的 Block Device（这块也有坑）。确认是标准的 ESSD 后进入下一步（驱动的问题可以先排除）</p><p>接着，我们需要考虑 mount —bind 在跨文件系统情况下的问题。虽然前面一步我们成功创建了文件。但是为了保险起见，我们执行 <code>fdisk -l</code> 和 <code>tune2fs -l</code> 两个命令，来确认分区和文件系统的正确性，确认文件系统的类型都是 ext4，那么没有问题。具体两个命令的使用方式参见 <a href="#refer-anchor-3">fdisk<sup>3</sup></a> 和 <a href="#refer-anchor-4">tune2fs<sup>4</sup></a></p><p>然后再回顾我们之前直接在 <code>/cache</code> 下创建问题没有问题，那么这个时候我们心里应该大概有底，这个应该不是代码问题，也不是权限问题（这一步我额外排除镜像的构建里没有额外的用户操作），那么我们需要排除一下扩容的问题。我们将 /data1 unmount 之后，重新 mount 后，再执行容器，发现问题依旧存在，那么我们就可以去排除扩容的问题了。</p><p>现在一些常见的问题已经基本排除，那么我们来考虑文件系统本身的问题。我登录到机器上，执行了以下两个操作</p><ol><li>在出问题的目录 <code>/cache/xxx/</code> 下，我用 <code>fallocate -l</code> 创建一个报错的文件（长文件名），失败</li><li>在出问题的目录 <code>/cache/xxx/</code> 下，我用 <code>fallocate -l</code> 创建一个短文件名），成功 </li></ol><p>OK，我们现在排查路径就往文件系统异常的方向上靠了，执行命令 <a href="#refer-anchor-5">dmesg<sup>5</sup></a> 查看内核日志，发现了如下错误</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[13155344.231942] EXT4-fs warning (device sdd): ext4_dx_add_entry:2461: Directory (ino: 3145729) index full, reach max htree level :2</span><br><span class="line">[13155344.231944] EXT4-fs warning (device sdd): ext4_dx_add_entry:2465: Large directory feature is not enabled on this filesystem</span><br></pre></td></tr></table></figure><p>OK，我们期待的异常信息找到了。原因是，ext4 基于的 BTree 索引，默认情况下只允许树的层高为2，实际上就大概限制了目录下的文件数量大概在 2k-3kw 以内。经过确认，这个问题目录下的确有大量小文件。我们再用 <code>tune2fs -l</code> 确认下是否是如我们猜想，得到结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filesystem revision #:    1 (dynamic)</span><br><span class="line">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum</span><br><span class="line">Filesystem flags:         signed_directory_hash</span><br></pre></td></tr></table></figure><p>bingo，的确没有开启 <code>large_dir</code> 的选项。那么我们执行 <code>tune2fs -O large_dir /dev/sdd</code> 开启这个选项，然后再次执行 <code>tune2fs -l</code> 确认下，发现已经开启了。然后我们再次执行容器，发现问题已经解决。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>上面的问题排查看似告一段落。但是实际上并没有闭环。一个问题的闭环有两个特征</p><ol><li>定位到具体的异常代码</li><li>有最小可复现版本确认我们找到 root cause 是符合预期的。</li></ol><p>从上面 dmesg 的信息我们能定位到内核中的函数，其实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ext4_dx_add_entry</span><span class="params">(<span class="type">handle_t</span> *handle, <span class="keyword">struct</span> ext4_filename *fname,</span></span><br><span class="line"><span class="params">     <span class="keyword">struct</span> inode *dir, <span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dx_frame</span> <span class="title">frames</span>[<span class="title">EXT4_HTREE_LEVEL</span>], *<span class="title">frame</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dx_entry</span> *<span class="title">entries</span>, *<span class="title">at</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> dir-&gt;i_sb;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_dir_entry_2</span> *<span class="title">de</span>;</span></span><br><span class="line"><span class="type">int</span> restart;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">restart = <span class="number">0</span>;</span><br><span class="line">frame = dx_probe(fname, dir, <span class="literal">NULL</span>, frames);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(frame))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(frame);</span><br><span class="line">entries = frame-&gt;entries;</span><br><span class="line">at = frame-&gt;at;</span><br><span class="line">bh = ext4_read_dirblock(dir, dx_get_block(frame-&gt;at), DIRENT_HTREE);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(bh)) &#123;</span><br><span class="line">err = PTR_ERR(bh);</span><br><span class="line">bh = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BUFFER_TRACE(bh, <span class="string">&quot;get_write_access&quot;</span>);</span><br><span class="line">err = ext4_journal_get_write_access(handle, sb, bh, EXT4_JTR_NONE);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line"></span><br><span class="line">err = add_dirent_to_buf(handle, fname, dir, inode, <span class="literal">NULL</span>, bh);</span><br><span class="line"><span class="keyword">if</span> (err != -ENOSPC)</span><br><span class="line"><span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">err = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* Block full, should compress but for now just split */</span></span><br><span class="line">dxtrace(printk(KERN_DEBUG <span class="string">&quot;using %u of %u node entries\n&quot;</span>,</span><br><span class="line">       dx_get_count(entries), dx_get_limit(entries)));</span><br><span class="line"><span class="comment">/* Need to split index? */</span></span><br><span class="line"><span class="keyword">if</span> (dx_get_count(entries) == dx_get_limit(entries)) &#123;</span><br><span class="line"><span class="type">ext4_lblk_t</span> newblock;</span><br><span class="line"><span class="type">int</span> levels = frame - frames + <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> icount;</span><br><span class="line"><span class="type">int</span> add_level = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dx_entry</span> *<span class="title">entries2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dx_node</span> *<span class="title">node2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh2</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (frame &gt; frames) &#123;</span><br><span class="line"><span class="keyword">if</span> (dx_get_count((frame - <span class="number">1</span>)-&gt;entries) &lt;</span><br><span class="line">    dx_get_limit((frame - <span class="number">1</span>)-&gt;entries)) &#123;</span><br><span class="line">add_level = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">frame--; <span class="comment">/* split higher index block */</span></span><br><span class="line">at = frame-&gt;at;</span><br><span class="line">entries = frame-&gt;entries;</span><br><span class="line">restart = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (add_level &amp;&amp; levels == ext4_dir_htree_level(sb)) &#123;</span><br><span class="line">ext4_warning(sb, <span class="string">&quot;Directory (ino: %lu) index full, &quot;</span></span><br><span class="line"> <span class="string">&quot;reach max htree level :%d&quot;</span>,</span><br><span class="line"> dir-&gt;i_ino, levels);</span><br><span class="line"><span class="keyword">if</span> (ext4_dir_htree_level(sb) &lt; EXT4_HTREE_LEVEL) &#123;</span><br><span class="line">ext4_warning(sb, <span class="string">&quot;Large directory feature is &quot;</span></span><br><span class="line"> <span class="string">&quot;not enabled on this &quot;</span></span><br><span class="line"> <span class="string">&quot;filesystem&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">err = -ENOSPC;</span><br><span class="line"><span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line">icount = dx_get_count(entries);</span><br><span class="line">bh2 = ext4_append(handle, dir, &amp;newblock);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(bh2)) &#123;</span><br><span class="line">err = PTR_ERR(bh2);</span><br><span class="line"><span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line">node2 = (<span class="keyword">struct</span> dx_node *)(bh2-&gt;b_data);</span><br><span class="line">entries2 = node2-&gt;entries;</span><br><span class="line"><span class="built_in">memset</span>(&amp;node2-&gt;fake, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> fake_dirent));</span><br><span class="line">node2-&gt;fake.rec_len = ext4_rec_len_to_disk(sb-&gt;s_blocksize,</span><br><span class="line">   sb-&gt;s_blocksize);</span><br><span class="line">BUFFER_TRACE(frame-&gt;bh, <span class="string">&quot;get_write_access&quot;</span>);</span><br><span class="line">err = ext4_journal_get_write_access(handle, sb, frame-&gt;bh,</span><br><span class="line">    EXT4_JTR_NONE);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line"><span class="keyword">if</span> (!add_level) &#123;</span><br><span class="line"><span class="type">unsigned</span> icount1 = icount/<span class="number">2</span>, icount2 = icount - icount1;</span><br><span class="line"><span class="type">unsigned</span> hash2 = dx_get_hash(entries + icount1);</span><br><span class="line">dxtrace(printk(KERN_DEBUG <span class="string">&quot;Split index %i/%i\n&quot;</span>,</span><br><span class="line">       icount1, icount2));</span><br><span class="line"></span><br><span class="line">BUFFER_TRACE(frame-&gt;bh, <span class="string">&quot;get_write_access&quot;</span>); <span class="comment">/* index root */</span></span><br><span class="line">err = ext4_journal_get_write_access(handle, sb,</span><br><span class="line">    (frame - <span class="number">1</span>)-&gt;bh,</span><br><span class="line">    EXT4_JTR_NONE);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">char</span> *) entries2, (<span class="type">char</span> *) (entries + icount1),</span><br><span class="line">       icount2 * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dx_entry));</span><br><span class="line">dx_set_count(entries, icount1);</span><br><span class="line">dx_set_count(entries2, icount2);</span><br><span class="line">dx_set_limit(entries2, dx_node_limit(dir));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Which index block gets the new entry? */</span></span><br><span class="line"><span class="keyword">if</span> (at - entries &gt;= icount1) &#123;</span><br><span class="line">frame-&gt;at = at - entries - icount1 + entries2;</span><br><span class="line">frame-&gt;entries = entries = entries2;</span><br><span class="line">swap(frame-&gt;bh, bh2);</span><br><span class="line">&#125;</span><br><span class="line">dx_insert_block((frame - <span class="number">1</span>), hash2, newblock);</span><br><span class="line">dxtrace(dx_show_index(<span class="string">&quot;node&quot;</span>, frame-&gt;entries));</span><br><span class="line">dxtrace(dx_show_index(<span class="string">&quot;node&quot;</span>,</span><br><span class="line">       ((<span class="keyword">struct</span> dx_node *) bh2-&gt;b_data)-&gt;entries));</span><br><span class="line">err = ext4_handle_dirty_dx_node(handle, dir, bh2);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line">brelse (bh2);</span><br><span class="line">err = ext4_handle_dirty_dx_node(handle, dir,</span><br><span class="line">   (frame - <span class="number">1</span>)-&gt;bh);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line">err = ext4_handle_dirty_dx_node(handle, dir,</span><br><span class="line">frame-&gt;bh);</span><br><span class="line"><span class="keyword">if</span> (restart || err)</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> dx_root *dxroot;</span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">char</span> *) entries2, (<span class="type">char</span> *) entries,</span><br><span class="line">       icount * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dx_entry));</span><br><span class="line">dx_set_limit(entries2, dx_node_limit(dir));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set up root */</span></span><br><span class="line">dx_set_count(entries, <span class="number">1</span>);</span><br><span class="line">dx_set_block(entries + <span class="number">0</span>, newblock);</span><br><span class="line">dxroot = (<span class="keyword">struct</span> dx_root *)frames[<span class="number">0</span>].bh-&gt;b_data;</span><br><span class="line">dxroot-&gt;info.indirect_levels += <span class="number">1</span>;</span><br><span class="line">dxtrace(printk(KERN_DEBUG</span><br><span class="line">       <span class="string">&quot;Creating %d level index...\n&quot;</span>,</span><br><span class="line">       dxroot-&gt;info.indirect_levels));</span><br><span class="line">err = ext4_handle_dirty_dx_node(handle, dir, frame-&gt;bh);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line">err = ext4_handle_dirty_dx_node(handle, dir, bh2);</span><br><span class="line">brelse(bh2);</span><br><span class="line">restart = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> journal_error;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">de = do_split(handle, dir, &amp;bh, frame, &amp;fname-&gt;hinfo);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(de)) &#123;</span><br><span class="line">err = PTR_ERR(de);</span><br><span class="line"><span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line">err = add_dirent_to_buf(handle, fname, dir, inode, de, bh);</span><br><span class="line"><span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">journal_error:</span><br><span class="line">ext4_std_error(dir-&gt;i_sb, err); <span class="comment">/* this is a no-op if err == 0 */</span></span><br><span class="line">cleanup:</span><br><span class="line">brelse(bh);</span><br><span class="line">dx_release(frames);</span><br><span class="line"><span class="comment">/* @restart is true means htree-path has been changed, we need to</span></span><br><span class="line"><span class="comment"> * repeat dx_probe() to find out valid htree-path</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (restart &amp;&amp; err == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> again;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ext4_dx_add_entry</code> 函数的主要功能是将新的目录项添加到目录索引中，我们能看到这段函数在 <code>add_level &amp;&amp; levels == ext4_dir_htree_level(sb)</code> 这里检查对应的特性是否打开，以及当前 BTree 层高，如果超出限制，则返回 <code>ENOSPC</code> 即 ERROR 28</p><p>好了，在复现异常之前，我们来获取下这个函数的被调用路径。这里我用 eBPF 的 trace 来获取 stacktrace，因为与主体无关，我在这里就不放代码了</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ext4_dx_add_entry</span><br><span class="line">ext4_add_nondir</span><br><span class="line">ext4_create</span><br><span class="line">path_openat</span><br><span class="line">do_filp_open</span><br><span class="line">do_sys_openat2</span><br><span class="line">do_sys_open</span><br><span class="line">__x64_sys_openat</span><br><span class="line">do_syscall_64</span><br><span class="line">entry_SYSCALL_64_after_hwframe</span><br><span class="line">[unknown]</span><br><span class="line">[unknown]</span><br></pre></td></tr></table></figure><p>那么我们怎么验证这个是我们的异常呢</p><p>首先我们利用 eBPF + kretproble 来获取 <code>ext4_dx_add_entry</code> 的返回值，如果返回值是 <code>ENOSPC</code>，则我们就可以确定这个是我们的异常</p><p>代码如下（不要问我这里为啥不用 Python 写，要写 C 了（</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">BPF_RINGBUF_OUTPUT(events, 65536);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">struct event_data_t &#123;</span></span><br><span class="line"><span class="string">    u32 pid;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int trace_ext4_dx_add_entry_return(struct pt_regs *ctx) &#123;</span></span><br><span class="line"><span class="string">    int ret = PT_REGS_RC(ctx);</span></span><br><span class="line"><span class="string">    if (ret == 0) &#123;</span></span><br><span class="line"><span class="string">        return 0;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    u32 pid=bpf_get_current_pid_tgid()&gt;&gt;32;</span></span><br><span class="line"><span class="string">    struct event_data_t *event_data = events.ringbuf_reserve(sizeof(struct event_data_t));</span></span><br><span class="line"><span class="string">    if (!event_data) &#123;</span></span><br><span class="line"><span class="string">        return 0;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    event_data-&gt;pid = pid;</span></span><br><span class="line"><span class="string">    events.ringbuf_submit(event_data, sizeof(event_data));</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_text)</span><br><span class="line"></span><br><span class="line">bpf.attach_kretprobe(event=<span class="string">&quot;ext4_dx_add_entry&quot;</span>, fn_name=<span class="string">&quot;trace_ext4_dx_add_entry_return&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_event_data</span>(<span class="params">cpu, data, size</span>):</span><br><span class="line">    event =  bpf[<span class="string">&quot;events&quot;</span>].event(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Process <span class="subst">&#123;event.pid&#125;</span> ext4 failed&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf[<span class="string">&quot;events&quot;</span>].open_ring_buffer(process_event_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bpf.ring_buffer_consume()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>然后我们写段很短的 Python 脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200000000</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">100000</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;we have created <span class="subst">&#123;i&#125;</span> files&quot;</span>)</span><br><span class="line">    filename=<span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">    file_name=<span class="string">f&quot;/data1/cache/<span class="subst">&#123;filename&#125;</span>+<span class="subst">&#123;filename&#125;</span>.txt&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&quot;w+&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后我们看到执行结果</p><p><img src="https://user-images.githubusercontent.com/7054676/211157342-812406e1-45c4-42f0-9ff4-3c4c3d5bcb05.png" alt="执行结果"></p><p>符合预期，那么我们可以说这个问题的排查路径的因果关系链完整了。那么我们也可以正式宣告解决了这个问题了</p><p>那么锦上添花的一点，对于这种上游的问题，我们如果能找到具体在什么时间点进行了修复，那就更好了。就这个 case 而言，ext4 的 large_dir 在 Linux 4.13 中得到引入，具体可以参见 <a href="#refer-anchor-6">88a399955a97fe58ddb2a46ca5d988caedac731b<sup>6</sup></a> 这个 commit。</p><p>OK 这个问题就告一段落</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这个问题比较冷门，但是排查方式其实是挺典型的线上问题的排查方法。对于问题，不要预设结果，一步步的根据现象去逼近最终的结论。以及 eBPF 真的好东西，能帮助做很多内核的事。最后我的 Linux 文件系统方面的底子还是太薄弱了，希望后面能重点加强一下</p><p>差不多就这样</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="refer-anchor-1"></div><ul><li>[1]. <a href="https://docs.docker.com/storage/bind-mounts/">https://docs.docker.com/storage/bind-mounts/</a></li></ul><div id="refer-anchor-2"></div>]- [2]. [https://man7.org/linux/man-pages/man2/fallocate.2.html](https://man7.org/linux/man-pages/man2/fallocate.2.html)<div id="refer-anchor-3"></div><ul><li>[3]. <a href="https://man7.org/linux/man-pages/man8/fdisk.8.html">https://man7.org/linux/man-pages/man8/fdisk.8.html</a></li></ul><div id="refer-anchor-4"></div><ul><li>[4]. <a href="https://linux.die.net/man/8/tune2fs">https://linux.die.net/man/8/tune2fs</a></li></ul><div id="refer-anchor-5"></div><ul><li>[5]. <a href="https://man7.org/linux/man-pages/man1/dmesg.1.html">https://man7.org/linux/man-pages/man1/dmesg.1.html</a></li></ul><div id="refer-anchor-6"></div><ul><li>[6]. <a href="https://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4.git/commit/?h=dev&amp;id=88a399955a97fe58ddb2a46ca5d988caedac731b">https://git.kernel.org/pub/scm/linux/kernel/git/tytso/ext4.git/commit/?h=dev&amp;id=88a399955a97fe58ddb2a46ca5d988caedac731b</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stay Simple, Stay Naive</title>
      <link href="//posts/2023/01/01/stay-simple-stay-naive/"/>
      <url>//posts/2023/01/01/stay-simple-stay-naive/</url>
      
        <content type="html"><![CDATA[<p>本来想在农历年前交年终总结的，不过想了想，去年的年终总结就因为太懒导致我鸽了。所以这个“双年”怎么也得总结下2022了。不过说起来怎么还没去字节，就开始 ego 了起来。</p><span id="more"></span><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>实际上每年都在觉得这一年很魔幻，但是下一年总会跳出来说“这一年更魔幻”。不过这也是人生的乐趣吧。</p><p>看了下20年总结的标题叫做”但行好事，莫问前程“，去年一下想不起标题，群内求助了下，发现”Stay Simple，Stay Naive“这个标题还不错，挺适合作为去年的总结与展望的。不过在写下这点文字的时候发现当年 +1S 的对象也已经仙去了。怎么说心里也还是有点很奇怪的感觉在里面。</p><p>不过，一日膜法，终身膜法，所以就还是 Naive 的 +1S 吧</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>去年从年初开始，我从太极图形离职后，就开始进入了我数字游民的生活。作为一个 FreeLancer，可能最大的好处就在于说免去了通勤的时间后，我可以有更多的时间做自己的事（睡大觉（不是</p><p>在离职之后，和女朋友一起换了一个新的房子，有着很大的落地窗的露台，采光很好，所以让我在这里有时间安心做一些自己的事情</p><p><img src="https://user-images.githubusercontent.com/7054676/166151791-40f3b47c-a649-4b9e-bb79-c58ccd263fd2.png" alt="老夫的专属少女阳台！"></p><p>所以去年在有自己的时间的情况下，我开始看之前没有怎么涉猎的杂书，印象比较深的有这样几本</p><ol><li>人造美人</li><li>置身事内：中国政府与经济发展</li><li>唐史并不如烟</li><li>最伟大的交易</li><li>病人家属，请来一下</li><li>昨日的世界</li><li>成为一颗星：宇航学员日记</li></ol><p>整体的阅读量在20本左右吧。然后发现，你去慢慢找书，然后发现某个作者的风格很符合你的 XP 是件非常幸福的事。</p><p>在看书之余，我也开始看番了，这个行动一度占据了我 Q3/Q4 很多业余时间（导致我这段时间不去干其余事了（你们这个群害人不浅啊。当然，补剧，看纪录片，也都是这一年的一部分，过这对于我来说实际上也是全新的体验了。技术和睡觉之外的世界也是格外的大啊</p><p>然后家里新入职了两只猫咪，现在家里整整有六只猫，这对于我来说完全是幸福的烦恼。撸猫一时爽，一直撸猫一直爽。（当然铲屎和猫咪集体生病的时候就很不爽了。</p><p>当然好事说了这么多，当然要说点坏事了，去年的减肥计划执行的很不彻底，以及去年的运动计划也没有执行，呜呜呜呜呜。</p><p>从去年开始再次勇敢面对抑郁症的现实后，在药物和整体相对自由的环境的情况下，我自己的精神状态控制的也还不错。不过可能因为这一年是我被性侵到现在第十五个年头的缘故吧，去年的噩梦有点多，希望时间能继续治愈一切吧。（不过说起来，我讨厌药物副作用（真的让人很不爽</p><p>说回来，去年有了自己时间后，家里也添置了不少能极大提升自己生活幸福度的物件</p><ol><li>一个 8*16T 的 NAS，妈妈再也不担心我的动漫没地方放了！</li><li>一个 4090 + i9-13900K 的台式机，工作娱乐都很爽</li><li>Apple TV 4K 配合局域网 NAS，我和妹子一起看了不少的电影（</li><li>一个尺寸合格的 Android 手机，追网络小说（</li><li>一个顶配的 iPad Pro 12.9 寸，轻办公和看微信读书都很好用（我真的没用来盖泡面看爱奇艺！</li></ol><p>另外一提的是，去年公益我也在继续坚持坐着，我自己累计捐款10k+，然后公益群的小伙伴一起凑了点钱给一个村小捐款6K+，另外一点非常开心的是，我也带动了身边的人，去捐助学生。教育是最好的公益.jpg。不知道还能坚持多久，但是还是做一些力所能及的事吧。</p><p>差不多是这样，2022 整体的生活也还算是有滋有味。不过心里还是会隐隐约约有点担心，在整体局势下行的情况下，我这样小确幸的生活又能持续多久呢？</p><h2 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h2><p>感情步入了第四个年头，去年因为北京疫情的原因，和荆澈同学一起朝夕相处（这是真的朝夕相处）了一年了。用我很喜欢的《士兵突击》里的一句台词</p><blockquote><p>常相守是个考验，随时随地，一生。</p></blockquote><p>两个人朝夕相处，因为各种细节上的差异，一定会有一些小的争执与摩擦。这个时候就需要两个人相互包容。相互理解。说道这里我就很庆幸荆澈同学对我的包容与监督了。她经常碎碎念的督促我起床，督促我运动，督促我继续改掉我很多不好的习惯Hhhhhh（mua.jpg</p><p>很多时候，我半夜噩梦醒来，总会下意识的去抱着荆澈同学，她即便迷迷糊糊搞不清情况，也会转过来给我抱抱。某种意义上，荆澈同学的陪伴，是让我不断走下去的勇气的源泉</p><p>说回来，朝夕相处也未必是个坏事，去年和荆澈同学一起去公园散步，一起逛吃逛吃的时间多了很多。也一起去泡了温泉，一起去了环球影城（Remote 万岁！）。</p><p>希望 2023 年也和荆澈同学也能一起顺顺利利的走下去，完成对荆澈同学的承诺（我要有八块腹肌.jpg（以及去旅游，去做更多的手工艺品！</p><p>反正我一如既往的 <strong>感激并享受着荆澈同学的爱</strong> 。</p><h2 id="工作与技术"><a href="#工作与技术" class="headerlink" title="工作与技术"></a>工作与技术</h2><p>首先聊聊我自己的变更，如前面所说，在22年初，因为自己的规划和身体的原因，我正式离开了太极（说实话挺舍不得这群同事的），正式开始了我数字游民的生活。目前来说，我依靠给一些客户做 SRE 方面的能力输出为生。这对于我来讲其实是个蛮大的挑战。因为我之前的定位其实更多的还是偏向于一个 Infra Developer，将 SRE 作为我正式工作方向，其实对于我来讲，也是开天辟地头一回了（感谢客户爸爸的信任</p><p>去年其实工作内容也发生了很大的转变，也让我更多的意识到了自己的不足。如果说自己之前是一个纯粹的 IC 的角色，那么去年我的工作内容的边界实际上有了不少的扩展。我需要去更多的考虑协调的有效性，体系化的建设。很多时候我都在笑称我自己这周写的文档可能比我写的代码还多了（XD</p><p>不过这对于我来说也是一个好事，思路的转变我相信会让我提升很多。</p><p>2022另外一个比较重大的改变就是从2022二月开始，在 Xuanwo 几位好友的启发下，我开始正式的以公开的方式，记录自己每周的生活与技术学习（我老板说会看我周报（摊手。这一点其实对于我自己来说，也是比较好的一个手段吧。用一个锚点，去约束自己的生活（面向周报有内容式学习（不是），去记录自己的一些感悟与心得（输出了不少稳定性与可观测性的东西。希望23年能继续坚持。</p><p>技术方面的话，去年的成长我自己觉得也还是比较明显的。一方面是在开源社区这块。年初因为寻找 Docker 替代品，机缘巧合之下开始为 <a href="https://github.com/containerd/nerdctl">nerdctl</a> 做输出，6月被 Promote 成为 Reviewer，12月被 Promote 成为 Committer。这也是我比较深度的参与开源社区了。同时我自己也会和身边的好友去交流关于开源社区的东西，比如和 Xuanwo 一起聊聊他的 OpenDAL，和 GaoCe GG 一起聊聊/吐槽他的创业项目 envd （他时常因为我比他还看好这个项目而惊讶（这个项目真的是好项目啊！。我自己觉得这一年去给不同社区贡献代码，参与讨论，对于我自己的提升是全方位的，更明确的意识到自己的 naive，也接受来自不同人的帮助与指导。如同我之前在一篇文章中的感悟一样</p><blockquote><p>从互联网诞生之初到现在，开源这一极具理想主义气质的行为事实上的改变了这个世界。世界各地的人都在开源的旗帜下，自由的挥发着自己的创意，尽情的一点点的改变着这个世界。有些时候想到我会有机会去参与到这样一个伟大的活动中，我会不由自主的颤栗。我很庆幸在我最初的职业生涯里就加入到了这个伟大的事业，我也希望我身边会有越来越多的人参与进来，一起挥洒着汗水，一起在这个操蛋但是又美好的世界里，找到自己心灵的应许之地。</p></blockquote><p>另外一方面的话，去年在技术深度这块做的也还算 OK，继续在之前自己积累的可观测性和稳定性方面精进，系统性的提升自己的一些体系化的思考（抽象成方法论），也继续在内核和 eBPF 这块做一些有意思的工作（比如帮助人去做一些小的工具）。希望23年也能继续勇猛精进</p><p>说起来，去年有一个很大的收获不知道算不算技术这块的，姑且算吧。之前组建的刷题群在去年格外的活跃，大家一起刷题，一起捐款，一起推荐番祸害群主（不是），一起做开源（去年群内诞生了两位开源项目的 maintainer），我很多时候遇到各种事情的时候都会在群里和群友们一起吐槽和发泄。很多时候我自己在感叹，在这个人心浮躁的时代，能遇到这样一群热情又纯粹的人，实则人生幸事，当浮一大白（不过我肝不好，就以零度代酒干了这杯）</p><p>差不多就这些，去年也还零零碎碎的做了很多其余的工作，开始翻译人生第一本书,保持了每日一题，读了十多篇论文，组织了好几次群内分享，写自己的 toy，很多很多。很多人觉得程序员是个很枯燥的行业。但是说实话，这一行真的让人迷醉</p><p><img src="https://user-images.githubusercontent.com/7054676/210173110-89ff93d9-9b9d-467c-b8e4-58de1d4a5f50.png" alt="勉强没有虚度的一年"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对比了下年初的目标，然后自评了一下差不多能给自己个3.5的绩效吧<br>优点和缺点都比较明显，聊聊缺点吧</p><ol><li>是自己在开源这块有技术深度的产出还是不够</li><li>自律性还是差了一些，花了不少时间在睡懒觉，玩游戏，看番上了</li><li>专注度上差了一些，一些拟好的目标经常走神</li><li>自己的运动目标没达成</li></ol><p>缺点和改进方向还是比较明确的，希望明年继续努力。我自己目前列好的一些 OKR 差不多是这样</p><ol><li>O1：代码能力<ol><li>学习前端，成为一个前端开源项目的 maintainer</li><li>继续保持 Leetcode 每日一题，确保百分之70以上的 daily 随机 medium 及以上题目能不看题解写出来</li></ol></li><li>O2: 读书<ol><li>重读 TCP 卷一</li><li>读完 CSAPP，并保证每章作业完成率不低于百分之八十</li><li>剩下的书待定</li></ol></li><li>O3：分享<ol><li>参考 xdp-tutorial 写一个 netfilter-tutorial</li><li>全年群内分享5次以上</li><li>六篇有效博客</li></ol></li><li>O4: 努力生活<ol><li>通过运动的方式，将体重降到 145（和某位群友赌了两千块的公益捐款）</li><li>和女朋友去三个以上地方玩</li><li>争取每周超过3点睡觉不超过两天（现在就emmm</li></ol></li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>2022 实际上真的挺魔幻的，不过套用狄更斯的一句老掉牙的话</p><blockquote><p>这是最坏的一年，这也是最好的一年</p></blockquote><p>说实话我也不知道23年会怎么样，未来几年会怎么样。不过无论怎么样，爱与希望总是会支撑我们走过一年年。嗯，Everything is gonna be OK.</p><p>说起来，今年有人问过我我想成为一个怎么样的人，我想了下，这么回答到</p><blockquote><p>我希望身边的人在很多年后，和老头老太太聊天或者给自己孙子提到我的时候会这么说”我之前认识一个叫 saka 的人，是个还不错的人“，那么我心满意足了</p></blockquote><p>Stay Simple，Stay Naive，永远谦逊，敬畏生活，勇敢前行</p><p>再见 2022，你好 2023</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 总结 </category>
          
          <category> 秀恩爱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我所热爱的开源社区</title>
      <link href="//posts/2022/11/22/why-i-love-the-open-source-community/"/>
      <url>//posts/2022/11/22/why-i-love-the-open-source-community/</url>
      
        <content type="html"><![CDATA[<p>今天是个不错的日子，最开始由我带进 <a href="https://github.com/containerd/nerdctl">nerdctl</a> 社区的 <a href="https://twitter.com/realyuchanns">@yuchanns</a> 因为其很活跃的表现被项目的主要维护者 <a href="https://twitter.com/AkihiroSuda">@AkihiroSuda</a> 推荐成为了项目的 maintainer，参见 <a href="https://github.com/containerd/nerdctl/pull/1540">nerdctl#PR1540</a>。而我也在这个项目中被提名成为 committer，参见 <a href="https://github.com/containerd/nerdctl/pull/1539">nerdctl#1539</a>。加上今天的公益群有太多关于开源的讨论，所以我想写篇文章记录下我自己的经历，希望能帮助更多的人热爱开源，拥抱开源。</p><span id="more"></span><h2 id="为什么我会参加开源"><a href="#为什么我会参加开源" class="headerlink" title="为什么我会参加开源"></a>为什么我会参加开源</h2><p>我参与的第一个开源项目，应该是能追溯到16年，我还没有本科毕业的时候，当时的我参加了 <a href="https://github.com/xitu/gold-miner">稀土掘金翻译计划</a>（slogan 里说的最好的英文技术资讯翻译项目，我觉得毫不夸张），在这个项目里我第一次接触到了 Git Workflow，也完整接触到了 GitHub 这个世界最大的同性交友社区（大雾（不过我相交至今对我帮助巨大的几位密友真的是通过这个项目结识的）。而我第一个参与的代码项目，应该可以追溯到17年3月，我给 <a href="https://github.com/sanic-org/sanic">Sanic</a> 这个项目新增了一个 Code Example，参见 <a href="https://github.com/sanic-org/sanic/pull/558">Sanic#PR558</a>。</p><p>在往后，我就一直在不断的参与开源社区，到现在为止，我贡献过不少的开源项目，CPython，Docker/Moby，Taichi，Logseq，Kubernetes，Dubbo，TiDB，nerdctl 等等。我也在不断的学习开源社区的工作方式，我也在不断的学习开源社区的文化，我也在不断的学习开源社区的技术。（最后面这句由 GitHub Copilot 自动完成）（XD</p><p>那么回到这一章的标题，我为什么会参与开源社区？或者更功利的说，开源社区给我带来了什么样的利益？</p><p>无他，对于我自己全方位的成长。</p><p>首先，参与开源社区对于我来讲，对于我自己是一个非常非常棒的提升的过程。你可以在这里面学到很多的东西</p><ol><li>怎么样去有效的说服别人</li><li>怎么样去写好 UT</li><li>怎么样去打磨 code style</li><li>怎么样去帮助同为新人的其余人</li></ol><p>更早的链接先不谈，大家可以看我 2022 年在 <a href="https://github.com/containerd/nerdctl">nerdctl</a> 项目上的贡献 <a href="https://github.com/containerd/nerdctl/pulls?q=is%3Apr+is%3Aclosed+author%3AZheaoli">nerdctl#ZheaoLi</a>，大家可以很明显的看到，我的 PR 从最开始到后面，无论是质量，还是风格都有不少的提升。这实际上就是开源社区所带给我的最直观的成长。我很庆幸有很棒的 Community Mentor 对我的 PR 从不放水，Review 非常严格，促使我不断的成长。</p><p>同时，让我也有机会去表达自己的想法，去发起 Proposal（比如 <a href="https://github.com/containerd/nerdctl">nerdctl#Issue1387</a>），去学会做一个 Owner，去帮助更多的新人参与进来。</p><p>某种意义上，这是日常的工作所给予不了我的特殊的体验，开源社区相对较少的利益纠葛，会让互利互惠的行为变得更纯粹，更加的自然。也会让人收益更大。这里引用 <a href="https://twitter.com/realyuchanns">@yuchanns</a> 今晚的一段发言</p><blockquote><p>我想大家刚学编程的时候都会有这种困境：学完不知道干啥、感觉好像没学，所以就想寻找各种实战教程来加深体会。<br>这种现象会在实际从事工作后迅速消除，因为有了实际应用场景。<br>但是当你对一些其他领域的东西产生兴趣，又会有这种困惑；而这是工作中不太有机会接触到的东西。除非你换了个工作、不然没法再通过工作经验来摆脱困境。<br>这时候参与到一个开放式的社区就很好了。其他人的工作中产生的需求给你提供了实战机（（<br>你不需要自己一一涉足到具体的工作中，只要解决他们延伸出来的需要，就可以有机会运用学到的东西（（</p></blockquote><p>当然，从功利的角度来说，积极的参与开源社区，你能认识很多有意思的人，让你职业生涯更为顺利也是能给你带来的好处就是了（</p><h2 id="那么怎么样去参与开源社区"><a href="#那么怎么样去参与开源社区" class="headerlink" title="那么怎么样去参与开源社区"></a>那么怎么样去参与开源社区</h2><p>参与开源社区无外乎有两种途径，</p><ol><li>自己创立一个项目的开源社区</li><li>加入一个已经存在的开源社区</li></ol><p>我主要会讨论下后者</p><p>很多人会给出开源三问 “我想参与开源社区，但是我不知道怎么做”，“我想参与开源社区，但是我不知道怎么找到一个项目”，“我想参与开源社区，但是我太菜了怎么办啊”</p><p>实际上这些问题解决起来都是没有你想象的那么困难，可能只是需要一点行动能力加一点好奇心。</p><p>实际上发展到现在，开源社区已经极其的庞大了，无论你的技术栈是什么，你都能找到合适的项目去参与。而且，开源社区的参与门槛也越来越低了，你不需要去了解整个项目的代码，你只需要去了解项目的 Issue，然后去解决这些 Issue，就可以参与到开源社区中来了。那么 How to find a project to contribute to ？</p><p>我自己的途径有两个</p><ol><li>通过 GitHub 的 Explore 页面，找一些新的项目，看这个项目是否戳中了我的痛点</li><li>社交媒体上大家的宣传</li></ol><p><a href="https://github.com/containerd/nerdctl">nerdctl</a> 这个项目实际上的来源就是当时好友 <a href="https://twitter.com/junnplus">@Junnplus</a> 在推上的推广</p><p><img src="https://user-images.githubusercontent.com/7054676/203397746-730d4e8c-7576-4652-b736-a4070f9f4516.png" alt="当时的截图"></p><p>然后我去看了下这个项目的定位，发现这个项目实际上戳中了我的痛点，于是我就开始在自己的环境中使用这个项目。</p><p>实际上去找到你感兴趣的项目实际上不是一件难事，可能只是需要一点点好奇心</p><p>那么，我找到一个项目后，我应该怎么样去参与进去？</p><p>实际上这里就需要一点行动力了，我自己大概方法是这样</p><ol><li>扫 Issue 区，以及订阅项目，一个项目的 Issue 能让我一定程度上的去了解这个项目的发展方向</li><li>我会不断的去使用这个项目，将我在使用中的问题转化成 Issue，进而转化成 PR</li><li>我会用我已有的知识进行迁移，尝试是否有可能发现新的潜在的问题</li></ol><p>以 <a href="https://github.com/containerd/nerdctl">nerdctl</a> 为例，Issue 区时不时的会有 <a href="https://github.com/containerd/nerdctl/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22">Good First Issue</a> 的出现，这个时候你可以主动的去认领对应的 Issue 进行贡献（从我的视角来看，项目的维护者对于 Good First Issue 的上心程度将会决定了一个项目的长远发展），<a href="https://twitter.com/realyuchanns">@yuchanns</a> 第一个 PR <a href="https://github.com/containerd/nerdctl/pull/1331">nerdctl#PR1331</a> 实际上就来源于我提的一个 Good First Issue <a href="https://github.com/containerd/nerdctl/issues/1330">nerdctl#1330</a>。当然对于一个已经有一定规模的项目来说，坐着等 Good First Issue 可能需要点运气，那么怎么办，答案就是第二，第三点</p><p>我在 <a href="https://github.com/containerd/nerdctl">nerdctl</a> 第一个贡献的 PR <a href="https://github.com/containerd/nerdctl/pull/790">nerdctl#PR790</a> 来自于我提出的 Issue <a href="https://github.com/containerd/nerdctl/issues/775">nerdctl#Issue775</a> ，这个 Issue 是我在使用过程中发现的 Bug，简而言之就是在私有镜像仓库下鉴权的一些问题。然后将 Issue 转化成对应的 PR 了。我在这个项目中其余的一些贡献也是修我自己遇到的一些问题</p><p>另外一个方法是，我会用我已有的知识去进行迁移，尝试是否能发现有潜在的问题。我在 <a href="https://github.com/toeverything/AFFiNE">Affine</a>(一个非常棒的笔记项目)提的 PR <a href="https://github.com/toeverything/AFFiNE/pull/403">Affine#PR403</a> 是我在本地构建 Affine 的时候，顺手读了一下他们的 Dockerfile（我是 SRE，对这个比较敏感（不然前端项目我去读 Dockerfile 干嘛），发现他们没有高效的利用缓存，然后我就提了 PR，进行了构建加速。这是实际上就是跨领域的去看一个项目能给你带来不一样的视角，进而促进你对项目的贡献。</p><p>那么，开源三问最后一问，”我想参与开源社区，但是我太菜了怎么办啊“</p><p>首先要说一点，开源社区的精髓就在于边做边学边成长，比如 <a href="https://twitter.com/realyuchanns">@yuchanns</a> 在写 <a href="https://github.com/containerd/nerdctl/pull/1407">nerdctl#PR1407</a> 的时候（这个 PR 主要是给容器新增一个可以绑定 MacAddress 的选项），他当时对于 CNI 这块也不是很熟悉，然后边做边学，我和他也在群里讨论过几次方案。最终 PR 合并的非常顺利。这某种意义上也是开源社区的一种乐趣与魅力。</p><p>那如果你说你现在就是背景知识不够，你想等再学学再写代码，那还能贡献吗？可以啊，用 <a href="https://twitter.com/tison1096">@tison</a> 的经典言论”一个社区的活绝对是很多样的“。你看，我给 <a href="https://github.com/bytebase/bytebase">bytebase</a> 提 Bug 的时候，发现他们的 Ticket 模板太难用了，然后我交了<a href="https://github.com/bytebase/bytebase/pull/3050">Bytebase#PR3050</a> 重构了他们的 Issue Template，后面他们基于我的基础上又完善了一波。所以，无论是 Issue，文档完善，帮助完善用例等，都是很棒的参与开源社区的方式。</p><p>当然可能新进来的同学还有个顾虑就是如果被拒绝了怎么办？那其实很常见，你看我拍脑袋给 <a href="https://github.com/lima-vm/lima">lima</a> 提的 <a href="https://github.com/lima-vm/lima/issues/1087">lima#Issue1087</a> 被拒的很惨。但是被拒绝也是一种学习，能让我自己从这个讨论的过程里去回顾到我思考不完善的地方。</p><p>所以看到这，你会发现，参与开源社区，真的没有那么难。需要的真的只是一点点行动力，以及一点点的好奇心而已</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从互联网诞生之初到现在，开源这一极具理想主义气质的行为事实上的改变了这个世界。世界各地的人都在开源的旗帜下，自由的挥发着自己的创意，尽情的一点点的改变着这个世界。有些时候想到我会有机会去参与到这样一个伟大的活动中，我会不由自主的颤栗。我很庆幸在我最初的职业生涯里就加入到了这个伟大的事业，我也希望我身边会有越来越多的人参与进来，一起挥洒着汗水，一起在这个操蛋但是又美好的世界里，找到自己心灵的应许之地。</p><p>Long Live the Open Source！</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重回 Windows 之路</title>
      <link href="//posts/2022/11/12/the-road-back-to-windows/"/>
      <url>//posts/2022/11/12/the-road-back-to-windows/</url>
      
        <content type="html"><![CDATA[<p>最近会回到 Windows 下办公了两周多，简单记录下自己的使用体验</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近刚配置了一台高配的主机（i9-13900k+4090），之前的 MBP 沦为开会本，开始尝试把 PC 作为主力机使用，由于驱动太新没搞上合适的 Linux 发行版，Ubuntu 系动不动又在“Ubuntu 内部错误”，所以我开始使用 Windows 作为自己的工作生活主力机。两周使用下来发现 Windows 的使用体验还是超出我的预期了。下面大概聊聊</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>时隔多年主力使用 Windows，感觉进步还是蛮大的，主要体现在</p><ol><li>系统交互上</li><li>开发者体验上</li></ol><p>系统交互上，Windows 吸收了不少其余的系统和软件的精髓，感觉进步不小，写几个我印象里比较深的吧</p><ol><li>开始菜单栏进行了改进，比之前感觉更好用了</li><li>File Explorer 的改进，比如支持 Tab 什么的，还是很舒服的</li><li>非常优秀的分屏功能，将窗口拖到屏幕上方就能选择不同的分屏比例和应用，同时在切换任务的时候，有 Task Group 的概念。这不比 macOS 高了不知道10个 Linux？</li><li>全局深色主题支持比之前好很多了</li></ol><p>整体使用下来，体验比前面的 Windows 好了不少，给人带来不少惊喜</p><p>然后在开发者体验方面，巨硬这几年拥抱开源的战略在 Windows 的开发者体验的优化体现的很不错</p><ol><li>WSL2 目前实测比 WSL1 时期好用了太多，IDE 以及其余的工具都能很好的支持</li><li>WSL2 的兼容性也出乎我的意料，我搞内核依赖的 BCC/eBPF 等工具都能在 WSL2 上正常运行，很不错</li><li>Visual Studio 对于 CMake 的支持超出了我的意料，非常不错</li></ol><p>果然巨硬现在是开发者的好朋友啊（</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>虽然 Windows 体验上有了很大的提升，但是还是有一些缺点的</p><ol><li>BUG 不少，比如在任务管理器里面重新排序任务之类的会卡界面（也有可能和我用的 dev channel 的 insider preview 有关</li><li>WSL2 的小问题不少，比如内存泄露，比如导出备份失败之类的</li><li>Windows 下面的权限管理始终是个问题，我迄今都没想明白，原神作为一个游戏要 UAC 干什么？检查我电脑上装莉莉丝的游戏了吗？</li><li>虽然有了 scope 这样的工具，Windows 上的软件包的管理还是有点蛋疼</li><li>好像没看到有类似 MacOS 上 setapp 这样的集中的软件分销体系，不知道是不是我没找到。反正买软件太分散了也挺蛋疼的</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容器 CPU 和 Memory 限制行为简述</title>
      <link href="//posts/2022/08/07/A-simple-introduction-about-cpu-and-memory-limit-in-docker/"/>
      <url>//posts/2022/08/07/A-simple-introduction-about-cpu-and-memory-limit-in-docker/</url>
      
        <content type="html"><![CDATA[<p>这篇是给之前没啥容器经验的选手准备的一篇文章，主要是讲一下容器的 CPU 和 Memory 限制行为。</p><span id="more"></span><h2 id="CPU-限制"><a href="#CPU-限制" class="headerlink" title="CPU 限制"></a>CPU 限制</h2><p>首先 Mac 或者是 Windows 选手在使用 Docker Desktop 的时候，会设置 Docker Desktop 的 CPU 限制，默认是 1，也就是说 Docker Desktop 只能使用 1 个 CPU。这是因为 Docker Desktop 裹了一层虚拟机（Windows 下应该是 WSL2/Hyper-V，Mac 下可能是 QEMU）。这相当于我们在一个特定 CPU 数量的宿主机中跑 Docker</p><p>首先提到 CPU 限制，本质上是限制进程的 CPU 使用的时间片，在 Linux 下，进程存在三种调度优先级</p><ol><li>SCHED_NORMAL</li><li>SCHED_FIFO</li><li>SCHED_RR</li></ol><p>1 用的是 Linux 中 CFS 调度器，而常见普通进程都是 SCHED_NORMAL 。OK 前提知识带过</p><p>说回容器中的 CPU 限制，目前主流语境下，容器特指以 Docker 为代表的一系列的基于 Linux 中 CGroup 和 Namespace 进行隔离的技术方案。那么在这个语境下，CPU 限制的实现利用了Linux CGroup 中三个 CPU Subsystem。我们主要关心的如下四个参数</p><ol><li>cpu.cfs_period_us</li><li>cpu.cfs_quota_us</li><li>cpu.shares</li><li>cpuset.cpus</li></ol><p>现在分别来聊一下</p><p>首先说 cpu.shares，在 Docker 中的使用参数是 —cpu-shares，本质上是一个下限的软限制，用来设定 CPU 的利用率权重。默认值是 1024。这里对于相对值可能理解有点抽象。那么我们来看个例子 假如一个 1core 的主机运行 3 个 container，其中一个 cpu-shares 设置为 1024，而其它 cpu-shares 被设置成 512。当 3 个容器中的进程尝试使用 100% CPU 的时候（因为 cpu.shares 针对的是下限，只有使用 100% CPU 很重要，此时才可以体现设置值），则设置 1024 的容器会占用 50% 的 CPU 时间。那再举个例子，之前这个场景，其余的两个容器如果都没有太多任务，那么空余出来的 CPU 时间，是可以继续被第一个 1024 的容器继续使用的</p><p>接下来聊一下 cpu.cfs_quota_us 和 cpu.cfs_period_us ，这两个是需要组合使用才能生效，本质上含义是在 cpu.cfs_period_us 的单位时间内，进程最多可以利用 cpu.cfs_quota_us （单位都是 us），如果 quota 耗尽，那么进程会被内核 throttle 。在 Docker 下，你可以利用 —cpu-period 和 —cpu-quota 这两个值分别进行设置。也可以通过 —cpu 来进行设置，当我们设置 —cpu 为 2 的时候，容器会保证 cpu.cfs_quota_us 两倍于 cpu.cfs_period_us，剩下的就以此类推了（Docker 默认的 cpu.cfs_period_us 的阈值是 100ms 即 10000us）</p><p>现在已经聊了三个参数了，那么我们什么时候该用什么参数呢。通常来说，对于性能相对敏感的进程，我们可以使用 cpu.shares 来保证进程尽可能多的使用 CPU），业务进程可以利用 cpu.cfs_quota_us 和 cpu.cfs_period_us 来保证相对较好的公平分配。但是这样也带来一个问题，就是对于业务流量比较大的应用，可能会因为频繁被 throtlle 导致我们的 RT 等指标出现毛刺。Linux 5.12 之后有了一个新功能，cpu.cfs_burst_us ，即进程可以在 CPU 利用率比较低的空闲时段积累一定的 credit，然后在密集使用的时候换取一定的 buffer，实现更少的 throttle 和更高的 CPU 利用率（当然这个特性还暂时没有被主流容器所完全支持）</p><p>现在新的问题来了，无论 share 还是 cpu.cfs_quota_us 和 cpu.cfs_period_us 被 throttle 的概率都不少，如果我们想让进程更好的利用 CPU 怎么办？答案就是 cpuset.cpus ，Docker 中的参数是 —cpuset-cpus，可以让进程进行绑核处理</p><p>嗯，CPU 的部分就到这里</p><h2 id="Mem-限制"><a href="#Mem-限制" class="headerlink" title="Mem 限制"></a>Mem 限制</h2><p>还是前提科普</p><p>首先 Mac 或者是 Windows 选手在使用 Docker Desktop 的时候，会设置 Docker Desktop 的 Mem 限制，这相当于我们在一个特定 Mem 数量的宿主机中跑 Docker</p><p>然后在我们今天的语境下，Mem 资源的限制还是依托于 CGroup 的 Memory Subsystem，参数有很多，我们目前只需要关心</p><ol><li>memory.limit_in_bytes</li></ol><p>含义即是容器的最大内存限制，如果设置为 -1，代表着无任何内存的限制。在 Docker 中的参数是 —memory。</p><p>行为的话分为这样两种情况</p><ol><li>如果系统内存还有空余，但是容器内存超过了 Limit, 那么容器进程会被 OOMKiller Kill 掉</li><li>如果系统内存先于容器达到了内核阈值，那么 OOMKiller 会在整个系统范围内根据根据负载等多个因素计算一个 score，然后 rank 后从高到低进行 OOM Kill 的操作</li></ol><p>当然实际上还有一种额外的情况。可以通过 —oom-kill-disable 参数设置 memory.oom_control 的值。如果设置为1，那么容器内存超过 Limit 就不会被 OOM Kill 掉而是会被暂停，如果设置为0，那么容器内存超过 Limit 就会被 OOM Kill 掉</p><p>嗯关于 Mem 的行为差不多就这些</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>差不多就这样吧，纯新手向的文章，水文一篇，大家别介意（</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode Weekly Contest 287 题解</title>
      <link href="//posts/2022/04/05/leetcode-weekly-contest-287/"/>
      <url>//posts/2022/04/05/leetcode-weekly-contest-287/</url>
      
        <content type="html"><![CDATA[<p>好久没打周赛了，打了一次周赛，简单的写个题解</p><span id="more"></span><h2 id="2224-Minimum-Number-of-Operations-to-Convert-Time"><a href="#2224-Minimum-Number-of-Operations-to-Convert-Time" class="headerlink" title="2224. Minimum Number of Operations to Convert Time"></a>2224. Minimum Number of Operations to Convert Time</h2><p>题面：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">You are given two strings current and correct representing two 24-hour times.</span><br><span class="line"></span><br><span class="line">24-hour times are formatted as &quot;HH:MM&quot;, where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59.</span><br><span class="line"></span><br><span class="line">In one operation you can increase the time current by 1, 5, 15, or 60 minutes. You can perform this operation any number of times.</span><br><span class="line"></span><br><span class="line">Return the minimum number of operations needed to convert current to correct.</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: current = &quot;02:30&quot;, correct = &quot;04:35&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">We can convert current to correct in 3 operations as follows:</span><br><span class="line">- Add 60 minutes to current. current becomes &quot;03:30&quot;.</span><br><span class="line">- Add 60 minutes to current. current becomes &quot;04:30&quot;.</span><br><span class="line">- Add 5 minutes to current. current becomes &quot;04:35&quot;.</span><br><span class="line">It can be proven that it is not possible to convert current to correct in fewer than 3 operations.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: current = &quot;11:00&quot;, correct = &quot;11:01&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We only have to add one minute to current, so the minimum number of operations needed is 1.</span><br></pre></td></tr></table></figure><p>这题没啥好说的吧，直接暴力计算时间写就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertTime</span>(<span class="params">self, current: <span class="built_in">str</span>, correct: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        correct_time = correct.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">        current_time = current.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">        minutes = <span class="built_in">int</span>(correct_time[<span class="number">1</span>]) - <span class="built_in">int</span>(current_time[<span class="number">1</span>])</span><br><span class="line">        hours = <span class="built_in">int</span>(correct_time[<span class="number">0</span>]) - <span class="built_in">int</span>(current_time[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> correct_time[<span class="number">1</span>] &lt; current_time[<span class="number">1</span>]:</span><br><span class="line">            minutes += <span class="number">60</span></span><br><span class="line">            hours -= <span class="number">1</span></span><br><span class="line">        results = hours</span><br><span class="line">        flag = [<span class="number">15</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">            <span class="keyword">if</span> minutes &gt;= i:</span><br><span class="line">                results += (minutes // i)</span><br><span class="line">                minutes = minutes % i</span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure><h2 id="2225-Find-Players-With-Zero-or-One-Losses"><a href="#2225-Find-Players-With-Zero-or-One-Losses" class="headerlink" title="2225. Find Players With Zero or One Losses"></a>2225. Find Players With Zero or One Losses</h2><p>题面：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.</span><br><span class="line"></span><br><span class="line">Return a list answer of size 2 where:</span><br><span class="line"></span><br><span class="line">answer[0] is a list of all players that have not lost any matches.</span><br><span class="line">answer[1] is a list of all players that have lost exactly one match.</span><br><span class="line">The values in the two lists should be returned in increasing order.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">You should only consider the players that have played at least one match.</span><br><span class="line">The testcases will be generated such that no two matches will have the same outcome.</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]</span><br><span class="line">Output: [[1,2,10],[4,5,7,8]]</span><br><span class="line">Explanation:</span><br><span class="line">Players 1, 2, and 10 have not lost any matches.</span><br><span class="line">Players 4, 5, 7, and 8 each have lost one match.</span><br><span class="line">Players 3, 6, and 9 each have lost two matches.</span><br><span class="line">Thus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: matches = [[2,3],[1,3],[5,4],[6,4]]</span><br><span class="line">Output: [[1,2,5,6],[]]</span><br><span class="line">Explanation:</span><br><span class="line">Players 1, 2, 5, and 6 have not lost any matches.</span><br><span class="line">Players 3 and 4 each have lost two matches.</span><br><span class="line">Thus, answer[0] = [1,2,5,6] and answer[1] = [].</span><br></pre></td></tr></table></figure><p>这题实际上就遍历统计就行，时间复杂度 O(N) 空间复杂度 O(N)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findWinners</span>(<span class="params">self, matches: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        index = defaultdict(<span class="keyword">lambda</span>: [<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> winner, loser <span class="keyword">in</span> matches:</span><br><span class="line">            index[winner][<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            index[loser][<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="built_in">sorted</span>([k <span class="keyword">for</span> k, v <span class="keyword">in</span> index.items() <span class="keyword">if</span> v[<span class="number">0</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> v[<span class="number">1</span>] == <span class="number">0</span>]),</span><br><span class="line">            <span class="built_in">sorted</span>([k <span class="keyword">for</span> k, v <span class="keyword">in</span> index.items() <span class="keyword">if</span> v[<span class="number">1</span>] == <span class="number">1</span>]),</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><h2 id="2226-Maximum-Candies-Allocated-to-K-Children"><a href="#2226-Maximum-Candies-Allocated-to-K-Children" class="headerlink" title="2226. Maximum Candies Allocated to K Children"></a>2226. Maximum Candies Allocated to K Children</h2><p>草，这题题号真有意思，尊。。。。</p><p>题面：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">You are given a 0-indexed integer array candies. Each element in the array denotes a pile of candies of size candies[i]. You can divide each pile into any number of sub piles, but you cannot merge two piles together.</span><br><span class="line"></span><br><span class="line">You are also given an integer k. You should allocate piles of candies to k children such that each child gets the same number of candies. Each child can take at most one pile of candies and some piles of candies may go unused.</span><br><span class="line"></span><br><span class="line">Return the maximum number of candies each child can get.</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: candies = [5,8,6], k = 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: We can divide candies[1] into 2 piles of size 5 and 3, and candies[2] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: candies = [2,5], k = 11</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There are 11 children but only 7 candies in total, so it is impossible to ensure each child receives at least one candy. Thus, each child gets no candy and the answer is 0.</span><br></pre></td></tr></table></figure><p>这题实际上最开始没想清楚，后面仔细想了下，实际上是个二分的题目</p><p>首先假设，我们所有的糖的和为 y, 假设被 k 整除后的值是 z（含义是最大的能够整数分割的数），那么我们题目里孩子能获得的最大的糖果的数量的值域一定是 [0,z]</p><p>这个区间是具备单调性（单调递增），那么就具备了二分的条件。那么我们二分的题目是什么？假设中间值是 mid ，我们计算每推糖果能够按照 mid 分成几份并求和，如果和小于 k ，那么意味着值比我们目标值大，否则则比目标值小。持续逼近即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumCandies</span>(<span class="params">self, candies: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">sum</span>(candies) // k</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="built_in">sum</span>(candy // mid <span class="keyword">for</span> candy <span class="keyword">in</span> candies):</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h2 id="2227-Encrypt-and-Decrypt-Strings"><a href="#2227-Encrypt-and-Decrypt-Strings" class="headerlink" title="2227. Encrypt and Decrypt Strings"></a>2227. Encrypt and Decrypt Strings</h2><p>这题实际上比第三题简单</p><p>题面：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">You are given a character array keys containing unique characters and a string array values containing strings of length 2. You are also given another string array dictionary that contains all permitted original strings after decryption. You should implement a data structure that can encrypt or decrypt a 0-indexed string.</span><br><span class="line"></span><br><span class="line">A string is encrypted with the following process:</span><br><span class="line"></span><br><span class="line">For each character c in the string, we find the index i satisfying keys[i] == c in keys.</span><br><span class="line">Replace c with values[i] in the string.</span><br><span class="line">A string is decrypted with the following process:</span><br><span class="line"></span><br><span class="line">For each substring s of length 2 occurring at an even index in the string, we find an i such that values[i] == s. If there are multiple valid i, we choose any one of them. This means a string could have multiple possible strings it can decrypt to.</span><br><span class="line">Replace s with keys[i] in the string.</span><br><span class="line">Implement the Encrypter class:</span><br><span class="line"></span><br><span class="line">Encrypter(char[] keys, String[] values, String[] dictionary) Initializes the Encrypter class with keys, values, and dictionary.</span><br><span class="line">String encrypt(String word1) Encrypts word1 with the encryption process described above and returns the encrypted string.</span><br><span class="line">int decrypt(String word2) Returns the number of possible strings word2 could decrypt to that also appear in dictionary.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Encrypter&quot;, &quot;encrypt&quot;, &quot;decrypt&quot;]</span><br><span class="line">[[[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;], [&quot;ei&quot;, &quot;zf&quot;, &quot;ei&quot;, &quot;am&quot;], [&quot;abcd&quot;, &quot;acbd&quot;, &quot;adbc&quot;, &quot;badc&quot;, &quot;dacb&quot;, &quot;cadb&quot;, &quot;cbda&quot;, &quot;abad&quot;]], [&quot;abcd&quot;], [&quot;eizfeiam&quot;]]</span><br><span class="line">Output</span><br><span class="line">[null, &quot;eizfeiam&quot;, 2]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">Encrypter encrypter = new Encrypter([[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;], [&quot;ei&quot;, &quot;zf&quot;, &quot;ei&quot;, &quot;am&quot;], [&quot;abcd&quot;, &quot;acbd&quot;, &quot;adbc&quot;, &quot;badc&quot;, &quot;dacb&quot;, &quot;cadb&quot;, &quot;cbda&quot;, &quot;abad&quot;]);</span><br><span class="line">encrypter.encrypt(&quot;abcd&quot;); // return &quot;eizfeiam&quot;. </span><br><span class="line">                           // &#x27;a&#x27; maps to &quot;ei&quot;, &#x27;b&#x27; maps to &quot;zf&quot;, &#x27;c&#x27; maps to &quot;ei&quot;, and &#x27;d&#x27; maps to &quot;am&quot;.</span><br><span class="line">encrypter.decrypt(&quot;eizfeiam&quot;); // return 2. </span><br><span class="line">                              // &quot;ei&quot; can map to &#x27;a&#x27; or &#x27;c&#x27;, &quot;zf&quot; maps to &#x27;b&#x27;, and &quot;am&quot; maps to &#x27;d&#x27;. </span><br><span class="line">                              // Thus, the possible strings after decryption are &quot;abad&quot;, &quot;cbad&quot;, &quot;abcd&quot;, and &quot;cbcd&quot;. </span><br><span class="line">                              // 2 of those strings, &quot;abad&quot; and &quot;abcd&quot;, appear in dictionary, so the answer is 2.</span><br></pre></td></tr></table></figure><p>这题加密部分其实直接按照规则写就行了，然后解密部分有个方法就是提前将字典里面的值预计算一次，然后就能 O(1) 计算了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Encrypter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, keys: <span class="type">List</span>[<span class="built_in">str</span>], values: <span class="type">List</span>[<span class="built_in">str</span>], dictionary: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">        self.index = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">zip</span>(keys, values)&#125;</span><br><span class="line">        self.counter = Counter(self.encrypt(item) <span class="keyword">for</span> item <span class="keyword">in</span> dictionary)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">self, word1: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(self.index.get(letter, <span class="string">&quot; &quot;</span>) <span class="keyword">for</span> letter <span class="keyword">in</span> word1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.counter[word2]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单聊聊在 Linux 内核中的网络质量监控</title>
      <link href="//posts/2022/01/31/a-simple-introduction-about-network-monitoring-in-linux-kernel/"/>
      <url>//posts/2022/01/31/a-simple-introduction-about-network-monitoring-in-linux-kernel/</url>
      
        <content type="html"><![CDATA[<p>这可能是2021年最后一篇文章（农历年），也可能是2022年第一篇文章，不过这完全取决于我什么时候写完。这次来简单聊聊 Linux 中的网络监控</p><span id="more"></span><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>这篇文章，既是一篇水文，又不是一篇水文。不过还是新手向的一个文章。这篇文章实际上在我的草稿箱里呆了一年多的时间了，灵感最初源自我在阿里的一些工作（某种意义上算是国内领先的（但也是比较小众的工作（XD</p><p>随着技术的发展，大家对于服务的稳定性要求越来越高，而保证服务质量的前提就是有着合格的监控的覆盖面（阿里对于服务稳定性的要求叫做 “1-5-10” 即，一分钟发现，五分钟处理，十分钟自愈，而这样一个对于稳定性的要求没有足够的覆盖面的监控的话，那么一切等于圈圈）。而在这其中，网络质量的监控是重中之重</p><p>在讨论网络质量的监控之前，我们需要来明确网络质量这个定义的覆盖范围。</p><ol><li>网络链路上的异常情况</li><li>服务端网络的处理能力</li></ol><p>在明确这样的覆盖范围后，我们可以来思考什么样的指标代表着网络质量的降低。（注：本文主要分析 TCP 及 over TCP 协议的监控，后续不再赘述）</p><ol><li>毫无疑问，如果我们存在丢包的情况</li><li>发送/接收队列阻塞</li><li>超时</li></ol><p>那么我们可以再来看下具体细节</p><ol><li>如 RFC793<sup>1</sup> 提出的 RTO，RFC6298<sup>2</sup> 提出的 Retransmission Timer 等指标，可以衡量包传送时间。一个粗略的概括是，这两个指标越大代表着网络质量越低</li><li>如 RFC2018<sup>3</sup> 提出的 SACK，一个不精确的概括是 SACK 越多，代表着丢包越多</li><li>如果我们的链接频繁的被 RST，那么也代表着我们的网络质量存在问题</li></ol><p>当然在实际的生产过程中，我们还可以从很多其余的指标来辅助衡量网络质量，不过因为本文主要是介绍思路以 prototype 为主，所以不做过多赘述</p><p>在明确我们这篇文章中要获取什么指标后，我们再来分析一下我们怎么样去获取这些指标</p><h2 id="内核网络质量监控"><a href="#内核网络质量监控" class="headerlink" title="内核网络质量监控"></a>内核网络质量监控</h2><h3 id="暴力版"><a href="#暴力版" class="headerlink" title="暴力版"></a>暴力版</h3><p>从内核中获取网络的 metric ，本质上来说是从内核获取运行状态。说道这点，对 Linux 有所了解的同学第一反应肯定是说从 <strong>The Proc Filesystem</strong><sup>4</sup> 看一下能不能拿到具体的指标。Yep， 不错的思路，实际上的确可以拿到一部分的指标（这也是 <code>netstat</code> 等一些网络工具的原理)</p><p>在 <code>/proc/net/tcp</code> 中，我们可以获取到内核吐出的 Metric，现在包括这样一些</p><ol><li>连接状态</li><li>本地端口，地址</li><li>远程端口，地址</li><li>接收队列长度</li><li>发送队列长度</li><li>慢启动阈值</li><li>RTO 值</li><li>连接所属的 socket 的 inode id</li><li>uid</li><li>delay ack 软时钟</li></ol><p>完整的解释可以参考 <strong>proc_net_tcp.txt</strong><sup>5</sup></p><p>这样的做法针对于 prototype 可能说是可以的，不过其固有的几个弊端限制了在生产上大规模使用</p><ol><li>内核已经明确不推荐使用 <strong>proc_net_tcp.txt</strong><sup>5</sup>，换句话说，并不保证未来的兼容性与维护</li><li>内核直接提供的 metric 信息还是太少，一些关于 RTT，SRTT 这样的指标还是没法获取，也没法获取 SACK 等一些特定事件。</li><li>根据内核输出的 metric。存在的问题是实时性和精度的问题，换句话说，我们在不考虑精度的情况下可以去做这方面的尝试</li><li><strong>proc_net_tcp.txt</strong><sup>5</sup> 是和 network namespace 进行绑定的，换句话说，在容器的场景下，我们需要遍历可能存在的多个 network namespace ，不断的走 <code>nsenter</code> 去获取对应的 Metric</li></ol><p>所以在这样的背景下，<strong>proc_net_tcp.txt</strong><sup>5</sup> 并不太适合比较大规模的使用场景。所以我们需要对其做更近一步的优化</p><h3 id="优化-1-0-版"><a href="#优化-1-0-版" class="headerlink" title="优化 1.0 版"></a>优化 1.0 版</h3><p>在上文里，我们提到了关于直接从 <strong>The Proc Filesystem</strong><sup>4</sup> 中获取数据的弊端。其中一条很重要的是提到了</p><blockquote><p>内核已经明确不推荐使用 <strong>proc_net_tcp.txt</strong><sup>5</sup>，换句话说，并不保证未来的兼容性与维护</p></blockquote><p>那么推荐的做法是什么呢？答案是 <strong>netlink+sock_diag</strong> </p><p>简单介绍下 netlink<sup>6</sup> 是 Linux 2.2 引入的一种 Kernel Space 与 User Space 进行通信的机制，最早由 RFC3549<sup>7</sup> 提出。官方对于 netlink<sup>6</sup> 的描述大概是这样</p><blockquote><p>Netlink is used to transfer information between the kernel anduser-space processes. It consists of a standard sockets-based interface for user space processes and an internal kernel API for kernel modules.<br>The internal kernel interface is not documented in this manual page.  There is also an obsolete netlink interface via netlink character devices; this interface is not documented here and is provided only for backward compatibility.</p></blockquote><p>简而言之大概是用户可以利用 netlink<sup>6</sup> 很方便的与内核中的不同的 Kernel Module 进行数据交互</p><p>而在我们这样的场景下，我们就需要利用到 sock_diag<sup>8</sup>，官方对此的描述是</p><blockquote><p>The sock_diag netlink subsystem provides a mechanism for obtaining information about sockets of various address families from the kernel.  This subsystem can be used to obtain information about individual sockets or request a list of sockets.</p></blockquote><p>这里简而言之是说我们可以利用 sock_diag<sup>7</sup> 来获取不同 socket 的连接状态及相应的指标。（我们能获取到上文提到的所有指标，也能获得更细的 RTT 等指标）啊对了，这里要注意，netlink<sup>6</sup> 可以通过设置参数来从所有的 Network Namespace 获取指标。</p><p>在使用 netlink<sup>6</sup> 时，可能直接用 Pure C 来写比较繁琐。所幸，社区已经有不少封装成熟的 Lib，比如这里我选用 vishvananda 所封装的 netlink 库<sup>8</sup>，这里我给一个 Demo</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/vishvananda/netlink&quot;</span></span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">results, err := netlink.SocketDiagTCPInfo(syscall.AF_INET)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> results &#123;</span><br><span class="line"><span class="keyword">if</span> item.TCPInfo != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Source:%s, Dest:%s, RTT:%d\n&quot;</span>, item.InetDiagMsg.ID.Source.String(), item.InetDiagMsg.ID.Destination.String(), item.TCPInfo.Rtt)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行示例大概是这样</p><p><img src="https://user-images.githubusercontent.com/7054676/151838248-eadaacf0-3d7a-4542-a091-9d401c37339c.png" alt="netlink"></p><p>OK，现在我们能用官方推荐的 Best Practice 来获取到更全更细的指标，也无需操心 Network namespace 的问题，但是我们最开始的几个问题还有一个比较棘手，就是实时性的问题。</p><p>因为如果我们选择周期性的轮询，那么如果在我们的轮询间隔中发生了网络波动，我们将丢失掉对应的现场。所以我们怎么样去解决实时性的问题呢？</p><h3 id="优化-2-0-版"><a href="#优化-2-0-版" class="headerlink" title="优化 2.0 版"></a>优化 2.0 版</h3><p>如果要在具体的比如重传，connection reset 等事件发生的时候，直接触发我们的调用。看过我之前博客的同学，可能第一时间考虑使用 eBPF + kprobe 的组合，在一些诸如 <code>tcp_reset</code> ，<code>tcp_retransmit_skb</code> 之类的关键调用上打点来获取实时的数据。Sounds good！</p><p>不过实际上还是有一些小小的问题</p><ol><li>kprobe 的开销在高频的情况下，相对来说会比较大一些</li><li>如果我们仅仅需要一些诸如 source_address, dest_address, source_port, dest_port 之类的信息，我们直接走 kprobe 拿完整地 skb 再来 cast 属实有点浪费</li></ol><p>所以我们有什么更好的方法吗？有的！</p><p>在 Linux 中，对于一系列的类似我们需求这样的特殊事件的触发与回调的场景，有一套基础设施叫做 Tracepoint<sup>9</sup>。这套设施，能够很好的帮我们处理监听事件并回调的需求。而在 Linux 4.15 以及 4.16 之后，Linux 新增了6个 tcp 相关的 Tracepoint<sup>9</sup></p><p>分别是</p><ol><li>tcp:tcp_destroy_sock</li><li>tcp:tcp_probe</li><li>tcp:tcp_receive_reset</li><li>tcp:tcp_retransmit_skb</li><li>tcp:tcp_retransmit_synack</li><li>tcp:tcp_send_reset</li></ol><p>这些 Tracepoint<sup>9</sup> 的含义，大家看名字可能就能明白了</p><p>而在这些 Tracepoint<sup>9</sup> 触发的时候，他们会给注册回调函数传入若干参数，这里我也给大家列一下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">tcp:tcp_retransmit_skb</span><br><span class="line">    const void * skbaddr;</span><br><span class="line">    const void * skaddr;</span><br><span class="line">    __u16 sport;</span><br><span class="line">    __u16 dport;</span><br><span class="line">    __u8 saddr[4];</span><br><span class="line">    __u8 daddr[4];</span><br><span class="line">    __u8 saddr_v6[16];</span><br><span class="line">    __u8 daddr_v6[16];</span><br><span class="line">tcp:tcp_send_reset</span><br><span class="line">    const void * skbaddr;</span><br><span class="line">    const void * skaddr;</span><br><span class="line">    __u16 sport;</span><br><span class="line">    __u16 dport;</span><br><span class="line">    __u8 saddr[4];</span><br><span class="line">    __u8 daddr[4];</span><br><span class="line">    __u8 saddr_v6[16];</span><br><span class="line">    __u8 daddr_v6[16];</span><br><span class="line">tcp:tcp_receive_reset</span><br><span class="line">    const void * skaddr;</span><br><span class="line">    __u16 sport;</span><br><span class="line">    __u16 dport;</span><br><span class="line">    __u8 saddr[4];</span><br><span class="line">    __u8 daddr[4];</span><br><span class="line">    __u8 saddr_v6[16];</span><br><span class="line">    __u8 daddr_v6[16];</span><br><span class="line">tcp:tcp_destroy_sock</span><br><span class="line">    const void * skaddr;</span><br><span class="line">    __u16 sport;</span><br><span class="line">    __u16 dport;</span><br><span class="line">    __u8 saddr[4];</span><br><span class="line">    __u8 daddr[4];</span><br><span class="line">    __u8 saddr_v6[16];</span><br><span class="line">    __u8 daddr_v6[16];</span><br><span class="line">tcp:tcp_retransmit_synack</span><br><span class="line">    const void * skaddr;</span><br><span class="line">    const void * req;</span><br><span class="line">    __u16 sport;</span><br><span class="line">    __u16 dport;</span><br><span class="line">    __u8 saddr[4];</span><br><span class="line">    __u8 daddr[4];</span><br><span class="line">    __u8 saddr_v6[16];</span><br><span class="line">    __u8 daddr_v6[16];</span><br><span class="line">tcp:tcp_probe</span><br><span class="line">    __u8 saddr[sizeof(struct sockaddr_in6)];</span><br><span class="line">    __u8 daddr[sizeof(struct sockaddr_in6)];</span><br><span class="line">    __u16 sport;</span><br><span class="line">    __u16 dport;</span><br><span class="line">    __u32 mark;</span><br><span class="line">    __u16 length;</span><br><span class="line">    __u32 snd_nxt;</span><br><span class="line">    __u32 snd_una;</span><br><span class="line">    __u32 snd_cwnd;</span><br><span class="line">    __u32 ssthresh;</span><br><span class="line">    __u32 snd_wnd;</span><br><span class="line">    __u32 srtt;</span><br><span class="line">    __u32 rcv_wnd;</span><br></pre></td></tr></table></figure><p>嗯，看到这里，大家可能心里应该有个数了，那么我们还是来写一下示例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"></span><br><span class="line">bpf_text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">BPF_RINGBUF_OUTPUT(tcp_event, 65536);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">enum tcp_event_type &#123;</span></span><br><span class="line"><span class="string">    retrans_event,</span></span><br><span class="line"><span class="string">    recv_rst_event,</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">struct event_data_t &#123;</span></span><br><span class="line"><span class="string">    enum tcp_event_type type;</span></span><br><span class="line"><span class="string">    u16 sport;</span></span><br><span class="line"><span class="string">    u16 dport;</span></span><br><span class="line"><span class="string">    u8 saddr[4];</span></span><br><span class="line"><span class="string">    u8 daddr[4];</span></span><br><span class="line"><span class="string">    u32 pid;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TRACEPOINT_PROBE(tcp, tcp_retransmit_skb)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    struct event_data_t event_data=&#123;&#125;;</span></span><br><span class="line"><span class="string">    event_data.type = retrans_event;</span></span><br><span class="line"><span class="string">    event_data.sport = args-&gt;sport;</span></span><br><span class="line"><span class="string">    event_data.dport = args-&gt;dport;</span></span><br><span class="line"><span class="string">    event_data.pid=bpf_get_current_pid_tgid()&gt;&gt;32;</span></span><br><span class="line"><span class="string">    bpf_probe_read_kernel(&amp;event_data.saddr,sizeof(event_data.saddr), args-&gt;saddr);</span></span><br><span class="line"><span class="string">    bpf_probe_read_kernel(&amp;event_data.daddr,sizeof(event_data.daddr), args-&gt;daddr);</span></span><br><span class="line"><span class="string">    tcp_event.ringbuf_output(&amp;event_data, sizeof(struct event_data_t), 0);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TRACEPOINT_PROBE(tcp, tcp_receive_reset)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    struct event_data_t event_data=&#123;&#125;;</span></span><br><span class="line"><span class="string">    event_data.type = recv_rst_event;</span></span><br><span class="line"><span class="string">    event_data.sport = args-&gt;sport;</span></span><br><span class="line"><span class="string">    event_data.dport = args-&gt;dport;</span></span><br><span class="line"><span class="string">    event_data.pid=bpf_get_current_pid_tgid()&gt;&gt;32;</span></span><br><span class="line"><span class="string">    bpf_probe_read_kernel(&amp;event_data.saddr,sizeof(event_data.saddr), args-&gt;saddr);</span></span><br><span class="line"><span class="string">    bpf_probe_read_kernel(&amp;event_data.daddr,sizeof(event_data.daddr), args-&gt;daddr);</span></span><br><span class="line"><span class="string">    tcp_event.ringbuf_output(&amp;event_data, sizeof(struct event_data_t), 0);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_event_data</span>(<span class="params">cpu, data, size</span>):</span><br><span class="line">    event = bpf[<span class="string">&quot;tcp_event&quot;</span>].event(data)</span><br><span class="line">    event_type = <span class="string">&quot;retransmit&quot;</span> <span class="keyword">if</span> event.<span class="built_in">type</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;recv_rst&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">&quot;%s %d %d %s %s %d&quot;</span></span><br><span class="line">        % (</span><br><span class="line">            event_type,</span><br><span class="line">            event.sport,</span><br><span class="line">            event.dport,</span><br><span class="line">            <span class="string">&quot;.&quot;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> event.saddr]),</span><br><span class="line">            <span class="string">&quot;.&quot;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> event.daddr]),</span><br><span class="line">            event.pid,</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf[<span class="string">&quot;tcp_event&quot;</span>].open_ring_buffer(process_event_data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    bpf.ring_buffer_consume()</span><br></pre></td></tr></table></figure><p>我这里使用了 <code>tcp_receive_reset</code> 和 <code>tcp_retransmit_skb</code> 来监控我们机器上的程序。为了演示具体的效果，我先用 Go 写了一个访问 Google 的程序，然后通过 <code>sudo iptables -I OUTPUT -p tcp -m string --algo kmp --hex-string &quot;|c02bc02fc02cc030cca9cca8c009c013c00ac014009c009d002f0035c012000a130113021303|&quot; -j REJECT --reject-with tcp-reset</code> 来给这个 Go 程序注入 Connection Reset （这里的注入原理是 Go 默认库的发起 HTTPS 链接的 Client Hello 特征是固定的，我用 iptables 识别出方向流量，然后重置链接）</p><p>效果如下</p><p><img src="https://user-images.githubusercontent.com/7054676/151841316-8c954deb-e7a6-4229-80d6-4134d884a003.png" alt="Tracepoint"></p><p>嗯，写到这里，你可能想明白了，我们可以将 Tracepoint<sup>9</sup> 和 netlink<sup>6</sup> 结合使用来满足我们实时性的需求</p><h3 id="优化-3-0-版"><a href="#优化-3-0-版" class="headerlink" title="优化 3.0 版"></a>优化 3.0 版</h3><p>实际上写到现在，也更多的是讲一些 Prototype 和思路上的介绍。而为了能满足生产上的需要，还有很多的工作要做（这也是我之前所做的工作的一部分），包括不仅限于：</p><ol><li>工程上的性能优化，避免影响服务</li><li>Kubernetes 等容器平台的兼容</li><li>对接 Prometheus 等数据监控平台</li><li>可能需要嵌入 CNI 来获取更简便的监控路径等等</li></ol><p>实际上社区在这一块也有很多很有意思的工作，比如 Cilium 等，大家有兴趣也可以关注下。而我后续拾掇拾掇代码，也会在合适的时候将我之前的一些实现路径给开源出来。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章差不多就写到这里，内核的网络监控终归是比较小众的领域。希望我这里面的一些经验能够帮助上大家。嗯，祝大家新年快乐！虎年大吉！（下一篇文章就是写去年的年终总结了）</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>RFC793: <a href="https://datatracker.ietf.org/doc/html/rfc793">https://datatracker.ietf.org/doc/html/rfc793</a></li><li>RFC6298：<a href="https://datatracker.ietf.org/doc/html/rfc6298">https://datatracker.ietf.org/doc/html/rfc6298</a></li><li>RFC2018：<a href="https://datatracker.ietf.org/doc/html/rfc2018">https://datatracker.ietf.org/doc/html/rfc2018</a></li><li>The /proc Filesystem：<a href="https://www.kernel.org/doc/html/latest/filesystems/proc.html">https://www.kernel.org/doc/html/latest/filesystems/proc.html</a></li><li>proc_net_tcp.txt：<a href="https://www.kernel.org/doc/Documentation/networking/proc_net_tcp.txt">https://www.kernel.org/doc/Documentation/networking/proc_net_tcp.txt</a></li><li>netlink：<a href="https://man7.org/linux/man-pages/man7/netlink.7.html">https://man7.org/linux/man-pages/man7/netlink.7.html</a></li><li>sock_diag：<a href="https://man7.org/linux/man-pages/man7/sock_diag.7.html">https://man7.org/linux/man-pages/man7/sock_diag.7.html</a></li><li>vishvananda/netlink：<a href="https://github.com/vishvananda/netlink">https://github.com/vishvananda/netlink</a><br>9: Linux Tracepoint：<a href="https://www.kernel.org/doc/html/latest/trace/tracepoints.html">https://www.kernel.org/doc/html/latest/trace/tracepoints.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 水文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单聊聊容器中的 UID 中的一点小坑</title>
      <link href="//posts/2021/12/03/a-simple-introduction-about-uid-docker/"/>
      <url>//posts/2021/12/03/a-simple-introduction-about-uid-docker/</url>
      
        <content type="html"><![CDATA[<p>今天不太舒服，在家请假了一天。突然想起最近因为一些小问题，看了下关于容器中 UID 的东西。所以简单来聊聊这方面的东西。算个新手向的文章</p><span id="more"></span><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>最近帮 FrostMing 把他的 <a href="https://github.com/frostming/tokei-pie-cooker">tokei-pie-cooker</a> 部署到我的 K8S 上做成一个 SaaS 服务。Frost 最开始给我了一个镜像地址。然后我啪的一下复制粘贴了一个 Deployment 出来</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tokei-pie</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">tokei-pie</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tokei-pie</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">12</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tokei-pie</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tokei-pie</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tokei-pie</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">frostming/tokei-pie-cooker:latest</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;2Gi&quot;</span></span><br><span class="line">            <span class="attr">ephemeral-storage:</span> <span class="string">&quot;3Gi&quot;</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;500Mi&quot;</span></span><br><span class="line">            <span class="attr">ephemeral-storage:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">runAsNonRoot:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>啪的一下，很快嘛，很简单对吧，限制下 Storage 用量，限制一下 NonRoot ，以免我被人打穿。Fine，<code>kubectl apply -f</code> 一下。Ops，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: container has runAsNonRoot and image has non-numeric user (tokei), cannot verify user is non-root (pod: &quot;tokei-pie-6c6fd5cb84-s4bz7_tokei-pie(239057ea-fe47-40a9-8041-966c65344a44)&quot;, container: tokei-pie)</span><br></pre></td></tr></table></figure><p>噢，被 K8$ 拦截了，拦截点在 <code>pkg/kubelet/kuberruntime/security_context_others.go</code> 中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyRunAsNonRoot</span><span class="params">(pod *v1.Pod, container *v1.Container, uid *<span class="type">int64</span>, username <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">effectiveSc := securitycontext.DetermineEffectiveSecurityContext(pod, container)</span><br><span class="line"><span class="comment">// If the option is not set, or if running as root is allowed, return nil.</span></span><br><span class="line"><span class="keyword">if</span> effectiveSc == <span class="literal">nil</span> || effectiveSc.RunAsNonRoot == <span class="literal">nil</span> || !*effectiveSc.RunAsNonRoot &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> effectiveSc.RunAsUser != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> *effectiveSc.RunAsUser == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;container&#x27;s runAsUser breaks non-root policy (pod: %q, container: %s)&quot;</span>, format.Pod(pod), container.Name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> uid != <span class="literal">nil</span> &amp;&amp; *uid == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;container has runAsNonRoot and image will run as root (pod: %q, container: %s)&quot;</span>, format.Pod(pod), container.Name)</span><br><span class="line"><span class="keyword">case</span> uid == <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(username) &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;container has runAsNonRoot and image has non-numeric user (%s), cannot verify user is non-root (pod: %q, container: %s)&quot;</span>, username, format.Pod(pod), container.Name)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简而言之，K8$ 先会从镜像的 manifact 中拿镜像的 Runing Username. 如果你镜像里有设置 Runing Username 且你设置了 runAsNoneRoot ，同时你没设置 Run uid，那么会报错。Make Sense，如果你指定的用户名的 uid 是0，那么实际上还是打穿了 SecurityContext 的限制</p><p>找 Frost 要了下他的 Dockerfile，如下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.10</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -m tokei</span></span><br><span class="line"><span class="keyword">USER</span> tokei</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> templates /app/templates</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.py .</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> gunicorn_config.py .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/home/tokei/.local/bin:$PATH&quot;</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;gunicorn&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;gunicorn_config.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>OK, 平平淡淡，没有异常。OK，那我啪的一下改了 Deployment，新版如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tokei-pie</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">tokei-pie</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tokei-pie</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">12</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tokei-pie</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tokei-pie</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tokei-pie</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">frostming/tokei-pie-cooker:latest</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;2Gi&quot;</span></span><br><span class="line">            <span class="attr">ephemeral-storage:</span> <span class="string">&quot;3Gi&quot;</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;500Mi&quot;</span></span><br><span class="line">            <span class="attr">ephemeral-storage:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">runAsNonRoot:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">runAsUser:</span> <span class="number">10086</span></span><br></pre></td></tr></table></figure><p>这里选了我自己的 Magic Number， 10086，这下总没问题了吧，我又 duang 的一下执行了 <code>kubectl apply -f</code>。Oooops，船新的报错</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/python: can&#x27;t open file &#x27;/home/tokei/.local/bin/gunicorn&#x27;: [Errno 13] Permission denied</span><br></pre></td></tr></table></figure><p>OK，那我抛弃我的 Magic Number，换成传说中的数字，1000 来看一下。OK，Works！</p><p>那么这一切到底是为什么呢？那么接下来小编会来告诉你（XD</p><h2 id="简单的介绍，完整的快乐"><a href="#简单的介绍，完整的快乐" class="headerlink" title="简单的介绍，完整的快乐"></a>简单的介绍，完整的快乐</h2><h3 id="容器中的-UID"><a href="#容器中的-UID" class="headerlink" title="容器中的 UID"></a>容器中的 UID</h3><p>首先讲一点前置的知识。首先在 Linux 中的 UID 分配规律。首先在一个 Linux UserNamespace 中，UID 默认的范围是从 0 - 60000。其中 UID 0 是 Root 的保留 UID。从理论上来讲，用户 UID/GID 的创建的范围是从 1 到 60000</p><p>但是实际上可能会更复杂一些，通常各发行版的内置的一些服务，可能会自带一些特殊的用户，比如经典的 www-data （之前没事喜欢搭博客的同学对这个肯定不陌生）。所以实践中，一个 User Namespace 内，一个 UID 的起始，通常是 500 或者 1000。具体的设置，取决于一个特殊文件的设置，<a href="https://man7.org/linux/man-pages/man5/login.defs.5.html">login.defs</a>，路径是 <code>/etc/login.defs</code></p><p>官方文档中描述如下：</p><blockquote><p>Range of user IDs used for the creation of regular users by useradd or newusers. The default value for UID_MIN (resp.  UID_MAX) is 1000 (resp. 60000).</p></blockquote><p>在我们调用 <a href="https://man7.org/linux/man-pages/man8/useradd.8.html"><code>useradd</code></a> 来在构建 Dockerfile 时添加用户。这个时候，在相关操作执行完毕后，会在 <a href="https://linux.die.net/man/5/passwd"><code>/etc/passwd</code></a> 这个特殊文件中添加对应的用户信息。以 Frost 的 Dockerfile 为例，最终的 passwd 文件内容如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br><span class="line">man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span><br><span class="line">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin</span><br><span class="line">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin</span><br><span class="line">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</span><br><span class="line">uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin</span><br><span class="line">proxy:x:13:13:proxy:/bin:/usr/sbin/nologin</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin</span><br><span class="line">irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin</span><br><span class="line">gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin</span><br><span class="line">nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin</span><br><span class="line">_apt:x:100:65534::/nonexistent:/usr/sbin/nologin</span><br><span class="line">tokei:x:1000:1000::/home/tokei:/bin/sh</span><br></pre></td></tr></table></figure><p>那么构建文件结束后，我们来看一下我们常见的容器运行时之一的 Docker 对此相关的处理。</p><p>这里还要科普一点前置的知识，现在 Docker 实际上只能算一个 Daemon+CLI，它核心的功能是调用其背后的 containerd。而 containerd 最终通过 runc 来创建相关的容器</p><p>那我们这里看一下 runc 对此相关的处理</p><p>在 runc 创建容器的时候，会调用 <code>runc/libcontainer/init_linux.go.finalizeNamespace</code> 这个函数完成一些设置，而在这个函数中，会调用 <code>runc/libcontainer/init_linux.go.setupUser</code> 这个函数来完成 Exec User 的设置，我们来看下源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupUser</span><span class="params">(config *initConfig)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// Set up defaults.</span></span><br><span class="line">defaultExecUser := user.ExecUser&#123;</span><br><span class="line">Uid:  <span class="number">0</span>,</span><br><span class="line">Gid:  <span class="number">0</span>,</span><br><span class="line">Home: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">passwdPath, err := user.GetPasswdPath()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">groupPath, err := user.GetGroupPath()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execUser, err := user.GetExecUserPath(config.User, &amp;defaultExecUser, passwdPath, groupPath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addGroups []<span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(config.AdditionalGroups) &gt; <span class="number">0</span> &#123;</span><br><span class="line">addGroups, err = user.GetAdditionalGroupsPath(config.AdditionalGroups, groupPath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rather than just erroring out later in setuid(2) and setgid(2), check</span></span><br><span class="line"><span class="comment">// that the user is mapped here.</span></span><br><span class="line"><span class="keyword">if</span> _, err := config.Config.HostUID(execUser.Uid); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;cannot set uid to unmapped user in user namespace&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, err := config.Config.HostGID(execUser.Gid); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;cannot set gid to unmapped user in user namespace&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.RootlessEUID &#123;</span><br><span class="line"><span class="comment">// We cannot set any additional groups in a rootless container and thus</span></span><br><span class="line"><span class="comment">// we bail if the user asked us to do so. <span class="doctag">TODO:</span> We currently can&#x27;t do</span></span><br><span class="line"><span class="comment">// this check earlier, but if libcontainer.Process.User was typesafe</span></span><br><span class="line"><span class="comment">// this might work.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(addGroups) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;cannot set any additional groups in a rootless container&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Before we change to the container&#x27;s user make sure that the processes</span></span><br><span class="line"><span class="comment">// STDIO is correctly owned by the user that we are switching to.</span></span><br><span class="line"><span class="keyword">if</span> err := fixStdioPermissions(config, execUser); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setgroups, err := ioutil.ReadFile(<span class="string">&quot;/proc/self/setgroups&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This isn&#x27;t allowed in an unprivileged user namespace since Linux 3.19.</span></span><br><span class="line"><span class="comment">// There&#x27;s nothing we can do about /etc/group entries, so we silently</span></span><br><span class="line"><span class="comment">// ignore setting groups here (since the user didn&#x27;t explicitly ask us to</span></span><br><span class="line"><span class="comment">// set the group).</span></span><br><span class="line">allowSupGroups := !config.RootlessEUID &amp;&amp; <span class="type">string</span>(bytes.TrimSpace(setgroups)) != <span class="string">&quot;deny&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> allowSupGroups &#123;</span><br><span class="line">suppGroups := <span class="built_in">append</span>(execUser.Sgids, addGroups...)</span><br><span class="line"><span class="keyword">if</span> err := unix.Setgroups(suppGroups); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := system.Setgid(execUser.Gid); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := system.Setuid(execUser.Uid); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if we didn&#x27;t get HOME already, set it based on the user&#x27;s HOME</span></span><br><span class="line"><span class="keyword">if</span> envHome := os.Getenv(<span class="string">&quot;HOME&quot;</span>); envHome == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := os.Setenv(<span class="string">&quot;HOME&quot;</span>, execUser.Home); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大家看注释应该差不多能理解这段代码在干啥，在这段代码将会调用 <code>runc/libcontainer/user/user.go.GetExecUserPath</code> 和 <code>runc/libcontainer/user/user.go.GetExecUser</code> 来获取 exec 时的 UID，我们来看一下这块的实现（下面代码我精简了一部（</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetExecUser</span><span class="params">(userSpec <span class="type">string</span>, defaults *ExecUser, passwd, group io.Reader)</span></span> (*ExecUser, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> defaults == <span class="literal">nil</span> &#123;</span><br><span class="line">defaults = <span class="built_in">new</span>(ExecUser)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy over defaults.</span></span><br><span class="line">user := &amp;ExecUser&#123;</span><br><span class="line">Uid:   defaults.Uid,</span><br><span class="line">Gid:   defaults.Gid,</span><br><span class="line">Sgids: defaults.Sgids,</span><br><span class="line">Home:  defaults.Home,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sgids slice *cannot* be nil.</span></span><br><span class="line"><span class="keyword">if</span> user.Sgids == <span class="literal">nil</span> &#123;</span><br><span class="line">user.Sgids = []<span class="type">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow for userArg to have either &quot;user&quot; syntax, or optionally &quot;user:group&quot; syntax</span></span><br><span class="line"><span class="keyword">var</span> userArg, groupArg <span class="type">string</span></span><br><span class="line">parseLine([]<span class="type">byte</span>(userSpec), &amp;userArg, &amp;groupArg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert userArg and groupArg to be numeric, so we don&#x27;t have to execute</span></span><br><span class="line"><span class="comment">// Atoi *twice* for each iteration over lines.</span></span><br><span class="line">uidArg, uidErr := strconv.Atoi(userArg)</span><br><span class="line">gidArg, gidErr := strconv.Atoi(groupArg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find the matching user.</span></span><br><span class="line">users, err := ParsePasswdFilter(passwd, <span class="function"><span class="keyword">func</span><span class="params">(u User)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> userArg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="comment">// Default to current state of the user.</span></span><br><span class="line"><span class="keyword">return</span> u.Uid == user.Uid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> uidErr == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// If the userArg is numeric, always treat it as a UID.</span></span><br><span class="line"><span class="keyword">return</span> uidArg == u.Uid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> u.Name == userArg</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; passwd != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> userArg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">userArg = strconv.Itoa(user.Uid)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to find user %s: %v&quot;</span>, userArg, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matchedUserName <span class="type">string</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(users) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// First match wins, even if there&#x27;s more than one matching entry.</span></span><br><span class="line">matchedUserName = users[<span class="number">0</span>].Name</span><br><span class="line">user.Uid = users[<span class="number">0</span>].Uid</span><br><span class="line">user.Gid = users[<span class="number">0</span>].Gid</span><br><span class="line">user.Home = users[<span class="number">0</span>].Home</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> userArg != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="comment">// If we can&#x27;t find a user with the given username, the only other valid</span></span><br><span class="line"><span class="comment">// option is if it&#x27;s a numeric username with no associated entry in passwd.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> uidErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Not numeric.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to find user %s: %v&quot;</span>, userArg, ErrNoPasswdEntries)</span><br><span class="line">&#125;</span><br><span class="line">user.Uid = uidArg</span><br><span class="line"></span><br><span class="line"><span class="comment">// Must be inside valid uid range.</span></span><br><span class="line"><span class="keyword">if</span> user.Uid &lt; minID || user.Uid &gt; maxID &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrRange</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Okay, so it&#x27;s numeric. We can just roll with this.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看着很复杂，实际上总结下来就这样</p><ol><li><p>首先从 <code>/etc/passwd</code> 读取已知的所有的用户</p></li><li><p>如果用户启动时传入的是用户名，那么判断是否有用户名和启动参数传入的相等，没有则启动失败</p></li><li><p>如果用户启动传入的是 UID，那么如果在已知用户中有对应的用户，那么设置为该用户。如果没有，则将进程的 UID 设置为传入的 UID</p></li><li><p>如果用户什么都没传入，那么以 <code>/etc/passwd</code> 中第一个用户来作为 exec 用户。默认情况下第一个用户通常是指 UID 为 0 的 root 用户。</p></li></ol><p>OK 那么回到我们的 Deployment 中，那我们不难得出如下的结论</p><ol><li><p>如果我们没有设置 runAsUser ，且镜像里也没指定启动用户，那么我们容器中的进程将以当前 user namespace 中 uid 为 0 的 root 用户启动</p></li><li><p>如果在 Dockerfile 中设定了启动时的用户，且没有设置 runAsUser，那么将以我们在 Dockerfile 中的用户启动</p></li><li><p>如果我们设置了 runAsUser 且 Dockerfile 中也指定了相关的用户，那么将以 runAsUser 所指定的 UID 启动进程</p></li></ol><p>OK 那么，到这里看似问题解决了。但是这里有个新的疑问。通常来说，我们创建文件之类的操作，默认的权限都是 <code>755</code> ，即对于非当前用户，也非当前用户组内的成员，有可读可执行权限。按道理说不应该出现前文所说的 <code>[Errno 13] Permission denied</code> 情况。</p><p>我进容器看了下报错的文件，的确也和我估计的一样，是 755 权限</p><p><img src="https://user-images.githubusercontent.com/7054676/144605351-630025e7-33a7-421e-b471-cb4cc5a217fe.png" alt="gunicorn.py"></p><p>那么问题出在哪呢？问题出在 <code>~/.local/</code> 这个文件夹，</p><p><img src="https://user-images.githubusercontent.com/7054676/144605509-1caf1ac5-85a9-406d-8a7c-5f6714dca6f3.png" alt="~/.local"></p><p>是的没错，这里的 <code>.local</code> 是 700 权限，即对于非当前用户，也非当前用户组内的成员，没有对当前目录的可执行权限。这里大家可能有点迷惑，目录的可执行权限是什么？这里引用下官方文档 <a href="https://www.linux.com/training-tutorials/understanding-linux-file-permissions/">Understanding Linux File Permissions</a> 中的描述</p><blockquote><p>execute – The Execute permission affects a user’s capability to execute a file or view the contents of a directory.</p></blockquote><p>OK，好吧，如果没有对应的目录的可执行权限，那么我们也没法执行该目录里的文件，即便我们有文件的可执行权限。</p><p>而我这里翻了一下 pip 的源码。发现 pip 在用户态安装的时候，如果不存在 .local 目录，那么会创建 .local 目录并将权限设置为 700。</p><p>OK 到这里我们的整个问题的因果链就已经完全建立了</p><blockquote><p>在 dockerfile 中创建并设置用户 tokei，uid 1000 -&gt; pip 创建了 700 的 .local， .local 归属 UID 1000 的用户-&gt; 我们 runAsUser 设置为 非 1000 的数字 -&gt; 无 .local 的可执行权限 -&gt; 报错</p></blockquote><p>说实话，我能理解 pip 为什么这么设计，但是我觉得这样的设计是有一点 broke 了一些约定俗成的规矩的，其合理性有待商榷</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个问题其实不算难查，但是发生的位置是我有点没有想到的，从我的角度来看，归根结底还是在与 pip 不遵守基本法造成的23333</p><p>这里留个题目大家有兴趣可以思考下。我们都知道 Docker 有个命令是 <code>docker cp</code> 是从宿主机往运行的容器中拷贝文件/从容器中往宿主机中拷贝文件。有个参数是 <code>-a</code> ，即保留原文件的 UID/GID，那么如果我们用这个参数从宿主机/容器往容器/宿主机中拷贝文件，那么我们 ls -lh 时，可以看到怎样的 User/UserGroup 信息。</p><p>OK，这篇水文就先写到这里，写水文真快乐。周末要是有时间的话，可以再写个水文简单聊聊一个关于最近遇到的一个很有趣的根据特征封锁 SSL 流量的手法分析</p><p>好了，溜了溜了</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 水文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊 sk_buff 中一个冷门字段: nohdr</title>
      <link href="//posts/2021/11/22/a-litte-introduction-about-nohdr-filed-in-skbuff/"/>
      <url>//posts/2021/11/22/a-litte-introduction-about-nohdr-filed-in-skbuff/</url>
      
        <content type="html"><![CDATA[<p>今天遇到一个很有意思的问题，“nohdr 字段到底有什么用”，在这里写个水文简单记录一下</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>首先来说，不管介绍再冷门的字段，既然涉及到 SKBUFF ，那么就得先来对 sk_buff 做个简单的介绍</p><p>简而言之，sk_buff 是 Linux 网络子系统的核心数据结构，从链路层到我们最终对数据包的操作，背后都离不开 sk_buff </p><p>sk_buff 要完全讲解基本就相当于把 Linux 网络系统完全讲解了，所以讲完是不可能讲完的，这辈子都不可能的！</p><p>简单聊几个关键，可能会帮助大家理解我们本文提到的冷门字段 nohdr 的关键字段吧</p><p>首先来讲，最重要的三个字段：<code>data</code> ，<code>mac</code> 和 <code>nh</code> ，分别代表着当前 sk_buff 的数据区的起始地址，L2 header 的起始地址，L3 Header 的起始地址。用一个图方便大家理解</p><p><img src="https://user-images.githubusercontent.com/7054676/142876157-422a2115-15bb-4b9e-8ed7-9335c09b695f.png" alt="sk_buff 三剑客"></p><p>看了图的同学可能会有点明白了，实际上在内核里，也是一层一层的通过指针偏移，不断的添加新的 header 来处理网络请求。和我们直觉相符。可能有同学会问，我既然知道 L3 Header 的起始地址，IP 之类的 L3 协议的 header 长度是固定的。我是不是可以算出 L4 的偏移，然后手动处理。</p><p>Bingo，内核里有 <code>tcphdr</code> 的数据结构（对应 IP 是 <code>iphdr</code> ），你根据偏移，手动 cast 就可以手动处理。不过详细做法以后再聊</p><p>接着两个比较重要的字段，是 <code>len</code> 和 <code>data_len</code> ，这两个字段都是标识数据长度，但是简要来说，len 代表着当前 sk_buff 所有数据的长度（即包含当前协议的 header 和 payload），data_len 代表当前有效数据长度（即当前协议 payload 长度）</p><p>OK，前情提要到此结束</p><h3 id="关于-nohdr"><a href="#关于-nohdr" class="headerlink" title="关于 nohdr"></a>关于 nohdr</h3><p>花开两朵，各表一支。聊了 sk_buff 一些预备知识，我们来聊一下 <code>nohdr</code> 这个字段。说实话这个字段真的很冷门</p><p>首先官方对此有对应描述</p><blockquote><p>The ‘nohdr’ field is used in the support of TCP Segmentation Offload (‘TSO’ for short). Most devices supporting this feature need to make some minor modifications to the TCP and IP headers of an outgoing packet to get it in the right form for the hardware to process. We do not want these modifications to be seen by packet sniffers and the like. So we use this ‘nohdr’ field and a special bit in the data area reference count to keep track of whether the device needs to replace the data area before making the packet header modifications.</p></blockquote><p>嗯，这段属实有点拗口。首先 TSO 大家肯定有所所了解。利用网卡来对大数据包进行分段（具体 Linux 下 GSO/TSO 的实现可以改天鸽一篇文章来聊），那么在这种情况下，网卡可能会需要对 header 部分进行一点小的修改来完成分片的操作。</p><p>但是有些时候，我们对于 L4 这一层的包，我并不需要关心其被修改的 Header ，只需要关心其 payload，那么怎么搞。这个时候就是 <code>nohdr</code> 发挥作用了。</p><p>在这里， <code>nohdr</code> 生效还需要配合另外一个字段，<code>dataref</code> 。 <code>dataref</code> 是一个计数字段，其具体的含义是指当前 data 字段所指向的数据区，被多少个 sk_buff 所引用。在这里有两种情况</p><ol><li><p>在 nohdr 为 0 的情况下，dataref 值为数据区的引用计数</p></li><li><p>在 nohdr 为 1 的情况下，高16位，是数据区中 payload 数据区的引用计数，低16位是数据区的引用计数</p></li></ol><p>对此官方有这样的描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We divide dataref into two halves. The higher 16 bits hold references * to the payload part of skb-&gt;data. The lower 16 bits hold references to * the entire skb-&gt;data. It is up to the users of the skb to agree on * where the payload starts.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* * All users must obey the rule that the skb-&gt;data reference count must be * greater than or equal to the payload reference count.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* * Holding a reference to the payload part means that the user does not * care about modifications to the header part of skb-&gt;data.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SKB_DATAREF_SHIFT 16 #<span class="keyword">define</span> SKB_DATAREF_MASK ((1 &lt;&lt; SKB_DATAREF_SHIFT) - 1)</span></span><br></pre></td></tr></table></figure><p>实际上这里也不太难理解为什么这么设计。首先来说，我们在内核里去获取数据包的时候，有些时候不需要去关心具体的 header，只需要关心具体的 payload。 而我们对于 payload 的引用计数，也需要单独的处理来保证其正确性。这样确保我们的数据还没处理完的时候。数据片不会被内核提前释放。当然这里需要大家在处理这块的时候需要保证数据区的引用计数要大于 payload 的引用计数（感觉这里像约定大于配置的做法？（当然这里不遵守约定的后果就是你内核 dump 了2333</p><p>在最后，我们的内核也通过 dataref 来在合适的时机释放数据区的内存空间，释放条件是满足以下其一即可</p><ol><li>!skb-&gt;cloned: skb 没有 被 clone</li><li>!atomic_sub_return(skb-&gt;nohdr ? (1 &lt;&lt; SKB_DATAREF_SHIFT) + 1 : 1, &amp;skb_shinfo(skb)-&gt;dataref) 即在 nohdr 为 1 的时候通过 dataref-(1 &lt;&lt; SKB_DATAREF_SHIFT) + 1) 判断是否需要释放数据区。而 nohdr 为 0 的时候通过 dataref-1 来决定是否需要释放数据区</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>水文差不多就这样。。<code>nohdr</code> 真的是个很冷门的字段。嗯，因为这篇水文的一些 reference 是在地铁上查的。。我就懒得列在文章里了。。差不多这样。。写题去了。。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 水文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Node.js 中 execSync 的一点问题</title>
      <link href="//posts/2021/08/24/a-little-problem-about-posix-node-js-execsync/"/>
      <url>//posts/2021/08/24/a-little-problem-about-posix-node-js-execsync/</url>
      
        <content type="html"><![CDATA[<p>很久没写水文了，昨天帮人查了一个 Node.js 中 <code>execSync</code> 这个函数特殊行为的问题，很有趣，所以大概记录下来水一篇文章</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>首先老哥给了一张截图</p><p><img src="https://user-images.githubusercontent.com/7054676/130622339-57e6a954-926e-4741-93a9-bc1ba0d155d8.png" alt="问题截图"></p><p>首先基本问题可以抽象为在 Node.js 中利用 <code>execSync</code> 这个函数执行 <code>ps -Af | grep -q -E -c &quot;\\-\\-user-data-dir=\\.+App&quot;</code> 这样一条命令的时候，Node.js 时不时会报错。具体堆栈大概为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Uncaught Error: Command failed: ps -Af | grep -q -E -c &quot;\-\-user-data-dir=\.+App&quot;</span><br><span class="line">    at checkExecSyncError (child_process.js:616:11)</span><br><span class="line">    at Object.execSync (child_process.js:652:15) &#123;</span><br><span class="line">  status: 1,</span><br><span class="line">  signal: null,</span><br><span class="line">  output: [ null, &lt;Buffer &gt;, &lt;Buffer &gt; ],</span><br><span class="line">  pid: 89073,</span><br><span class="line">  stdout: &lt;Buffer &gt;,</span><br><span class="line">  stderr: &lt;Buffer &gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是同样的命令在终端上并不会有类似的现象。所以这个问题有点困扰人</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先先看一下 Node.js 文档中对 <code>execSync</code> 的描述</p><blockquote><p>The child_process.execSync() method is generally identical to child_process.exec() with the exception that the method will not return until the child process has fully closed. When a timeout has been encountered and killSignal is sent, the method won’t return until the process has completely exited. If the child process intercepts and handles the SIGTERM signal and doesn’t exit, the parent process will wait until the child process has exited.<br>If the process times out or has a non-zero exit code, this method will throw. The Error object will contain the entire result from child_process.spawnSync().<br>Never pass unsanitized user input to this function. Any input containing shell metacharacters may be used to trigger arbitrary command execution.</p></blockquote><p>大意就是，这个函数通过子进程来执行一个命令，在命令执行超时之前会一直等待。OK 没有问题。那接下来，我们先来看一下上面提到的报错堆栈以及 <code>execSync</code> 的实现代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">execSync</span>(<span class="params">command, options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> opts = <span class="title function_">normalizeExecArgs</span>(command, options, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> inheritStderr = !opts.<span class="property">options</span>.<span class="property">stdio</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ret = <span class="title function_">spawnSync</span>(opts.<span class="property">file</span>, opts.<span class="property">options</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inheritStderr &amp;&amp; ret.<span class="property">stderr</span>)</span><br><span class="line">    process.<span class="property">stderr</span>.<span class="title function_">write</span>(ret.<span class="property">stderr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> err = <span class="title function_">checkExecSyncError</span>(ret, opts.<span class="property">args</span>, command);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret.<span class="property">stdout</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkExecSyncError</span>(<span class="params">ret, args, cmd</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> err;</span><br><span class="line">  <span class="keyword">if</span> (ret.<span class="property">error</span>) &#123;</span><br><span class="line">    err = ret.<span class="property">error</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret.<span class="property">status</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;Command failed: &#x27;</span>;</span><br><span class="line">    msg += cmd || <span class="title class_">ArrayPrototypeJoin</span>(args, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret.<span class="property">stderr</span> &amp;&amp; ret.<span class="property">stderr</span>.<span class="property">length</span> &gt; <span class="number">0</span>)</span><br><span class="line">      msg += <span class="string">`\n<span class="subst">$&#123;ret.stderr.toString()&#125;</span>`</span>;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-restricted-syntax</span></span><br><span class="line">    err = <span class="keyword">new</span> <span class="title class_">Error</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="title class_">ObjectAssign</span>(err, ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们能看到，这里 <code>execSync</code> 在执行完命令执行代码后，会进入 <code>checkExecSyncError</code> 来检查子进程的 <code>Exit Status Code</code> 是否为0，不为0则认为命令执行出错，然后抛出异常。</p><p>看起来没有问题，那么也就是我们执行命令的时候出错了？那我们验证下吧</p><p>对于这种涉及 Linux 下 Syscall 问题排查的工具（这个问题在 Mac 等环境下也存在，不过我为了方便排查，跑去 Linux 上复现了），除了 <code>strace</code> 好像也暂时找不到更成熟方便的工具了（虽然基于 eBPF 也能做，但是说实话自己现撸绝对没 <code>strace</code> 的效果好。</p><p>那么上命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo strace -t -f -p <span class="variable">$PID</span> -o error_trace.txt</span><br></pre></td></tr></table></figure><blockquote><p>tips: 在使用 strace 的时候可以利用 -f 参数，可以 trace 被 trace 进程创建的子进程</p></blockquote><p>好了执行命令，成功拿到整个 syscall 的调用链路，OK 开始分析</p><p>首先我们将目光很快定位到了最关键的部分（因为整个文件太长，有将近 4K 行，我就直接挑重点部分分析了）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">894259 13:21:23 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f12d9465a50) = 896940</span><br><span class="line">...</span><br><span class="line">896940 13:21:23 execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ps -Af | grep -E -c \&quot;\\-\\-user-da&quot;...], 0x4aae230 /* 40 vars */ &lt;unfinished ...&gt;</span><br><span class="line">...</span><br><span class="line">896940 13:21:24 &lt;... wait4 resumed&gt;[&#123;WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 1&#125;], 0, NULL) = 896942</span><br><span class="line">896940 13:21:24 --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=896942, si_uid=1000, si_status=1, si_utime=0, si_stime=0&#125; ---</span><br><span class="line">896940 13:21:24 rt_sigreturn(&#123;mask=[]&#125;) = 896942</span><br><span class="line">896940 13:21:24 exit_group(1)           = ?</span><br><span class="line">896940 13:21:24 +++ exited with 1 +++</span><br></pre></td></tr></table></figure><p>首先这里科普一下，Node.js 中没有直接使用 <code>fork</code> 来创建新的进程，而是使用 <code>clone</code> 来创建新的进程，至于两者之间的差别，要详细说的话，可以单独水一篇超长文了（我先立个 flag）这里先用官方的说法大概描述下</p><blockquote><p>These system calls create a new (“child”) process, in a manner similar to fork(2).<br>By contrast with fork(2), these system calls provide more precise control over what pieces of execution context are shared between the calling process and the child process.  For example, using these system calls, the caller can control whether or not the two processes share the virtual address space, the table of file descriptors, and the table of signal handlers.  These system calls also allow the new child process to be placed in separate namespaces(7).</p></blockquote><p>用简短的概括性的话来描述就是,<code>clone</code> 提供了 <code>fork</code> 近似的语义,不过通过 <code>clone</code> ,开发者能更细粒度的控制进程/线程创建过程中的细节</p><p>OK, 这里我们看到 <code>894259</code> 这个主进程通过 <code>clone</code> 创建了 <code>896940</code> 这个进程。在执行过程中, <code>896940</code> 这个进程利用 <code>execve</code> 这个 syscall 通过 sh (这是 <code>execSync</code> 的默认行为)我们的命令 <code>ps -Af | grep -q -E -c &quot;\\-\\-user-data-dir=\\.+App&quot;</code>。 OK，我们也看到了，<code>896940</code> 在退出的时候，的确是以 1 的 exit code 退出的，和我们之前的分析一致。那么换句话说，在我们执行命令的时候，有 error 的出现。那么这里的 error 出现在哪呢？</p><p>我们分析一下命令，如果熟悉常见 shell 的同学可能发现了，我们的命令中实际上使用了管道操作符 | ，不精确的来说，当这个操作符出现的时候，前后两个命令将分别在两个进程执行，然后通过 pipe 进行 IPC。那么换句话说，我们可以很快定位这两个进程，直接快速搜了一下文本</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">896941 13:21:23 execve(&quot;/bin/ps&quot;, [&quot;ps&quot;, &quot;-Af&quot;], 0x564c16f6ec38 /* 40 vars */) = 0</span><br><span class="line">...</span><br><span class="line">896942 13:21:23 execve(&quot;/bin/grep&quot;, [&quot;grep&quot;, &quot;-E&quot;, &quot;-c&quot;, &quot;\\-\\-user-data-dir=\\.*&quot;], 0x564c16f6ecb0 /* 40 vars */ &lt;unfinished ...&gt;</span><br><span class="line">...</span><br><span class="line">896941 13:21:24 &lt;... exit_group resumed&gt;) = ?</span><br><span class="line">896941 13:21:24 +++ exited with 0 +++</span><br><span class="line">...</span><br><span class="line">896942 13:21:24 exit_group(1)           = ?</span><br><span class="line">896942 13:21:24 +++ exited with 1 +++</span><br></pre></td></tr></table></figure><p>OK，我们发现 <code>896942</code> 即执行 <code>grep</code> 的进程直接以 exit code 1 退出了。那么这是为什么呢？？看了下 <code>grep</code> 的官方文档，，卧操，差点吐血</p><blockquote><p>Normally, the exit status is 0 if selected lines are found and 1 otherwise. But the exit status is 2 if an error occurred, unless the -q or —quiet or —silent option is used and a selected line is found. Note, however, that POSIX only mandates, for programs such as grep, cmp, and diff, that the exit status in case of error be greater than 1; it is therefore advisable, for the sake of portability, to use logic that tests for this general condition instead of strict equality with 2.</p></blockquote><p>如果 grep 没有匹配到数据，那么会以 1 作为 exit code 退出进程。。如果匹配到了，则0退出。。但是，但是，卧操，卧操。。按照标准语义，exit code 1 的含义难道不是 <code>Operation not permitted</code> 吗？？完全不按基本法出牌！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上通篇看了下来，我们可以总结出两个原因</p><ol><li>Node.js 在对 POSIX 相关 API 进行抽象封装的时候，直接按照了标准语义，给用户兜底了。虽然从理论上讲这应该是个应用自决的行为</li><li>grep 没有按照基本法办事</li></ol><p>说实话我也不知道怎么去评价这两方面谁更坑一点。按照前面所说么处理子进程的 exit code 从理论上讲这应该是个应用自决的行为，但是 Node.js 自己做了一层封装，在节省用户心智的同时，遇到一些非标场景，也会有不小的隐患了。。</p><p>只能说不断根据不同的场景做 trade-off 吧</p><p>好了，这篇文章就到这里了，因为是临时起义，所以我就懒得将相关 Reference 列在文里了。差不多这样吧，水文目标达成.jpg</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 水文 </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我自己被性侵经历的访谈记录</title>
      <link href="//posts/2021/05/07/something-I-want-to-share-about-sex-assault1/"/>
      <url>//posts/2021/05/07/something-I-want-to-share-about-sex-assault1/</url>
      
        <content type="html"><![CDATA[<p>这篇文章是我 2020 年 12 月接受华中师范大学关于儿童性侵的采访所产生采访稿。在这次采访中，我完整的复盘了在我12岁那年发生在我身上的强奸事件。在这次采访中，我完整回顾了当时我和我家庭的一些反应，也表达了我一些关于性侵这件事的看法。我希望每个人都能平安顺利的过完一生，但是如果有不好的事情发生的时候，我希望这篇文章能帮到你。Everything is gonna be OK。</p><span id="more"></span><h2 id="采访稿"><a href="#采访稿" class="headerlink" title="采访稿"></a>采访稿</h2><div class="table-container"><table><thead><tr><th><strong>时间标签</strong></th><th><strong>说话人</strong></th><th><strong>逐字稿</strong></th><th><strong>备忘录</strong></th></tr></thead><tbody><tr><td></td><td>访谈对象：</td><td>Hello，你好。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>Hi，你好啊。好，那在开始之前我再说一下我们的知情同意书吧，就是前面也发给你过。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，对，我看了，啊，签名我忘了签了。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>没事，等一下发给我也行。知情同意书主要包括研究目标：就是聚焦于探索儿童期性创伤经历者的创伤应对和表露过程。然后你说的话对于我来说，都很重要，所以需要录音，我们的访谈大概持续是三十到六十分钟。如果说这次访谈中断或者没有完成的话，可以协商下一次。参与这个研究，你随时都有权利选择退出，访谈过程中或遇到一些你不想回答的问题，你都可以选择拒绝回答。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，没问题没问题。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>还有一些小小的风险，就是可能会谈到一些触动你情绪的这件事的时候，可能就会引起你的情绪有些波动。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，没事儿，快乐水我已经准备好了（笑）。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，好，但是呢我会就是照顾到你的情绪，因为我是有做过心理咨询的经验的。嗯，然后还有就是你的个人隐私处理问题。首先就是这个录音我会给它变进行一个变音，我处理好逐字稿之后就会把它删除。然后还有就是你的一些能够辨认出你个人信息的内容，我会进行一个匿名化的处理。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>之后你生成的就说是paper，我能够拿到一份拷贝吗？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，你是说论文吗？可以。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，是的是的是的，没错，就是你的相关研究结果。因为我其实对这个事情很好奇，因为我我其实一直是在做性侵这方面公益的。但是据我所知的话，其实国内这方面对于专门性侵受害者的研究，其实我觉得好像还是一个很偏门的领域。我其实挺好奇的。对，因为当时你在这个过程中说的时候，我其实也挺好奇的你为啥会选择这个方向。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>这个通过我看论文的时候我就发现了，因为国内真的很少，就是比较权威的论文，真的非常少。我参考的文献全部都是英文的，就看论文的时候还是挺痛苦的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>就是因为我自己亲身经历，还有我去跟就是给别人做。因为我之前在做公益嘛，就是校园暴力，其实校园性侵属于校园暴力一种嘛。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>然后的话做的时候，我发现其实国内对于这方面，研究特别少。包括就是说起因、结果的研究，包括怎么样去做进行一个系统性的，就是说是受创伤后的心理干涉的介入。我觉得这方面研究好像都很少，我其实挺好奇的。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，确实很少。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哎，你们导师也是专门做这一块的？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>没有，我们导师主要是做危机干预和自杀预防的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>啊，对，自杀干预前几年好像也是比较少。做自杀干预很有必要，我的好朋友八月份就离世了，就因为这抑郁症。来吧，我们现在就开始吧。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，行，好，那开始之前我再做一个自我介绍吧。尽管前面已经介绍过了，我是来自河南信阳，然后今年26岁，是现在是在华中师范心理学院的在读研究生。然后很高兴，也很感谢你能够愿意支持，然后参与这个研究。好，在开始之前你也就是简单做一个自我介绍，包括年龄啊，职业还有居住地和婚姻状况。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>啊，我现在很明显未婚，然后的话成都人，然后年龄的话，我九四年的跟你同岁。然后但是不知道我们月份谁大谁小。然后现在程序员然后在阿里。嗯，对，就是差不多这个情况。我受侵犯的年纪。我想想具体年份，啊，零七年到现在已经是快14年了，已经是十多年了。所以当时应该是我13岁的时候。13岁未满，07年2月，我没记错的话。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>还是能够记得很清楚的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，因为我其实我自己是选择把我很多事情公开出来。因为我觉得国内对于同性……因为我其实是比较，呃，在常规的…（遭遇性侵）这样是比较少见的，我是同性的性侵。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对对，然后然后大家可能更focus 在就是说我异性的性侵。但是国内的性侵的话，对于同性性侵其实这一块比异性的研究更少，而且是什么，法律也不完善。所以说我是会刻意的记忆，然后把这个事情分享出来。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>这比一般女生更需要勇气。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>啊，其实还好，其实还好。对，我觉得其实男生来讲，就拿我自己的亲身经历来讲，其实男生受创伤它是一个持续的过程，它是一个持续的过程，可能你小时候觉得做出这个事情有点无所谓。但是当你大了之后，潜意识了，因为我之前抑郁过嘛，我之前抑郁过，去做过心理诊断。然后当时就是说是心理咨询师就确定了诱因，有一个其中的诱因可能就是这件事引发了一个长期性的一个p t s d 。然后，对，然后可能说比女性来得更猛一些。但是可能说，但是在社会舆论氛围上相对能够获得就更多的，就是说可能说宽容一些，或者说是我也不知道怎么界定啊。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，好，那现在我们就开始吧，就按照我的访谈提纲。我们就像讲故事那样的方式，以时间发展顺序来讲一下。就是当时遭遇侵犯的背景，然后还有你当时是怎么去应对处理的。在这个过程中你经历了怎么样的一个心路历程。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，o k ，其实我的话当时是在住宿学校，然后的话，因为就是这个事情可能就比较长。就是我在住宿学校，然后我当时也不算太合群的一个人。然后就是可能就说校官就界定了，界定了就是说这个是一个小孩子，而且他可能也是有性需求嘛。然后现在我想起来他部队退役的，然后就这是一个性需求。嗯，那么他会长期的培养我一个服服从。就比如说平时就因为我当时是就是有点不听话的小孩子嘛。然后就比如说训练军姿啊训练或者其他的，那么服从之后呢，然后就在事发当天晚上，然后把我拉到一个卧室去，然后去喝了一些酒，然后这个事情。就是我彻底就失去了反抗的这个意识了，就是说，那么这个事情就发生了。至于发生之后的话，就是说发生之后，我第二天早上回去，然后我爸请我吃香肠，当时刚过年不久嘛，我们家还有香肠，然后我就回家，因为那个时候是晚上是周五晚上，然后第二天周六回家，然后当时就觉得不太对劲，然后就很不爽，然后跟我爸说了这事。然后我家里人就发现，就可能说知道我被性侵了，然后就赶紧去报警，然后做了就是精液采集，然后做了笔录。然后后面的话，在大概在一年之后，他定罪之前，又重新做了一次我的d n a 鉴定。因为体液采集是从我身上采集的嘛，然后做了一次d n a 鉴定。然后你要说心路历程的话，其实，嗯，跟女孩子不同的是，男孩子其实可能最开始在小时候，最开始可能他并不会认识到这是一次强奸。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>其实女孩子也不知道。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>呃，女孩子可能最开始知道，因为女孩子可能从小父母就教育她，说你那个地方很羞羞的嘛，然后你就，然后不能让男孩子碰。然后或者碰到这个地方对你不好，可能是有这样一个介绍。那么女孩子最开始会就会觉得这个地方是有个耻辱感，就有个很明确的耻辱感，很明确的被侵犯感。而男孩子可能说，就我自己的亲身经验来讲，你最开始其实反应可能可能并不会太强烈。就可能你最开始都不知道这发生了什么，就觉得很不舒服很不爽。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>然后你第二天早上就跟你父亲说了？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，因为当时我觉得就很不爽。对，然后又因为香肠那个诱因嘛，然后这个东西大家都理解，然后就是加上香肠这个诱因。然后的话就我父亲就发现我的异样，然后就去报警。对。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>那你父亲还挺细致的一个人。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，我父亲，其实这一件事情我一直很感谢我父亲。因为如果说是传统家长，可能就会考虑说，啊，出于名誉考虑遮盖子嘛，对，遮盖子，然后就说或者说：哎，事情发生就发生了，过。然后就报警了，然后最后那个哥们儿是以猥亵儿童罪被判4年，我就记得没错。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>4年。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，因为因为男生很尴尬的一点，就是说他不是…因為國內的法律的性侵，它强奸是针对于女性的一个性器官的插入说，而对于男生来讲它其实是没有强奸这个说法的，而我当时凑巧的是我年龄小于十四岁，然后所以说他以那个侵犯儿童、猥亵儿童罪，刑法二百三十几条，我记得没错的话，然后他就入刑了。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，就是这样看来的话，家庭关系其实也很重要。你和父亲的交流……</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>非常的重要，非常的重要，我觉得其实很……就是说我自己身边也有被性侵的。其实这个事情的伤害程度很取决于家庭对这个事情的处理。如果你家庭觉得说：这是一个性侵。那么我及时报警，然后寻求公权或者说警察的帮助。那么这个事情呢受伤害或者说再配合再更开明一点，配合及时的心理介入干涉。那么这个伤害会控制到非常小的点。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，就是你父亲知道之后，他当时的一个反应是什么样的，还有包括你的家里人反应？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>呃，我其实我父亲他在我面前其实没有表现太多的焦虑。嗯，对我父亲懂得，家长嘛，就是可能说再天大的事，可能也不能在孩子面前（焦虑，不淡定）…我母亲当时是在成都，然后我在小地方，我小时候出生在小地方，这个钢铁城市嘛，然后，对，我父亲然后当时其实是很淡定的，当时他做了两件事，我没记错的话，第一个他给他朋友打电话，就是说他怕警察不认这个事情。于是他找他朋友咨询：我能不能去其他的诊所？先将精液或者说其他的体液部分固定下来，然后后面发现这些事情好像并不合规。然后我父亲就当时把我带到了那个住宿学校的辖区的派出所去做了那个就是说笔录，包括第一波的体液采集，对。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>你父亲真的很厉害。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，对。然后就是后面的话，然后出于其他考虑，然后他就将我带来成都了嘛。对，然后的话就说是和那个环境做隔离。因为这个事情整个公开报道出去其实还是会对你的成长造成一个影响，因为这个特别是教育系统，就是基本上是教育系统，你一出去，一转学，大家一打听就知道这孩子不太对劲（笑）。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯。就是那你对于你父亲当时那个处理，你当时心里面就是有一个什么样的状态？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，其实我当时还是懵懂的状态，其实还是懵懂的状态。就是说，包括体液采集，做笔录的时候，我当时其实并没有意识到这个事情是一个强奸。我当时其实心里没有很明确的这个词，这个是对于男生的一个强奸。然后我其实就觉得这可能是个不好的事情。嗯，然后呢那么我就配合警察，把这个事情完全记录、说出来。然后做笔录，其实还是小孩子对于，就是说当时去做这一套，我父亲替我拍了板之后，我当时做这一套核心的一个动机，更可能还是说，呃，小孩子对于长辈，对于就是说是或者说其他的一个服从，就是我当时并没有意识到这个东西发生了什么。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，那你后来什么时候开始意识到这件事情它的一个性质是什么的？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>唔，其实初步意识到应该是在高中，然后完整的去复盘我自己的这件事儿的话，应该是在大学。应该是在快毕业的时候，当时其实，呃，我完整的复盘其实诱因应该是国内的me too 运动。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，实际上是应该是me too 运动。然后诱因…，我其实之前有个粗浅的复盘，但是真正的去重新的就是从头到尾的去审视这件事是就应该是me too，对，然后的话对，差不多就是这样一个情况。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>就是这件事情对你有什么影响？就是从它发生一直到现在的话，对你有什么影响？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>呃，其实我觉得你要说真正的影响很难量化。因为就是说很多东西就包括我去做心理咨询之后，其实医生的看法就是说这个事情是潜移默化的，就是说潜移默化的一个伤害，就是说是长期性的一个p t s d。然后当时我去医院去确诊，然后就因为我当时是确诊抑郁症嘛，然后重度抑郁，然后是伴自杀焦虑，然后的话就是自杀倾向。然后的话，呃，当时其实医生当时听我把这个事情清理完整描述过之后，医生的评价就是说是你这个抑郁的有一部分其实就是来源于你这件事儿。嗯，就说，对，对，因为就是什么，因为我是抑郁需要吃药并伴做那个心理干涉嘛，然后，对，但是就是说你要说这件事情有什么明显的，就是说后遗（症），一个就是要很量化的，就是说你觉得这个事情对你影响有多大，我觉得这没量化。我觉得这个东西是一个潜移默化的过程。因为我当时是在受侵害的，最开始他是没有做到一个系统的心理干涉，我是没有做到的。对，可能对于同性的时候，可能说最开始你觉得没什么，但是越想越想觉得有事儿。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>那你诊断为抑郁症的时候，大概是多大？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>啊，应该是在17年。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，在三年前。就是在此之前就没有表现出来一些具体的症状？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>有，其实有我一直神经衰弱，但是我其实在大学的时候应该是有，但是我是没有去确诊的，因为就是说没有确诊。对，但是正式确认是在17年。对，然后的话，所以说我觉得这个事情可能更可能来讲还是一个长期的一个潜移默化的。就是说它并不会对你就是说你一下子觉得：哎，你自己不是一个干净的人，你一下子觉得你想跳楼了。我觉得这个不存在，但是可能就是说潜移默化的过程。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>那你觉得这种潜移默化主要是来自于哪里呢？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>我觉得可能最开始就是打破你自己的，就说是一个完整感。就是说你自己觉得自己是一个不完整，或者说是你觉得你自己是…用这种传统的话来讲呢，就是你自己是个不干净的，懂我意思吧？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，就是我自己猜的话，潜意识可能会给自己加一个这样的，其实我觉得可能说。呃，然后你就会觉得你自己说话会比别人低一头或者是其他。对，我觉得这个可能还是一个社会氛围所造成的吧。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，就是在高中之后慢慢的开始有这种意识。那其实对是小一点的话，你其实还是不太知道这件事情是什么性质？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，对，对，男生其实很麻烦的一件事就在这个地方，最开始如果你是被性侵的那个男生，男生你在小时候你可能会觉得这是一个游戏，你可能会去更觉得这是一个游戏。但是你在大了之后，你会发现慢慢觉得这不是…（一个词，听不清）欸？怎么这么不太对劲啊？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，就是慢慢的意识到的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，是的，没错。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>你就是最开始就已经选择，也不是说你主动告诉你父亲，就是你父亲他自己觉察到这件事情。那再后来你有没有再表露过这件事情？嗯，再一次向别人说这件事情的时候是什么时候，然后是什么原因？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>我其实应该是还是在大学吧。然后我其实之前其实只跟几个好朋友说过，然后我正式选择公开这件事情，应该还是在大学或者说快毕业，me too事件之后，因为我觉得可能说我的经（历），因为我当时其实有个背景是我也是在做公益，我之前是救援队的。然后的话我之前大学在救援队服务，然后是以私人身份去做一些，然后就包括啊校园校园暴力和校园性侵，资助我也在做。呃，我可能觉得，更觉得这件事的话，可能就是说，我需要让这件事变得有意义。然后于是我选择就是说公开的把我这个经历分享出来。因为我觉得可能说，呃，一个事情如果只能变成你自己的痛苦，或者说你自己的建议，那么你自己是否痛苦其实是没有太大意义的。对，而且我这个事情又是相对来说对别人更容易产生帮助的，因为其实你知道儿童期间的性侵其实是很常见的一个事情。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，其实是，然后家庭，就是说父母的干涉又是非常重要的。我选择的在知乎，你看到我的那个答案，包括我选择的一些社群里面把这个事情，呃，就是说我自己的当时的经历，以及我家庭所做的一些手段，包括我家庭当时做的不足的地方，就因为认知的关系嘛，没有给我寻求及时的心理介入，这些事情分享出来我就是希望说，我自己能够把这些，啊，把我自己的经历能够变得更为有意义一点，然后不仅限于我自己所受到的伤害。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>做的真的很好。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>唉，（深深叹一口气）对，这也是我参加你的这个研究的原因吧。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，我也看到，你说这就是你分享的意义。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯嗯，对，对，我觉得其实就是说你自己每个人受伤害嘛，然后要怎么样去把自己受到的创伤，受到的伤害变得让它具备除了伤害以外更多的意义。我觉得这是一个很好玩的话题。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，很有意义，很有价值的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，对，这就是我自己选择的，我自己披露出来的一个啊，心理活动。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>好，还有就是你刚才提到也告诉过好朋友，那你是在什么时候告诉好朋友，然后他们又是怎么回应你，他们当时的这个态度和反应是什么样的？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>他们其实就觉得就是说：不可思议。就是这样子，然后就觉得就觉得说，出于保护我，就告诉我这件事情还是不要跟别人说。出于好意，就是让我这件事情不要跟别人说。然后这个事情不要跟别人说，其实后面相处也是没有什么太大的变化，因为好朋友嘛，对。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>那也是因为你非常的信任他们。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，因为其实是在闲聊的时候嘛，就是闲聊的时候就说了这事。这个没有什么可以防备的，就说了这事儿，虽然我父母我一直在告诉我说：这个事情你千万不要给别人说啊。但是我从小都不是个好小孩。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，就是在朋友那里，其实也是得到了一定的支持。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，是的，没错。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>还有很多小孩就是选择告诉父母的话，他还会造成二次伤害。所以就是说你父亲的这种处理真的特别可贵。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，对，是的，我觉得其实是被性侵伤害的（人），从我自己打过交道来看，其实是很大一部分伤害是来自原生家庭。这个我们毫不避讳的讲的是其实很多包括就觉得说可能说女孩子就觉得说：啊，你嫁不出去了，就直接原生家庭给的压力，就“你嫁不出去了，你怎么这样？”就受害者有罪推定嘛，是吧，受害者有罪推定。“哎，当时谁叫你穿那么少干嘛，然后叫你再穿这么少？”其实我父母也有，我母亲也有一点这种就说：哎，叫你当时不合群，你要是合群，你教官就不会挑上你了嘛！”我觉得这种东西其实是没有必要的那个谴（责），苛责。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>对对对，明明就是加害者的错，反过来还要去揪你的毛病。对，所以面对母亲的那种那种责怪，你其实感觉怎么样？。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>我母亲其实也不是恶意的嘛。她其实就是说教育我要去合群嘛。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，其实我小时候我一直不太想去为了合群而合群，但是他们长辈嘛，她为了教育我去合群，就是说可能说举了一个不恰当的例子。但是不恰当的例子其实呢也是说，目前我跟你说性侵的伤害，就是说遇到了一个现状，很多时候的压力和伤害其实是更多的是，就是说比性侵这件事情伤害更大的，可能说是来自于原生家庭的一个苛责。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，对，确实是。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>好，你觉得有什么是促进你来表述这件事情，有什么是阻碍你来表述这件事情的？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>哦，其实阻碍我去表述这件事情的因素并不多。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，我也发现了。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>对，因为我觉得你们说“关我吊事儿”，就是用术语来说就是就是“关我什么事儿”。然后我说我的，你们看的惯就看，看不惯就不看，你们又不给我发钱，发工资是不是？我这个人的性格是比较，就是比较那个就怎么说，就反常规的吧，所以说我觉得还好。再一个就是说促进我表露的话，可能就还是说，呃，国内就是说是目前就是说是对于性侵受害者态度的一个变化。嗯，就说是一个……就是因为之前，可能说在零几年或者说前几年或者更早的时候，觉得性侵它是一个非常shame的事情，就是说你不光彩。就是说“how shame you “就是说你怎么能这样，就是就刚才我举的例子吧，你被性侵了，你一定是穿的太少了，你一定是穿的太骚了，或者说你一定是穿的太浪了。啊，这种就是受害者有罪论。这几年国内其实是对性侵受害者态度其实是逐渐变好了。而且就是我刚才说了嘛，另外一个契机可能就是说是me too。然后我觉得可能说，啊，把这个事情公布出来，然后让别人，能够帮到别人，我觉得是能够去抚慰自己被性侵。就特别说如果有一些人告诉你说：我孩子，呃，但是我不希望有这样一天，啊，但是就是如果说有一天跟你说，有个当父亲或当母亲跟你说：我孩子被性侵性了，我按照你说的做了。其实我觉得如果说是有这样一件事情，它其实是能够治愈很多东西的。但是我不希望有一天会出现这种情况。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>对，然后我觉得这可能说是，呃，一个是算是一个自我的拯救吧。第二个就是说可能说还是希望就是说能够帮…就说是用自己的一些东西去回馈一些什么。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯。当你回忆了整个的这样的一个经历之后，你现在是有什么感受？用一个词来概括一下。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>啊！还好。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>还好？用一个词来概括的话？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>啊，还好，就是跟产品经理撕完逼之后的，怎么说，啊，轻松。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>轻松？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>对，轻松吧，我觉得其实，我觉得怎么说呢？我觉得其实这样面对面聊这个问题，其实聊完之后其实还是会有些轻松感的，对，就像跟产品经理撕完批之后，然后你会觉得：哇，爽死了。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>程序员的快乐。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>啊，是的。那能再具体一点说一下，为什么是这种感觉呢？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>因为我觉得其实你在网上以一个虚拟的身份去说，可能说大家都知道迈克萨卡的i d 是我。因为我可能说我觉得我在这个社区比较活跃，大家可能觉得迈克萨卡的i d 是我，我也会在微信群里面说，大家看到啊，这个啊微信i d是迈克萨卡的人是我。但是我觉得可能说跟你就是一个真人的去one on one的去说，就是相对来说是一个陌生人。我跟我女朋友其实是很深入地聊过这件事儿的。就是说，呃，跟你一个陌生人去one on one的去聊这件事儿，其实也是在治愈自己那个心里面的一个东西，对，其实是因为，因为潜意识来讲可能最开始我觉得这还是一件shame的事情。所以我想的是在网上以一个虚拟的身份去做。那我去给你做访谈，就其实说我有一些枷锁，其实还是（非常大的？）（没听清楚）。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯嗯，你刚才我联系你时你说去抽根烟，我就觉得，嗯，可能就是就觉得又要去面对这个事情，情绪上需要准备一下。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，其实你是第一个就是说以一个相对陌生人的身份去忘one on one的去聊这件事儿。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>那个单词是怎么你能说慢点吗？one什么？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>就是one on one，就是一对一，就是一对一，面对面。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>哦哦。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，我们这边应该就是叫one on one，然后就是跟老板one on one的聊天。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>哦哦，在我打断你之前，你刚才要说什么，你接着说吧。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，没有没有，其实我觉得，对，就是说你自己以一个虚拟的身份去说这个事情，就是说是有温度的去说这个事情，我觉得其实是两种体验吧。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，确实是。你刚才提到你女朋友，因为你女朋友毕竟是你除了爸妈之外关系最亲密的人嘛，你告诉了她这件事情，那你再具体说一下，就是你告诉她的这个经过吧，还有你做了什么思想工作？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>就是在晚上休息之前，我给她就聊到了小时候这件事情，其实也没什么，因为我的事情她都知道，她其实没有什么，我就只是在去聊一些东西。她其实也没什么反应，就是觉得很心疼心疼。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，心疼。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，对，对，然后其实我觉得跟亲密的人聊这个事情，其实是没有什么。当然前提是你亲密的人不会再苛责你：你当时为什么穿的那么少，那么浪？对，就是……（没听清楚）其实我觉得去聊这种事情，我觉得是，嗯，也是能够促进感情的一种比较好的方式吧。就是说是互相剖析嘛。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，就是那种完全信任的那种状态。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>是的，没错。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>你对于儿童性侵犯的一个现状有什么样的认识？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>很严重，非常严重，因为性侵其实它是一个很大的概念。我可能下面的话会说的比较露骨一点，不要介意啊。就是说性侵，它可能并不仅仅限于就是说，呃，一个强奸的一个行为。就是插入了，它可能是边缘性的一个性侵，可说搂搂抱抱，对于小女孩或小男孩的一个搂搂抱抱，乃至于说是对于性器官的一个接触，对。然后而且这个，其实现在是越发多样了。可能往常的人来说，我觉得就是说，往常的人来说，就觉得说啊，男生对于女的是一个性侵。后面可能就是说，大家发现男的对于男的其实是一个性侵。但是可能现在这些情况可能会更加多样，就可能说，呃，我并不会去做一些实质性的侵入的工作。我可能就只是说，哎，我见到一个萝莉，我去搂搂抱抱，或者说我心生邪念了，我去做一些性器官的接触。或者说我，或者说是…因为我其实见到，如果你有关注，其实见到很多案例，就可能说，呃，我叫一个小女孩用棒棒糖让她来帮我口一次，也就是说是口交一次，对吧，嗯，其实见过这种案例的，对，然后或者说是，呃，或者说是叫一个小男孩来给口一次，或者说是其他，而且这个他身份可能是会有变化的。可能后面会多样的，就是说我一个二十多岁的女生，或者说就是我自己的生活比较开放。嗯，对，然后我去我去勾搭一个小孩，然后我去跟他发生性关系。其实在我看来这种其实也是一种性侵。因为在小男孩性观念没有成熟之前，你这个操作是会对他造成很大影响的，他的性取向或者性操作会有很大影响吧。包括现在其实同性恋也放到台面上来讲了，就是说我同性恋去强行掰弯一个人，或者说我去性侵一个小男孩，其实也是一个，就是说性侵它其实是现在很严重，儿童性侵其实是很严重的一件事。而且现在是多样化。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，但是相关的法律确实还没有跟得上。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>是的，没错。对，就比如说，呃，我一个，呃就比如说我一个二十多岁三十多岁的女生，我去性侵一个男生，一个十多岁的男生，如果说我是有其他身份的，我是一个老师，或者说是一个在其他国家，他是能够得到一个，就可能说是更重的处罚。而国内的话，其实这一块的法律行为是没有完善的。就可能说如果这个男生小于14岁，你可能会以侵犯儿童，猥亵儿童罪的名义去入刑。然后就比如说小于14岁是强奸这种，其实仅限于女性，没有男性，因为国内强奸它采取的还是一个插入的说法，性器官男生对于女生的一个侵犯。所以说我觉得其实我国法律有其实还有很大的空间要走。包括就是说是在被性侵之后的及时的心理介入。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，对对对，真的是急需完善的一个状态。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，其实是国内，其实现在性侵其实是多样化的。比如说是儿童性侵，其实多样化。因为其实生活好了嘛，大家其实会想怎么回事？而且其实比如说同性同龄之间的性侵，其实也是非常严重的。就比如说校园暴力的凌辱的行为，就由凌辱转化为性侵，这种事情其实都没有被重视的。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>还有很长的路要要走。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>是的，没错，是的，没错。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>然后你觉得对于遭遇过儿童期性侵犯的受害者来说，他需要哪些力量的介入和帮助？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，我觉得最强力的是公权力。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>什么？公权力？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>嗯，公权力的介入，就是政府部门的介入。就我当时其实这个事情实际上还没有太大，是因为派出所的人给我留下很深的印象。对，当时因为没来得及吃晚饭嘛，然后我当时我还记得就是说那个派出所当时应该和我父亲那边还在联系……（信号原因，没听清）因为一般像这种小地方的警察，可能觉得这种事情就很不耐烦：没事没事，你们先回家自己处理嘛。和稀泥嘛，基层的传统玩法，和稀泥嘛。然后那个警察叔叔就很尽责，然后我记得当时我还没吃早饭，然后录笔录录到下午两点多，还没采体液。小孩子嘛，饿嘛，然后我记得我还在当时他办公室吃了一袋苹果片，然后我现在还记得，然后，对，我觉得这种东西，公权力的及时的介入，其实是能够在第一时间对小孩子就说是一个很贴切的保障。因为大家都从小都得到一个认识嘛：警察叔叔是好人。你受到欺负，警察叔叔会来帮你，对吧？然后，对，这个东西公权力的介入一定是第一优先的，就是说家庭和公权力的及时介入第一是优先。第二个其实我觉得很重要的就说是在性侵的一个月以内，就说是我觉得不管他当时有没有表现出异样啊，一定是要寻求及时的心理干涉。对，就是说因为性侵其实跟其他一样，就是你学心理的肯定比我清楚，就是说性侵跟其他的一样，就是说受伤害的这个东西，他或多或少的一定会有p t sd 相关的东西。如果说是你没有去寻求心理的介入，那么你这个东西可能就是说你心里始终是有个梗儿在这儿。就比如说台湾有个作家叫张苑，就是台湾那个作家自杀的那一位我忘了。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>林奕含。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>啊，对，林奕含，然后她其实她其实就是这种，呃，就可能说像我这样皮实的人，可能说会选择自我开导，但是选择像她那样的人，可能就是一个p t s d，然后再加上其他各种事情的不理解，抑郁，然后自杀。其实我觉得所以说第一时间的公权力介入，第一时间的心理干涉一定是非常必要的且非常重要的。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯嗯，确实是的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>但是我觉得国内其实好像专门做儿童性侵心理干涉的好像很少。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>确实很少。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，我觉得就这个东西其实是亟待完善的。因为其实用成人的那套心理干涉的做法去做儿童心理，其实是（一个词，没听清）不同的。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，首先心理学在中国就刚刚发展起来，就是处于起步的那种朝阳状态。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>啊，就是说这些东西还得需要时间去完善吧。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>对，确实它需要一个过程。不过也在慢慢的变好。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>其实说实话，我觉得短期之内其实是不一定能看到太好的变好。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>是的是的是的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>唉，任重道远吧。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>路漫漫。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，其实是我一个（没听清），我觉得对于小孩子来讲，就是说及时的、周边的帮助非常的重要。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>对于预防和干预儿童性侵犯你有什么建议？其实这个问题和刚才那个问题是一个性质的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>预防其实你这个事情没法解，你预防不了，你预防不了。因为你其实性侵它一定是意味着一个事情，就是说是有一方的呃，就是说是，呃，不管是体力还是其他的，他一定是凌驾于另外一方的。对吧？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>是的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对。我就举这么一个不太恰当的例子，就是说性侵，它这个事情其实你只能从就是说是一些呃去打一些预防针。就比如说女孩子就是现在常见的：女孩子啊，你不来让男孩子摸啊，然后这种东西。但是如果说，比如说我，就是说我要采取暴力手段了，我举一个不恰当的例子，希望你不要介意。就是比如说我见到一个萝莉了，对，我采取暴力手段，我去搂搂抱抱，来做一个就是说是，呃，过分的事情，你觉得她有抵抗力吗？没有，对吧？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，然后你觉得这件事情能预防吗？没有办法。对，所以说我觉得预防其实，其实它一部分其实是个很奢侈的事情，因为它是需要一个去体系化的一个建设，很奢侈的事情。我觉得更重要的可能却需要去告诉孩子说：这个事情不是一个shame的事情。如果你被侵犯了，这不是你的错误，你需要告诉及时告诉爸爸。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯嗯，对。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>我觉得这个事情其实是比预防更重要的事情。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>很中肯，嗯。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对对，因为，呃，知乎上你应该也能看到很多匿名的，就觉得说家里人觉得丢脸，很多，特别是女孩子，然后家里人就不告诉她这些。对吧？然后我觉得这个可能说是因为很多事情预防预防不了。因为就比如说走在路上，突然有人心生歹念，就是你怎么预防？防也防不动啊。除非你随身身上带把刀，然后谁敢碰我我割了他。这种事情当然也都是说笑话，然后我觉得这种事情就一定去培养一个观念：就是说这个事情它不是一个shame的事情，不是你的错，你需要（告诉家里人？没听清，不确定）。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，主要是家庭方面影响特别大。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>是的，其实我觉得公权力方面也影响非常大。因为其实很多就是基层嘛，就是其实很多他虽然说他是警察，但是可能他的法律意识没有吧。然后他可能就会下意识的，就是说，因为这种地方是个小地方，可能就会说：啊，为了你女儿着想，这个事情和了吧。咱们就不走中间法吧，你们就都妥一下对吧。我觉得就是说基层，就说是可能就觉得说，呃，反正就觉得，呃，就千万不要和稀泥，就不要受害者有罪推定，就这个事情不是他的错误。我觉得就是建立一个系统的认知，这个事情是非常重要的。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，就是现在来看的话，你回头去看你的那些应对方式，你会有一个什么样的感受？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>我父亲做很帮，啊，然后但是可能说他可以做的更棒，但是这个东西其实是马后炮的，我也没法去跟07年的时候，那个时候他……啊，对不起，我去看一下吧，可能有人在敲门。反正我觉得他当时做的很棒，那一套行云流水，其实也很感激他。对，但是的话我觉得可能说，如果说我自己从现在一个事后的角度去复盘，我觉得可能还缺了就我刚刚说的心理干涉。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，那包括你自己的应对方式呢，就是你选择把它给说出来。你觉得如果不说的话，你会怎么样？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，其实我这个东西很多事情没法做假设呀。我也不知道我不说会怎么样。其实这个东西我觉得其实没法做没法。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，那你去看你的这种应对方式的话，你是什么感受？你怎么看待？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>我其实也没什么特别的感受。我只是觉得我做了一件应该做的事情。没什么特别的感受。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，我还设计了一个问题，就是如果说你可以回到当初那件事情发生的时候，你会做什么？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>其实说实话，我觉得这个问题其实没有太大意义。因为其实。你像刚才我说的很多时候，他其实是处于弱势的一个地位，校园性侵他其实是对于性一个很懵懂的这个东西，你没法去假设去说你具备一个完全的性知识人。穿越回去附身到他身上，然后说当时会怎么做，我觉得其实这个东西，这个假设其实是没有意义的。我说的比较直白啊。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，因为可能就是男生比较理性嘛，但是就是对我自己而言，我是希望我能够回去的，就是我假想过这样的一个场景，我如果可以回去，那我就可以避免这所有的一切的发生，就是有一个情绪的宣泄口嘛，这就是我问这个问题的原因。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>是，是一个情绪的宣泄口，但是就是可能说，呃，对于更大多数人来讲，其实这个东西其实没有意义。我们只能往前看，就是就像刚才我说的。其实我知道你意思，你其实想说我去总结一套经验出来，就是说避免当时发生。但是其实就像我刚才说的，很多时候儿童性侵的受害者他其实是面对的是成年人，他其实是面对的是成年人，而且是多种多样的成年人。他其实留给他的选择余地不多。我感觉你情绪好像有点波动啊。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>没有，是因为我想到我前面访谈的那些女生，加害者全部都不是成年人，啊，有一个是成年人，其余的全都是中学生，十四岁左右的小男生。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，唉，其实我觉得这个事情吧，其实这个事情其实说实话，这种东西就是纯粹就是属于飞来横祸的。对，因为这个东西，就比如我走在路上，然后被突然十二楼掉下来一个东西砸死了。然后我也没法说我提前预知到今天三点十分楼上要掉东西，避开它。这个东西没法预测，除非我直接具备超能力。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，好，再追加一个问题呢，就整个访谈下来你有什么感受，还有你对于我这个访谈的感受吧？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，我觉得其实反正我觉得其实感觉还好吧。我最开始想的就是你的态度会push一些，就稍微有侵略性一些，学院性一点，其实我觉得整个聊下来感觉还不错。然后的话，对，但是我觉得自己更希望就是说我自己希望是能越来越多的人有来做你这方面的研究的。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>我也有这样的希望啊。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，我觉得可能是我自己更希望说是有更多人来做这个研究。其实我不介意去做访谈，但是我希望能有更多人。其实说实话我也很好奇，为什么你是第一个找我的？为什么没有其他人找我？其实我也很好奇这个问题。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>你是觉得在很早之前就应该有人去做这样的一个研究？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，我觉得其实它并不是一个新鲜事儿，它其实并不是一个新鲜事儿。其实我觉得虽然说国内心理学就是说这方面的研究起步晚吧，但是也不至于到了2020年的今天才有人来开始去做这个，马上都要2021年了，才有人来去找当时的事儿。但是也有可能是我不是在圈子内啊，我不知道啊，也有可能我不在圈子内，我不知道。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>其实我很早就想写这个，但是我不太敢跟我导师说，怕被否决。他们会说这是一个特别特别敏感的话题，可行性特别低。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>o k ，o k ，o k 明白，我其实很好奇，那你最终决定去做这个话题的时候，你导师你老板什么看法？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>我老师就支持我啊。但是他说你要考虑一个问题，就是你可能找不到被试，你找不够，因为这是一个非常敏感的问题，你找研究对象是非常困难的。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>啊，是的。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>还有就是我没有提到的，而你想要说的，想要表达的一些东西？</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>哦，其实我当时想聊的，其实基本上你这个题做的还不错。其实我想聊的其实基本上都聊到了。就是说反正我觉得其实我更希望的就是说是国内这方面的研究能够跟上，其实先不提法律层面上了，因为法律必定是滞后于社会发展。对，然后对，我先不提法律上，我就希望心理干涉这一块儿能够及时跟上，就包括大家的观点，就千万不要去面对一个性侵受害者说：你当时穿的太少了，你太骚，你太浪了…这种东西，就被害者有罪论你千万不要再去讲。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>对对对。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>就是这些吧，我就是只想说“去你丫的”！反正我觉得其实这个东西，反正我觉得你做这个事情是比较有意义的。就我刚才说，我很好奇为啥为啥会2020年才有人找。当然我不在圈内，可能更早有人做了，我没知道而已，就翻到了我而已。但是我觉得的确应该是非常少见。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，13年、14年也是有人做的，因为我看到一些相关的硕士论文。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，反正希望你这边的研究一切顺利吧，反正就是说我自己还是觉得就是其实是反正如果说你对这个，我不知道你对做这个事情有怀疑没有。如果有的话，反正我还明确告诉你：做这个事情非常有意义。</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，谢谢，谢谢。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>对，行，看你这边还有啥想问的没？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>目前是没有了。你做的一切也非常非常有意义。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>谢谢。那要不然就先这样？</td><td></td></tr><tr><td></td><td>访谈者：</td><td>嗯，好，那你忙吧，拜拜。</td><td></td></tr><tr><td></td><td>访谈对象：</td><td>拜拜。</td></tr></tbody></table></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实想说的话有很多，但是一下不知道怎么说吧。在这里先引用我的采访者在论文中写的一句话作为结尾吧</p><blockquote><p>我始终相信星星之火，可以燎原。</p></blockquote><p>Everything is gonna be OK</p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用动态 tracing 技术来 trace 内核中的网络请求</title>
      <link href="//posts/2021/04/17/how-to-tracing-package-in-the-linux-kernel/"/>
      <url>//posts/2021/04/17/how-to-tracing-package-in-the-linux-kernel/</url>
      
        <content type="html"><![CDATA[<p>这周帮朋友用 eBPF/SystemTap 这样的动态 tracing 工具做了一些很有趣的功能。这篇文章算是一个总结</p><span id="more"></span><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>实际上这周的一些想法，最开始是实际上来源于某天一个朋友问我的一个问题</p><blockquote><p>我们能不能监控机器上哪些进程在发出 ICMP 请求？需要拿到 PID，ICMP 包出口地址，目标地址，进程启动命令</p></blockquote><p>很有趣的问题。实际上首先拿到这个问题时候，我们第一反应肯定是 “让机器上的进程在发 ICMP 包的时候”直接往一个地方写日志不就好了，emmmm，用一个 meme 镇楼吧</p><p><img src="https://user-images.githubusercontent.com/7054676/115106820-68ae5400-9f99-11eb-8dbd-772d18f6b039.png" alt="鸡生蛋蛋生鸡"></p><p>嗯，可能大家都知道我想说什么了，我们这种场景实际上只能选择旁路，无侵入的方式去做。</p><p>那么涉及到包的旁路的 trace，大家第一反应肯定是 <a href="https://www.tcpdump.org/manpages/tcpdump.1.html">tcpdump</a> 去抓包。但是在我们今天的问题下，tcpdump 只能拿到包信息， 但是拿不到具体的 PID，启动命令等信息。</p><p>所以我们可能需要用另外一些方式去实现我们的需求</p><p>在需求最开始之初，我们还可能的选择的方式有这样一些</p><ol><li><p>走 <a href="https://www.kernel.org/doc/Documentation/networking/proc_net_tcp.txt">/proc/net/tcp</a> 去拿具体的 socket 的 <strong>inode</strong> 信息，然后反查 pid 关联</p></li><li><p>eBPF + kprobe 内核打点做监控</p></li><li><p>SystemTap + kprobe 内核打点做监控</p></li></ol><p>第一种方式，实际上只能拿到 TCP 一层的信息，但是 ICMP 并不是 TCP 协议啊（衰（虽然同属 L4 </p><p>那么看到最后，我们貌似就只有用 eBPF/SystemTap 配合 kprobe 的一条路可以走了</p><h2 id="基础的-trace"><a href="#基础的-trace" class="headerlink" title="基础的 trace"></a>基础的 trace</h2><h3 id="Kprobe"><a href="#Kprobe" class="headerlink" title="Kprobe"></a>Kprobe</h3><p>在继续下面的代码实际操作之前，我们首先要来认识一下 <a href="https://www.kernel.org/doc/html/latest/trace/kprobes.html">Kprobe</a></p><p>先引用一段官方文档的介绍</p><blockquote><p>Kprobes enables you to dynamically break into any kernel routine and collect debugging and performance information non-disruptively. You can trap at almost any kernel code address 1, specifying a handler routine to be invoked when the breakpoint is hit.<br>There are currently two types of probes: kprobes, and kretprobes (also called return probes). A kprobe can be inserted on virtually any instruction in the kernel. A return probe fires when a specified function returns.<br>In the typical case, Kprobes-based instrumentation is packaged as a kernel module. The module’s init function installs (“registers”) one or more probes, and the exit function unregisters them. A registration function such as register_kprobe() specifies where the probe is to be inserted and what handler is to be called when the probe is hit.</p></blockquote><p>简单来说，kprobe 是内核的一个提供的一个 trace 机制，在执行我们所设定特定的内核函数时/后，会按照我们所设定的规则触发我们的回调函数。用官方的话来说，“You can trap at almost any kernel code address”</p><p>在我们今天的场景下，不管利用 eBPF 还是 SystemTap 都需要依赖 Kprobe 并选择合适的 hook 点来完成我们内核调用的 trace</p><p>那么，在我们今天的场景下，我们应该选择在什么函数上加上对应的 hook 呢？</p><p>首先我们来想一下，ICMP 是一个四层的包，最终封装在一个 IP 报文中分发出去，那么我们来看一下，内核中 IP 报文发送中的关键调用，参见下图</p><p><img src="https://user-images.githubusercontent.com/7054676/115108292-37865180-9fa2-11eb-920f-dada0463ea10.png" alt="IP Layer 关键系统调用"></p><p>在这里我选择将 ip_finish_output 作为我们的 hook 点。</p><p>OK，Hook 点确认后，在开始正式编码前，我们来大概介绍下 <code>ip_finish_output</code></p><h3 id="ip-finish-output"><a href="#ip-finish-output" class="headerlink" title="ip_finish_output"></a>ip_finish_output</h3><p>首先来看下这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_finish_output</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = BPF_CGROUP_RUN_PROG_INET_EGRESS(sk, skb);</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> NET_XMIT_SUCCESS:</span><br><span class="line"><span class="keyword">return</span> __ip_finish_output(net, sk, skb);</span><br><span class="line"><span class="keyword">case</span> NET_XMIT_CN:</span><br><span class="line"><span class="keyword">return</span> __ip_finish_output(net, sk, skb) ? : ret;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体细节先不在这里展开（因为实在是太多了Orz），在系统调用 <code>ip_finish_output</code> 时，会触发我们设定的 kprobe 的钩子，在我们所设定的 hook 函数中会收到 <code>net</code>, <code>sk</code>, <code>skb</code> 三个参数（这三个参数也是调用 <code>ip_finish_output</code> 时的值。</p><p>在这三个参数中，我们主要来将视线放在 <code>struct sk_buff *skb</code> 上。</p><p>熟悉 Linux Kernel 协议栈实现的同学肯定对 <code>sk_buff</code> 这个数据结构非常非常熟悉了。这个数据结构是 Linux Kernel 中网络相关的核心数据结构。通过不断的偏移指针，这个数据结构能够很方便帮助我们确认我们待发送/已接收的数据在内存中所存放的位置。</p><p>空口直说好像有点抽象，我们来看个图</p><p><img src="https://user-images.githubusercontent.com/7054676/115132085-9514af80-a02f-11eb-9434-3bf085714817.png" alt="sk_buff"></p><p>以发送一个 TCP 包为例，我们能看到这个图中，sk_buff 经历了六个阶段</p><p>a. 根据 TCP 中的一些选项如 MSS 等，分配一个 buffer<br>b. 根据 MAX_TCP_HEADER 在我们申请好的内存 buffer 中预留一段足够容纳所有网络层的 header 的空间（TCP/IP/Link等）<br>c. 填入 TCP 的 payload<br>d. 填入 TCP header<br>e. 填入 IP header<br>d. 填入 link header</p><p>可以参照一下 TCP 报文结构，这样大家会有一个更直观的理解</p><p><img src="https://user-images.githubusercontent.com/7054676/115132279-6c8db500-a031-11eb-9fd3-1ea346015cdb.png" alt="TCP Segement Format"></p><p>大家能看到，通过 sk_buff 的一些指针的操作，我们就能很方便的获取到其中不同 layer 的 header 和具体的 payload</p><p>OK，现在让我们正式的来开始实现我们所需要的功能</p><h3 id="eBPF-KProbe"><a href="#eBPF-KProbe" class="headerlink" title="eBPF + KProbe"></a>eBPF + KProbe</h3><p>首先简单介绍下 eBPF。BPF 指 Berkeley Packet Filter ，最早期是用来设计在内核中实现一些网络包过滤的功能。但是后续社区对其做了非常多的强化增强，使其不仅能应用于网络目地。这也是名字中 e 的来历（extend）</p><p>本质上而言，eBPF 在内核维护了一层 VM，可以加载特定规则生成的代码，让内核变得更具有可编程性（后面我争取写一篇 eBPF 从入门到入土的介绍文章）</p><blockquote><p>Tips: Tcpdump 的背后就是 BPF</p></blockquote><p>然后在这次实现中，我们使用了 <a href="https://github.com/iovisor/bcc">BCC</a> 来简化我们 eBPF 相关的编写难度</p><p>OK，先上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line">bpf_text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">#include &lt;linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/sched.h&gt;        /* For TASK_COMM_LEN */</span></span><br><span class="line"><span class="string">#include &lt;linux/icmp.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/ip.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/netdevice.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">struct probe_icmp_sample &#123;</span></span><br><span class="line"><span class="string">    u32 pid;</span></span><br><span class="line"><span class="string">    u32 daddress;</span></span><br><span class="line"><span class="string">    u32 saddress;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">BPF_PERF_OUTPUT(probe_events);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">static inline unsigned char *custom_skb_network_header(const struct sk_buff *skb)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">return skb-&gt;head + skb-&gt;network_header;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">static inline struct iphdr *get_iphdr_in_icmp(const struct sk_buff *skb)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    return (struct iphdr *)custom_skb_network_header(skb);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int probe_icmp(struct pt_regs *ctx, struct net *net, struct sock *sk, struct sk_buff *skb)&#123;</span></span><br><span class="line"><span class="string">    struct iphdr * ipdata=get_iphdr_in_icmp(skb);</span></span><br><span class="line"><span class="string">    if (ipdata-&gt;protocol!=1)&#123;</span></span><br><span class="line"><span class="string">        return 1;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    u64 __pid_tgid = bpf_get_current_pid_tgid();</span></span><br><span class="line"><span class="string">    u32 __pid = __pid_tgid;</span></span><br><span class="line"><span class="string">    struct probe_icmp_sample __data = &#123;0&#125;;</span></span><br><span class="line"><span class="string">    __data.pid = __pid;</span></span><br><span class="line"><span class="string">    u32 daddress;</span></span><br><span class="line"><span class="string">    u32 saddress;</span></span><br><span class="line"><span class="string">    bpf_probe_read(&amp;daddress, sizeof(ipdata-&gt;daddr), &amp;ipdata-&gt;daddr);</span></span><br><span class="line"><span class="string">    bpf_probe_read(&amp;saddress, sizeof(ipdata-&gt;daddr), &amp;ipdata-&gt;saddr);</span></span><br><span class="line"><span class="string">    __data.daddress=daddress;</span></span><br><span class="line"><span class="string">    __data.saddress=saddress;</span></span><br><span class="line"><span class="string">    probe_events.perf_submit(ctx, &amp;__data, sizeof(__data));</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IcmpSamples</span>(ctypes.Structure):</span><br><span class="line">    _fields_ = [</span><br><span class="line">        (<span class="string">&quot;pid&quot;</span>, ctypes.c_uint32),</span><br><span class="line">        (<span class="string">&quot;daddress&quot;</span>, ctypes.c_uint32),</span><br><span class="line">        (<span class="string">&quot;saddress&quot;</span>, ctypes.c_uint32),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_text)</span><br><span class="line"></span><br><span class="line">filters = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_ip_address</span>(<span class="params">data</span>):</span><br><span class="line">    results = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    results[<span class="number">3</span>] = data &amp; <span class="number">0xFF</span></span><br><span class="line">    results[<span class="number">2</span>] = (data &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    results[<span class="number">1</span>] = (data &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    results[<span class="number">0</span>] = (data &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;.&quot;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> results[::-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_icmp_event</span>(<span class="params">cpu, data, size</span>):</span><br><span class="line">    <span class="comment"># event = b[&quot;probe_icmp_events&quot;].event(data)</span></span><br><span class="line">    event = ctypes.cast(data, ctypes.POINTER(IcmpSamples)).contents</span><br><span class="line">    daddress = parse_ip_address(event.daddress)</span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">f&quot;pid:<span class="subst">&#123;event.pid&#125;</span>, daddress:<span class="subst">&#123;daddress&#125;</span>, saddress:<span class="subst">&#123;parse_ip_address(event.saddress)&#125;</span>&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf.attach_kprobe(event=<span class="string">&quot;ip_finish_output&quot;</span>, fn_name=<span class="string">&quot;probe_icmp&quot;</span>)</span><br><span class="line"></span><br><span class="line">bpf[<span class="string">&quot;probe_events&quot;</span>].open_perf_buffer(print_icmp_event)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bpf.kprobe_poll()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>OK，这段代码严格意义上来说是混编的，一部分是 C，一部分是 Python，。Python 部分大家肯定都很熟悉，BCC 帮我们加载我们的 C 代码，并 attch 到 kprobe 上。然后不断输出我们从内核中往外传输的数据</p><p>那我们重点来看看 C 部分的代码（实际上这严格来说不算标准 C，算是 BCC 封装的一层 DSL）</p><p>首先看一下我们辅助的两个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">custom_skb_network_header</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> skb-&gt;head + skb-&gt;network_header;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> iphdr *<span class="title function_">get_iphdr_in_icmp</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> iphdr *)custom_skb_network_header(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如前面所说，我们可以根据 sk_buff 中的 head 和 network_header 就能计算出我们 IP 头部在内存中的地址，然后我们将其 cast 成一个 <code>iphdr</code> 结构体指针</p><p>我们还得再来看一下 iphdr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LITTLE_ENDIAN_BITFIELD)</span></span><br><span class="line">__u8ihl:<span class="number">4</span>,</span><br><span class="line">version:<span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (__BIG_ENDIAN_BITFIELD)</span></span><br><span class="line">__u8version:<span class="number">4</span>,</span><br><span class="line">  ihl:<span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span><span class="string">&quot;Please fix &lt;asm/byteorder.h&gt;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">__u8tos;</span><br><span class="line">__be16tot_len;</span><br><span class="line">__be16id;</span><br><span class="line">__be16frag_off;</span><br><span class="line">__u8ttl;</span><br><span class="line">__u8protocol;</span><br><span class="line">__sum16check;</span><br><span class="line">__be32saddr;</span><br><span class="line">__be32daddr;</span><br><span class="line"><span class="comment">/*The options start here. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>熟悉 IP 报文结构的同学肯定就很眼熟了对吧，其中 <code>saddr</code> 和 <code>daddr</code> 就是我们的源地址和目标地址，<code>protocol</code> 代表着我们 L4 协议的类型，其中为1的时候代表着 ICMP 协议</p><p>OK 然后来看一下我们的 trace 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">probe_icmp</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx, <span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> * <span class="title">ipdata</span>=</span>get_iphdr_in_icmp(skb);</span><br><span class="line">    <span class="keyword">if</span> (ipdata-&gt;protocol!=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    u64 __pid_tgid = bpf_get_current_pid_tgid();</span><br><span class="line">    u32 __pid = __pid_tgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">probe_icmp_sample</span> __<span class="title">data</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    __data.pid = __pid;</span><br><span class="line">    u32 daddress;</span><br><span class="line">    u32 saddress;</span><br><span class="line">    bpf_probe_read(&amp;daddress, <span class="keyword">sizeof</span>(ipdata-&gt;daddr), &amp;ipdata-&gt;daddr);</span><br><span class="line">    bpf_probe_read(&amp;saddress, <span class="keyword">sizeof</span>(ipdata-&gt;daddr), &amp;ipdata-&gt;saddr);</span><br><span class="line">    __data.daddress=daddress;</span><br><span class="line">    __data.saddress=saddress;</span><br><span class="line">    probe_events.perf_submit(ctx, &amp;__data, <span class="keyword">sizeof</span>(__data));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如前面所说，kprobe 触发调用时，会将 <code>ip_finish_output</code> 的三个参数传入到我们的 trace 函数中来，那我们就可以根据传入的数据做很多的事了，现在来介绍下上面的代码中所做的事</p><ol><li>将 sk_buff 转换成对应的 iphdr</li><li>判断当前报文是否为 ICMP 协议</li><li>利用内核 BPF 提供的 helper <code>bpf_get_current_pid_tgid</code> 获取当前调用 <code>ip_finish_output</code> 进程的 pid</li><li>获取 saddr 和 daddr。注意我们这里用的 bpf_probe_read 也是 BPF 提供的 helper function，原则上来讲，在 eBPF 中为了保证安全，我们所有从内核中读取数据的行为都应该利用 <code>bpf_probe_read</code> 或 <code>bpf_probe_read_kernel</code> 来实现</li><li>通过 perf 将数据提交出去</li></ol><p>这样一来，我们就能排查到机器上具体什么进程在发送 ICMP 请求了</p><p>来看下效果</p><p><img src="https://user-images.githubusercontent.com/7054676/115132783-db6d0d00-a035-11eb-952a-3fcf33c86690.png" alt="image"></p><p>OK，我们的需求基本上达到了，不过这里算是留了一个小问题，大家可以思考下，我们怎么样根据 pid 获取启动进程时的 cmdline ?</p><h3 id="SystemTap-kprobe"><a href="#SystemTap-kprobe" class="headerlink" title="SystemTap + kprobe"></a>SystemTap + kprobe</h3><p>eBPF 的版本实现了，但是有个问题啊，eBPF 只能在高版本的内核中使用。一般而言，在 xb86_64 上，Linux 3.16 中支持了 eBPF。而我们依赖的 kprobe 对于 eBPF 的支持则是在 Linux 4.1 中实现的。通常而言，我们一般推荐使用 4.9 及以上内核来配合 eBPF 使用</p><p>那么问题来了。实际上我们现在有很多 Centos 7 + Linux 3.10 这样的传统的搭配，那么他们怎么办呢？</p><blockquote><p>Linux 3.10 live’s matter! Centos 7 live’s matter!</p></blockquote><p>那没办法，只能换一个技术栈来做了。这个时候，我们就首先考虑由 RedHat 开发，贡献进入社区，低版本可用的 SystemTap</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="comment">#include&lt;linux/byteorder/generic.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;linux/if_ether.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;linux/skbuff.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;linux/ip.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;linux/in.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;linux/tcp.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/sched.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/list.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/pid.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/mm.h&gt;</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> isicmp:long (data:long)</span><br><span class="line">%&#123;</span><br><span class="line">    struct iphdr *ip;</span><br><span class="line">    struct sk_buff *skb;</span><br><span class="line">    int tmp = 0;</span><br><span class="line"></span><br><span class="line">    skb = (struct sk_buff *) STAP_ARG_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;protocol == htons(ETH_P_IP))&#123;</span><br><span class="line">            ip = (struct iphdr *) skb-&gt;data;</span><br><span class="line">            tmp = (ip-&gt;protocol == 1);</span><br><span class="line">    &#125;</span><br><span class="line">    STAP_RETVALUE = tmp;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> task_execname_by_pid:string (pid:long) %&#123;</span><br><span class="line">    struct task_struct *task;</span><br><span class="line"></span><br><span class="line">    task = pid_task(find_vpid(STAP_ARG_pid), PIDTYPE_PID);</span><br><span class="line"></span><br><span class="line">//     proc_pid_cmdline(p, STAP_RETVALUE);</span><br><span class="line">    snprintf(STAP_RETVALUE, MAXSTRINGLEN, <span class="string">&quot;%s&quot;</span>, task-&gt;<span class="built_in">comm</span>);</span><br><span class="line">    </span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> ipsource:long (data:long)</span><br><span class="line">%&#123;</span><br><span class="line">    struct sk_buff *skb;</span><br><span class="line">    struct iphdr *ip;</span><br><span class="line">    __be32 src;</span><br><span class="line"></span><br><span class="line">    skb = (struct sk_buff *) STAP_ARG_data;</span><br><span class="line"></span><br><span class="line">    ip = (struct iphdr *) skb-&gt;data;</span><br><span class="line">    src = (__be32) ip-&gt;saddr;</span><br><span class="line"></span><br><span class="line">    STAP_RETVALUE = src;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">/* Return ip destination address */</span><br><span class="line"><span class="keyword">function</span> ipdst:long (data:long)</span><br><span class="line">%&#123;</span><br><span class="line">    struct sk_buff *skb;</span><br><span class="line">    struct iphdr *ip;</span><br><span class="line">    __be32 dst;</span><br><span class="line"></span><br><span class="line">    skb = (struct sk_buff *) STAP_ARG_data;</span><br><span class="line"></span><br><span class="line">    ip = (struct iphdr *) skb-&gt;data;</span><br><span class="line">    dst = (__be32) ip-&gt;daddr;</span><br><span class="line"></span><br><span class="line">    STAP_RETVALUE = dst;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> parseIp:string (data:long) %&#123; </span><br><span class="line">    sprintf(STAP_RETVALUE,<span class="string">&quot;%d.%d,%d.%d&quot;</span>,(int)STAP_ARG_data &amp;0xFF,(int)(STAP_ARG_data&gt;&gt;8)&amp;0xFF,(int)(STAP_ARG_data&gt;&gt;16)&amp;0xFF,(int)(STAP_ARG_data&gt;&gt;24)&amp;0xFF);</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">probe kernel.function(<span class="string">&quot;ip_finish_output&quot;</span>).call &#123;</span><br><span class="line">    <span class="keyword">if</span> (isicmp(<span class="variable">$skb</span>)) &#123;</span><br><span class="line">        pid_data = pid()</span><br><span class="line">        /* IP */</span><br><span class="line">        ipdst = ipdst(<span class="variable">$skb</span>)</span><br><span class="line">        ipsrc = ipsource(<span class="variable">$skb</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid is:%d,source address is:%s, destination address is %s, command is: &#x27;%s&#x27;\n&quot;</span>,pid_data,parseIp(ipsrc),parseIp(ipdst),task_execname_by_pid(pid_data))</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上大家可以看到，我们思路还是一样，利用 <code>ip_finish_output</code> 来作为 kprobe 的 hook 点，然后我们获取对应的 iphdr 然后进行操作。</p><p>嗯，我们的需求的基础功能差不多就是这样了，大家可以在额外进行一些功能增强，比如获取完整的进程 cmdline 等等</p><h2 id="更近一步的想法和实验"><a href="#更近一步的想法和实验" class="headerlink" title="更近一步的想法和实验"></a>更近一步的想法和实验</h2><p>大家可能对于 ICMP 这样的冷门协议没有太明显的感觉，那么我们换个需求大家可能就更为有感觉了</p><blockquote><p>监控机器上哪些进程在发出 HTTP 1.1 请求</p></blockquote><p>嗯，一如往的，我们先来看一下系统中的关键调用</p><p><img src="https://user-images.githubusercontent.com/7054676/115133429-baf38180-a03a-11eb-903f-f2cf46f3edd0.png" alt="TCP"></p><p>嗯，这里我们选择 <code>tcp_sendmsg</code> 来作为我们的切入点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_sendmsg</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> msghdr *msg, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">lock_sock(sk);</span><br><span class="line">ret = tcp_sendmsg_locked(sk, msg, size);</span><br><span class="line">release_sock(sk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，其中 <code>sock</code> 是包含我们一些关键元数据的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Now struct inet_timewait_sock also uses sock_common, so please just</span></span><br><span class="line"><span class="comment"> * don&#x27;t add nothing before this first member (__sk_common) --acme</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_common</span>__<span class="title">sk_common</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_common</span> &#123;</span></span><br><span class="line"><span class="comment">/* skc_daddr and skc_rcv_saddr must be grouped on a 8 bytes aligned</span></span><br><span class="line"><span class="comment"> * address on 64bit arches : cf INET_MATCH()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__addrpairskc_addrpair;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__be32skc_daddr;</span><br><span class="line">__be32skc_rcv_saddr;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span>  &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>skc_hash;</span><br><span class="line">__u16skc_u16hashes[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* skc_dport &amp;&amp; skc_num must be grouped as well */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">__portpairskc_portpair;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">__be16skc_dport;</span><br><span class="line">__u16skc_num;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以看到，我们能在 <code>sock</code> 中获取到我们端口的五元组数据，然后我们从 <code>msghdr</code> 中能获取到具体的数据</p><p>那么，以我们需求中的 HTTP 为例，我们实际上只需要判断，我们获取到的 TCP 包中是否包含 <strong>HTTP/1.1</strong> ，便可粗略判断，这个请求是否是 HTTP 1.1 请求（很暴力的做法Hhhhh</p><p>OK，我们来看下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bcc <span class="keyword">import</span> BPF</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">bpf_text = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">#include &lt;linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/ip.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/tcp.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;uapi/linux/ptrace.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;net/sock.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;bcc/proto.h&gt;</span></span><br><span class="line"><span class="string">#include &lt;linux/socket.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">struct ipv4_data_t &#123;</span></span><br><span class="line"><span class="string">    u32 pid;</span></span><br><span class="line"><span class="string">    u64 ip;</span></span><br><span class="line"><span class="string">    u32 saddr;</span></span><br><span class="line"><span class="string">    u32 daddr;</span></span><br><span class="line"><span class="string">    u16 lport;</span></span><br><span class="line"><span class="string">    u16 dport;</span></span><br><span class="line"><span class="string">    u64 state;</span></span><br><span class="line"><span class="string">    u64 type;</span></span><br><span class="line"><span class="string">    u8 data[300];</span></span><br><span class="line"><span class="string">    u16 data_size;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">BPF_PERF_OUTPUT(ipv4_events);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int trace_event(struct pt_regs *ctx,struct sock *sk, struct msghdr *msg, size_t size)&#123;</span></span><br><span class="line"><span class="string">    if (sk == NULL)</span></span><br><span class="line"><span class="string">        return 0;</span></span><br><span class="line"><span class="string">    u32 pid = bpf_get_current_pid_tgid() &gt;&gt; 32;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // pull in details</span></span><br><span class="line"><span class="string">    u16 family = sk-&gt;__sk_common.skc_family;</span></span><br><span class="line"><span class="string">    u16 lport = sk-&gt;__sk_common.skc_num;</span></span><br><span class="line"><span class="string">    u16 dport = sk-&gt;__sk_common.skc_dport;</span></span><br><span class="line"><span class="string">    char state = sk-&gt;__sk_common.skc_state;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (family == AF_INET) &#123;</span></span><br><span class="line"><span class="string">        struct ipv4_data_t data4 = &#123;&#125;;</span></span><br><span class="line"><span class="string">        data4.pid = pid;</span></span><br><span class="line"><span class="string">        data4.ip = 4;</span></span><br><span class="line"><span class="string">        //data4.type = type;</span></span><br><span class="line"><span class="string">        data4.saddr = sk-&gt;__sk_common.skc_rcv_saddr;</span></span><br><span class="line"><span class="string">        data4.daddr = sk-&gt;__sk_common.skc_daddr;</span></span><br><span class="line"><span class="string">        // lport is host order</span></span><br><span class="line"><span class="string">        data4.lport = lport;</span></span><br><span class="line"><span class="string">        data4.dport = ntohs(dport);</span></span><br><span class="line"><span class="string">        data4.state = state;</span></span><br><span class="line"><span class="string">        struct iov_iter temp_iov_iter=msg-&gt;msg_iter;</span></span><br><span class="line"><span class="string">        struct iovec *temp_iov=temp_iov_iter.iov;</span></span><br><span class="line"><span class="string">        bpf_probe_read_kernel(&amp;data4.data_size, 4, &amp;temp_iov-&gt;iov_len);</span></span><br><span class="line"><span class="string">        u8 * temp_ptr;</span></span><br><span class="line"><span class="string">        bpf_probe_read_kernel(&amp;temp_ptr, sizeof(temp_ptr), &amp;temp_iov-&gt;iov_base);</span></span><br><span class="line"><span class="string">        bpf_probe_read_kernel(&amp;data4.data, sizeof(data4.data), temp_ptr);</span></span><br><span class="line"><span class="string">        ipv4_events.perf_submit(ctx, &amp;data4, sizeof(data4));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">bpf = BPF(text=bpf_text)</span><br><span class="line"></span><br><span class="line">filters = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_ip_address</span>(<span class="params">data</span>):</span><br><span class="line">    results = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    results[<span class="number">3</span>] = data &amp; <span class="number">0xFF</span></span><br><span class="line">    results[<span class="number">2</span>] = (data &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    results[<span class="number">1</span>] = (data &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    results[<span class="number">0</span>] = (data &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;.&quot;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> results[::-<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_http_payload</span>(<span class="params">cpu, data, size</span>):</span><br><span class="line">    <span class="comment"># event = b[&quot;probe_icmp_events&quot;].event(data)</span></span><br><span class="line">    <span class="comment"># event = ctypes.cast(data, ctypes.POINTER(IcmpSamples)).contents</span></span><br><span class="line">    event= bpf[<span class="string">&quot;ipv4_events&quot;</span>].event(data)</span><br><span class="line">    daddress = parse_ip_address(event.daddr)</span><br><span class="line">    <span class="comment"># data=list(event.data)</span></span><br><span class="line">    <span class="comment"># temp=binascii.hexlify(data) </span></span><br><span class="line">    body = <span class="built_in">bytearray</span>(event.data).<span class="built_in">hex</span>()</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;48 54 54 50 2f 31 2e 31&quot;</span>.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>) <span class="keyword">in</span> body:</span><br><span class="line">        <span class="comment"># if &quot;68747470&quot; in temp.decode():</span></span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">f&quot;pid:<span class="subst">&#123;event.pid&#125;</span>, daddress:<span class="subst">&#123;daddress&#125;</span>, saddress:<span class="subst">&#123;parse_ip_address(event.saddr)&#125;</span>, <span class="subst">&#123;event.lport&#125;</span>, <span class="subst">&#123;event.dport&#125;</span>, <span class="subst">&#123;event.data_size&#125;</span>&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bpf.attach_kprobe(event=<span class="string">&quot;tcp_sendmsg&quot;</span>, fn_name=<span class="string">&quot;trace_event&quot;</span>)</span><br><span class="line"></span><br><span class="line">bpf[<span class="string">&quot;ipv4_events&quot;</span>].open_perf_buffer(print_http_payload)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        bpf.perf_buffer_poll()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><p>OK，我们来看下效果</p><p><img src="https://user-images.githubusercontent.com/7054676/115135218-4ecc4a00-a049-11eb-899b-baecffdb6268.png" alt="效果"></p><p>实际上这个我们还可以再扩展一下。比如针对 Go 这样，所发出的 HTTPS 连接有着固定特征的语言，我们也可以用相对简单的做法去完成机器上的包来源的溯源（大家可以参考下无辄的这篇文章，<a href="https://www.imwzk.com/posts/2021-03-14-why-i-always-get-503-with-golang/#%E5%B0%BE%E5%A3%B0">为什么用 Go 访问某网站始终会 503 Service Unavailable ？</a>)</p><p>我自己也做了一个测试，大家可以参考下代码：<a href="https://github.com/Zheaoli/linux-traceing-script/blob/main/ebpf/go-https-tracing.py">https://github.com/Zheaoli/linux-traceing-script/blob/main/ebpf/go-https-tracing.py</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上无论是 eBPF 还是 SystemTap ，这类动态 tracing 技术可以 Linux Kernel 变得更具被可编程性。相较于传统的 recompile kernel 这些手段来说，更为方便快捷。而 BCC/BPFTrace 这类的更进一步的封装框架的出现，更进一步的降低了我们去观测内核的难度</p><p>很多时候我们很多需求都可以选择旁路的方式去更快捷的实现。但是要注意的一点是，动态 tracing 技术的引入势必增加了内核的不稳定性，而且一定程度上会影响性能。所以我们需要根据具体的场景去做 trade-off</p><p>好了，这篇文章差不多就水到这里，后面有时间争取出一个 eBPF 从入门到入土的系列文章（flag++</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 水文 </tag>
            
            <tag> eBPF </tag>
            
            <tag> SystemTap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当我们在聊 CI/CD 时，我们在聊什么？</title>
      <link href="//posts/2021/04/11/a-simple-introduce-about-ci-cd/"/>
      <url>//posts/2021/04/11/a-simple-introduce-about-ci-cd/</url>
      
        <content type="html"><![CDATA[<p>本文实际上是在群内第二次分享的内容。这次其实想来聊聊，关于 CI/CD 的一些破事和演进过程中我们所需要遇到的一些问题，当然本文中是一个偏新手向的文章和一点点爆论，随便看看就好。</p><span id="more"></span><h2 id="开宗明义，定义先行"><a href="#开宗明义，定义先行" class="headerlink" title="开宗明义，定义先行"></a>开宗明义，定义先行</h2><p>在我们谈论一个事物之前，我们需要对这个事物给出一个定义，那我们先来看一下我们今天要聊的 CI 与 CD 的定义。</p><p>首先，CI 指 Continuous Integration ，在中文语境中的表述是<strong>持续集成</strong>。而 CD 在常见语境下可能是两种意思：Continuous Delivery 或 Continuous Deployment，与之对应的表述是<strong>持续交付/持续部署</strong>。这里借用一下 Brent Laster 在 <strong>What is CI/CD?</strong><a href="#refer-anchor-1"><sup>1</sup></a> 中给出的定义</p><blockquote><p>Continuous integration (CI) is the process of automatically detecting, pulling, building, and (in most cases) doing unit testing as source code is changed for a product. CI is the activity that starts the pipeline (although certain pre-validations—often called “pre-flight checks”—are sometimes incorporated ahead of CI).<br>The goal of CI is to quickly make sure a new change from a developer is “good” and suitable for further use in the code base.<br>Continuous deployment (CD) refers to the idea of being able to automatically take a release of code that has come out of the CD pipeline and make it available for end users. Depending on the way the code is “installed” by users, that may mean automatically deploying something in a cloud, making an update available (such as for an app on a phone), updating a website, or simply updating the list of available releases.</p></blockquote><p>光看定义，可能大家还是会很懵逼，那么下面我们用一些实际的例子来给大家从头捋一遍 CI/CD 那些事</p><h2 id="Re：从0开始构建流程"><a href="#Re：从0开始构建流程" class="headerlink" title="Re：从0开始构建流程"></a>Re：从0开始构建流程</h2><p>这个标题好像起的有点草，不过不管了。首先我们假定这样一个最简单的需求</p><blockquote><p>我们基于 Hexo 构建了一个个人的博客系统。其中包含我们所需要发布的文章，我们配置的主题。我们需要将其发布到具体的 Repo 上。</p></blockquote><p>好了，基于这个需求，我们来从0到0玩一圈吧（笑（</p><h3 id="构建原生之初"><a href="#构建原生之初" class="headerlink" title="构建原生之初"></a>构建原生之初</h3><p>可能这里有很多人会问，为啥会选择 Hexo 来作为我们的切入点。原因很简单啊！因为它够简单啊！</p><p>言归正传，首先 Hexo 有两个命令 <code>hexo g</code> &amp;&amp; <code>hexo d</code> ，分别是根据当前目录下的 Markdown 文件来生成静态的网页。然后将生成的产物根据配置推送到对应的 repo 上</p><p>OK，那么我们在最原始的阶段一个构建的流程就是这样</p><ol><li>用一个编辑器，开开心心的写文章</li><li>然后在本地终端执行 <code>hexo g &amp;&amp; hexo d</code></li></ol><p>问题来了，现在有些时候提交了博客，但是忘了执行生成命令怎么办？或者是我每次都需要敲重复的命令很麻烦怎么办？那就让我们把整个过程自动化一下吧。Let’s rock!</p><h3 id="更进一步的构建"><a href="#更进一步的构建" class="headerlink" title="更进一步的构建"></a>更进一步的构建</h3><p>OK，我们先来假设一下，我们如果完成了自动化，我们现在发布一个博客的工作流应该编程什么样的</p><ol><li>我们编写一个 Markdown 文件，推送到 GitHub 仓库里的 Master 分支上</li><li>我们的自动任务开始构建我们博客，生成一系列静态文件和样式</li><li>将我们的静态文件和样式推送到我们的站点 Repo/CDN 等目标位置</li></ol><p>好了，那么这里有两个核心的问题</p><ol><li>在我们推送代码的时候，自动开始构建</li><li>在构建完成后，推送产物</li></ol><p>那我们现在基于 GitHub Action 来配置一套我们的自动化构建任务</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">And</span> <span class="string">Publish</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;12.x&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Package</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">Html</span> <span class="string">File</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">🚀</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@3.7.1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PUBLSH_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">gh-pages</span> <span class="comment"># The branch the action should deploy to.</span></span><br><span class="line">          <span class="attr">FOLDER:</span> <span class="string">public</span> <span class="comment"># The folder the action should deploy.</span></span><br></pre></td></tr></table></figure><p>我们能看到这段配置实际上完成了这样一些事情</p><ol><li>在我们往 master 分支提交代码的时候触发构建</li><li>拉取代码</li><li>安装构建所需依赖</li><li>构建生成静态文件</li><li>推送静态文件</li></ol><p>如果上面任何一个步骤失败了，都将取消后面步骤的执行。实际上这样一个简单的任务已经包含了一个 CI &amp;&amp; CD 所包含的基础要素（这里 CD 我并未严格区分 Continuous Delivery/Continuous Deployment)</p><ol><li>与已有的代码持续的构建与集成</li><li>集成中区分多个 phase。每个 phase 将依赖上个 phase 结果。</li><li>将构建产物交付/部署出去。交付/部署的成功依赖于集成的成功</li></ol><p>那么在这里，我们将博客系统换成一个我们工程中的例子。将 Hexo 换成我们的 Python 服务。将新增博文换成我们的新增的代码。将构建命令换成 mypy/pylint 等检查工具。你看，CI/CD 实际上和你想象的复杂的系统，是不是有很大差别？</p><p>这里可能有很多人会提出这样一个问题，如果说这里我们将这些命令，不用线上的形式触发。而在本地用 Git Hook 等形式进行实现。那么这算不算一种 CI 与 CD 呢？我觉得毫无疑问算的，从我的视角来看，CI/CD 核心的要素在于通过可以重复，自动化的任务，来尽早暴露缺陷，减轻人为因素所带来的不必要的事故发生。</p><h2 id="这个开发过份傻逼却不谨慎"><a href="#这个开发过份傻逼却不谨慎" class="headerlink" title="这个开发过份傻逼却不谨慎"></a>这个开发过份傻逼却不谨慎</h2><p>首先抛出一个最基础的爆论，然后我们接着往下谈</p><blockquote><p>所有人都有傻逼的时候，而且这个傻逼的时候可能还会很多。</p></blockquote><p>在这样一个爆论的情况下，我们来回顾一下上面举<strong>基于 Hexo 去构建一个个人博客系统</strong>的例子中，如果我们不选择通过一种收敛的，自动化的系统去解决我们的构建，发布需求。那么我们哪些环节会出现风险</p><ol><li>最基础的，写完博客，忘了构建，忘了发布</li><li>比如我们升级一下依赖中的 Hexo 版本或者主题版本，我们没有测试，导致构建出来的样式失效</li><li>我们的 Markdown 有问题，导致构建失败</li><li>比如多个人维护一个博客的情况下，我们每个人都需要保存目标仓库/CDN的密钥等信息。导致信息泄漏等</li></ol><p>将<strong>基于 Hexo 去构建一个个人博客系统</strong>的例子切换成我们日常开发的场景，那么我们可能遇到的问题会更多。简单举几个</p><ol><li>没法很快速的回滚</li><li>没法溯源具体的构建/发布记录</li><li>没有自动化的任务，研发懒得跑测试或者 lint 导致代码腐化</li><li>高峰期上线导致事故</li></ol><p>嗯，这些问题大家是不是都很熟悉？大概就是，我起了，构建了，出事故了，有啥好说的23333</p><p><img src="https://user-images.githubusercontent.com/7054676/114294469-75cacf00-9ad1-11eb-8853-20e5a50bacce.png" alt="image"></p><p>讲到这里的大家实际上有没有发现一个问题？我在这篇文章中，没有对 CI 与 CD 进行区分？从我的视角来看，CI/CD 本质上是践行的同一个事。即 <strong>对于研发流程与交付流程的收敛</strong></p><p>从我的视角来看，去构建一个 CI/CD 系统核心的目标在于</p><ol><li>通过收敛入口以及自动化的任务触发，尽可能减轻人为因素所带来的系统不稳定性</li><li>通过快速，多次，可重复，无感知的任务，尽可能的在较早阶段暴露系统中的问题</li></ol><p>在这样两个大目标的前提下，我们便会根据不同的业务场景，采用不同的手段与形式丰富我们 CI/CD 中的内容，包括不仅限于</p><ol><li>在 CI 阶段自动化的单元测试，E2E 测试等</li><li>在 CI 阶段周期性的 Nighty Build 等</li><li>在 CD 阶段进行发布管控等</li></ol><p>不过无论我们怎么样去构建一个 CI/CD 系统，或者选择什么样的粒度去进行 CI/CD。我觉得一个合格的 CI/CD 系统与机制 都需要遵照这样几个原则（个人向总结）</p><ol><li>入口的收敛，SOP 的建立。如果不达成这点共识，研发能够通过技术手段绕过 CI/CD 系统那么便又回到的了我们本章的标题（这个研发过份傻逼却不谨慎）</li><li>对于业务代码无侵入</li><li>集成任务/发布任务一定要是自动化，可重复的</li><li>可回溯的历史记录与结果</li><li>可回溯的构建集成产物</li><li>从上到下的支持</li></ol><p>那么遵照我总结的这样几个原则，我们来迭代一下我们之前的博客的发布过程</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">And</span> <span class="string">Publish</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;12.x&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Package</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">Html</span> <span class="string">File</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">To</span> <span class="string">Repo🚀</span></span><br><span class="line">        <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.ref</span> <span class="string">==</span> <span class="string">&#x27;refs/heads/master&#x27;</span><span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@3.7.1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PUBLSH_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">gh-pages</span> <span class="comment"># The branch the action should deploy to.</span></span><br><span class="line">          <span class="attr">FOLDER:</span> <span class="string">public</span> <span class="comment"># The folder the action should deploy.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">to</span> <span class="string">Collect</span> <span class="string">Repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">JamesIves/github-pages-deploy-action@3.7.1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">GITHUB_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PUBLSH_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">BRANCH:</span> <span class="string">build-$&#123;&#123;</span> <span class="string">github.run_id</span> <span class="string">&#125;&#125;</span> <span class="comment"># The branch the action should deploy to.</span></span><br><span class="line">          <span class="attr">FOLDER:</span> <span class="string">public</span> <span class="comment"># The folder the action should deploy.</span></span><br></pre></td></tr></table></figure><p>在这段更改后的构建流程中，我选择以 PR 为粒度去触发 CI 流程，并将历史产物进行存储，而在合并主分支后，新增发布流程。在这样一来，我在博客构建发布的时候，便能够通过回溯的历史产物来验证我框架升级，新增博文等操作的正确性。同时依托 GitHub Action，我能很好的完成历史构建的回溯</p><p><img src="https://user-images.githubusercontent.com/7054676/114294865-f38fda00-9ad3-11eb-938b-c25b7a4ca6bf.png" alt="image"></p><p>嗯，这样便可以尽可能避免我傻逼的操作所带来的各种副作用（逃</p><h2 id="进击的构建：终章"><a href="#进击的构建：终章" class="headerlink" title="进击的构建：终章"></a>进击的构建：终章</h2><p>好了，啥都没有，傻眼了吧<br>。<br>。<br>。<br>。</p><p>只是开个玩笑。实际上本文到这差不多就可以告一段落了。实际上大家通过这篇文章可以发现一个问题。就是实际上构建一个 CI/CD 系统可能并不会涉及很多，很高深的技术问题(极少数的场景除外）无论是传统的 Jenkins，还是新生的 GitHub Action，GitLab-CI，亦或者是云厂商提供的服务都能很好的帮助我们去构建一套贴合业务的 CI/CD 系统。但我之前在推特上发表了的一个爆论“CI/CD 的建立往往不是一个技术问题，而是一个制度问题，更可以称为是一个想法问题”。</p><p>所以，我希望我们每个人都能认识到我们都会犯错这样一个事实。然后尽可能的将自己所负责的系统的开发流程与交付流程尽可能的收敛与自动化。让一个 CI/CD 真正称为我们日常工作中的一部分。</p><p>差不多这样，溜了，溜了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 水文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继续爆论容器中的一号进程</title>
      <link href="//posts/2021/02/27/damn-the-init-process/"/>
      <url>//posts/2021/02/27/damn-the-init-process/</url>
      
        <content type="html"><![CDATA[<p>上周的文章聊了关于容器中的一号进程的一些概况后，在我师父某川(可以去 GitHub 找他玩，<a href="https://github.com/jschwinger23">jschwinger23</a>) 的指导与配合下，我们一起对目前主流的被广泛使用的两个容器中一号进程的实现 dumb-init 和 tini 做了一番探究，继续写个水文来爆论一番。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="我们为什么需要一个一号进程，我们希望的一号进程需要承担怎样的职责？"><a href="#我们为什么需要一个一号进程，我们希望的一号进程需要承担怎样的职责？" class="headerlink" title="我们为什么需要一个一号进程，我们希望的一号进程需要承担怎样的职责？"></a>我们为什么需要一个一号进程，我们希望的一号进程需要承担怎样的职责？</h3><p>在继续聊关于 dumb-init 和 tini 的相关爆论之前，我们需要来 review 一个问题。我们为什么需要一个一号进程？以及我们所选择的一号进程需要承担怎么样的职责</p><p>其实我们在容器场景下需要一号进程托管在前面实际上有两种主要的场景，</p><ol><li><p>对于容器内 Graceful Upgrade 二进制这种场景，主流的一种做法之一是 fork 一个新的进程，exec 新的二进制文件，新进程处理新链接，老进程处理老链接。（Nginx 就采用这种方案）</p></li><li><p>没有正确的处理信号转发以及进程回收的情况</p></li><li><p>一些如同 calico-node 的场景么，我们出于方便打包的考虑，将多个二进制运行在同一容器中</p></li></ol><p>对于第一种其实需要说的没有太多，我们来看一下第二点的测试</p><p>我们先准备一个最简单 Python 文件，<strong>demo1.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">10000</span>)</span><br></pre></td></tr></table></figure><p>然后依照常规，我们开始用一个 bash 脚本裹一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">python /root/demo1.py</span><br></pre></td></tr></table></figure><p>最后编写 Dockerfile </p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> demo1.py /root/demo1.py</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> demo1.sh /root/demo1.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;/root/demo1.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>构建后开始执行，我们先来看一下进程结构</p><p><img src="https://user-images.githubusercontent.com/7054676/109394863-29ce2b80-7964-11eb-88aa-4e1f6e2e3e00.png" alt="进程结构"></p><p>没有问题，现在我们用 <strong>strace</strong> 来 trace 一下，2049962、2050009 这两个进程，然后对 2049962 这个 bash 进程发 <em>*SIGTERM</em>＊ 信号</p><p>我们来看下结果</p><p><img src="https://user-images.githubusercontent.com/7054676/109394942-a9f49100-7964-11eb-8fa5-5d676e512081.png" alt="2049962进程的 trace 结果"></p><p><img src="https://user-images.githubusercontent.com/7054676/109394966-d8726c00-7964-11eb-9e18-f99a0a64b5cd.png" alt="2050009进程的 trace 结果"></p><p>我们能清晰看到 2049962 进程在接到 <strong>SIGTERM</strong> 的时候，没有将其转发给 2050009 进程。在我们手动 SIGKILL 2049962 后， 2050009 也随即退出，这里可能有人会有点疑惑，为什么 2049962 退出后，2050009 也会退出呢？</p><p>这里是由于 pid namespace 本身的特性，我们来看看，<a href="https://man7.org/linux/man-pages/man7/pid_namespaces.7.html">pid_namespaces</a> 中的相关介绍</p><blockquote><p>If the “init” process of a PID namespace terminates, the kernel terminates all of the processes in the namespace via a SIGKILL signal.  </p></blockquote><p>当当前 pid ns 内的一号进程退出的时候，内核直接 SIGKILL 伺候该 pid ns 内的剩余进程</p><p>OK，在我们结合容器调度框架后，那么在生产上实际会出现很多的坑，来看一段我之前的吐槽</p><blockquote><p>我们一个测试服务，Spring Cloud 的，在下线后，节点无法从注册中心摘除，然后百思不得其解，最后查到问题，，<br>本质上是这样，POD 被摘除的时候，K8S Scheduler 会给 POD 的 ENTRYPOINT 发一个 SIGTERM 信号，然后等待三十秒（默认的 graceful shutdown 超时实践)，还没响应就会 SIGKILL 直接杀<br>问题在于，我们 Eureka 版的服务是通过 start.sh 来启动的，ENTRYPOINT [“/home/admin/start.sh”]，容器里默认是 /bin/sh 是 fork/exec 模式，导致我服务进程没法正确的收到 SIGTERM 信号，然后一直没结束就被 SIGKILL 了</p></blockquote><p>刺激不刺激。除了信号转发无法正常处理以外，我们应用程序常见的一个常见处理的问题就是 Z 进程的出现，即子进程结束之后，无法正确的回收。比如早期 puppeteer 臭名昭著的 Z 进程问题。 在这种情况下，除了应用程序本身的问题以外，另外可能的原因是在守护进程这样的场景下，孤儿进程 re-parent 之后的进程，不具备回收子进程的功能</p><p>OK 在回顾完上面我们常见的问题后，我们来 review 一下我们对于容器内一号进程所需要承担的职责</p><ol><li><p>信号的转发</p></li><li><p>Z 进程的回收</p></li></ol><p>而在目前，在容器场景下，大家主要使用两个方案来作为自己的容器内一号进程，<a href="https://github.com/Yelp/dumb-init">dumb-init</a> 和 <a href="https://github.com/krallin/tini">tini</a>。这两个方案对于容器内孤儿与 Z 进程的处理都算是 OK。但是信号转发的实现上一言难尽。那么接下来</p><p>爆论时间！</p><h3 id="拉跨的-dumb-init"><a href="#拉跨的-dumb-init" class="headerlink" title="拉跨的 dumb-init"></a>拉跨的 dumb-init</h3><p>某种程度上来说，<strong>dumb-init</strong> 这货完全是属于虚假宣传的典范。代码实现非常糙</p><p>来看看官方的宣传</p><blockquote><p>dumb-init runs as PID 1, acting like a simple init system. It launches a single process and then proxies all received signals to a session rooted at that child process.</p></blockquote><p>这里，dumb-init 说自己使用了 Linux 中的进程 Session，我们都知道，一个进程 Session 在默认情况下，共享一个 Process Group Id 。那么我们这里可以理解为，dumb-init 能将信号完全转发到进程组中的每个进程上。听起来很美好是不是？</p><p>我们先来测试一下吧</p><p>测试代码如下，<strong>demo2.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    cpid = os.fork()</span><br><span class="line">time.sleep(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>Dockerfile 如下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/dumb-init https://github.com/Yelp/dumb-init/releases/download/v1.2.5/dumb-init_1.2.5_x86_64</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /usr/local/bin/dumb-init</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> demo2.py /root/demo2.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/local/bin/dumb-init&quot;</span>, <span class="string">&quot;--&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/root/demo2.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>构建，开跑，先来看下进程结构</p><p><img src="https://user-images.githubusercontent.com/7054676/109396500-dca28780-796c-11eb-9ae1-37be10affbb0.png" alt="demo2 的进程结构"></p><p>然后老规矩，strace 2103908、2103909、2103910 这三个进程，然后我们对 <strong>dumb-init</strong> 的进程做一下发送 SIGTERM 的操作吧</p><p><img src="https://user-images.githubusercontent.com/7054676/109396545-1f645f80-796d-11eb-9205-7735e5fd3685.png" alt="strace 2103908"></p><p><img src="https://user-images.githubusercontent.com/7054676/109396563-3440f300-796d-11eb-82ed-94693d49cfc8.png" alt="strace 2103909"></p><p><img src="https://user-images.githubusercontent.com/7054676/109397059-c649fb00-796f-11eb-8206-02af6d9dc02b.png" alt="strace 2103910"></p><p>诶？dumb-init 老师，发生了甚么事？为什么 2103909 直接被 SIGKILL 了，而没有收到 SIGTERM</p><p>这里我们要来看下 dumb-init 的关键实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_signal</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    DEBUG(<span class="string">&quot;Received signal %d.\n&quot;</span>, signum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal_temporary_ignores[signum] == <span class="number">1</span>) &#123;</span><br><span class="line">        DEBUG(<span class="string">&quot;Ignoring tty hand-off signal %d.\n&quot;</span>, signum);</span><br><span class="line">        signal_temporary_ignores[signum] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (signum == SIGCHLD) &#123;</span><br><span class="line">        <span class="type">int</span> status, exit_status;</span><br><span class="line">        <span class="type">pid_t</span> killed_pid;</span><br><span class="line">        <span class="keyword">while</span> ((killed_pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">                exit_status = WEXITSTATUS(status);</span><br><span class="line">                DEBUG(<span class="string">&quot;A child with PID %d exited with exit status %d.\n&quot;</span>, killed_pid, exit_status);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                assert(WIFSIGNALED(status));</span><br><span class="line">                exit_status = <span class="number">128</span> + WTERMSIG(status);</span><br><span class="line">                DEBUG(<span class="string">&quot;A child with PID %d was terminated by signal %d.\n&quot;</span>, killed_pid, exit_status - <span class="number">128</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (killed_pid == child_pid) &#123;</span><br><span class="line">                forward_signal(SIGTERM);  <span class="comment">// send SIGTERM to any remaining children</span></span><br><span class="line">                DEBUG(<span class="string">&quot;Child exited with status %d. Goodbye.\n&quot;</span>, exit_status);</span><br><span class="line">                <span class="built_in">exit</span>(exit_status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        forward_signal(signum);</span><br><span class="line">        <span class="keyword">if</span> (signum == SIGTSTP || signum == SIGTTOU || signum == SIGTTIN) &#123;</span><br><span class="line">            DEBUG(<span class="string">&quot;Suspending self due to TTY signal.\n&quot;</span>);</span><br><span class="line">            kill(getpid(), SIGSTOP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 dumb-init 老师处理信号的代码，在收到信号后，将除 SIGCHLD 的信号做转发（注意 SIGKILL 是不可 handle 信号），我们来看看信号转发的逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">forward_signal</span><span class="params">(<span class="type">int</span> signum)</span> &#123;</span><br><span class="line">    signum = translate_signal(signum);</span><br><span class="line">    <span class="keyword">if</span> (signum != <span class="number">0</span>) &#123;</span><br><span class="line">        kill(use_setsid ? -child_pid : child_pid, signum);</span><br><span class="line">        DEBUG(<span class="string">&quot;Forwarded signal %d to children.\n&quot;</span>, signum);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DEBUG(<span class="string">&quot;Not forwarding signal %d to children (ignored).\n&quot;</span>, signum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下直接 kill 发送信号，其中 -child_pid 是这样一个特性：</p><blockquote><p>If pid is less than -1, then sig is sent to every process in the process group whose ID is -pid.</p></blockquote><p>直接转发进程组，看起来没啥问题啊？那么上面是甚么原因呢？我们再来复习下上一段话，kill 给进程组发信号的逻辑是 <strong>sig is sent to every process</strong> ，懂了，一个 O(N) 的遍历嘛。没啥问题啊？好了，不卖关子，这里 dumb-init 的实现存在一个 race-condition</p><p>我们刚刚说了，kill 进程组的行为是一个 O(N) 的遍历，那么必然会有进程先收到信号，而有进程后收到信号。以 SIGTERM 为例，假设我们 dumb-init 的子进程先收到 SIGTERM，优雅退出后，dumb-init 收到 SIGCHLD 的信号，然后 wait_pid 拿到子进程 ID，判断是自己直接托管的进程后，自杀退出。好了，由于 dumb-init 是我们当前 pid ns 内的 init 进程，再来复习下 pid ns 的特性。</p><blockquote><p>If the “init” process of a PID namespace terminates, the kernel terminates all of the processes in the namespace via a SIGKILL signal. </p></blockquote><p>在 dumb-init 自杀以后，剩余进程将直接被内核 SIGKILL 伺候。也就导致了我们上面看到的，子进程没有收到转发的信号！</p><p>所以这里加粗处理一下，<strong>dumb-init 所承诺的，能将信号转发到所有进程上，完全是虚假宣传！</strong></p><p>而且请注意，dumb-init 宣称自己能管理一个 Session 内的进程！但是实际上他们只做了一个进程组的信号转发！完全是虚假宣称！Fake News！</p><p>而且如上面所提到的，在我们热更新二进制这样的场景下，dumb-init 在进程退出后直接自杀。和不使用一号进程完全没有差别！</p><p>我们可以来测试一下，测试代码 demo3.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">pid = os.fork()</span><br><span class="line">time.sleep(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>fork 一个进程，总共两个进程</p><p>Dockerfile 如下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O /usr/local/bin/dumb-init https://github.com/Yelp/dumb-init/releases/download/v1.2.5/dumb-init_1.2.5_x86_64</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /usr/local/bin/dumb-init</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> demo3.py /root/demo3.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/local/bin/dumb-init&quot;</span>, <span class="string">&quot;--&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/root/demo3.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>构建，执行，先看看进程结构</p><p><img src="https://user-images.githubusercontent.com/7054676/109397207-9818eb00-7970-11eb-8dbb-35ccbe5d26cf.png" alt="demo3 进程结构"></p><p>然后模拟老进程退出，我们直接 SIGKILL 掉 2134836，然后我们看看 2134837 的 strace 的结果</p><p><img src="https://user-images.githubusercontent.com/7054676/109397254-d31b1e80-7970-11eb-9bf2-fcc3e12ca77c.png" alt="strace 2134837"></p><p>如预期一样，在 dumb-init 自杀后，2134837 被内核 SIGKILL 了</p><p>所以跟我复习一遍 <strong>dumb-init</strong> 拉跨！好了，我们接着聊 tini 的实现</p><h3 id="态度友好的聊聊-tini"><a href="#态度友好的聊聊-tini" class="headerlink" title="态度友好的聊聊 tini"></a>态度友好的聊聊 tini</h3><p>平心而论，tini 的实现，虽然也还有坑，但是比 <strong>dumb-init</strong> 细腻到不知道哪里去了，我们直接来先看下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">/* Wait for one signal, and forward it */</span></span><br><span class="line"><span class="keyword">if</span> (wait_and_forward_signal(&amp;parent_sigset, child_pid)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Now, reap zombies */</span></span><br><span class="line"><span class="keyword">if</span> (reap_zombies(child_pid, &amp;child_exitcode)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (child_exitcode != <span class="number">-1</span>) &#123;</span><br><span class="line">PRINT_TRACE(<span class="string">&quot;Exiting: child has exited&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> child_exitcode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先 tini 没有设置 signal handler ，不断循环 <code>wait_and_forward_signal</code> 和 <code>reap_zombies</code> 这两个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">wait_and_forward_signal</span><span class="params">(<span class="type">sigset_t</span> <span class="type">const</span>* <span class="type">const</span> parent_sigset_ptr, <span class="type">pid_t</span> <span class="type">const</span> child_pid)</span> &#123;</span><br><span class="line"><span class="type">siginfo_t</span> sig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigtimedwait(parent_sigset_ptr, &amp;sig, &amp;ts) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (errno) &#123;</span><br><span class="line"><span class="keyword">case</span> EAGAIN:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EINTR:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;Unexpected error in sigtimedwait: &#x27;%s&#x27;&quot;</span>, strerror(errno));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* There is a signal to handle here */</span></span><br><span class="line"><span class="keyword">switch</span> (sig.si_signo) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGCHLD:</span><br><span class="line"><span class="comment">/* Special-cased, as we don&#x27;t forward SIGCHLD. Instead, we&#x27;ll</span></span><br><span class="line"><span class="comment"> * fallthrough to reaping processes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PRINT_DEBUG(<span class="string">&quot;Received SIGCHLD&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">PRINT_DEBUG(<span class="string">&quot;Passing signal: &#x27;%s&#x27;&quot;</span>, strsignal(sig.si_signo));</span><br><span class="line"><span class="comment">/* Forward anything else */</span></span><br><span class="line"><span class="keyword">if</span> (kill(kill_process_group ? -child_pid : child_pid, sig.si_signo)) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == ESRCH) &#123;</span><br><span class="line">PRINT_WARNING(<span class="string">&quot;Child was dead when forwarding signal&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;Unexpected error when forwarding signal: &#x27;%s&#x27;&quot;</span>, strerror(errno));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>sigtimedwait</code> 这个函数来接收信号，然后过滤掉 <code>SIGCHLD</code> 转发。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">reap_zombies</span><span class="params">(<span class="type">const</span> <span class="type">pid_t</span> child_pid, <span class="type">int</span>* <span class="type">const</span> child_exitcode_ptr)</span> &#123;</span><br><span class="line"><span class="type">pid_t</span> current_pid;</span><br><span class="line"><span class="type">int</span> current_status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">current_pid = waitpid(<span class="number">-1</span>, &amp;current_status, WNOHANG);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (current_pid) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"><span class="keyword">if</span> (errno == ECHILD) &#123;</span><br><span class="line">PRINT_TRACE(<span class="string">&quot;No child to wait&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;Error while waiting for pids: &#x27;%s&#x27;&quot;</span>, strerror(errno));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">PRINT_TRACE(<span class="string">&quot;No child to reap&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* A child was reaped. Check whether it&#x27;s the main one. If it is, then</span></span><br><span class="line"><span class="comment"> * set the exit_code, which will cause us to exit once we&#x27;ve reaped everyone else.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PRINT_DEBUG(<span class="string">&quot;Reaped child with pid: &#x27;%i&#x27;&quot;</span>, current_pid);</span><br><span class="line"><span class="keyword">if</span> (current_pid == child_pid) &#123;</span><br><span class="line"><span class="keyword">if</span> (WIFEXITED(current_status)) &#123;</span><br><span class="line"><span class="comment">/* Our process exited normally. */</span></span><br><span class="line">PRINT_INFO(<span class="string">&quot;Main child exited normally (with status &#x27;%i&#x27;)&quot;</span>, WEXITSTATUS(current_status));</span><br><span class="line">*child_exitcode_ptr = WEXITSTATUS(current_status);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(current_status)) &#123;</span><br><span class="line"><span class="comment">/* Our process was terminated. Emulate what sh / bash</span></span><br><span class="line"><span class="comment"> * would do, which is to return 128 + signal number.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PRINT_INFO(<span class="string">&quot;Main child exited with signal (with signal &#x27;%s&#x27;)&quot;</span>, strsignal(WTERMSIG(current_status)));</span><br><span class="line">*child_exitcode_ptr = <span class="number">128</span> + WTERMSIG(current_status);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;Main child exited for unknown reason&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Be safe, ensure the status code is indeed between 0 and 255.</span></span><br><span class="line">*child_exitcode_ptr = *child_exitcode_ptr % (STATUS_MAX - STATUS_MIN + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If this exitcode was remapped, then set it to 0.</span></span><br><span class="line">INT32_BITFIELD_CHECK_BOUNDS(expect_status, *child_exitcode_ptr);</span><br><span class="line"><span class="keyword">if</span> (INT32_BITFIELD_TEST(expect_status, *child_exitcode_ptr)) &#123;</span><br><span class="line">*child_exitcode_ptr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (warn_on_reap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">PRINT_WARNING(<span class="string">&quot;Reaped zombie process with pid=%i&quot;</span>, current_pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if other childs have been reaped.</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we make it here, that&#x27;s because we did not continue in the switch case. */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>reap_zombies</code> 函数中，不断利用 <code>waitpid</code> 这个函数来处理进程，在没有子进程等待处理或者遇到其余系统错误时退出循环。</p><p>注意这里 tini 和 dumb-init 的的实现差异，dumb-init 在回收自己的入口子进程后便会自杀。而 tini 将会在所有自己的子进程退出之后，结束循环，然后判断是否自杀。</p><p>那么我们这里来测试一下</p><p>还是 demo2 的例子，我们来测试一下孙进程的例子</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> demo2.py /root/demo2.py</span></span><br><span class="line"><span class="keyword">ENV</span> TINI_VERSION v0.<span class="number">19.0</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://github.com/krallin/tini/releases/download/<span class="variable">$&#123;TINI_VERSION&#125;</span>/tini /tini</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /tini</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;/tini&quot;</span>,<span class="string">&quot;-s&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;--&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/root/demo2.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>然后构建，执行，进程结构如下</p><p><img src="https://user-images.githubusercontent.com/7054676/109397971-b54fb880-7974-11eb-9899-0d71af5ad835.png" alt="demo2-tini 进程结构图"></p><p>然后，老规矩，strace , kill 发 SIGTERM 看一下，</p><p><img src="https://user-images.githubusercontent.com/7054676/109398085-648c8f80-7975-11eb-8b08-21fb0c0399fa.png" alt="strace 2160093"></p><p><img src="https://user-images.githubusercontent.com/7054676/109398094-75d59c00-7975-11eb-8d42-ee062609e152.png" alt="strace 2160094"></p><p><img src="https://user-images.githubusercontent.com/7054676/109398106-871ea880-7975-11eb-94a8-0b25374fa79e.png" alt="strace 2160095"></p><p>嗯，如预期一样，那么 tini 的实现是不是没有问题了呢，我们再来准备一个例子,demo4.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    signal.signal(<span class="number">15</span>, <span class="keyword">lambda</span> _, __: time.sleep(<span class="number">1</span>))</span><br><span class="line">    cpid = os.fork()</span><br><span class="line">time.sleep(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>这里我们用 <code>time.sleep(1)</code> 来模拟，程序接到 SIGTERM 后需要优雅处理，然后我们还是准备下 dockefile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> demo4.py /root/demo4.py</span></span><br><span class="line"><span class="keyword">ENV</span> TINI_VERSION v0.<span class="number">19.0</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://github.com/krallin/tini/releases/download/<span class="variable">$&#123;TINI_VERSION&#125;</span>/tini /tini</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /tini</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;/tini&quot;</span>,<span class="string">&quot;-s&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;--&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;/root/demo4.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>然后构建，允许，看进程结构，啪的一下很快啊</p><p><img src="https://user-images.githubusercontent.com/7054676/109398222-83d7ec80-7976-11eb-88e9-4e7231b2c90d.png" alt="demo4 进程结构"></p><p>然后 strace ，发 SIGTERM 一条龙服务，</p><p><img src="https://user-images.githubusercontent.com/7054676/109398244-aa962300-7976-11eb-9c4f-7ca7dbe1b833.png" alt="strace 2173315"></p><p><img src="https://user-images.githubusercontent.com/7054676/109398251-bc77c600-7976-11eb-8b24-d5bb60c1ce96.png" alt="strace 2173316"></p><p><img src="https://user-images.githubusercontent.com/7054676/109398257-cac5e200-7976-11eb-9921-457195ee052c.png" alt="strace 2173317"></p><p>然后我们发现，2173316 和 2173317 这两个进程，成功接收到 SIGTERM 的信号后，在处理中，被 SIGKILL 了。那么这是为甚么呢？实际上这里也存在一个潜在的 race condition</p><p>当我们开启 tini 的使用。2173315 退出后，2173316 将被 re-parent ，</p><p>按照内核的 re-parent 流程，2173317 re-parent 到 tini 进程。</p><p>但是，tini 在使用 <code>waitpid</code> 的时候，使用了 <code>WNOHANG</code> 这个选项，那么这里如果在执行 waitpid 时，子进程还未结束，那么将立刻返回0。从而退出循环，开始自杀流程。</p><p>刺激不刺激，关于这点，我师父和我提了一个 issue: <a href="https://github.com/krallin/tini/issues/180">tini Exits Too Early Leading to Graceful Termination Failure</a></p><p>然后，我也做了一版修复，具体可以参考<a href="https://github.com/Zheaoli/tini/commit/f5286c205d948a6cbb07fa8dca9e763bdb3ebe61">use new threading to run waipid</a>（还在 PoC，没写单测，处理也有点糙）</p><p>实际上思路很简单 ，我们不使用 <code>waitpid</code> 中的 <code>WNOHANG</code> 选项，将其变为阻塞的调用，然后用一个新的线程来做 <code>waitpid</code> 的处理</p><p>构建一版测试效果如下</p><p><img src="https://user-images.githubusercontent.com/7054676/109398735-96075a00-7979-11eb-85e9-f8ab99c3d5f5.png" alt="demo5 进程结构"></p><p><img src="https://user-images.githubusercontent.com/7054676/109398751-b1726500-7979-11eb-8398-0069c4f3a2aa.png" alt="strace 1808102"></p><p><img src="https://user-images.githubusercontent.com/7054676/109398764-c4853500-7979-11eb-981f-a5ea65ae7572.png" alt="strace 1808104"></p><p><img src="https://user-images.githubusercontent.com/7054676/109398777-d666d800-7979-11eb-972a-37cf82e371d4.png" alt="strace 1808105"></p><p>嗯，如预期一样，测试没有问题。</p><p>当然这里实际上可能细心的朋友发现，原本的 tini 也没法处理二进制更新的情况，原因和 demo5 里的原因一致。这里大家可以去测试一下</p><p>实际上这里我的处理很过于粗糙和暴力，我们实际上只要保证让 tini 的退出条件变成<strong>一定要等到 waitpid()=-1 &amp;&amp; errno==EHILD再退出</strong>。具体的实现手段大家可以一起来思考（实际上还不少</p><p>最后来总结一下问题的核心：</p><p>无论是 dumb-init 还是 tini 在现行的实现里，都犯了同一个错误，即在容器这个特殊的场景下，都没有等待所有子孙进程的退出再退出。其实解决方案很简单，退出条件一定要是 <strong>waitpid()=-1 &amp;&amp; errno==EHILD</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文吐槽了 dumb-init 和 tini。dumb—init 实现属实拉跨，tini 的实现细腻了很多。但是 tini 依旧存在不可靠的行为，以及我们所期待的 fork 二进制更新这种使用一号进程的场景在 dumb-init 和 tini 上都没法实现。而且 dumb-init 和 tini 目前也还有一个共通的局限性。即无法处理子进程进程组逃逸的情况。（比如十个子进程各自逃逸到一个进程组中）。</p><p>而且在文中的测试中，我们用 <code>time.sleep(1)</code> 来模拟 Graceful Shutdown 的行为，tini 也已经无法满足需求了。。So。。。。</p><p>所以归根到底一句话，应用的信号，进程回收这些基础行为应该应用自决。任何管杀不管埋而寄托于一号进程的行为，都是对于生产的不负责任。（如果你们实在想要一个一号进程，还是用 tini 吧，千万别用 dumb-init)</p><p>所以 exec 裸起大法好，不用一号进程平安保！</p><p>差不多水文就这样吧，这篇水文从提出问题到验证结论，到 patch PoC 报销了我快一个星期的业余时间（本文初稿在凌晨4点过写完）。最后感谢某川同学和我一起搞了几个凌晨三点过。最后，祝大家看的愉快。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 水文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单聊聊容器中的一号进程</title>
      <link href="//posts/2021/02/13/a-simple-introduction-about-the-init-process-in-container/"/>
      <url>//posts/2021/02/13/a-simple-introduction-about-the-init-process-in-container/</url>
      
        <content type="html"><![CDATA[<p>新年了，决定趁着有时间的时候多写几篇技术水文。今天的话，准备来简单聊聊容器中我们每天都会接触，但是时常又会被我们忽略的一号进程</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>容器技术发展到现在，其实形态上已经发生了很大的变化。根据不同的场景，既有传统的 <strong>Docker</strong><a href="#refer-anchor-1"><sup>1</sup></a>, <strong>containterd</strong><a href="#refer-anchor-2"><sup>2</sup></a> 这样传统基于 CGroup + Namespace 的容器形态，也有像 <strong>Kata</strong><a href="#refer-anchor-3"><sup>3</sup></a> 这样基于 VM 的新型的容器形态。本文主要着眼在传统容器中一号进程上。</p><p>我们都知道，传统容器依赖的 CGroup + Namespace 进行资源隔离，本质上来说，还是 OS 内的一个进程。所以在继续往下聊容器相关的内容之前，我们需要先来简单聊聊 Linux 中的进程管理</p><h3 id="Linux-中的进程管理"><a href="#Linux-中的进程管理" class="headerlink" title="Linux 中的进程管理"></a>Linux 中的进程管理</h3><h4 id="简单聊聊进程"><a href="#简单聊聊进程" class="headerlink" title="简单聊聊进程"></a>简单聊聊进程</h4><p>Linux 中的进程实际上是个非常大的话题，如果要展开聊，实际上这个话题可以聊一整本书= =，所以为了时间着想，我们还是把目光聚集在最核心的一部分上面（实际上是因为很多东西我也不懂。</p><p>首先来讲，在内核中利用一个特殊的结构体来维护进程有关的相关信息，比如常见的 PID，进程状态，打开的文件描述符等信息。在内核代码中，这个结构体是 <strong>task_struct</strong><a href="#refer-anchor-4"><sup>4</sup></a>, 其大概结构大家可以看一下下图</p><p><img src="https://user-images.githubusercontent.com/7054676/107845716-b4694380-6e18-11eb-9d19-ebfb9927b1ac.png" alt="task_struct"></p><p>而通常而言，我们会在系统上跑很多个进程。所以内核用一个进程表(实际上 Linux 中管理进程表的有多个数据结构，这里我们用 PID Hash Map 来举例）来维护所有 Process Descriptor 相关的信息，详见下图</p><p><img src="https://user-images.githubusercontent.com/7054676/107845790-30638b80-6e19-11eb-951e-7fdfa86a0234.png" alt="PID Hash Table"></p><p>OK， 这里我们大概了解了进程中的基本结构，现在我们来看我们常见使用进程的一个场景：父子进程。我们都知道，我们有时会在一个进程中，通过 <strong>fork</strong><a href="#refer-anchor-5"><sup>5</sup></a> 这个 sys call 来创建出一个新的进程。通常来说，我们创建的新的进程是当前进程的子进程。那么在内核中怎么表达这种父子关系呢？</p><p>回到刚刚提到 <strong>task_struct</strong>, 在这个结构体中存在这样几个字段来描述父子关系</p><ol><li><p>real_parent：一个 task_struct 指针，指向父进程</p></li><li><p>parent: 一个 task_struct 指针，指向父进程。在大多数情况下，这个字段的值和 <code>real_parent</code> 一致。在有进程对当前进程使用 <strong>ptrace</strong><a href="#refer-anchor-6"><sup>6</sup></a> 等情况的时候，和 <code>real_parent</code> 字段不一致</p></li><li><p>children：list_head, 其指向一个由当前进程所创建的所有子进程的双向链表</p></li></ol><p>这里大家可能还有点抽象的话，给大家一个图就能看清楚了</p><p><img src="https://user-images.githubusercontent.com/7054676/107846739-f8604680-6e20-11eb-939c-f033909570c3.png" alt="Relation Between Process"></p><p>实际上，我们发现，不同进程之间的父子关系，反应到具体的数据结构之上，就形成了一个完整的树形结构（先记住这点，我们稍后会再提到这里）</p><p>到现在为止，我们已经对 Linux 中的进程，有了最简单一个概念，那么接下来，我们会聊聊我们在进程使用中常遇到的两个问题：孤儿进程&amp;&amp;僵尸进程</p><h4 id="孤儿进程-amp-amp-僵尸进程"><a href="#孤儿进程-amp-amp-僵尸进程" class="headerlink" title="孤儿进程 &amp;&amp; 僵尸进程"></a>孤儿进程 &amp;&amp; 僵尸进程</h4><p>首先来聊聊 <strong>僵尸进程</strong> 这个概念。</p><p>如前面所说，我们内核有进程表来维护 Process Descriptor 相关信息。那么在 Linux 的设计中，当一个子进程退出后，将保存自己的进程相关的状态以供父进程使用。而父进程将调用 <strong>waitpid</strong><a href="#refer-anchor-7"><sup>7</sup></a> 来获取子进程状态，并清理相关资源。</p><p>那么如上所说，父进程是有可能需要拿到子进程相关的状态的。那么也就导致为了满足这一设计，内核中的进程表将一直保存相关资源。当僵尸进程多了以后，那么将造成很大的资源浪费。</p><p>首先来看一个简单的僵尸进程的例子 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s child process\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the child process pid is %d\n&quot;</span>, pid);</span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们编译执行这段代码，然后配合 <code>ps</code> 命令查看一下，发现我们的确造了一个 z 进程</p><p><img src="https://user-images.githubusercontent.com/7054676/107847485-0e710580-6e27-11eb-977c-678a7fa4b362.png" alt="Z Process Demo"></p><p>OK 我们再来看一个正确处理子进程退出的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signalfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEVENTS 64</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deletejob</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;delete task %d\n&quot;</span>, pid); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addjob</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;add task %d\n&quot;</span>, pid); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line">  <span class="type">sigset_t</span> mask;</span><br><span class="line">  sigemptyset(&amp;mask);</span><br><span class="line">  sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">  <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;mask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> sfd = signalfd(<span class="number">-1</span>, &amp;mask, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> epoll_fd = epoll_create(MAXEVENTS);</span><br><span class="line">  event.events = EPOLLIN | EPOLLEXCLUSIVE | EPOLLET;</span><br><span class="line">  event.data.fd = sfd;</span><br><span class="line">  <span class="type">int</span> s = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sfd, &amp;event);</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  events = <span class="built_in">calloc</span>(MAXEVENTS, <span class="keyword">sizeof</span>(event));</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> n = epoll_wait(epoll_fd, events, MAXEVENTS, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll EINTR error\n&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINVAL) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll EINVAL error\n&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EFAULT) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll EFAULT error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EBADF) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll EBADF error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) ||</span><br><span class="line">          (!(events[i].events &amp; EPOLLIN))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll err\n&quot;</span>);</span><br><span class="line">        close(events[i].data.fd);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sfd == events[i].data.fd) &#123;</span><br><span class="line">        <span class="keyword">struct</span> signalfd_siginfo si;</span><br><span class="line">        <span class="type">ssize_t</span> res = read(sfd, &amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="keyword">sizeof</span>(si)) &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Something wrong\n&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (si.ssi_signo == SIGCHLD) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Got SIGCHLD\n&quot;</span>);</span><br><span class="line">          <span class="type">int</span> child_pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">          deletejob(child_pid);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">      execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    addjob(pid);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK, 我们现在都知道了，子进程退出后需要由父进程正确的回收相关的资源。那么问题来了，我们父进程先于子进程退出了怎么办。实际上这是一个很常见的场景。比如说大家去用两次 fork 实现守护进程。</p><p>我们常规的认知来说，我们父进程退出后，这个进程所属的所有子进程会进行 re-parent 到当前 PID Namespace 的一号进程上，那么这样的答案是正确的么？对，也不对，我们首先来看一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  <span class="type">int</span> err = prctl(PR_SET_CHILD_SUBREAPER, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Here&#x27;s child process1\n&quot;</span>);</span><br><span class="line">      sleep(<span class="number">20</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;the child process pid is %d\n&quot;</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sleep(<span class="number">40</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个很典型的两次 fork 创建守护进程的代码（除了我没写 SIGCHLD 处理（逃）。我们来看下这段代码的输出</p><p><img src="https://user-images.githubusercontent.com/7054676/107848258-ebe1eb00-6e2c-11eb-8c72-e4c5915ffa3f.png" alt="Daemon Process Output1"></p><p>我们能看到守护进程的 PID 是 449920</p><p>然后我们执行 <code>ps -efj</code> 和 <code>ps auf</code> 两个命令看一下结果</p><p><img src="https://user-images.githubusercontent.com/7054676/107848296-32cfe080-6e2d-11eb-943f-0efb9975b7ee.png" alt="Daemon Process Output2"></p><p>我们能看到，449920 这个进程在父进程退出后没有 re-parent 到当前空间的一号进程上。这是为什么呢？可能眼尖的同学已经注意到，这段代码中一个特殊的 sys call <strong>prctl</strong><a href="#refer-anchor-8"><sup>8</sup></a>。我们给当前进程设置了 <strong>PR_SET_CHILD_SUBREAPER</strong> 的属性。</p><p>这里我们来看一下内核里的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When we die, we re-parent all our children, and try to:</span></span><br><span class="line"><span class="comment"> * 1. give them to another thread in our thread group, if such a member exists</span></span><br><span class="line"><span class="comment"> * 2. give it to the first ancestor process which prctl&#x27;d itself as a</span></span><br><span class="line"><span class="comment"> *    child_subreaper for its children (like a service manager)</span></span><br><span class="line"><span class="comment"> * 3. give it to the init process (PID 1) in our pid namespace</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_struct *<span class="title function_">find_new_reaper</span><span class="params">(<span class="keyword">struct</span> task_struct *father,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> task_struct *child_reaper)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span>, *<span class="title">reaper</span>;</span></span><br><span class="line"></span><br><span class="line">thread = find_alive_thread(father);</span><br><span class="line"><span class="keyword">if</span> (thread)</span><br><span class="line"><span class="keyword">return</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (father-&gt;signal-&gt;has_child_subreaper) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ns_level = task_pid(father)-&gt;level;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find the first -&gt;is_child_subreaper ancestor in our pid_ns.</span></span><br><span class="line"><span class="comment"> * We can&#x27;t check reaper != child_reaper to ensure we do not</span></span><br><span class="line"><span class="comment"> * cross the namespaces, the exiting parent could be injected</span></span><br><span class="line"><span class="comment"> * by setns() + fork().</span></span><br><span class="line"><span class="comment"> * We check pid-&gt;level, this is slightly more efficient than</span></span><br><span class="line"><span class="comment"> * task_active_pid_ns(reaper) != task_active_pid_ns(father).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (reaper = father-&gt;real_parent;</span><br><span class="line">     task_pid(reaper)-&gt;level == ns_level;</span><br><span class="line">     reaper = reaper-&gt;real_parent) &#123;</span><br><span class="line"><span class="keyword">if</span> (reaper == &amp;init_task)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (!reaper-&gt;signal-&gt;is_child_subreaper)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">thread = find_alive_thread(reaper);</span><br><span class="line"><span class="keyword">if</span> (thread)</span><br><span class="line"><span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> child_reaper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们总结一下，当父进程退出后，所属的子进程，将按照如下顺序进行 re-parent</p><ol><li><p>线程组里其余可用线程（这里的线程有所不一样，可以暂时忽略）</p></li><li><p>在当前所属的进程树上不断寻找设置了 <strong>PR_SET_CHILD_SUBREAPER</strong> 进程</p></li><li><p>在前面两者都无效的情况下，re-parent 到当前 PID Namespace 中的 1 号进程上</p></li></ol><p>到这里，我们关于 Linux 中进程管理的基础介绍就完成了。那么我们将来聊聊容器中的情况</p><h3 id="容器中的一号进程"><a href="#容器中的一号进程" class="headerlink" title="容器中的一号进程"></a>容器中的一号进程</h3><p>这里，我们将利用，Docker 作为背景聊聊这个话题。首先，在 Docker 1.11 之后，其架构发生了比较大的变化，如下图所示</p><p><img src="https://user-images.githubusercontent.com/7054676/107848502-cf46b280-6e2e-11eb-8a69-f9eaf9d155a8.png" alt="Docker Arch since version 1.11"></p><p>那么我们拉起一个容器的的流程如下</p><ol><li><p>Docker Daemon 向 containerd 发送指令</p></li><li><p>containerd 创建一个 containterd-shim 进程</p></li><li><p>containerd-shim 创建一个 runc 进程</p></li><li><p>runc 进程将根据 OCI 标准，设置相关环境（创建 cgroup，创建 ns 等），然后执行 <code>entrypoint</code> 中的设定的命令</p></li><li><p>runc 在执行完相关设置后，将自我退出，此时其子进程（即容器命名空间内的1号进程）将被 re-parent 给 containerd-shim 进程。</p></li></ol><p>OK，上面 step 5 操作，就需要依赖我们上节中讲到的 <strong>prctl</strong> 和 <strong>PR_SET_CHILD_SUBREAPER</strong> 。</p><p>自此，containerd-shim 将承担容器内进程相关的操作，即便其父进程退出，子进程也会根据 re-parent 的流程托管到 containerd-shim 进程上。</p><p>那么，这样是不是就没有问题了呢？</p><p>答案很明显不是。来给大家举一个实际上的场景：假设我一个服务需要实现一个需求叫做优雅下线。通常而言，我们会在暴力杀死进程之前，利用 SIGTERM 信号实现这个功能。但是在容器时期有个问题，我们一号进程，可能不是程序本身（比如大家习惯性的会考虑在 entrypoint 中用 bash 去裹一层），或者经过一些特殊场景，容器中的进程，全部已经托管在 containerd-shim 上了。而 contaninerd-shim 是不具备信号转发的能力的。</p><p>所以在这样一些场景下，我们就需要考虑额外引入一些组件来完成我们的需求。这里以一个非常轻量级的专门针对容器的设计的一号进程项目 <strong>tini</strong><a href="#refer-anchor-9"><sup>9</sup></a> 来作为介绍</p><p>我们这里看一下核心的一些代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_subreaper</span> <span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (subreaper &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (prctl(PR_SET_CHILD_SUBREAPER, <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EINVAL) &#123;</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;PR_SET_CHILD_SUBREAPER is unavailable on this platform. Are you using Linux &gt;= 3.4?&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;Failed to register as child subreaper: %s&quot;</span>, strerror(errno))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">PRINT_TRACE(<span class="string">&quot;Registered as child subreaper&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">wait_and_forward_signal</span><span class="params">(<span class="type">sigset_t</span> <span class="type">const</span>* <span class="type">const</span> parent_sigset_ptr, <span class="type">pid_t</span> <span class="type">const</span> child_pid)</span> &#123;</span><br><span class="line"><span class="type">siginfo_t</span> sig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigtimedwait(parent_sigset_ptr, &amp;sig, &amp;ts) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (errno) &#123;</span><br><span class="line"><span class="keyword">case</span> EAGAIN:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EINTR:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;Unexpected error in sigtimedwait: &#x27;%s&#x27;&quot;</span>, strerror(errno));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* There is a signal to handle here */</span></span><br><span class="line"><span class="keyword">switch</span> (sig.si_signo) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGCHLD:</span><br><span class="line"><span class="comment">/* Special-cased, as we don&#x27;t forward SIGCHLD. Instead, we&#x27;ll</span></span><br><span class="line"><span class="comment"> * fallthrough to reaping processes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PRINT_DEBUG(<span class="string">&quot;Received SIGCHLD&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">PRINT_DEBUG(<span class="string">&quot;Passing signal: &#x27;%s&#x27;&quot;</span>, strsignal(sig.si_signo));</span><br><span class="line"><span class="comment">/* Forward anything else */</span></span><br><span class="line"><span class="keyword">if</span> (kill(kill_process_group ? -child_pid : child_pid, sig.si_signo)) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == ESRCH) &#123;</span><br><span class="line">PRINT_WARNING(<span class="string">&quot;Child was dead when forwarding signal&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">PRINT_FATAL(<span class="string">&quot;Unexpected error when forwarding signal: &#x27;%s&#x27;&quot;</span>, strerror(errno));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们能很清楚看到两个核心点</p><ol><li><p>tini 会通过 <strong>prctl</strong> 和 <strong>PR_SET_CHILD_SUBREAPER</strong> 来接管容器内的孤儿进程</p></li><li><p>tini 在收到信号后，会将信号转发给子进程或者是所属的子进程组</p></li></ol><p>当然其实 tini 本身也有一些小问题（不过比较冷门）这里留一个讨论题：假设我们有这样一个服务，在创建10个守护进程后自己退出。在这十个守护进程中，我们都会设置一个全新的进程组 ID （所谓进程组逃逸）。那么我们怎么样将信号转发到这十个进程上（仅供讨论，生产上这么干的人早被打死了）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可能看到这里，可能有人要喷我不讲武德，说好的容器内一号进程，但是花了大半篇幅来讲 Linux 进程233333.</p><p>实际上传统容器基本可以认为是在 OS 中执行的一个完整进程。讨论容器中的一号进程离不开讨论 Linux 中进程管理的相关知识点。</p><p>希望通过这篇技术水文能帮大家对容器中一号进程有个大概的认知，并能正确的使用和管理他。</p><p>最后祝大家新年快乐！（希望新年我能不以写水文为生，呜呜呜呜）</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="refer-anchor-1"></div><ul><li>[1]. <a href="https://www.docker.com/">Docker</a></li></ul><div id="refer-anchor-2"></div><ul><li>[2]. <a href="https://containerd.io/">containerd</a></li></ul><div id="refer-anchor-3"></div><ul><li>[3]. <a href="https://katacontainers.io/">kata</a></li></ul><div id="refer-anchor-4"></div><ul><li>[4]. <a href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h#L649">task_struct</a></li></ul><div id="refer-anchor-5"></div><ul><li>[5]. <a href="https://man7.org/linux/man-pages/man2/fork.2.html">Linux Man Page: fork</a></li></ul><div id="refer-anchor-6"></div><ul><li>[6]. <a href="https://man7.org/linux/man-pages/man2/ptrace.2.html">Linux Man Page: ptrace</a></li></ul><div id="refer-anchor-7"></div><ul><li>[7]. <a href="https://linux.die.net/man/2/waitpid">Linux man page: waitpid</a></li></ul><div id="refer-anchor-8"></div><ul><li>[8]. <a href="https://man7.org/linux/man-pages/man2/prctl.2.html">Linux man page: prctl</a></li></ul><div id="refer-anchor-9"></div><ul><li>[9]. <a href="https://github.com/krallin/tini">tini</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 水文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>但行好事，莫问前程</title>
      <link href="//posts/2021/02/11/do-anything-you-want/"/>
      <url>//posts/2021/02/11/do-anything-you-want/</url>
      
        <content type="html"><![CDATA[<p>这篇文章，实际上本应该在 2020 年结束时写完的。不过我是一个拖延症患者，而且写这篇文章时会想起一些已经离去的人，所以一直不愿动笔，拖到了现在。不过在农历新年的末尾，还是得写出来，给自己去过一年一个总结吧。</p><span id="more"></span><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>怎么说呢，2020其实是很操蛋的一年，我无数次的在内心问候”2020，我日你仙人“（山本大佐表示很赞）</p><p>但是2020呢，其实又是挺好的一年，让我估计后面会无数次的从2020这一年里学到的东西中受益。</p><p>所以吧，我把这暂且称为薛定谔2020？（算了，这 TM 就是 Manjusaka 的2020</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>大年三十了，先说点难过的吧，熟悉我的朋友都知道，我其实2020的职业生涯从职级的角度上来说可以用职场败犬来形容</p><p>Yep，没错，我被降级了，而且晋升还他娘挂了。你说我气不气</p><p>你要说我心态没有炸实际上是不可能的，在19年调转时刚得知降级结果那段时间心态简直爆炸。当时我老板说了一句印象非常深刻的话”你怎么焦虑成这样了，我记得你当时刚进来时不是这样的啊？“</p><p>在心里接受降级后，开始继续努力搬砖争取晋升回来后，然后，晋升又挂了。我？？？？？？</p><p>不过说回来，其实这段经历，可能在刚刚发生那一会儿乃至后续的一段时间，让我一度焦虑狂躁。但是从我现在的视角去看，其实也能反思很多东西。</p><p>实际上经历过这一段很特殊的经历后，我自己的心态已经算是相对平和，某种意义上比刚去阿里云时来得更为沉得住气。如同前段时间我给老板说过的一样，现在的我更希望去做一些自己认可的事，而不是纯粹的为了半年后的晋升去做什么事。往往机关算尽，到头却功亏一篑。不值当</p><p>嘛，当时在调转之初，我老板送我的一句话，我觉得非常受用：</p><blockquote><p>你现在所经历的事情在当下你看来可能无法接受，但是如果将时间放大到整个一生这几十年的尺度来看，其实可能也不算什么大事了。</p></blockquote><p>抛开职级不谈，说实话在阿里云一年多时间里，虽然也经历了客服支持，连续加班等非常惨痛的经历。不过就我而言，可以说还是蛮享受以及这段时间的工作。</p><p>在云这边我主要的工作是和同事一起从0开始做了一款公有云上的网关产品。在去年组织结构变动后，又跑来做监控服务了。</p><p>在这么样的一个过程中，我的角色从在饿了么时期的一个纯粹的一个对内的 infra RD 的角色切换成了一个云产品的研发，我觉得这样一个角色的转变其实是能让我从一个不同的视角去审视 infra 这件事。如果说在对内时期，你做的东西可以通过一些非技术上的手段去强行 push 落地的话。那么在做云产品的时候，如果你产品无法提供足够 OK 的成本，特性，是不会有客户给你产品买单的（当然，你爸要是客户老板当我没说）。</p><p>这样一个观点的转变，让我更能从客户的视角去系统的思考我们做的事的意义。而通过客户支持的经历让我能贴近客户真实的使用场景与业务。我觉得这样一段经历对于我来说是非常重要的。</p><p>另外一个方面是我在云这段时间，有足够的场景和驱动力，去对内核，eBPF ，SystemTap 等一些相对冷门和深入的技术进行探究。我觉得也是非常不错的。</p><p>不过提到工作我就没法逃避的一个事实（也是我迟迟不想写这篇文章的原因）就是，2020，我失去的我最早期刚进入职场时的领路人，也是我最好的朋友。如果说，我师父在我职业早期送我最重要的礼物是说”学习任何一个东西需要系统化“，那么他送给我的礼物就是正确的职业态度，正确的提问方式等很多很细碎，但是足够让我受益终生的东西。So，RIP &amp;&amp; 2020 我日你仙人*2。</p><h2 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h2><p>和荆澈同学的感情步入了第三年，依旧非常甜蜜。荆澈同学一如既往的照顾我，比如我身上现在的行头都是荆澈同学给我买的，而此文由荆澈同学给我买的 HHKB Hybrid 写出！</p><p>而且我们第一次一起去拍了美美的情侣照！有一说一，情侣照成片拿到手后，我最喜欢干的一件事就是换微信头像Hhhh（逃</p><p>不过说实话，很多时候觉得我自己还不算是一个合格的男朋友，很多时候小事和小细节非常不注意（= =我也很绝望）会无意间让她非常不开心，用她吐槽我的话来说，就是”败兴大王“，而且之前自己作死导致19年身体一直时好时坏，也让荆澈同学操了不少心。</p><p>所以，有些时候我也在想，荆澈同学没把我扔出去也是神奇Hhhh。不过我自己也定了很多目标，会一点点的改掉自己很多不好的习惯！不过这里突然想引用一下每年给荆澈同学一封信中我经常说的一句话</p><blockquote><p>亲爱的，我感激并享受着你的爱</p></blockquote><p>啊，对了，在年初的时候，和荆澈同学一起，列了不少今年要一起做的事，希望能一起好好的走下去。（再次表白荆澈同学！）</p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>嘛，实际上去年年初的时候，因为各种原因没有给自己立下什么 flag，所以大概聊聊自己过去一年多做的一些事吧。</p><p>读书方面的话，我自己比较印象深刻的有这样几本</p><ol><li><p>Design Data Intensive Application</p></li><li><p>Kubernetes in Action</p></li><li><p>BPF Performance Tools</p></li></ol><p>然后因为各种原因，复习/新读了几篇论文，比如印象比较深刻的 Cloud Programming Simplified A Berkeley View on Serverless Computing, Maglev A Fast and Reliable Software Network Load Balancer。</p><p>社区方面的话，今年一如既往的参与了 PyCon China 2021 的筹办，参与了两次 Meetup 分享。收获了微软的 MVP ，算是完成了一个软粉的夙愿。</p><p>整体来看吧，可能输出没有之前多，而且也有点偷懒了，具体原因后面会说。，不过可能还算是一个合格的答卷。希望21年能够继续在技术上勇猛精进吧</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>嘛，实际上生活上这一年多的变化还是蛮大的，首先正儿八经的讲，我没有穿迷彩了！（实际上是荆澈同学看不下去了包办了我全身的行头！）</p><p>在年初的时候，家里加入了一个新的成员，一只“憨厚“”老实“”稳重“的红虎斑缅因猫年年，这样一来，我们家就有了四只猫！年年说实话给我们的生活带来了很多的乐趣（除了踩在我肚子上的时候）</p><p>而过去一年，在生活上比较大的一个变化是，我第一次意识到了，除了技术和睡觉，生活也很重要。开始时不时的和亲爱的荆澈同学一起打打游戏（一起动森，一起分手厨房），一起看看剧，逛逛淘宝啥的。说实话，非常幸福，这也是我之前从未有过的体验。Hhhhhh</p><p>另外一方面，2020年，我做了一件对我来说可能是比较重要的一个事，在17年确诊抑郁后，当时分析成因可能是因为来源于自己小时候被性侵后的 PTSD。所以我选择将我自己的经历不断以文字的形式公开出来。而去年，我选择参与进华师的一个研究，我面向研究者，完整的，深入的直面了当时我被性侵的细节，心里状况，反思及建议</p><p>这件事实际上，对于我来说意义也非常重要。我希望能通过自己和其余人的努力，能让国内被性侵儿童心里干涉相关的研究能够进一步发展。这里非常非常谢谢亲爱的荆澈同学对我的支持，几次因为小时候的事极度丧的时候，都是荆澈同学一直在给我拥抱并安慰。而且荆澈同学也非常支持并鼓励我讲自己的经历分享出来。同时我们决定，将自己参加研究所得到的相关收入捐赠给公益基金会。</p><h2 id="但行好事，莫问前程"><a href="#但行好事，莫问前程" class="headerlink" title="但行好事，莫问前程"></a>但行好事，莫问前程</h2><p>嗯，差不多流水帐就这样一些，说实话，2020年，对于我来说其实是很特殊的一年，有过哭泣，有过坚强，想过放弃，但是又继续走了下去</p><p>这一年，或者说过去四年，能跌跌撞撞的走到现在，有很多的人想感谢，亲爱的荆澈同学，师父，几位密友，捕蛇者说的搭档，历任的 Leader，推上认识的朋友。感谢你们一路相伴，带我看了更大的世界。然后，其实我想第一次在这里谢谢自己，谢谢自己在无数次想过一了百了之后，还是坚持到了今天。</p><p>前两天，我看着我招行账单，上面显示说，我自己的收入比19年高了不少，当时心里百味杂陈，给亲爱的说“我们日子会越过越好的”</p><p>嗯，Everything is gonna be OK</p><p>如果说四年前，在17年的总结中，我送给自己的话是 “诗酒趁年华”。那么在经历过挫折，反思，成长，可能不算丰富，但是对我来说却意义重大的四年后。我选择送给自己的话，也是这篇记录的标题</p><p><strong>但行好事，莫问前程</strong></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 总结 </category>
          
          <category> 秀恩爱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云原生时代的几个爆论</title>
      <link href="//posts/2020/12/31/fuck-the-cloud-native/"/>
      <url>//posts/2020/12/31/fuck-the-cloud-native/</url>
      
        <content type="html"><![CDATA[<p>从去年调转到现在，做了一段时间的云原生，我突发奇想，想发表几个爆论来论述下我眼中的云原生来作为今年最后一篇技术博客。本文纯属个人向吐槽，与本人公司立场无关</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>云原生大概在 2014-2015 年开始左右，开始正式的提出了这个概念。2015 年 Google 主导成立了云原生计算基金会（Cloud Native Computing Foundation aka CNCF)。在 2018 年，CNCF 在 <strong>CNCF Cloud Native Definition v1.0</strong><a href="#refer-anchor-1"><sup>1</sup></a> 首次对云原生的概念有了一个认定</p><blockquote><p>Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.<br>These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.</p></blockquote><p>其中文翻译如下：</p><blockquote><p>云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。<br>这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。</p></blockquote><p>从官方的定义来看，我更愿意将其称为一个愿景(vision/landscape)而不是一个定义(definition)，因为在上述的表达中，并没有清晰明确的表述出<strong>云原生</strong>这一新生概念的具体的范围与边界，也没有阐述清楚 <strong>Cloud Native</strong> 和 <strong>Non-Cloud Native</strong> 之间的差异。</p><p>如果以个人的视角来看，一个云原生应用具备以下特质</p><ol><li>容器化</li><li>服务化</li></ol><p>而一个践行云原生的组织，那么应该具备以下特质</p><ol><li><p>重度 Kubernetes 或其余容器调度平台（如 Shopee 自研的 <strong>eru2</strong><a href="#refer-anchor-2"><sup>2</sup></a></p></li><li><p>具备完整的监控体系</p></li><li><p>具备完整的 CI/CD 体系</p></li></ol><p>在这个基础上，最近看到很多人都在讨论云原生这一新生概念，所以我想在这里聊聊个人向的四个爆论（爆论中的数据是个人主观判断，轻喷）</p><ol><li>百分之95以上的公司，没有完成 CI/CD 体系的建立。也没有完成线上服务进程的收敛</li><li>百分之90以上的公司，没有能微服务化的技术储备</li><li>百分之90以上的公司，没有能撑起容器化的技术储备</li></ol><h2 id="开始爆论"><a href="#开始爆论" class="headerlink" title="开始爆论"></a>开始爆论</h2><h3 id="1-百分之95以上的公司，没有完成-CI-CD-体系的建立。也没有完成线上服务进程的收敛"><a href="#1-百分之95以上的公司，没有完成-CI-CD-体系的建立。也没有完成线上服务进程的收敛" class="headerlink" title="1. 百分之95以上的公司，没有完成 CI/CD 体系的建立。也没有完成线上服务进程的收敛"></a>1. 百分之95以上的公司，没有完成 CI/CD 体系的建立。也没有完成线上服务进程的收敛</h3><p>CI 指持续集成（Continuous Integration aka CI），而 CD 指<strong>持续交付</strong>(Continuous Delivery aka CD)，通常来讲 CI 与 CD 的定义如下（此处引用 Brent Laster 在 <strong>What is CI/CD?</strong><a href="#refer-anchor-3"><sup>3</sup></a> 中给出的定义</p><blockquote><p>Continuous integration (CI) is the process of automatically detecting, pulling, building, and (in most cases) doing unit testing as source code is changed for a product. CI is the activity that starts the pipeline (although certain pre-validations—often called “pre-flight checks”—are sometimes incorporated ahead of CI).<br>The goal of CI is to quickly make sure a new change from a developer is “good” and suitable for further use in the code base.<br>Continuous deployment (CD) refers to the idea of being able to automatically take a release of code that has come out of the CD pipeline and make it available for end users. Depending on the way the code is “installed” by users, that may mean automatically deploying something in a cloud, making an update available (such as for an app on a phone), updating a website, or simply updating the list of available releases.</p></blockquote><p>通常在我们的实践中，CI 和 CD 的边界并不明显。以常见的基于 Jenkins 的实践为例，我们通常的一套路径是</p><ol><li><p>创建一个 Jenkins 的项目，设定一个 Pipeline（其中包含代码拉取，构建，单元测试等 task），设置触发条件</p></li><li><p>当指定代码仓库存在主分支代码合入等操作时，执行 Pipeline ，然后生成产物</p></li></ol><p>在生成产物后的，常见有两种做法</p><ol><li><p>在生成产物的下一个阶段触发自动的 deploy 流程，按照 deploy script 直接将生成的产物/镜像直接部署到目标服务器上</p></li><li><p>将生成的产物上传到中间平台，由人通过部署平台手动触发部署任务</p></li></ol><p>在上面描述的过程中，如果有着完备的流程的公司还会有着其余的辅助流程（如 PR/MR 时的 CI 流程，CR 流程等）</p><p>而在面对目标平台的部署时，我自己的另外一个观点是大部分的公司没有完成线上服务进程的收敛。讲个笑话：</p><blockquote><p>Q: 你们怎么部署线上服务呀？A；nohup，tmux，screen</p></blockquote><p>对于当下而言，一个规范化的 CI/CD 流程，收口的线上的服务进程的管理，至少在当下，有着可以遇见的几个好处</p><ol><li><p>尽可能的降低人为手动变更带来的风险</p></li><li><p>能够较好的完成基础运行依赖配置的收口</p></li><li><p>依托目前主流的开源的 systemd, supervisor, pm2 等进程管理工具，能对进程提供基础的 HA 的保证（包括进程探活，进程重拉等）</p></li><li><p>为后续的服务化，容器化等步骤打下基础</p></li></ol><h3 id="2-百分之90以上的公司，没有能微服务化的技术储备"><a href="#2-百分之90以上的公司，没有能微服务化的技术储备" class="headerlink" title="2. 百分之90以上的公司，没有能微服务化的技术储备"></a>2. 百分之90以上的公司，没有能微服务化的技术储备</h3><p>如果说，对于爆论1 提到的 CI/CD 等手段，我更多的觉得这是一个制度障碍大于技术障碍的现实。那么接下来的几个爆论，我更愿意用<strong>没有技术储备</strong>来形容</p><p>先来说说爆论2: 百分之90以上的公司，没有能微服务化的技术储备</p><p>首先来聊聊微服务的概念吧，微服务实际上在计算机历史上有着不同的论述，在2014年 Martin Fowler 和 James Lewis 正式在 <strong>Microservices a definition of this new architectural term</strong><a href="#refer-anchor-4"><sup>4</sup></a> 一文中正式的提出了微服务（Microservice）这一概念。<br>此处引用维基百科的一段概述</p><blockquote><p>微服务是由以单一应用程序构成的小服务，自己拥有自己的行程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用HTTP API通信。同时服务会使用最小的规模的集中管理 (例如 Docker) 能力，服务可以用不同的编程语言与数据库等组件实现</p></blockquote><p>那么我们来用研发的话来尝试描述下关于微服务和与之对应的传统单体服务（Monolith） 之间显著性的差异</p><ol><li><p>微服务的 scope 更小，其更多的专注在某一个功能，或者某一类的功能上</p></li><li><p>由于其 scope 更小的特性，其变更，crash 所带来的影响相较于传统的单体来说更小</p></li><li><p>对于多语言多技术栈团队来说更为友好</p></li><li><p>”符合“现在互联网所需求的小步快跑，快速迭代的大目标</p></li></ol><p>那么我们这里需要思考一下，微服务这一套体系，如果我们想要去进行落地和实践，那么我们需要怎么样的技术储备？我觉得主要是两个方面，架构和治理</p><p>首先来聊聊架构吧，我觉得对于微服务来说，最麻烦的一个问题在于从传统单体应用上进行拆分（当然要是最开始创始之初就开始搞微服务的当我没说，虽然这样也有其余的问题）</p><p>如前面所说，微服务相较于传统的单体应用来说，，其 scope 更小，更专注在某一个功能或者某一类的功能上。那么这里所引申出来我觉得做微服务最大的一个问题在于合理的划分功能边界并进行拆分</p><p>如果拆分不合理那么将导致服务之间相互耦合，比如我将用户鉴权放置在商城服务中，导致我论坛服务需要依赖其不需要的商城服务。如果拆分的过细，那么将导致出现一个很有趣的现象，一个规模不大的业务拆了100多个服务 repo 出来（我们把这种情况称为： 微服务难民2333）</p><p>我们践行落地微服务这一套理念，是因为我们在业务和团队规模扩大后，面对多样化的需求与团队成员技术栈时，传统单体应用在其持续维护上的成本将会是一个不小的开支。我们希望引入微服务来尽可能减少维护成本，降低风险。但是不合理的拆分，将会重新让我们的维护成本远超继续践行单体化的方案</p><p>而我觉得阻碍微服务继续践行的另外一个问题是治理问题。我们来看一下在微服务化后我们所面临的几个问题</p><ol><li><p>可观测性的问题。如前面所说，微服务化后的单个服务 scope 更小，更多的专注在某一个功能或者某一类功能上。那么这可能导致的问题是，我们在完成一个业务请求所需要经历的请求链路更长。那么按照通用的观点来看，链路更长，其风险更大。那么在在当服务存在异常时（比如业务 RT 的突然增高）我们怎么样去定位具体服务的问题？</p></li><li><p>配置框架的收口。在微服务化的场景中，我们可能会选择将一些基础的功能下沉至具体的内部框架中（如服务注册，发现，路由等），那么意味着我们需要维护自己的框架，同时完成配置的收敛</p></li><li><p>老生常谈的服务治理（注册、发现、熔断）等</p></li><li><p>由于微服务化后，对于一个完备 CI/CD 机制的需求将变得更为迫切。那么如果存在爆论1的情况，将会成为践行微服务这一理念的障碍</p></li></ol><p>诚然，目前无论开源社区（如 Spring Cloud，Go—Micro 等）还是四大云厂商（AWS，Azure，阿里云，GCP）都在尝试提供一种开箱即用的微服务方案，但是除了没法很好的解决如上面所说的诸如架构这样的问题外，其也存在自己的问题</p><ol><li><p>无论是依赖开源社区的方案，还是云厂商的方案，都需要使用者具备一定的技术素养，来定位特定情况下框架中的问题</p></li><li><p>Vendor Lock-in，目前开箱即用的微服务方案并没有一个通用的开源事实标准。那么依赖某一个开源社区或者云厂商的方案将存在 vendor lock-in 的问题</p></li><li><p>无论是开源社区的方案还是云厂商的方案，都存在多语言不友好的问题（大家貌似现在都喜欢 Java 一点（Python 没人权.jpg</p></li></ol><p>所以爆论2想表明的一个最核心的观点就是：微服务化并不是一个无代价的行为，与之相反的是一个需要不低技术储备与人力投入的的行为。所以请不要认为微服务是万能良药。请按需使用</p><h3 id="3-百分之90以上的公司，没有能撑起容器化的技术储备"><a href="#3-百分之90以上的公司，没有能撑起容器化的技术储备" class="headerlink" title="3. 百分之90以上的公司，没有能撑起容器化的技术储备"></a>3. 百分之90以上的公司，没有能撑起容器化的技术储备</h3><p>目前很主流的一个观点，是能上容器尽可能上容器，说实话这个想法实际上是有一定的合理性的，去 review 这个想法，我们需要去看一下容器这个东西，给我们带来了什么样的改变</p><p>容器首先毫无疑问，会给我们带来非常多的好处：</p><ol><li>真正意义上让开发与生产环境保持一致是一种非常方便的事，换句话说，开发说的“这个服务在我本地没啥问题”是一句有用的话了</li><li>让部署一些服务变的更为方便，无论是分发，还是部署，</li><li>能做到一定程度上的资源隔离与分配</li></ol><p>那么，看起来我们是不是可以无脑用容器？不，不是，我们需要再来 Review 一下，容器化后我们可能所要面临的一些弊端：</p><ol><li>容器安全性问题，目前最主流的容器实现（此处点名 Docker）本质上而言还是基于 CGroups + NS 来进行资源与进程隔离。那么其安全性将会是一个非常值得考量的问题。毕竟 Docker 越权与逃逸漏洞年年有，年年新。那么这意味着我们是需要去有一个系统的机制去规范我们容器的使用，来保证相关的越权点能被把控在一个可控的范围内。而另一个方向是镜像安全问题，大家都是面向百度/CSDN/Google/Stackoverflow 编(fu)程(zhi)选手，那么势必会出现一个情况，当我们遇到一个问题，搜索一番，直接复制点 Dockerfile 下来，这个时候，将会存在很大的风险点，毕竟谁也不知道 base image 里加了啥料不是？</li><li>容器的网络问题。当我们启动若干个镜像后，那么容器之间的网络互通怎么处理？而大家生产环境，肯定不止一个机器那么少，那么跨主机的情况下，怎么样去进行容器间的通信，同时保证网络的稳定性？</li><li>容器的调度与运维的问题，当我一个机器高负载的时候，怎么样去将该机器上的一些容器调度到其余的机器上？而怎么样去探知一个容器是否存活？如果一个容器 crash 了，怎么样重新拉起？</li><li>容器具体的细节问题，比如镜像怎么样构建与打包？怎么样上传？（又回到了爆论1）乃至说怎么样去排查一些 corner case 的问题？</li><li>对于一些特定的 large size 的镜像（如机器学习同学常用的 CUDA 官方镜像，打包了字典模型等大量数据的镜像等）怎么样去快速下载，快速发布？</li></ol><p>可能这里又会有一种观点，没事，我们上 Kubernetes 就好啦，上面这些很多问题就能解决啦！好吧，我们再来聊聊这个问题</p><p>首先我已经忽略掉自建 Kubernetes 集群的场景了，因为那不是一般人能 Hold 住的。那么我们来看一下，依托公有云使用的情况吧，以阿里云为例，点开页面，然后我们见到这样张图</p><p><img src="https://manjusakablog.blob.core.windows.net/blog-resource/images/2020-06-29-01.png" alt="1"></p><p><img src="https://manjusakablog.blob.core.windows.net/blog-resource/images/2020-06-29-02.png" alt="2"></p><p>好了，提问：</p><ol><li>VPC 是什么？</li><li>Kubernetes 1.16.9 和 1.14.8 有什么区别</li><li>Docker 19.03.5 和阿里云安全沙箱 1.1.0 是什么，有什么区别</li><li>专有网络是什么？</li><li>虚拟交换机是什么？</li><li>网络插件是什么？Flannel 和 Terway 又是什么？有什么区别？当你翻了翻文档，然后文档告诉你，Terway 是阿里云基于 Calico 魔改的 CNI 插件。那么 CNI 插件是什么？Calico 是什么？</li><li>Pod CIDR 是什么怎么设？</li><li>Service CIDR 是什么怎么设？</li><li>SNAT 是什么怎么设？</li><li>安全组怎么配置？</li><li>Kube-Proxy 是什么？iptables 和 IPVS 有什么区别？怎么选？</li></ol><p>大家能看到上面的问题涵盖了这样几方面</p><ol><li><p>Kubernetes 本身的深入了解（CNI，runtime，kube-proxy 等）</p></li><li><p>一个合理网络规划</p></li><li><p>对于云厂商特定功能的熟悉</p></li></ol><p>在我看来，这三方面任何一方面对于一个技术团队的技术储备以及对于业务的理解（广义的技术储备）都需要有一个不浅的需求。</p><p>当然这里在碎碎念一下，实际上搞 Kubernetes 这一套开销实际上很大的（有点偏题，但是还是继续说吧）</p><ol><li>你得有个镜像仓库吧，不贵，中国区基础版780一个月</li><li>你集群内的服务需要暴露出去用吧？行叭，买个最低规格的 SLB，简约型，每个月200</li><li>好了，你每个月日志得花钱吧？假设你每个月20G日志，不多吧？行，39.1</li><li>你集群监控要不要？好，买，每天50w条日志上报吧？行，不贵，975 一个月</li></ol><p>算一下，一个集群吧，(780+200+39.1+975)*12=23292.2一年，不算集群基础的 ENI，ECS 等费用，美滋滋</p><p>而且 Kubernetes 会有很多的玄学的问题，也需要技术团队有足够的技术储备来进行排查（我想想啊，我遇到过 CNI 一号进程 crash 了没重拉，特定版本上的内核 cgroup 泄漏，ingress OOM 等问题），大家可以去 Kubernetes 的 Issue 区看一下盛况（说多了都是泪）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我知道这篇文章写出来会存在很多的争议。但是我始终想表述的一个观点是对于云原生时代这一套东西（实际上也更多是之前传统技术的延伸），他们的引入并不是无代价，并不是无成本的。对于有着足够规模与痛点的公司来说，这样的成本对于他们的业务增长来说是一个正向的促进，而对于更多中小企业来说，可能这一套对于业务的提升将会是非常小乃至说是负作用。</p><p>我希望我们技术人员在做技术决策的时候，一定是在评估自己的团队的技术储备乃至对于业务的收益后再引入某一种技术与理念，而不是引入一个技术只是因为它看起来够先进，够屌，能够为我的简历背书</p><p>最后用之前我分享过的一句话来作为本文的结尾吧</p><blockquote><p>一个企业奔着技术先进性去搞技术，就是死</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="refer-anchor-1"></div><ul><li><ol><li><a href="https://github.com/cncf/toc/blob/master/DEFINITION.md">CNCF Cloud Native Definition v1.0</a></li></ol></li></ul><div id="refer-anchor-2"></div><ul><li><ol><li><a href="https://github.com/projecteru2/core">projecteru2</a></li></ol></li></ul><div id="refer-anchor-3"></div><ul><li><ol><li><a href="https://opensource.com/article/18/8/what-cicd">What is CI/CD?</a></li></ol></li></ul><div id="refer-anchor-4"></div><ul><li><ol><li><a href="https://martinfowler.com/articles/microservices.html">Microservices a definition of this new architectural term</a></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 随想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 随想 </tag>
            
            <tag> 云原生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单聊聊进程中的信号处理 V2</title>
      <link href="//posts/2020/11/07/a-simple-introduction-about-signal-process-in-linux-v2/"/>
      <url>//posts/2020/11/07/a-simple-introduction-about-signal-process-in-linux-v2/</url>
      
        <content type="html"><![CDATA[<p>上次写了一个水文<a href="https://manjusaka.itscoder.com/posts/2020/10/24/a-simple-introduction-about-signal-process-in-linux/">简单聊聊进程中的信号处理</a> ，师父看了后把我怒斥了一顿，表示上篇水文中的例子太 old style, too simple ,too naive。如果未来出了偏差，我也要负泽任的。吓得我连和妹子周年庆的文章都没写，先赶紧来重新水一篇文章，聊聊更优秀，更方便的信号处理方式</p><span id="more"></span><h2 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>首先来看看，之前那篇文章中的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deletejob</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;delete task %d\n&quot;</span>, pid); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addjob</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;add task %d\n&quot;</span>, pid); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="type">int</span> olderrno = errno;</span><br><span class="line">  <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  sigfillset(&amp;mask_all);</span><br><span class="line">  <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">    deletejob(pid);</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (errno != ECHILD) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">  sigfillset(&amp;mask_all);</span><br><span class="line">  signal(SIGCHLD, handler);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">      execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">    addjob(pid);</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来复习下几个关键的 <code>syscall</code></p><ol><li><strong>signal</strong><a href="#refer-anchor-1"><sup>1</sup></a>: 信号处理函数，使用者可以通过这个函数为当前进程指定具体信号的 Handler。当信号触发时，系统会调用具体的 Handler 进行对应的逻辑处理。</li><li><strong>sigfillset</strong><a href="#refer-anchor-2"><sup>2</sup></a>: 用于操作 <strong>signal sets</strong>（信号集）的函数之一，这里的含义是将系统所有支持的信号量添加进一个信号集中</li><li><strong>fork</strong><a href="#refer-anchor-3"><sup>3</sup></a>: 大家比较熟悉的一个 API 了，创建一个新的进程，并返回 <strong>pid</strong> 。如果是在父进程中，返回的 <strong>pid</strong> 是对应子进程的 <strong>pid</strong>。如果子进程中，<strong>pid</strong> 为0</li><li><strong>execve</strong><a href="#refer-anchor-4"><sup>4</sup></a>: 执行一个特定的可执行文件</li><li><strong>sigprocmask</strong><a href="#refer-anchor-5"><sup>5</sup></a>：设置进程的信号屏蔽集。当传入第一个参数为 <strong>SIG_BLOCK</strong> 时，函数会将当前进程的信号屏蔽集保存在第三个参数传入的信号集变量中，并将当前进程的信号屏蔽集设置为第二个参数传入的信号屏蔽集。当第一个参数为 <strong>SIG_SETMASK</strong> 时，函数会将当前进程的信号屏蔽集设置为第二个参数设置的值。</li><li><strong>wait_pid</strong><a href="#refer-anchor-6"><sup>6</sup></a>: 做一个不精确的概括，回收并释放已终止的子进程的资源。</li></ol><p>好了，复习完关键点之后，开始进入本文的关键部分。</p><h2 id="更优雅的信号处理手段"><a href="#更优雅的信号处理手段" class="headerlink" title="更优雅的信号处理手段"></a>更优雅的信号处理手段</h2><h3 id="更优雅的-handler"><a href="#更优雅的-handler" class="headerlink" title="更优雅的 handler"></a>更优雅的 handler</h3><p>首先再来看看上面信号处理部分的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="type">int</span> olderrno = errno;</span><br><span class="line">  <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  sigfillset(&amp;mask_all);</span><br><span class="line">  <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">    deletejob(pid);</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (errno != ECHILD) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  errno = olderrno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们为了保证 <code>handler</code> 不被其余的信号打断，所以我们在处理的时候使用 <code>sigprocmask</code> + <code>SIG_BLOCK</code> 来做信号屏蔽。这样看起来逻辑上没啥问题，但是有个问题。当我们有其余很多不同 <code>handler</code> 的时候，我们势必会生成很多重复冗余的代码。那么我们有没有更优雅的方法来保证我们的 <code>handler</code> 的安全呢？</p><p>有（超大声（好，很有精神！（逃。隆重介绍一个新的 <strong>syscall</strong> -&gt; <strong>sigaction</strong><a href="#refer-anchor-7"><sup>7</sup></a></p><p>废话不多说，先上代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deletejob</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;delete task %d\n&quot;</span>, pid); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addjob</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;add task %d\n&quot;</span>, pid); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="type">int</span> olderrno = errno;</span><br><span class="line">  <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  sigfillset(&amp;mask_all);</span><br><span class="line">  <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    deletejob(pid);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (errno != ECHILD) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">  sigfillset(&amp;mask_all);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">new_action</span>;</span></span><br><span class="line">  new_action.sa_handler=handler;</span><br><span class="line">  new_action.sa_mask=mask_all;</span><br><span class="line">  signal(SIGCHLD, handler);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">      execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">    addjob(pid);</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好！很有精神！大家可能发现了，我们这段代码相较于之前的代码增加了关于 sigaction 相关的设置。难道？</p><p>yep，在 <strong>sigaction</strong> 中，我们可以通过设置 <code>sa_mask</code> 来设置当信号处理函数执行期间，进程将阻塞哪些信号。</p><p>你看，这样我们的代码是不是相较于之前更为优雅了。当然，<strong>sigaction</strong> 还有很多其余很有用的设置项，大家可以下来了解一下。</p><h3 id="更快速的信号处理方式"><a href="#更快速的信号处理方式" class="headerlink" title="更快速的信号处理方式"></a>更快速的信号处理方式</h3><p>在我们上面的例子中，我们已经解决了优雅的设置信号处理函数这样的问题，那么我们现在又面临了一个全新的问题。</p><p>如上面所说，我们信号处理函数在执行时，我们选择阻塞了其余的信号。那么这里存在一个问题，当我们在信号处理函数中的逻辑耗时较长，且不需要原子性（即需要和信号处理函数保持同步），而且系统中的信号发生频率较高。那么我们这样的做法将会导致进程的信号队列不断增加，进而导致不可预料的后果。</p><p>那么我们这里有什么更好的方法来处理这件事呢？</p><p>假设，我们打开一个文件，在信号处理函数中只完成一件事，就是往这个文件中写一个特定的值。然后我们轮询这个文件，如果一旦发生变化，那么我们读取文件中的值，判断具体的信号，做具体的信号处理，这样是不是既保证了信号的妥投，又保证我们信号处理逻辑将阻塞信号的代价降至最低了？</p><p>当然，当然，社区知道大家嫌写代码难，所以专门给大家提供了一个船新的 <code>syscall</code> -&gt; <strong>signalfd</strong><a href="#refer-anchor-8"><sup>8</sup></a></p><p>老规矩，先来看看例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/signalfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEVENTS 64</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deletejob</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;delete task %d\n&quot;</span>, pid); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addjob</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;add task %d\n&quot;</span>, pid); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line">  <span class="type">sigset_t</span> mask;</span><br><span class="line">  sigemptyset(&amp;mask);</span><br><span class="line">  sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">  <span class="keyword">if</span> (sigprocmask(SIG_SETMASK, &amp;mask, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;sigprocmask&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> sfd = signalfd(<span class="number">-1</span>, &amp;mask, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> epoll_fd = epoll_create(MAXEVENTS);</span><br><span class="line">  event.events = EPOLLIN | EPOLLEXCLUSIVE | EPOLLET;</span><br><span class="line">  event.data.fd = sfd;</span><br><span class="line">  <span class="type">int</span> s = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sfd, &amp;event);</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  events = <span class="built_in">calloc</span>(MAXEVENTS, <span class="keyword">sizeof</span>(event));</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> n = epoll_wait(epoll_fd, events, MAXEVENTS, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll EINTR error\n&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINVAL) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll EINVAL error\n&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EFAULT) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll EFAULT error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno == EBADF) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll EBADF error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) ||</span><br><span class="line">          (!(events[i].events &amp; EPOLLIN))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll err\n&quot;</span>);</span><br><span class="line">        close(events[i].data.fd);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sfd == events[i].data.fd) &#123;</span><br><span class="line">        <span class="keyword">struct</span> signalfd_siginfo si;</span><br><span class="line">        <span class="type">ssize_t</span> res = read(sfd, &amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="keyword">sizeof</span>(si)) &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Something wrong\n&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (si.ssi_signo == SIGCHLD) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Got SIGCHLD\n&quot;</span>);</span><br><span class="line">          <span class="type">int</span> child_pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">          deletejob(child_pid);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">      execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    addjob(pid);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，我们来介绍下这段代码中的一些关键点</p><ol><li>signalfd 是一类特殊的文件描述符，这个文件可读，可 <strong>select</strong> 。当我们指定的信号发生时，我们可以从返回的 fd 中读取到具体的信号值。</li><li><strong>signalfd</strong> 优先级比信号处理函数低。换句话说，假设我们为信号 <strong>SIGCHLD</strong> 注册了信号处理函数，同时也为其注册了 <strong>signalfd</strong> 那么当信号发生时，将优先调用信号处理函数。所以我们在使用 <strong>signalfd</strong> 时，需要利用 <strong>sigprocmask</strong> 设置进程的信号屏蔽集。</li><li>如前面所说，该文件描述符可 <strong>select</strong> ，换句话说，我们可以利用 <strong>select</strong><a href="#refer-anchor-9"><sup>9</sup></a>, <strong>poll</strong><a href="#refer-anchor-10"><sup>10</sup></a>, <strong>epoll</strong><a href="#refer-anchor-11"><sup>11</sup></a><a href="#refer-anchor-12"><sup>12</sup></a> 等函数来对 fd 进行监听。在上面的的代码中，我们就利用 <strong>epoll</strong> 对 <strong>signalfd</strong> 进行监听</li></ol><p>当然，这里额外要注意的一点是，很多语言不一定提供了官方的 <strong>signalfd</strong> 的 API（如 Python），但是也有可能提供了等价的替代品，典型的例子就是 Python 中的 <strong>signal.set_wakeup_fd</strong><a href="#refer-anchor-13"><sup>13</sup></a></p><p>在这里也给大家留一个思考题：除了利用 <strong>signalfd</strong> ，还有什么方法可以实现高效，安全的信号处理？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>私以为信号处理是作为一个研发的基本功，我们需要安全，可靠的处理在程序环境中遇到的各种信号。而系统也提供了很多设计很优秀的 API 来减轻研发的负担。但是我们要知道，信号本质上是通讯手段的一种。而其天生的弊端便是携带的信息较少。很多时候，当我们有很多高频的信息传递需要去做的时候，这个时候可能利用信号并不是一个很好的选择。当然这个并没有定论。只能 case by case 的去做 trade-off。</p><p>差不多就这样吧，本周第二篇水文混完（逃</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="refer-anchor-1"></div><ul><li>[1]. <a href="https://man7.org/linux/man-pages/man7/signal.7.html">Linux man page: signal</a></li></ul><div id="refer-anchor-2"></div><ul><li>[2]. <a href="https://linux.die.net/man/3/sigfillset">Linux man page: sigfillset</a></li></ul><div id="refer-anchor-3"></div><ul><li>[3]. <a href="https://man7.org/linux/man-pages/man2/fork.2.html">Linux man page: fork</a></li></ul><div id="refer-anchor-4"></div><ul><li>[4]. <a href="https://man7.org/linux/man-pages/man2/execve.2.html">Linux man page: execve</a></li></ul><div id="refer-anchor-5"></div><ul><li>[5]. <a href="https://man7.org/linux/man-pages/man2/sigprocmask.2.html">Linux man page: sigprocmask</a></li></ul><div id="refer-anchor-6"></div><ul><li>[6]. <a href="https://linux.die.net/man/2/waitpid">Linux man page: waitpid</a></li></ul><div id="refer-anchor-7"></div><ul><li>[7]. <a href="https://www.man7.org/linux/man-pages/man2/sigaction.2.html">Linux man page: sigaction</a></li></ul><div id="refer-anchor-8"></div><ul><li>[8]. <a href="https://www.man7.org/linux/man-pages/man2/sigaction.2.html">Linux man page: signalfd</a></li></ul><div id="refer-anchor-9"></div><ul><li>[9]. <a href="https://man7.org/linux/man-pages/man2/select.2.html">Linux man page: select</a></li></ul><div id="refer-anchor-10"></div><ul><li>[10]. <a href="https://man7.org/linux/man-pages/man2/poll.2.html">Linux man page: poll</a></li></ul><div id="refer-anchor-11"></div><ul><li>[11]. <a href="https://man7.org/linux/man-pages/man2/epoll_ctl.2.html">Linux man page: epoll_ctl</a></li></ul><div id="refer-anchor-12"></div><ul><li>[12]. <a href="https://man7.org/linux/man-pages/man2/epoll_wait.2.html">Linux man page: epoll_wait</a></li></ul><div id="refer-anchor-13"></div><ul><li>[13]. <a href="https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd">Python Documentation: signal.set_wakeup_fd</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 水文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么有些时候 Python 中乘法比位运算更快</title>
      <link href="//posts/2020/11/06/why-mul-faster-than-bit-shift-sometimes-in-python/"/>
      <url>//posts/2020/11/06/why-mul-faster-than-bit-shift-sometimes-in-python/</url>
      
        <content type="html"><![CDATA[<p>我本来以为我不再会写水文了，但是突然发现自己现在也只能勉强写写水文才能维持生活这样子。那就继续写水文吧</p><span id="more"></span><p>某天，一个技术群里老哥提出了这样一个问题，为什么在一些情况下，Python 中的简单乘/除法比位运算要慢</p><p>首先秉持着实事求是的精神，我们先来验证一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [33]: %timeit 1073741825*2                                                                                                                                                                                                                                                                           </span><br><span class="line">7.47 ns ± 0.0843 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)</span><br><span class="line"></span><br><span class="line">In [34]: %timeit 1073741825&lt;&lt;<span class="string">1                                                                                                                                                                                                                                                                          </span></span><br><span class="line"><span class="string">7.43 ns ± 0.0451 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">In [35]: %timeit 1073741823&lt;&lt;1</span>                                                                                                                                                                                                                                                                          </span><br><span class="line">7.48 ns ± 0.0621 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)</span><br><span class="line"></span><br><span class="line">In [37]: %timeit 1073741823*2                                                                                                                                                                                                                                                                           </span><br><span class="line">7.47 ns ± 0.0564 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)</span><br></pre></td></tr></table></figure><p>我们发现几个很有趣的现象</p><ol><li>在值 <code>x&lt;=2^30</code> 时，乘法比直接位运算要快</li><li>在值 <code>x&gt;2^32</code> 时，乘法显著慢于位运算</li></ol><p>这个现象很有趣，那么这个现象的 <code>root cause</code> 是什么？实际上这和 Python 底层的实现有关</p><h2 id="简单聊聊"><a href="#简单聊聊" class="headerlink" title="简单聊聊"></a>简单聊聊</h2><h3 id="PyLongObject-的实现"><a href="#PyLongObject-的实现" class="headerlink" title="PyLongObject 的实现"></a>PyLongObject 的实现</h3><p>在 Python 2.x 时期，Python 中将整型分为两类，一类是 <strong>long</strong>, 一类是 <strong>int</strong> 。在 Python3 中这两者进行了合并。目前在 Python3 中这两者做了合并，仅剩一个 <strong>long</strong> </p><p>首先来看看 <strong>long</strong> 这样一个数据结构底层的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">longobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    digit ob_digit[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里不用关心，<strong>PyObject_VAR_HEAD</strong> 的含义，我们只需要关心 <strong>ob_digit</strong> 即可。</p><p>在这里，<code>ob_digit</code> 是使用了 C99 中的“柔性数组”来实现任意长度的整数的存储。这里我们可以看一下官方代码中的文档</p><blockquote><p>Long integer representation.The absolute value of a number is equal to SUM(for i=0 through abs(ob_size)-1) ob_digit[i] <em> 2**(SHIFT</em>i)<br>Negative numbers are represented with ob_size &lt; 0; zero is represented by ob_size == 0.<br>In a normalized number, ob_digit[abs(ob_size)-1] (the most significant digit) is never zero.  Also, in all cases, for all valid i,0 &lt;= ob_digit[i] &lt;= MASK.<br>The allocation function takes care of allocating extra memory so that ob_digit[0] … ob_digit[abs(ob_size)-1] are actually available.<br>CAUTION:  Generic code manipulating subtypes of PyVarObject has to aware that ints abuse  ob_size’s sign bit.</p></blockquote><p>简而言之，Python 是将一个十进制数转为 <strong>2^(SHIFT)</strong> 进制数来进行存储。这里可能不太好了理解。我来举个例子，在我的电脑上，SHIFT 为 30 ，假设现在有整数 1152921506754330628 ，那么将起转为 2^30 进制表示则为: 4<em>(2^30)^0+2</em>(2^30)^1+1*(2^30)^2 。那么此时 <code>ob_digit</code> 是一个含有三个元素的数组，其值为 [4,2,1]</p><p>OK，在明白了这样一些基础知识后，我们回过头去看看 Python 中的乘法运算</p><h3 id="Python-中的乘法运算"><a href="#Python-中的乘法运算" class="headerlink" title="Python 中的乘法运算"></a>Python 中的乘法运算</h3><p>Python 中的乘法运算，分为两部分，其中关于大数的乘法，Python 使用了 <strong>Karatsuba 算法</strong><a href="#refer-anchor-1"><sup>1</sup></a>，具体实现如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyLongObject *</span><br><span class="line"><span class="title function_">k_mul</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t asize = Py_ABS(Py_SIZE(a));</span><br><span class="line">    Py_ssize_t bsize = Py_ABS(Py_SIZE(b));</span><br><span class="line">    PyLongObject *ah = <span class="literal">NULL</span>;</span><br><span class="line">    PyLongObject *al = <span class="literal">NULL</span>;</span><br><span class="line">    PyLongObject *bh = <span class="literal">NULL</span>;</span><br><span class="line">    PyLongObject *bl = <span class="literal">NULL</span>;</span><br><span class="line">    PyLongObject *ret = <span class="literal">NULL</span>;</span><br><span class="line">    PyLongObject *t1, *t2, *t3;</span><br><span class="line">    Py_ssize_t shift;           <span class="comment">/* the number of digits we split off */</span></span><br><span class="line">    Py_ssize_t i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (ah*X+al)(bh*X+bl) = ah*bh*X*X + (ah*bl + al*bh)*X + al*bl</span></span><br><span class="line"><span class="comment">     * Let k = (ah+al)*(bh+bl) = ah*bl + al*bh  + ah*bh + al*bl</span></span><br><span class="line"><span class="comment">     * Then the original product is</span></span><br><span class="line"><span class="comment">     *     ah*bh*X*X + (k - ah*bh - al*bl)*X + al*bl</span></span><br><span class="line"><span class="comment">     * By picking X to be a power of 2, &quot;*X&quot; is just shifting, and it&#x27;s</span></span><br><span class="line"><span class="comment">     * been reduced to 3 multiplies on numbers half the size.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We want to split based on the larger number; fiddle so that b</span></span><br><span class="line"><span class="comment">     * is largest.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (asize &gt; bsize) &#123;</span><br><span class="line">        t1 = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = t1;</span><br><span class="line"></span><br><span class="line">        i = asize;</span><br><span class="line">        asize = bsize;</span><br><span class="line">        bsize = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use gradeschool math when either number is too small. */</span></span><br><span class="line">    i = a == b ? KARATSUBA_SQUARE_CUTOFF : KARATSUBA_CUTOFF;</span><br><span class="line">    <span class="keyword">if</span> (asize &lt;= i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (asize == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (PyLongObject *)PyLong_FromLong(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> x_mul(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If a is small compared to b, splitting on b gives a degenerate</span></span><br><span class="line"><span class="comment">     * case with ah==0, and Karatsuba may be (even much) less efficient</span></span><br><span class="line"><span class="comment">     * than &quot;grade school&quot; then.  However, we can still win, by viewing</span></span><br><span class="line"><span class="comment">     * b as a string of &quot;big digits&quot;, each of width a-&gt;ob_size.  That</span></span><br><span class="line"><span class="comment">     * leads to a sequence of balanced calls to k_mul.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * asize &lt;= bsize)</span><br><span class="line">        <span class="keyword">return</span> k_lopsided_mul(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split a &amp; b into hi &amp; lo pieces. */</span></span><br><span class="line">    shift = bsize &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (kmul_split(a, shift, &amp;ah, &amp;al) &lt; <span class="number">0</span>) <span class="keyword">goto</span> fail;</span><br><span class="line">    assert(Py_SIZE(ah) &gt; <span class="number">0</span>);            <span class="comment">/* the split isn&#x27;t degenerate */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        bh = ah;</span><br><span class="line">        bl = al;</span><br><span class="line">        Py_INCREF(bh);</span><br><span class="line">        Py_INCREF(bl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (kmul_split(b, shift, &amp;bh, &amp;bl) &lt; <span class="number">0</span>) <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The plan:</span></span><br><span class="line"><span class="comment">     * 1. Allocate result space (asize + bsize digits:  that&#x27;s always</span></span><br><span class="line"><span class="comment">     *    enough).</span></span><br><span class="line"><span class="comment">     * 2. Compute ah*bh, and copy into result at 2*shift.</span></span><br><span class="line"><span class="comment">     * 3. Compute al*bl, and copy into result at 0.  Note that this</span></span><br><span class="line"><span class="comment">     *    can&#x27;t overlap with #2.</span></span><br><span class="line"><span class="comment">     * 4. Subtract al*bl from the result, starting at shift.  This may</span></span><br><span class="line"><span class="comment">     *    underflow (borrow out of the high digit), but we don&#x27;t care:</span></span><br><span class="line"><span class="comment">     *    we&#x27;re effectively doing unsigned arithmetic mod</span></span><br><span class="line"><span class="comment">     *    BASE**(sizea + sizeb), and so long as the *final* result fits,</span></span><br><span class="line"><span class="comment">     *    borrows and carries out of the high digit can be ignored.</span></span><br><span class="line"><span class="comment">     * 5. Subtract ah*bh from the result, starting at shift.</span></span><br><span class="line"><span class="comment">     * 6. Compute (ah+al)*(bh+bl), and add it into the result starting</span></span><br><span class="line"><span class="comment">     *    at shift.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. Allocate result space. */</span></span><br><span class="line">    ret = _PyLong_New(asize + bsize);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="literal">NULL</span>) <span class="keyword">goto</span> fail;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> Py_DEBUG</span></span><br><span class="line">    <span class="comment">/* Fill with trash, to catch reference to uninitialized digits. */</span></span><br><span class="line">    <span class="built_in">memset</span>(ret-&gt;ob_digit, <span class="number">0xDF</span>, Py_SIZE(ret) * <span class="keyword">sizeof</span>(digit));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. t1 &lt;- ah*bh, and copy into high digits of result. */</span></span><br><span class="line">    <span class="keyword">if</span> ((t1 = k_mul(ah, bh)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> fail;</span><br><span class="line">    assert(Py_SIZE(t1) &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(<span class="number">2</span>*shift + Py_SIZE(t1) &lt;= Py_SIZE(ret));</span><br><span class="line">    <span class="built_in">memcpy</span>(ret-&gt;ob_digit + <span class="number">2</span>*shift, t1-&gt;ob_digit,</span><br><span class="line">           Py_SIZE(t1) * <span class="keyword">sizeof</span>(digit));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Zero-out the digits higher than the ah*bh copy. */</span></span><br><span class="line">    i = Py_SIZE(ret) - <span class="number">2</span>*shift - Py_SIZE(t1);</span><br><span class="line">    <span class="keyword">if</span> (i)</span><br><span class="line">        <span class="built_in">memset</span>(ret-&gt;ob_digit + <span class="number">2</span>*shift + Py_SIZE(t1), <span class="number">0</span>,</span><br><span class="line">               i * <span class="keyword">sizeof</span>(digit));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. t2 &lt;- al*bl, and copy into the low digits. */</span></span><br><span class="line">    <span class="keyword">if</span> ((t2 = k_mul(al, bl)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(t1);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(Py_SIZE(t2) &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(Py_SIZE(t2) &lt;= <span class="number">2</span>*shift); <span class="comment">/* no overlap with high digits */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ret-&gt;ob_digit, t2-&gt;ob_digit, Py_SIZE(t2) * <span class="keyword">sizeof</span>(digit));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Zero out remaining digits. */</span></span><br><span class="line">    i = <span class="number">2</span>*shift - Py_SIZE(t2);          <span class="comment">/* number of uninitialized digits */</span></span><br><span class="line">    <span class="keyword">if</span> (i)</span><br><span class="line">        <span class="built_in">memset</span>(ret-&gt;ob_digit + Py_SIZE(t2), <span class="number">0</span>, i * <span class="keyword">sizeof</span>(digit));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4 &amp; 5. Subtract ah*bh (t1) and al*bl (t2).  We do al*bl first</span></span><br><span class="line"><span class="comment">     * because it&#x27;s fresher in cache.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    i = Py_SIZE(ret) - shift;  <span class="comment">/* # digits after shift */</span></span><br><span class="line">    (<span class="type">void</span>)v_isub(ret-&gt;ob_digit + shift, i, t2-&gt;ob_digit, Py_SIZE(t2));</span><br><span class="line">    Py_DECREF(t2);</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>)v_isub(ret-&gt;ob_digit + shift, i, t1-&gt;ob_digit, Py_SIZE(t1));</span><br><span class="line">    Py_DECREF(t1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 6. t3 &lt;- (ah+al)(bh+bl), and add into result. */</span></span><br><span class="line">    <span class="keyword">if</span> ((t1 = x_add(ah, al)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> fail;</span><br><span class="line">    Py_DECREF(ah);</span><br><span class="line">    Py_DECREF(al);</span><br><span class="line">    ah = al = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        t2 = t1;</span><br><span class="line">        Py_INCREF(t2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((t2 = x_add(bh, bl)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(t1);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(bh);</span><br><span class="line">    Py_DECREF(bl);</span><br><span class="line">    bh = bl = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    t3 = k_mul(t1, t2);</span><br><span class="line">    Py_DECREF(t1);</span><br><span class="line">    Py_DECREF(t2);</span><br><span class="line">    <span class="keyword">if</span> (t3 == <span class="literal">NULL</span>) <span class="keyword">goto</span> fail;</span><br><span class="line">    assert(Py_SIZE(t3) &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add t3.  It&#x27;s not obvious why we can&#x27;t run out of room here.</span></span><br><span class="line"><span class="comment">     * See the (*) comment after this function.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    (<span class="type">void</span>)v_iadd(ret-&gt;ob_digit + shift, i, t3-&gt;ob_digit, Py_SIZE(t3));</span><br><span class="line">    Py_DECREF(t3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> long_normalize(ret);</span><br><span class="line"></span><br><span class="line">  fail:</span><br><span class="line">    Py_XDECREF(ret);</span><br><span class="line">    Py_XDECREF(ah);</span><br><span class="line">    Py_XDECREF(al);</span><br><span class="line">    Py_XDECREF(bh);</span><br><span class="line">    Py_XDECREF(bl);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不对 <strong>Karatsuba 算法</strong><a href="#refer-anchor-1"><sup>1</sup></a> 的实现做单独解释，有兴趣的朋友可以参考文末的 reference 去了解具体的详情。</p><p>在普通情况下，普通乘法的时间复杂度位 n^2 (n 为位数），而 K 算法的时间复杂度为 3n^(log3) ≈ 3n^1.585 ，看起来 K 算法的性能要优于普通乘法，那么为什么 Python 不全部使用 K 算法呢？</p><p>很简单，K 算法的优势实际上要在当 n 足够大的时候，才会对普通乘法形成优势。同时考虑到内存访问等因素，当 n 不够大时，实际上采用 K 算法的性能将差于直接进行乘法。</p><p>所以我们来看看 Python 中乘法的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">long_mul</span><span class="params">(PyLongObject *a, PyLongObject *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    PyLongObject *z;</span><br><span class="line"></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fast path for single-digit multiplication */</span></span><br><span class="line">    <span class="keyword">if</span> (Py_ABS(Py_SIZE(a)) &lt;= <span class="number">1</span> &amp;&amp; Py_ABS(Py_SIZE(b)) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        stwodigits v = (stwodigits)(MEDIUM_VALUE(a)) * MEDIUM_VALUE(b);</span><br><span class="line">        <span class="keyword">return</span> PyLong_FromLongLong((<span class="type">long</span> <span class="type">long</span>)v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z = k_mul(a, b);</span><br><span class="line">    <span class="comment">/* Negate if exactly one of the inputs is negative. */</span></span><br><span class="line">    <span class="keyword">if</span> (((Py_SIZE(a) ^ Py_SIZE(b)) &lt; <span class="number">0</span>) &amp;&amp; z) &#123;</span><br><span class="line">        _PyLong_Negate(&amp;z);</span><br><span class="line">        <span class="keyword">if</span> (z == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们看到，当两个数皆小于 2^30-1 时，Python 将直接使用普通乘法并返回，否则将使用 K 算法进行计算</p><p>这个时候，我们来看一下位运算的实现，以右移为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static PyObject *</span><br><span class="line">long_rshift(PyObject *a, PyObject *b)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t wordshift;</span><br><span class="line">    digit remshift;</span><br><span class="line"></span><br><span class="line">    CHECK_BINOP(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(b) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_ValueError, <span class="string">&quot;negative shift count&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> PyLong_FromLong(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (divmod_shift(b, &amp;wordshift, &amp;remshift) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> NULL;</span><br><span class="line">    <span class="keyword">return</span> long_rshift1((PyLongObject *)a, wordshift, remshift);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static PyObject *</span><br><span class="line">long_rshift1(PyLongObject *a, Py_ssize_t wordshift, digit remshift)</span><br><span class="line">&#123;</span><br><span class="line">    PyLongObject *z = NULL;</span><br><span class="line">    Py_ssize_t newsize, hishift, i, j;</span><br><span class="line">    digit lomask, himask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        /* Right shifting negative numbers <span class="keyword">is</span> harder */</span><br><span class="line">        PyLongObject *a1, *a2;</span><br><span class="line">        a1 = (PyLongObject *) long_invert(a);</span><br><span class="line">        <span class="keyword">if</span> (a1 == NULL)</span><br><span class="line">            <span class="keyword">return</span> NULL;</span><br><span class="line">        a2 = (PyLongObject *) long_rshift1(a1, wordshift, remshift);</span><br><span class="line">        Py_DECREF(a1);</span><br><span class="line">        <span class="keyword">if</span> (a2 == NULL)</span><br><span class="line">            <span class="keyword">return</span> NULL;</span><br><span class="line">        z = (PyLongObject *) long_invert(a2);</span><br><span class="line">        Py_DECREF(a2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        newsize = Py_SIZE(a) - wordshift;</span><br><span class="line">        <span class="keyword">if</span> (newsize &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> PyLong_FromLong(<span class="number">0</span>);</span><br><span class="line">        hishift = PyLong_SHIFT - remshift;</span><br><span class="line">        lomask = ((digit)<span class="number">1</span> &lt;&lt; hishift) - <span class="number">1</span>;</span><br><span class="line">        himask = PyLong_MASK ^ lomask;</span><br><span class="line">        z = _PyLong_New(newsize);</span><br><span class="line">        <span class="keyword">if</span> (z == NULL)</span><br><span class="line">            <span class="keyword">return</span> NULL;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, j = wordshift; i &lt; newsize; i++, j++) &#123;</span><br><span class="line">            z-&gt;ob_digit[i] = (a-&gt;ob_digit[j] &gt;&gt; remshift) &amp; lomask;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; newsize)</span><br><span class="line">                z-&gt;ob_digit[i] |= (a-&gt;ob_digit[j+<span class="number">1</span>] &lt;&lt; hishift) &amp; himask;</span><br><span class="line">        &#125;</span><br><span class="line">        z = maybe_small_long(long_normalize(z));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们能看到，在两侧都是小数的情况下，位移动算法将比普通乘法，存在更多的内存分配等操作。这样也会回答了我们文初所提到的一个问题，“为什么一些时候乘法比位运算更快”。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文差不多就到这里了，实际上通过这次分析我们能得到一些很有趣但是也很冷门的知识。实际上我们目前看到这样一个结果，是 Python 对于我们常见且高频的操作所做的一个特定的设计。而这也提醒我们，Python 实际上对于很多操作都存在自己内建的设计哲学，在日常使用的时候，其余语言的经验，可能无法复用</p><p>差不多就这样吧，只能勉强写水文苟活了（逃</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="refer-anchor-1"></div><ul><li>[1]. <a href="https://zh.wikipedia.org/wiki/Karatsuba%E7%AE%97%E6%B3%95">Karatsuba 算法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单聊聊进程中的信号处理</title>
      <link href="//posts/2020/10/24/a-simple-introduction-about-signal-process-in-linux/"/>
      <url>//posts/2020/10/24/a-simple-introduction-about-signal-process-in-linux/</url>
      
        <content type="html"><![CDATA[<p>最近在某个技术群里帮人分析了 Linux 编程下信号处理的一段代码。我自己觉得这段代码是挺不错的一个例子，所以写个简单的水文，用这段代码聊聊 Linux 中的信号处理</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我们首先来看一看这一段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deletejob</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;delete task %d\n&quot;</span>, pid); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addjob</span><span class="params">(<span class="type">pid_t</span> pid)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;add task %d\n&quot;</span>, pid); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="type">int</span> olderrno = errno;</span><br><span class="line">  <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  sigfillset(&amp;mask_all);</span><br><span class="line">  <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">    deletejob(pid);</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (errno != ECHILD) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;waitpid error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  errno = olderrno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  <span class="type">sigset_t</span> mask_all, prev_all;</span><br><span class="line">  sigfillset(&amp;mask_all);</span><br><span class="line">  signal(SIGCHLD, handler);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">      execve(<span class="string">&quot;/bin/date&quot;</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask_all, &amp;prev_all);</span><br><span class="line">    addjob(pid);</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;prev_all, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这段代码是比较典型的信号处理的代码，为了引出后续的内容，我们先来复习一下，这段代码中几个关键的 <code>syscall</code> </p><ol><li><strong>signal</strong><a href="#refer-anchor-1"><sup>1</sup></a>: 信号处理函数，使用者可以通过这个函数为当前进程指定具体信号的 Handler。当信号触发时，系统会调用具体的 Handler 进行对应的逻辑处理。</li><li><strong>sigfillset</strong><a href="#refer-anchor-2"><sup>2</sup></a>: 用于操作 <strong>signal sets</strong>（信号集）的函数之一，这里的含义是将系统所有支持的信号量添加进一个信号集中</li><li><strong>fork</strong><a href="#refer-anchor-3"><sup>3</sup></a>: 大家比较熟悉的一个 API 了，创建一个新的进程，并返回 <strong>pid</strong> 。如果是在父进程中，返回的 <strong>pid</strong> 是对应子进程的 <strong>pid</strong>。如果子进程中，<strong>pid</strong> 为0</li><li><strong>execve</strong><a href="#refer-anchor-4"><sup>4</sup></a>: 执行一个特定的可执行文件</li><li><strong>sigprocmask</strong><a href="#refer-anchor-5"><sup>5</sup></a>：设置进程的信号屏蔽集。当传入第一个参数为 <strong>SIG_BLOCK</strong> 时，函数会将当前进程的信号屏蔽集保存在第三个参数传入的信号集变量中，并将当前进程的信号屏蔽集设置为第二个参数传入的信号屏蔽集。当第一个参数为 <strong>SIG_SETMASK</strong> 时，函数会将当前进程的信号屏蔽集设置为第二个参数设置的值。</li><li><strong>wait_pid</strong><a href="#refer-anchor-6"><sup>6</sup></a>: 做一个不精确的概括，回收并释放已终止的子进程的资源。</li></ol><p>OK 了解完这样一些关键的 <strong>syscall</strong> 后，这段代码那么基本上不难理解了。但是要吃透这段代码，我们还需要去复习一下一些 Linux 或者说 POSIX 中的机制：</p><ol><li>由 <code>fork</code> 创建出来的子进程，会继承父进程中的很多东西。就本文中聊的信号一部分来说，子进程会继承父进程的信号屏蔽集和信号处理函数的相关设置</li><li><code>execve</code> 执行后，会重设当前进程的程序段与堆栈。所以在上面的代码中我们执行 <code>/bin/date</code> 后，子进程会被重设。信号处理函数等设置也会被重设</li><li>每个进程都有信号屏蔽集，在信号屏蔽集中的信号被触发时，会进入一个队列，暂时不会触发进程的信号处理，此时信号处于 <strong>pending</strong> 状态。在取消对应信号的屏蔽与阻塞后，再次触发进程的信号处理机制。如果进程显式声明忽略信号，那么不会触发信号的处理。（Tips：关于信号队列这一点，这是一个 POSIX 1. 的约定。在 POSIX 中将这种机制称为<strong>可靠信号</strong>，当阻塞期间，有多个信号发生时，会进入一个可靠队列确保信号能被妥投。 Linux 支持可靠信号，其余 Unix/类 Unix 不一定支持）</li><li>子进程退出后，会给所属的父进程传递一个 <strong>SIGCHLD</strong><a href="#refer-anchor-1"><sup>1</sup></a> 信号，父进程在接受到这种信号后，需要调用 <strong>wait_pid</strong><a href="#refer-anchor-6"><sup>6</sup></a> 函数对子进程进行处理。否则未被回收的子进程，会成为一个僵尸进程，也就是通常说的 Z 进程</li></ol><p>OK，到现在，大家在掌握这些东西后，对于上面的代码应该能完整明白了。不过可能大家还有一个疑惑，为什么在这段代码中需要调用 <strong>sigprocmask</strong><a href="#refer-anchor-5"><sup>5</sup></a> 设置进程的信号屏蔽集来阻塞信号呢？这涉及到另一个问题。</p><p>如前面所说，信号在触发时，进程会”跳转“对应的信号处理函数进行处理。但是信号处理函数处理完后的行为会怎么样呢？依照 Linux 中的设计，可能会出现两种情况</p><ol><li>对于可重入函数而言，信号处理函数返回后会继续处理</li><li>对于不可重入函数而言，会返回 <strong>EINTR</strong><a href="#refer-anchor-1"><sup>1</sup></a></li></ol><p>OK 大家这里应该对我们为什么会在这里使用 <strong>sigprocmask</strong><a href="#refer-anchor-5"><sup>5</sup></a> 有具体的了解了，实际上是为了保证我们的一些函数能够正常的执行完，不会被信号处理所打断。当然这里也有其余的问题，如果信号触发特别密集的情况下，这里的处理会带来额外的 cost。所以还是需要根据不同的场景做 trade-off 了。</p><p>好了。差不多就这样吧，福报久了真没力气写文章，💊。下一篇文章应该就是我最近做内核协议栈监控的一些吃屎记录了（flag++（逃。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="refer-anchor-1"></div><ul><li>[1]. <a href="https://man7.org/linux/man-pages/man7/signal.7.html">Linux man page: signal</a></li></ul><div id="refer-anchor-2"></div><ul><li>[2]. <a href="https://linux.die.net/man/3/sigfillset">Linux man page: sigfillset</a></li></ul><div id="refer-anchor-3"></div><ul><li>[3]. <a href="https://man7.org/linux/man-pages/man2/fork.2.html">Linux man page: fork</a></li></ul><div id="refer-anchor-4"></div><ul><li>[4]. <a href="https://man7.org/linux/man-pages/man2/execve.2.html">Linux man page: execve</a></li></ul><div id="refer-anchor-5"></div><ul><li>[5]. <a href="https://man7.org/linux/man-pages/man2/sigprocmask.2.html">Linux man page: sigprocmask</a></li></ul><div id="refer-anchor-6"></div><ul><li>[6]. <a href="https://linux.die.net/man/2/waitpid">Linux man page: waitpid</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 水文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Kubernetes 和容器化的一些随想</title>
      <link href="//posts/2020/06/29/some-tips-about-kubernetes-and-container/"/>
      <url>//posts/2020/06/29/some-tips-about-kubernetes-and-container/</url>
      
        <content type="html"><![CDATA[<p>这段时间在不少群里争论过关于 Kubernetes 和容器化的一些事，干脆总结下一些碎碎念作为一个概括吧。本文仅代表个人立场，不代表商业观点</p><span id="more"></span><h2 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h2><p>目前很主流的一个观点，是能上容器尽可能上容器，说实话这个想法实际上是有一定的合理性的，去 review 这个想法，我们需要去看一下容器这个东西，给我们带来了什么样的改变</p><p>容器首先毫无疑问，会给我们带来非常多的好处：</p><ol><li>真正意义上让开发与生产环境保持一致是一种非常方便的事，换句话说，开发说的“这个服务在我本地没啥问题”是一句有用的话了</li><li>让部署一些服务变的更为方便，无论是分发，还是部署，</li><li>能做到一定程度上的资源隔离与分配</li></ol><p>那么，看起来我们是不是可以无脑用容器？不，不是，我们需要再来 Review 一下，容器化后我们所要面临的一些弊端：</p><ol><li>容器安全性问题，目前最主流的容器实现（此处点名 Docker）本质上而言还是基于 CGroups + NS 来进行资源与进程隔离。那么其安全性将会是一个非常值得考量的问题。毕竟 Docker 越权与逃逸漏洞年年有，年年新。那么这意味着我们是需要去有一个系统的机制去规范我们容器的使用，来保证相关的越权点能被把控在一个可控的范围内。而另一个方向是镜像安全问题，大家都是面向百度/CSDN/Google/Stackoverflow 编(fu)程(zhi)选手，那么势必会出现一个情况，当我们遇到一个问题，搜索一番，直接复制点 Dockerfile 下来，这个时候，将会存在很大的风险点，毕竟谁也不知道 base image 里加了啥料不是？</li><li>容器的网络问题。当我们启动若干个镜像后，那么容器之间的网络互通怎么处理？而大家生产环境，肯定不止一个机器那么少，那么跨主机的情况下，怎么样去进行容器间的通信，同时保证网络的稳定性？</li><li>容器的调度与运维的问题，当我一个机器高负载的时候，怎么样去将该机器上的一些容器调度到其余的机器上？而怎么样去探知一个容器是否存活？如果一个容器 crash 了，怎么样重新拉起？</li><li>容器具体的细节问题，比如镜像怎么样构建与打包？怎么样上传？乃至说怎么样去排查一些 corner case 的问题？</li></ol><p>我们做一个业务决策的时候，我们肯定不会是因为某个技术够先进，够舒服，而是需要去衡量这个业务决策的 ROI，同时在利弊之间做一个 Trade-Off，用容器化这件事来说吧，我们来思考下我们可能迁移容器常见的几个误区：</p><ol><li>我们想对利用容器做资源隔离！那么问题来了，用 systemd + cgroup 这样简便的方法做和容器之间有什么区别？是容器的成本更低？</li><li>我们想践行 Devops 所以想上容器化！实际上 Devops 和容器化关联并不算大，它更多的是一种方法论，一个团队之间内部协作的一套方法论。不精确的来讲，是通过自动化，流程改进，SOP 引入等手段，将一套服务的分发与运维更为简便化。换句话说，在我们去践行 Devops 这一套方法论的时候，实际上不是一个技术问题，而是一个制度问题（讲个笑话，Devops 的开发不需要写脚本）。在其中，无论是我们传统的 Ansible 等运维手段，还是一些自动化测试的方法与框架，都可以成为 Devops 的一部分。那么这里还是一个问题，我们为什么要用容器？是因为传统的工具践行 Devops 的 cost 远高于用容器化的？</li></ol><p>从这两个例子大家能看出来，当我们去做容器化这件事的时候，一定要思考的问题是，容器化是真正解决了我们什么痛点，还是只是因为它看起来够先进，够屌，能为我简历背书？</p><h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><p>前面聊到容器化的几个问题，促成了以 Kubernetes 为代表的容器编排体系的诞生。大家在想，哇，既然解决了这个问题，那么我们再来聊聊这个问题</p><p>首先我已经忽略掉自建 Kubernetes 集群的场景了，因为那不是一般人能 Hold 住的。那么我们来看一下，依托公有云使用的情况吧，以阿里云为例，点开页面，然后我们见到这样张图</p><p><img src="https://manjusakablog.blob.core.windows.net/blog-resource/images/2020-06-29-01.png" alt="images"></p><p><img src="https://manjusakablog.blob.core.windows.net/blog-resource/images/2020-06-29-02.png" alt="images"></p><p>好了，提问：</p><ol><li>VPC 是什么？</li><li>Kubernetes 1.16.9 和 1.14.8 有什么区别</li><li>Docker 19.03.5 和阿里云安全沙箱 1.1.0 是什么，有什么区别</li><li>专有网络是什么？</li><li>虚拟交换机是什么？</li><li>网络插件是什么？Flannel 和 Terway 又是什么？有什么区别？当你翻了翻文档，然后文档告诉你，Terway 是阿里云基于 Calico 魔改的 CNI 插件。那么 CNI 插件是什么？Calico 是什么？</li><li>Pod CIDR 是什么怎么设？</li><li>Service CIDR 是什么怎么设？</li><li>SNAT 是什么怎么设？</li><li>安全组怎么配置？</li><li>Kube-Proxy 是什么？iptables 和 IPVS 有什么区别？怎么选？</li></ol><p>是不是和你想象的一键点点点有很大区别？你可能说，我们小公司不管这些，暴力出奇迹，一键全默认。。。。emmmm，那上什么 Kubernetes 啊。。好了，假设你上了后，来，我们继续算账</p><ol><li>你得有个镜像仓库吧，不贵，中国区基础版780一个月</li><li>你集群内的服务需要暴露出去用吧？行叭，买个最低规格的 SLB，简约型，每个月200</li><li>好了，你每个月日志得花钱吧？假设你每个月20G日志，不多吧？行，39.1</li><li>你集群监控要不要？好，买，每天50w条日志上报吧？行，不贵，975 一个月</li></ol><p>算一下，一个集群吧，(780+200+39.1+975)*12=23292.2 不算集群基础的 ENI，ECS 等费用，美滋滋</p><p>而且会衍生很多其余的问题，具体的话，大家可以去 Kubernetes 的 Issue 区看一下盛况</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写这个文章，并不为吐槽或者喷人，只是想表明一个观点，借用我比较喜欢的一篇文章<a href="https://mp.weixin.qq.com/s/9j3BnR3UqA-lnJDoM5Hrvg">中台，我信了你的邪 | 深氪</a> 中的一句话</p><blockquote><p>到了去年底，阿里巴巴董事长兼CEO张勇在湖畔大学分享时也说：如果一个企业奔着中台做中台，就是死。</p></blockquote><p>逍遥子是不是说过这句话待考，但我很赞同，同时我认为<strong>一个企业奔着技术先进性去搞技术，就是死</strong> ，毕竟技术是需要为业务服务的，而技术的进步很大程度上依赖业务的沉淀与需求</p><p>好了，这应该是我写过最水的文章了，先这样吧。继续搬砖了</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 水文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 水文 </tag>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单聊聊 Maglev ，来自 Google 的软负载均衡实践</title>
      <link href="//posts/2020/05/22/a-simple-introduction-about-maglev/"/>
      <url>//posts/2020/05/22/a-simple-introduction-about-maglev/</url>
      
        <content type="html"><![CDATA[<p>好久没博客了，来写个简单的读论文笔记吧，这篇文章是来自 Google 2016 年发表的一篇论文 <a href="https://research.google/pubs/pub44824/">Maglev: A Fast and Reliable Software Network Load Balancer</a> 分享了他们内部从08年开始大规模使用的软负载均衡系统的实现。里面很多很有趣的细节，我看我能写多少，算多少吧<br><span id="more"></span></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>负载均衡的概念大家肯定都比较熟悉了，再次不再赘述。现在我们需要考虑 Google 的场景。设计之初，Google 需要一种高性能的 LB 来承担 Google 一些重头服务的流量，比如 Google 搜索，Gmail 等等。由于流量非常庞大，那么 LB 需要非常强大的性能来处理大量的流量。</p><p>在这里，传统的想法可能说，我直接上专业的硬件负载均衡，能用钱解决的问题，都不算事（笑。但是这样的方案有着不小的问题</p><p><img src="https://user-images.githubusercontent.com/7054676/82123782-c9537080-97cd-11ea-9030-4af01358be9d.png" alt="image"></p><ol><li>硬件负载均衡单点的性能决定了整个网络能承担的请求</li><li>在 HA 上存在缺陷。为了保证单点失效的时候，整个网络集群不陷入瘫痪。那么我们通常需要 1:1 的做冗余</li><li>灵活性和编程性欠缺，想做骚操作的时候没有切入点</li><li>太贵了。贵到 Google 都承受不了（逃</li></ol><p>在这样一种情况下，Google 开始考虑自行构建一种 SLB (Software Load Balance) 系统。去构建这样一种系统。好处也很明显。比如方便的 Scale ，为了保证 HA 所需的冗余从之前的 1:1 可以降至 N+1 ，方便的定制性等。架构就演变成下图了</p><p><img src="https://user-images.githubusercontent.com/7054676/82126035-7c2acb00-97dc-11ea-9f65-8aa4f29b34ea.png" alt="image"></p><p>但是挑战也很明显。首先需要有足够的性能，这样保证集群有足够的吞吐。同时需要做 connection tracking ，这样保证同一个连接的数据包能妥投到同一个机器上。也许要保证能有透明的 failover 的能力。</p><p>这样一些要件结合起来，这也就是我们今天要聊的 Maglev。Google 从 08 年开始大规模的应用的 LB 系统</p><h2 id="Maglev-初窥"><a href="#Maglev-初窥" class="headerlink" title="Maglev 初窥"></a>Maglev 初窥</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>在继续聊 Maglev 之前，我们需要去了解 Google 现在怎么样去去使用 Maglev 的，下面是一个简化后的示意图</p><p><img src="https://user-images.githubusercontent.com/7054676/82126042-8c42aa80-97dc-11ea-8647-767d5e63dda8.png" alt="image"></p><p>同时这里我们需要介绍一个很重要的概念叫做 VIP(Virtual IP Address) 。 用过 Kubernetes 的同学肯定对这个概念并不陌生。VIP 并不是一个实际与网卡绑定的物理 IP。近似来讲它可以作为后端一组 Endpoint 的抽象，当你访问这个 VIP 的时候，实际上是在访问后端的 Endpoint 。这里举个更方便理解的例子，以 Kubernetes 为例，我们在创建完一组 Pod 后，为了暴露 Pod 中提供的服务，我们通常会创建一个 Service 来关联对应的 Pod。Service 通常会有一个 IP，那么这个 IP 就是一个 VIP 。当我们访问 Service 的 IP 的时候，通常会随机从后面的 Pod 中选择一个承接请求。</p><p>好了，回到 Maglev ，我们现在来看下整个的一个流程。Maglev 会和 VIP 关联，然后将 VIP 透传给一组 Router。 当用户在浏览器中输入 <a href="https://www.google.com">https://www.google.com</a> 并按下回车的时候，浏览器会进行 DNS 解析。而 DNS 解析将由 Google 的 DNS 服务器进行处理。DNS 服务器会根据用户的区域选择一个最近集群的 VIP 返回给用户，然后浏览器会根据获取到的 VIP 建立连接。</p><p>当 Router 收到对应包时，会将包转发给 VIP 所属的 Maglev 集群中的任意节点。集群中的每个节点权重都是平衡。Maglev 节点在接受到包的时候，会利用 GRE(Generic Routing Encapsulation) 进行封包。然后传输给对应的后端端点。</p><p>当后端端点接收到数据包的时候，会进行接包并处理请求。当响应数据准备就绪的时候，会进行封包操作，会将 VIP 的作为源地址，用户的 IP 作为目标地址，然后响应数据作为数据包操作。这个时候，后端端点会利用 DSR(Direct Server Return) 将数据包绕过 Maglev 直接返回。这样避免响应过大的时候对 Maglev 造成额外的负担。实际上 DSR 在 L4 的 LB 实现，如 HAProxy，Envoy 等都得到了比较多的应用。改天有时间写篇博客来聊聊。</p><h3 id="Maglev-配置"><a href="#Maglev-配置" class="headerlink" title="Maglev 配置"></a>Maglev 配置</h3><p>如前面所说， Maglev 接收来自 Router 的 VIP 请求，然后将对应流量转发到对应的后端端点上。每个 Maglev 将由 Controller 和 Forwarder 组成，其架构如下所示</p><p><img src="https://user-images.githubusercontent.com/7054676/82127700-3d9b0d80-97e8-11ea-8cc3-8a6f5b1ccd3e.png" alt="image"></p><p>而 Controller 和 Forwarder 都利用 Configuration Object 管理相关 VIP。Configuration Object 这一套实际上又是另外一套系统（可以近似的认为是注册中心），彼此之间通过 RPC 来通信。</p><p>在 Maglev 机器上，Controller 会定期对 Forwarder 进行检查。根据检查结果来确定是否通过 BGP 提交/撤回所有 VIP 的注册（要么全部成功，要么全部失败，其实还是为了保障系统的一致性）。这样确保从 Router 过来的流量都能扔到健康的机器上</p><p>而从 Router 过来的 VIP 流量将会由 Forwarder 进行处理。在 Forwarder 中，每个 VIP 都会和一个或多个 backend pool 关联。除非特殊处理，Maglev 中的 backend 都是服务端点。一个 backend pool 可以包含一组服务端点的的物理 IP ，也可以是其余的 backend pool。每个 backend pool 都会根据其特定需求，设计若干个监控检查器，数据包只会转发给健康的服务。如之前所说，同一个服务可能会被包含在多个 backend pool 中，因此 Forwarder 将会根据具体的地址进行去重，避免额外的开销。</p><p>Forwarder 的 Config Manager 将负责从 Configuration Object 中拉取，解析并验证相关的配置。所有配置的提交都是具备原子性（要么全部成功，要么全部失败）。在推送和解析到生效的过程中，存在一个非常短暂的 gap，在此期间，一个 Maglev 集群之间的配置可能存在不同步的情况。不过因为一致性 Hash 的存在，在这个非常短的 Gap 内，大部分请求还是能成功妥投。</p><h2 id="Maglev-实现"><a href="#Maglev-实现" class="headerlink" title="Maglev 实现"></a>Maglev 实现</h2><p>好了，扯了这么多，来看一下 Maglev 整个系统的一些实践细节</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>总所周知（如前面所说），Maglev 由 Forwarder 来实际承担流量相关的转发工作，我们用一张图来说明一下它的结构</p><p><img src="https://user-images.githubusercontent.com/7054676/82140858-7082e700-9864-11ea-9653-a5e8ba9b5d97.png" alt="image"></p><p>Forwarder 将直接从 NIC(Network Interface Card) 拿到数据包，然后直接扔入 NIC 转发到后端。期间所有操作都不会过内核（实际上过内核会有额外的 cost）</p><p>从 NIC 中捞出的包，会先由 <code>Steering Module</code> 进行处理，在处理过程中，<code>Steering Module</code> 将会根据五元组（协议，目标地址，目标端口，源地址，源端口）进行 hash 计算。然后将其转入对应的 <code>Receiving Queue</code> 中。每个 <code>Receiving Queue</code> 都会对应一个处理线程。处理线程将过滤掉目标 VIP 和本机注册 VIP 不匹配的包。然后会重新计算五元组 hash，然后从 <code>Connection Tracking Table</code> 中查找对应的值。</p><p>在 <code>Connection Tracking Table</code> 中存放之前五元组 Hash 所对应的 Backend，然后如果查找命中，那么直接复用，如果未命中，则为这个包选择一个新的 Backend, 然后将键值对加入 <code>Connection Tracking Table</code>。如果此时没有 Backend 可用，那么这个包会被丢弃。当这个包完成查找操作后，如前面所说，会改写这个包，然后将其放入 <code>transmission queue</code> 中去。最后将 <code>muxing module</code> 会将 <code>transmission queue</code> 的包直接通过 NIC 发送出去。</p><p>这里有个问题，在 <code>Steering Module</code> 中为啥不考虑根据 <code>round-robin</code> 这种常见的策略来做？大家都知道每个线程的处理速度是不一致的，如果直接裸 <code>round-robin</code> ，那么面对这种情况，可能会导致数据包重排的情况发生，如果是引入权重的概念来改良，又会引入新的复杂度，毕竟线程的处理速度是动态变化的。另外一种是 <code>connnection tracking</code> 的情况，假设我们有个需要持久化的连接，我们需要保证每个包都能扔到同样的机器上，这个时候用 <code>round-robin</code> 就会引入额外的复杂性。不过对于一些特殊情况，比如 <code>receive queue</code> 满了，一致性 Hash 处理不过来的时候，我们会利用 <code>round-robin</code> 作为 backup 的手段来替代一致性 Hash，这种情况对于同时存在同样5元组包的时候比较好用。</p><h3 id="高效处理数据包"><a href="#高效处理数据包" class="headerlink" title="高效处理数据包"></a>高效处理数据包</h3><p>前面已经花了很多时间讲述了，Maglev 是直接对 TCP 的数据包进行操作，同时因为 Google 的流量极为庞大，那么这个时候实际上是需要 Maglev 有着良好的转发性能。不然在大规模场景下，其吞吐能力会无法满足需求。Google 怎么做的？答：直接对网卡操作。。</p><p>我们都知道在 Linux 中进行网络编程的时候，将数据包从内核态拷贝到用户态实际上是一件开销非常大的事，所以对于一些极端需求性能的场景，如 L4 的负载均衡等，大家可能更倾向于将东西做到内核里，避免跨态拷贝。这也是 LVS 等工具的思路。但是实际上对于更大规模的流量，来讲，从网卡到内核，经过内核中的一堆 filter 处理也是一件开销非常大的事，而如同前面所说，Maglev 只依赖数据包中的五元组，对于包序列号，包 payload ，都不需要关心。于是 Google：我有一个大胆的想法！好了，来看张图</p><p><img src="https://user-images.githubusercontent.com/7054676/82677245-4bceab00-9c7a-11ea-9d30-68f948b32f9a.png" alt="image"></p><p>Google 选择直接在 NIC (即网卡) 上进行编程。让 <code>Forwarder</code> 和 NIC 共享一片内存。内存中维护的是一个环状的数据包池子。然后 <code>Forwarder</code> 中的 <code>steering module</code> 和 <code>muxing module</code> 各自维护三个指针来处理这些数据包，下面详细描述一下</p><p>首先而言 <code>steering module</code> 维护了三个指针</p><ol><li><code>received</code> ，管理接收数据包</li><li><code>reserved</code>, 管理已接收未处理的数据包</li><li><code>processed</code>, 管理处理完成的数据包</li></ol><p>那么流程是这样的，当 NIC 接受到新的数据包后，那么 <code>received</code> 指针指向的内存会被修改。然后当一个数据包被分发给线程完成相关操作后，那么 <code>processed</code> 指针指向的内存地址会被修改。因为是个环状结构嘛， <code>received</code> 和 <code>processed</code> 中间存在的数据包就是已接收但未完成处理的包，由 <code>reserved</code> 指针进行管理。</p><p>于此对应的，<code>muxing module</code> 也维护了三个指针</p><ol><li><code>sent</code>，管理已发送完毕的数据包</li><li><code>ready</code>，管理已经就绪等待发送的数据包</li><li><code>recycled</code>, 管理已回收的数据包</li></ol><p>那么对应的流程是这样的，当 <code>steering module</code> 完成相关包的处理的时候，<code>ready</code> 指针指向的内存会被修改，然后等待发送。当一个数据包发送后，<code>sent</code> 指向的内存地址被修改。在 <code>ready</code> 和 <code>sent</code> 之外有另一个状态 <code>recycled</code> 管理已经回收的数据包。</p><p>我们可以看到在这个过程中，没有发生数据拷贝的操作，实际上这减小了一部分复制数据带来的时延。不过这种方法存在的问题就是，当指针越界后，会带来很大的额外开销。所以 Google 采用的做法是批处理，比如接收 3000 个小包集中处理一次，这样的骚操作</p><p>另外需要做一些额外的优化，比如包处理线程之间不共享数据以避免竞态。比如需要将线程与具体 CPU Core 绑定来保证性能等等</p><p>目前来看，Google 这一套的做法效率非常的出色，平均每个包的处理只需要 300 ns($10^{-9}$s)。如同前面所说，Google 采用批处理的方式来处理包，这样的问题是每当一些例如硬件中断的情况发生的时候，可能到达处理阈值的时间会比大部分情况长很多，所以 Google 设计了一个 50μs($10^{-6}$s) 的 Timer 来处理这种情况。换句话说，当因为硬件或者其余问题时，整体的包处理时长可能会增加 50μs 的时间（其实这里感觉 Google 怎么是在得瑟，你看我们性能超棒的噢，只有硬件是我们的瓶颈喔（逃</p><h3 id="后端选择"><a href="#后端选择" class="headerlink" title="后端选择"></a>后端选择</h3><p>如同前面所说的一样，<code>Forwarder</code> 会为数据包选择一个后端。对于 TCP 这种常见来说，将相同五元组的数据包转发到同一个后端节点上非常重要。Google 采取在 Maglev 中维护一个 <code>connction tracking table</code> 来解决这个问题。当一个包抵达的时候，Maglev 会计算其五元组 Hash ，然后确定在 table 中是否存在，如果不存在，则选择一个节点作为后端，然后将记录值添加到 table 中。如果存在则直接复用</p><p>这样看起来没有问题了对吧？Google：不，不是，还有问题！</p><p>我们首先考虑这样一种场景：如前面所说，Maglev 前面挂了一个/组 Router，而 Router 是不提供连接亲和的，即不保证把同一个连接的包发送到同一个机器上。所以可能存在的情况是同一个连接的不同数据包会被仍在不同的机器上。再比如，我们假设 Router 是具有连接亲和的，但是也会存在如果机器发生重启后，<code>connection tracking table</code> 被清空的情况。</p><p>再来一个例子，我们都知道 <code>connection tracking table</code> 它所能使用的内存，必定是有一个阈值的。这样在面对一些流量非常大，或者 <code>SYN Flood</code> 这种非正常情景的时候。当 <code>connection tracking table</code> 的容量到达阈值的时候，我们势必会清理一些数据。那么在这个时候，一个连接的 tracking 信息就很有可能被清理。那么在这种情况下，我们怎么样去做 <code>connection tracking</code> ？</p><p>Google 选择的做法是引入一致性 Hash</p><h3 id="一致性-Hash：Maglev-Hash"><a href="#一致性-Hash：Maglev-Hash" class="headerlink" title="一致性 Hash：Maglev Hash"></a>一致性 Hash：Maglev Hash</h3><p>整体算法其实有很多细节，这里只说明大概，具体细节大家可以去阅读原文查找</p><p>首先，我们要确定经过预处理后的产物 <code>lookup table</code> 的长度 M。所有 Key 都会被 hash 到这个 <code>lookup table</code> 中去，而 <code>lookup table</code> 中的每个元素都会被映射到一个 Node 上</p><p>而计算 <code>lookup table</code> 的计算分为两步</p><ol><li>计算每一个 node 对于每一个 lookup table 项的一个取值（也就是原文中提到的 permutation）；</li><li>根据这个值，去计算每一个 lookup table 项所映射到的 node（放在 entry 中，此处 entry 用原文的话来讲就是叫做 <code>the final lookup table</code>）。</li></ol><p>permutation 是一个 M×N 的矩阵，列对应 lookup table，行对应 node。 为了计算 permutation，需要挑选两个 hash 算法，分别计算两个值 offset 与 skip 。最后根据 offset 和 skip 的值来填充 permutation，计算方式描述如下：</p><ol><li>offset ← h 1 (name[i]) mod M</li><li>skip ← h 2 (name[i]) mod (M − 1)+ 1</li><li>permutation[i][j] ← (offset+ j × skip) mod M</li></ol><p>其中 i 是 Node Table 中 Node 的下标，j 是 lookup table 下标</p><p>在计算完 permutation 后，我们就可以计算最后的 lookup table 了，这个 table 用一维的数组表示</p><p><img src="https://user-images.githubusercontent.com/7054676/82696622-f73b2800-9c99-11ea-8d14-08f67487f3b9.png" alt="image"></p><p>这里贴一张图，大家可以配合下面的代码一起看一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据已经计算好的 permutation 来计算 lookup_table</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_lookup_table</span>(<span class="params">n: <span class="built_in">int</span>, m: <span class="built_in">int</span>, permutation: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># result 是最终记录分布的 Hash 表</span></span><br><span class="line">    result: <span class="type">List</span>[<span class="built_in">int</span>] = [-<span class="number">1</span>] * m</span><br><span class="line">    <span class="comment"># next 是用来解决冲突的，在遍历过程中突然想要填入的 entry 表已经被占用，</span></span><br><span class="line">    <span class="comment"># 则通过 next 找到下一行。一直进行该过程直到找到一个空位。</span></span><br><span class="line">    <span class="comment"># 因为每一列都包含有 0~M-1 的每一个值，所以最终肯定能遍历完每一行。</span></span><br><span class="line">    <span class="comment"># 计算复杂度为 O(M logM) ~ O(M^2)</span></span><br><span class="line">    <span class="built_in">next</span>: <span class="type">List</span>[<span class="built_in">int</span>] = [<span class="number">0</span>] * n</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            x = permutation[i][<span class="built_in">next</span>[i]]</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># 找到空位，退出查找</span></span><br><span class="line">                <span class="keyword">if</span> result[x] == -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="built_in">next</span>[i] += <span class="number">1</span></span><br><span class="line">                x = permutation[i][<span class="built_in">next</span>[i]]</span><br><span class="line">            result[x] = i</span><br><span class="line">            <span class="built_in">next</span>[i] += <span class="number">1</span></span><br><span class="line">            flag += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 表已经填满，退出计算</span></span><br><span class="line">            <span class="keyword">if</span> flag == m:</span><br><span class="line">                <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>在这里我们能看到，这段循环代码必然结束，而最坏情况下，复杂度会非常高，最坏的情况可能会到 O(M^2)。原文中建议找一个远大于 N 的 M （To avoid this happening we always choose M such that M ≫ N.）可以使平均复杂度维持在 O(MlogM)</p><p>而 Maglev 中 Google 自研的一致性算法性能怎么样呢？论文中也做了测试</p><p><img src="https://user-images.githubusercontent.com/7054676/82696955-abd54980-9c9a-11ea-8aa4-480ae328d387.png" alt="image"></p><p>可以看到，对于不同大小的 lookup table，Maglev 表现出了更好的均衡性</p><p>说实话，Maglev 在我看来本质上是一个带虚节点的 Hash，说实话，我没想到为什么 Google 不用 Dynamo 等已经比较成熟的 Hash ？难道是因为政策原因？（毕竟 Dynamo 是 AWS 家的嘛（逃。BTW Enovy 也实现了 Maglev 。参见 <a href="https://github.com/envoyproxy/envoy/issues/2267">Evaluate other consistent hash LB algorithms</a> ，而且引入了权重，实现的挺不错，有兴趣的同学可以去看看（逃</p><p>说实话，Maglev Hash 还有很多细节没有讲，不过实在懒得写了，，等后面出一个一致性 Hash 的分析博客吧，Flag++</p><h2 id="Maglev-优化"><a href="#Maglev-优化" class="headerlink" title="Maglev 优化"></a>Maglev 优化</h2><p>前面我们已经把 Maglev 这一套的基本原理讲的差不多了。但是如果作为一个生产上大规模使用的 LB ，那么势必还需要针对细节做很多优化，由于这里涉及到很多方面，我这里只简单介绍一下，剩下的还是建议大家直接去读原文</p><h3 id="分段数据包的处理"><a href="#分段数据包的处理" class="headerlink" title="分段数据包的处理"></a>分段数据包的处理</h3><p>熟悉网络的同学都知道，在基于 IP 协议传输报文的时候，受限于 MTU 的大小，在传输的时候，可能会存在数据分片传输的情况，而这些分片后的数据不一定会带有完整的五元组信息。比如一个数据被切分为两段，那么第一段将带有 L3 和 L4 的头部信息，而第二段只带有 L3 的信息。而在传输过程中，因为网络关系，Maglev 无法完全保证对接收到的数据作出正确的处理</p><p>这样问题就大了，因为数据分段的情况实际上是非常场景的。那么对于这样的场景，Maglev 应该怎么样去处理？首先我们需要确定怎么样才能保证所有数据都能妥投</p><ol><li>保证一个数据报文的不同数据段都需要由同一个 Maglev 实例处理</li><li>对于同一个数据报文的不同数据段需要能保证后端选择结果是一致的</li></ol><p>OK，那么我们来看看 Google 是怎么解决这个问题的。</p><p>首先，每个 Maglev 实例中都会有一个特殊的 <code>backend pool</code> ，池子中是该 Maglev 集群中所有的实例。当接收到数据后，Maglev 会先根据三元组（源地址，目标地址，协议簇）计算 hash ，然后选择一个 Maglev 实例进行转发，这样就能保证同一数据报文的不同分段能传输到同一个 Maglev 实例上。当然这里需要利用 GRE 的递归控制来避免无限循环。</p><p>好了我们来看看条件2怎么满足。在每个 Maglev 实例上会维护一个特殊的表，记录数据分片后第一个数据端的转发结果。以前面的例子为例，当一个报文的第二个分段抵达的时候，Maglev 会查询表中是否存在第一个数据段的转发结果。如果存在则直接转发，如果不存在，则将这个数据段缓存，直到第一个数据段抵达，或者到达超时阈值</p><h3 id="监控与调试"><a href="#监控与调试" class="headerlink" title="监控与调试"></a>监控与调试</h3><p>真正的用时都是不需要调试（划掉）（笑，Google 为了这一套系统设计了辅助的监控与调试手段来帮助日常的开发迭代。</p><p>在监控这边，分为黑盒和白盒两种监控手段。比如遍布全球的特定监控节点，以确认 VIP 的健康状态。当然与之配套的还有一整套白盒监控。Google 会监控具体的服务器指标，同时会监控 Maglev 本身的指标</p><p>当然与之配套的还有一些调试工具。比如 Google 开发了一套类似 X-Trace 的 packettracer。可以通过 packettracer 来发送一些带有特定标头和 payload 的信息。当 Maglev 接到这样一些特殊的数据包后，除了照常转发数据包以外，也会讲一些关键信息上报到指定位置</p><p>这其实也体现了软负载均衡相较于硬件负载均衡的一个好处，无论可调试性还是可迭代性都是硬件负载均衡无法媲美的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章其实我读了挺久，里面很多细节挺值得慢慢深究的，所以再次建议大家一定要去找原文读一下，非常不错。另外顺便推荐一篇文章，是美团技术团队的作品，他们也参考了 Maglev 来实现自己的高性能 L4 负载均衡，参见<a href="https://tech.meituan.com/2017/01/05/mgw.html">MGW——美团点评高性能四层负载均衡</a></p><p>好了，这篇文章，就先到这里吧，这篇文章应该是我写的最耗时的一篇文章了。。不过想想后面还有几篇文章要写，头就很大</p><p>溜了溜了</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 水文 </category>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 水文 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么 Python 的 Type Hint 没有流行起来</title>
      <link href="//posts/2020/03/20/a-simple-history-about-type-hint-in-python/"/>
      <url>//posts/2020/03/20/a-simple-history-about-type-hint-in-python/</url>
      
        <content type="html"><![CDATA[<p>在知乎上看到一个很有意思的问题，<a href="https://www.zhihu.com/question/370231112/answer/1091038983">为什么TypeScript如此流行，却少见有人写带类型标注的Python？</a></p><p>虽然我没忍住在知乎上输出了答案，但是为了以防万一，我在博客上扩展，与更新一下</p><p>BTW 最近上线真的心力憔悴，写个文章放松下</p><span id="more"></span><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>其实这个答案很简单，历史包袱与 ROI，在了解为什么有这样的现象之前，首先我们要去了解 Type Hint 能给我们带来什么，然后我们需要去了解 Type Hint 的前世今生</p><p>在现在这个时间点（2020.03）来看，Type Hint 能给我们带来肉眼可见的收益是</p><ol><li>通过 annotation ，配合 IDE 的支持，能让我们在代码编辑的时候的体验更好</li><li>通过 mypy/pytype 等工具的支持，我们能在 CI/CD 流程中去集成静态类型检查</li><li>通过 pydantic 以及很多新式框架的支持，我们能够减少很多重复的工作</li></ol><p>可能大家以为从 Python 3.5 引入 <a href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a> 开始，Python Type Hint 便已经成熟。但是实际上，这个时间比大家想象的短的多</p><p>好了，我们现在要去回顾一下整个 Type Hint 发展史上的关键节点</p><ol><li>PEP 3107 Function Annotations</li><li>PEP 484 Type Hints</li><li>PEP 526 Syntax for Variable Annotations</li><li>PEP 563 Postponed Evaluation of Annotations</li></ol><h3 id="PEP-3107"><a href="#PEP-3107" class="headerlink" title="PEP 3107"></a>PEP 3107</h3><p>如同前面所说，大家最开始认识 Type Hint 的时间应该是14 年 9 月提出，15 年 5 月通过的 <a href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a> 。但是实际上雏形早的多，PEP 484 的语法实际上来自于 06 年提出，3.0 引入的 PEP 3107 所设计的语法，参见 <a href="https://www.python.org/dev/peps/pep-3107/">PEP 3107 — Function Annotations</a></p><p>在 PEP 3107 中，对于这个提案的目标，有这样一段描述</p><blockquote><p>Because Python’s 2.x series lacks a standard way of annotating a function’s parameters and return values, a variety of tools and libraries have appeared to fill this gap. Some utilise the decorators introduced in “PEP 318”, while others parse a function’s docstring, looking for annotations there.<br>This PEP aims to provide a single, standard way of specifying this information, reducing the confusion caused by the wide variation in mechanism and syntax that has existed until this point.</p></blockquote><p>说人话就是，为了能够给函数的参数或者返回值添加额外的元信息，大家五花八门各显神通，有用 <a href="https://www.python.org/dev/peps/pep-0318/">PEP 318</a> 装饰器的，有用 docstring 来做的。社区为了缓解这个现象，决定推出新的语法糖，来让用户能够方便的为参数签名和返回值添加额外的信息</p><p>最后形成的语法如下 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a: <span class="string">&#x27;x&#x27;</span>, b: <span class="number">5</span> + <span class="number">6</span>, c: <span class="built_in">list</span></span>) -&gt; <span class="built_in">max</span>(<span class="number">2</span>, <span class="number">9</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>是不是很眼熟？ 没错，3107 实际上奠定了后续 Type Hint 的基调</p><ol><li>可标注</li><li>作为 function/method 信息的一部分，可 inspect</li><li>runtime</li></ol><p>但是新的疑惑就来了，为什么这个提案经常被人忽略？还是，我们需要放在具体的时间点来看</p><p>这个提案提出时间最早可以追溯至06年，在 <a href="https://www.python.org/dev/peps/pep-3000/">PEP3000</a> 这个可能是 Python 历史上最著名的提案（即宣告 Python 3 的诞生）中确定在 Python 3 中引入，08年正式发布</p><p>在这个时间点下，3107 面临着两个问题：</p><ol><li>在06-08这个时间点上，社区最主要的精力都在友(ji)好(lie)的讨(si)论(bi)，我们为什么要 Python 3？以及为什么我们要迁到 Python 3</li><li>3107 实际上只是告诉大家，你可以标注，你可以方便的获取标注信息，但是怎么样去抽象一个类型的表示，如一个 int 类型的 list ，这种事，还是依靠社区自行发展，换句话说，叫做放养</li></ol><p>问题1，无解，只能依靠时间去慢慢推动。问题2，促成了 PEP 484 的诞生</p><h3 id="PEP-484"><a href="#PEP-484" class="headerlink" title="PEP 484"></a>PEP 484</h3><p><a href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a> 这个提案大家应该都有一定程度上的了解了，在此不再描述提案的具体内容</p><p>PEP 484 最大的意义在于， 在继承了 PEP 3107 奠定的语法和基调之上，将 Python 的类型系统进行了合理的抽象，这也是重要的产物 <code>typing</code>，直到这时，Python 中的 type hint 才有了基本的官方规范，同时达到了基本的可用性，这个时间点是 15 年 9 月（9月13，Python 3.5.0 正式 Release）</p><p>但是实际上 PEP 484 在这个时间点也只能说基本满足使用，我来举几个被诟病的例子</p><p>首先看一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    left: <span class="type">Optional</span>[Node]</span><br><span class="line">    right: <span class="type">Optional</span>[Node]</span><br></pre></td></tr></table></figure><p>这段代码实际上很简单对吧，一个标准的二叉树节点的描述，但是放在 PEP 484 中，这段代码暴露出两个问题</p><ol><li>无法对变量进行标注。如同我前面所说的一样，PEP 484 本质上是 PEP 3107 的一个扩展，这个时候 hint 的范围仅限于 function/method ，而在上面的代码中，在 3.5 时期，我是无法对我的 left 和 right 的变量进行标注的，一个编程语言的基本要素之一的变量，无法被 Type Hint ，那么一定程度上我们可以说这样一个 type hint 的功能没有闭环</li><li>循环引用，字面意义，在社区/StackOverflow 上如何解决 Type Hint 中的循环引用这个问题，一度让人十分头大。社区：What the fuck?</li></ol><p>所幸，Python 社区意识到了这个问题，推出了两个提案来解决这样的问题</p><h3 id="PEP-526"><a href="#PEP-526" class="headerlink" title="PEP 526"></a>PEP 526</h3><p>问题1 促成了 <a href="https://www.python.org/dev/peps/pep-0526/">PEP 526 — Syntax for Variable Annotations</a> 的诞生，16 年 8 月提出，16 年 9 月被接受。16 年 9 月在 <a href="https://bugs.python.org/issue27985">BPO-27985</a> 实现。在我印象里，这应该是 Python 社区中数的出来的争议小，接收快，实现快的 PEP 了</p><p>在 526 中，Python 正式允许大家对变量进行标注，无论是 <code>class attribute</code> 还是普通的 <code>variable</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    left: <span class="built_in">str</span></span><br></pre></td></tr></table></figure><p>这样是可以的，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">abc</span>():</span><br><span class="line">    a:<span class="built_in">int</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这样也是可以的</p><p>在这个提案的基础上，Python 官方也推动了 <a href="https://www.python.org/dev/peps/pep-0557/">PEP 557 — Data Classes</a> 的落地，当然这是后话</p><p>话说回来，526 只解决了上面的问题1，没有解决问题2，这个事情，将会由 PEP 563 来解决</p><h3 id="PEP-563"><a href="#PEP-563" class="headerlink" title="PEP 563"></a>PEP 563</h3><p>为了解决循环引用的问题，Python 引入了 <a href="https://www.python.org/dev/peps/pep-0563/">PEP 563 — Postponed Evaluation of Annotations</a>，17 年 9 月社区提出，17 年 11 月被接受，18 年 1 月在 <a href="https://github.com/python/cpython/pull/4390">GH-4390</a> 中实现。</p><p>在 563 之后，我们上面的代码可以这么写了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    left: <span class="type">Optional</span>[<span class="string">&quot;Node&quot;</span>]</span><br><span class="line">    right: <span class="type">Optional</span>[<span class="string">&quot;Node&quot;</span>]</span><br></pre></td></tr></table></figure><p>嗯，484 中的两个问题，终于被解决了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以 PEP 563 作为重要分割点，Python 最早在 18 年 1 月之后才初步具备完整的生态和生产可用性，如果考虑 release version，那么应该是 18 年 6 月，Python 3.7 正式发布之后的事了。</p><p>在 Python 3.6/7 之后，社区也才开始围绕 Type Hint 去构建一套生态体系，</p><p>比如利用 PEP 526 来高效的验证数据格式，参见 <a href="https://github.com/samuelcolvin/pydantic">pydantic</a> </p><p>顺带一提，这货也是目前很火的一个新型框架（也是我目前最喜欢的一个框架）FastAPI 的根基</p><p>各大公司也开始跟进，例如 Google 的 <a href="https://github.com/google/pytype">pytype</a> ，微软推出了 <a href="https://github.com/microsoft/pyright">pyright</a> 来提供在 VSCode 上的支持</p><p>还有许许多多优秀的如 starlette 这样库</p><p>直到这时，Python + Type Hint 的真正的威力才开始挥发出来。这样才开始能回答大家这样一个问题：“我为什么要切换到 Type Hint”，我猜在 IDE 里写的爽肯定不是一个重要原因</p><p>要知道，我们在做技术决策时候，一定是因为这个决策能给我们带来足够的 benefit，换句话说，有足够的 ROI，而不是单纯的因为，我们喜欢它</p><p>这样看起来，到现在，满打满算一年半不超过两年的时间。对于一个用户习惯养成周期来说，这太短了。更何况还有一大堆的 Python 2 代码在那放着23333</p><p>话说回来，作为对比，TypeScript Release 时间可以上溯至 12 年 10 月，发布 0.8 版本，当时的 TS 应该是具备了相对完整地类型系统。</p><p>TS 用了 8 年，Python 可能也还有很长的路要走</p><p>当然，这个答案也只是从技术和历史的角度聊聊这个问题。至于其余的很多因素，包括社区的博奕与妥协等，暂还不在这个答案的范围内，大家有兴趣的话，可以去 python-idea，python-dev，discuss-python 这几个地方去找一找历史上关于这几个提案的讨论，非常有意思。</p><p>最后，TS 成功还有一个原因，它有个好爸爸&amp;&amp;它爸爸有钱（逃</p><p>嗯，差不多就这样吧，最近干活干的心里憔悴的我，也就只能写点垃圾水文了压压惊，平复心情了。。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单聊聊 MySQL 全文索引</title>
      <link href="//posts/2020/03/01/talk-about-full-text-search-in-mysql/"/>
      <url>//posts/2020/03/01/talk-about-full-text-search-in-mysql/</url>
      
        <content type="html"><![CDATA[<p>最近踩 MYSQL 中文本搜索的坑踩了挺多，来写个具体的文章总结下 MYSQL 中文本搜索的一些知识点吧</p><span id="more"></span><h2 id="模糊搜索"><a href="#模糊搜索" class="headerlink" title="模糊搜索"></a>模糊搜索</h2><p>在我们是使用 MYSQL 的过程中，总会有一些模糊搜索的需求，比如我们现在有这样一张表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> `<span class="keyword">user</span>`</span><br><span class="line">(</span><br><span class="line">    `id`         <span class="type">bigint</span>(<span class="number">20</span>)   <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">    `name`       <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `age`        <span class="type">int</span>          <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `update_time` <span class="type">timestamp</span>    <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    `create_time` <span class="type">timestamp</span>    <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    index (`name`),</span><br><span class="line">    <span class="keyword">primary</span> key (`id`)</span><br><span class="line">) engine <span class="operator">=</span> InnoDB</span><br><span class="line">  charset <span class="operator">=</span> <span class="string">&#x27;utf8mb4&#x27;</span>;</span><br></pre></td></tr></table></figure><p>现在我们需要对于 <code>name</code> 做一些模糊匹配的需求，比如我们需要去匹配 <code>name</code> 中包含 <code>草</code> 字，于是大家仔细一想，OK，写出了如下的 SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%草%&#x27;</span></span><br></pre></td></tr></table></figure><p>好了，当你行高采烈的将这段代码上线后，你发现，线上炸了，为啥？因为 MYSQL 的坑. MYSQL 的 like 查询存在这样两个限制</p><ol><li>只有前缀匹配 ‘草%’ 和后缀匹配 ‘%草’ 才会走索引，而任意匹配则不会</li><li>当无法走索引的时候，MYSQL 会遍历全表来查询数据</li></ol><p>当你一个表的数据规模很大的时候，那么暴力扫表必然会带来极大的开销</p><p>但是我们实际工作中这样的任意匹配的需求肯定很多，那么我们应该怎么做？或许可以尝试下全文搜索</p><h2 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h2><h3 id="简单聊聊全文搜索"><a href="#简单聊聊全文搜索" class="headerlink" title="简单聊聊全文搜索"></a>简单聊聊全文搜索</h3><p>全文搜索大家已经不太陌生了，简而言之用一种不太精确的说法就是，用一组关键词在一堆文本数据中寻找匹配项。在目前业界比较主流的全文搜索方案有：</p><ol><li>支持全文搜索的关系行数据库</li><li>Apache Lucene</li><li>基于 Apache Lucene 的 ElasticSearch</li><li>Apache Solr</li></ol><p>后两种是目前业界主要的方案，可能很多全文搜索的需求都会考虑用 ES 或者 Solr 实现。但是这样一种方法并不是无代价的。有这样几个比较现实的问题</p><ol><li>ES/Solr 在数据量比较大的情况下的运维问题，怎么样保证集群的 HA 将是一个很考研团队功底的问题</li><li>怎么样将 MYSQL 或其余数据源中的数据实时/离线 ETL 至 Search Engine 中</li><li>新增的学习与 Codebase 的维护成本。</li><li>新增一个依赖之后，对于系统整体的 HA 的保证</li></ol><p>在技术决策中，我们往往需要去衡量一个选项的 ROI 来辅助决策。如果我们面对一个比较简单的搜索场景，那么选用 ES/Solr 所带来的开销将会使其 ROI 变得相对较低。因此在一些简单的场景，我们可能会更希望利用数据库本身的能力来完成我们的需求</p><p>所幸，在 MySQL 5.5 之后，其支持了一定的全文搜索的能力</p><h3 id="MySQL-全文搜索"><a href="#MySQL-全文搜索" class="headerlink" title="MySQL 全文搜索"></a>MySQL 全文搜索</h3><p>MYSQL 全文搜索的前提是需要在表中建立一个 Full Text Index</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `<span class="keyword">user</span>`</span><br><span class="line">    <span class="keyword">ADD</span> FULLTEXT INDEX name_index (`name`);</span><br></pre></td></tr></table></figure><p>注意全文索引，仅对类型为 <code>CHAR</code>/<code>VARCHAR</code>/<code>TEXT</code> 的字段生效。</p><p>然后，我们插入两条数据 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `<span class="keyword">user</span>` (name, age, createTime, updateTime)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;Jeff.S.Wang&#x27;</span>, <span class="number">18</span>, <span class="built_in">current_timestamp</span>, <span class="built_in">current_timestamp</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `<span class="keyword">user</span>` (name, age, createTime, updateTime)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;Jeff.Li&#x27;</span>, <span class="number">18</span>, <span class="built_in">current_timestamp</span>, <span class="built_in">current_timestamp</span>);</span><br></pre></td></tr></table></figure><p>好了，我们可以来看看 MYSQL 怎么进行全文查询了</p><p>首先，按照官方的定义，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MATCH (col1,col2,...) AGAINST (expr [search_modifier])</span><br></pre></td></tr></table></figure><p>而 <code>search_modifier</code> 是所选取的匹配模式，在MYSQL中共有四种</p><ol><li>IN NATURAL LANGUAGE MODE 自然语言模式</li><li>IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION 自然语言带扩展模式</li><li>IN BOOLEAN MODE 逻辑模式</li><li>WITH QUERY EXPANSION 扩展模式</li></ol><p>我们常用的是 <strong>自然语言模式</strong> 和 <strong>逻辑模式</strong>。</p><p>首先来聊聊 <strong>自然语言模式</strong>，很简单，顾名思义，MYSQL 会直接计算待匹配关键字，然后返回对应的值，这里引用一段官网的解释：</p><blockquote><p>By default or with the IN NATURAL LANGUAGE MODE modifier, the MATCH() function performs a natural language search for a string against a text collection. A collection is a set of one or more columns included in a FULLTEXT index. The search string is given as the argument to AGAINST(). For each row in the table, MATCH() returns a relevance value; that is, a similarity measure between the search string and the text in that row in the columns named in the MATCH() list.</p></blockquote><p>我们来写一段 SQL </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">user</span>` </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">MATCH</span>(name) AGAINST(<span class="string">&#x27;Jeff&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE)</span><br></pre></td></tr></table></figure><p>然后我们发现能得到如下的结果</p><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>age</th><th>updateTime</th><th>createTime</th></tr></thead><tbody><tr><td>1</td><td>Jeff Li</td><td>18</td><td>2020-03-01 15:38:07</td><td>2020-03-01 15:38:07</td></tr><tr><td>2</td><td>Jeff.S.Wang</td><td>18</td><td>2020-03-01 15:42:28</td><td>2020-03-01 15:42:28</td></tr></tbody></table></div><p>然后，我们来尝试匹配下用户的 LastName，比如我们想找一位姓 Wang 的用户</p><p>然后我们写出了如下的 SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">user</span>` </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">MATCH</span>(name) AGAINST(<span class="string">&#x27;Jeff&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE)</span><br></pre></td></tr></table></figure><p>得到如下结果</p><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>age</th><th>updateTime</th><th>createTime</th></tr></thead><tbody><tr><td>2</td><td>Jeff.S.Wang</td><td>18</td><td>2020-03-01 15:42:28</td><td>2020-03-01 15:42:28</td></tr></tbody></table></div><p>然后我们开始尝试，去搜索一位姓 Li 的用户，然后我们写下了，如下的 SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">user</span>` </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">MATCH</span>(name) AGAINST(<span class="string">&#x27;Li&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE)</span><br></pre></td></tr></table></figure><p>然后我们发现，什么结果都没有？？？？？WTF？Why？</p><p>原因在于分词粒度，在我们进行录入新数据的时候，MySQL 会将我们的索引字段中的数据按照一定的分词基准长度进行分词，然后存储以待查询，其有四个参数控制分词的长度</p><ol><li>innodb_ft_min_token_size </li><li>innodb_ft_max_token_size </li><li>ft_min_word_len 作用同上，不过是针对 MyISAM 引擎</li><li>ft_max_word_len </li></ol><p>以 InnoDB 为例，其默认的 <code>innodb_ft_min_token_size</code> 的值是 3，换句话说在我们之前的录入的数据中，我们数据中存储的分词后的单元是</p><ol><li>Jeff</li><li>Wang</li></ol><p>所以我们第二次搜索没有结果，现在我们将 MySQL 的参数修改一下后，重新执行一下？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">user</span>` </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">MATCH</span>(name) AGAINST(<span class="string">&#x27;Li&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE)</span><br></pre></td></tr></table></figure><p>还还还是不行？？？？</p><p>查了下官方文档后，我们发现有这样的描述</p><blockquote><p>Some variable changes require that you rebuild the FULLTEXT indexes in your tables. Instructions for doing so are given later in this section.</p></blockquote><p>而索引分词粒度也包含在其中，，所以我们需要删除/rebuild索引，，然后重新执行（有点坑。。）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">user</span>` </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">MATCH</span>(name) AGAINST(<span class="string">&#x27;Li&#x27;</span> <span class="keyword">IN</span> <span class="keyword">NATURAL</span> <span class="keyword">LANGUAGE</span> MODE)</span><br></pre></td></tr></table></figure><p>好了，现在正常的返回结果了</p><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>age</th><th>updateTime</th><th>createTime</th></tr></thead><tbody><tr><td>1</td><td>Jeff Li</td><td>18</td><td>2020-03-01 15:38:07</td><td>2020-03-01 15:38:07</td></tr></tbody></table></div><p>现在让我们来聊聊另一种匹配模式，BOOLEAN MODE </p><p>逻辑模式允许我们用一些操作符来检索一些数据，我们举一些常见的例子，剩下大家可以去看看 MYSQL 官方文档</p><ol><li>AGAINST(‘Jeff Li’ IN BOOLEAN MODE) 表示，要么存在 <strong>Jeff</strong> 要么存在 <strong>Li</strong></li><li>AGAINST(‘+Jeff’ IN BOOLEAN MODE) 表示，必须存在 <strong>Jeff</strong></li><li>AGAINST(‘+Jeff -Li’ IN BOOLEAN MODE) 表示 必须存在 <strong>Jeff</strong> 且 <strong>Li</strong> 必须不存在</li></ol><p>我们来执行下这几个 SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">user</span>` </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">MATCH</span>(name) AGAINST(<span class="string">&#x27;Jeff Li&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE)</span><br></pre></td></tr></table></figure><p>结果</p><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>age</th><th>updateTime</th><th>createTime</th></tr></thead><tbody><tr><td>1</td><td>Jeff Li</td><td>18</td><td>2020-03-01 15:38:07</td><td>2020-03-01 15:38:07</td></tr><tr><td>2</td><td>Jeff.S.Wang</td><td>18</td><td>2020-03-01 15:42:28</td><td>2020-03-01 15:42:28</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">user</span>` </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">MATCH</span>(name) AGAINST(<span class="string">&#x27;+Jeff&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE)</span><br></pre></td></tr></table></figure><p>结果</p><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>age</th><th>updateTime</th><th>createTime</th></tr></thead><tbody><tr><td>1</td><td>Jeff Li</td><td>18</td><td>2020-03-01 15:38:07</td><td>2020-03-01 15:38:07</td></tr><tr><td>2</td><td>Jeff.S.Wang</td><td>18</td><td>2020-03-01 15:42:28</td><td>2020-03-01 15:42:28</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">user</span>` </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">MATCH</span>(name) AGAINST(<span class="string">&#x27;+Jeff -Li&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE) </span><br></pre></td></tr></table></figure><p>结果</p><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>age</th><th>updateTime</th><th>createTime</th></tr></thead><tbody><tr><td>2</td><td>Jeff.S.Wang</td><td>18</td><td>2020-03-01 15:42:28</td><td>2020-03-01 15:42:28</td></tr></tbody></table></div><p>好，现在我们有一些中文搜索的需求，我们先来插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `<span class="keyword">user</span>` (name, age, createTime, updateTime)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;奥特曼&#x27;</span>, <span class="number">18</span>, <span class="built_in">current_timestamp</span>, <span class="built_in">current_timestamp</span>);</span><br></pre></td></tr></table></figure><p>现在我们来搜索姓<strong>奥</strong>的用户，我们按照之前的 Guide 写出了如下的 SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">MATCH</span>(name) AGAINST(<span class="string">&#x27;+奥&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE)</span><br></pre></td></tr></table></figure><p>然后我们惊喜的发现，又又又没有结果？？？Why？？？</p><p>其实还是之前提到过的一个问题，<strong>分词</strong>，MySQL 的默认的分词引擎，只支持英文的分词，而不支持中文分词，那么没有分词，没有搜索？怎么办？</p><p>在 MySQL 5.7 之后，MySQL 提供了 <code>ngram</code> 这个组件来帮助我们进行中文分词，使用很简单</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `<span class="keyword">user</span>`</span><br><span class="line">    <span class="keyword">add</span> fulltext index name_index (`name`) <span class="keyword">with</span> parser ngram;</span><br></pre></td></tr></table></figure><p>这里有几点要注意：</p><ol><li>ngram 不仅适用于中文，按照官方文档，韩文，日文也都支持</li><li>一个字段上只能有一个全文索引，所以需要删除原有全文索引</li></ol><p>同时，如同默认的分词一样，<strong>ngram</strong> 也受分词粒度的限制，不过 <strong>ngram</strong> 的设置参数是</p><ol><li>ngram_token_size</li></ol><p>我们按照需要设置即可</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>全文搜索对于日常开发来讲，是一个很常见的需求，在我们的 infra 没法让我们去安心的使用外部组件的时候，利用数据库提供的能力也许是个不错的选项。不过还是有很多的坑要踩，有很多的参数要优化。。BTW 阿里云的 RDS 设置真的难用（小声吐槽</p><p>好了。。我的拖延症实在没救了。。而且这两天牙疼真的无奈，呜呜呜呜呜</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode Weekly Contest 176 题解</title>
      <link href="//posts/2020/02/23/leetcode-weekly-contest-176/"/>
      <url>//posts/2020/02/23/leetcode-weekly-contest-176/</url>
      
        <content type="html"><![CDATA[<p>emmmm，我的拖延症没救了，顺便加上这周沉迷 Kotlin ，这篇本应该周一就写完的题解拖到现在，= =然而这周双周赛，，我又得写两篇题解了。。。</p><span id="more"></span><h2 id="1351-Count-Negative-Numbers-in-a-Sorted-Matrix"><a href="#1351-Count-Negative-Numbers-in-a-Sorted-Matrix" class="headerlink" title="1351. Count Negative Numbers in a Sorted Matrix"></a>1351. Count Negative Numbers in a Sorted Matrix</h2><p>题面：</p><blockquote><p>Given a m * n matrix grid which is sorted in non-increasing order both row-wise and column-wise.<br>Return the number of negative numbers in grid.</p></blockquote><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: There are 8 negatives number in the matrix.</span><br></pre></td></tr></table></figure><p>题面很简单，给定一个矩阵，矩阵横/纵向都是递减的，求这个矩阵中负数的个数，这个题，因为横/纵向的数据规模都是小于100的，那就没啥说的了，，直接暴力，横向遍历，然后遇到负数就停止遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNegatives</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n_length = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> grid:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_length):</span><br><span class="line">                <span class="keyword">if</span> item[i] &lt; <span class="number">0</span>:</span><br><span class="line">                    result += n_length - i</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="1352-Product-of-the-Last-K-Numbers"><a href="#1352-Product-of-the-Last-K-Numbers" class="headerlink" title="1352. Product of the Last K Numbers"></a>1352. Product of the Last K Numbers</h2><p>题面:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Implement the class ProductOfNumbers that supports two methods:</span><br><span class="line"></span><br><span class="line">1. add(int num)</span><br><span class="line"></span><br><span class="line">Adds the number num to the back of the current list of numbers.</span><br><span class="line">2. getProduct(int k)</span><br><span class="line"></span><br><span class="line">Returns the product of the last k numbers in the current list.</span><br><span class="line">You can assume that always the current list has at least k numbers.</span><br><span class="line">At any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;ProductOfNumbers&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;add&quot;,&quot;getProduct&quot;]</span><br><span class="line">[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]</span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">[null,null,null,null,null,null,20,40,0,null,32]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">ProductOfNumbers productOfNumbers = new ProductOfNumbers();</span><br><span class="line">productOfNumbers.add(3);        // [3]</span><br><span class="line">productOfNumbers.add(0);        // [3,0]</span><br><span class="line">productOfNumbers.add(2);        // [3,0,2]</span><br><span class="line">productOfNumbers.add(5);        // [3,0,2,5]</span><br><span class="line">productOfNumbers.add(4);        // [3,0,2,5,4]</span><br><span class="line">productOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 * 4 = 20</span><br><span class="line">productOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 * 5 * 4 = 40</span><br><span class="line">productOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0</span><br><span class="line">productOfNumbers.add(8);        // [3,0,2,5,4,8]</span><br><span class="line">productOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 * 8 = 32 </span><br></pre></td></tr></table></figure><p>题面很简单，设计一个数据结构，提供一个 <code>add</code> 方法，让用户能够往里面添加速度，提供一个 <code>getProduct</code> 方法，让用户能求倒数K个数的乘积，这题没啥好说的，直接暴力写，中间加个 hashmap 作为缓存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Dict</span></span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductOfNumbers</span>:</span><br><span class="line">    _value: <span class="type">List</span>[<span class="built_in">int</span>]</span><br><span class="line">    _cache_result: <span class="type">Dict</span>[<span class="built_in">int</span>, <span class="built_in">int</span>]</span><br><span class="line">    _cache_index: <span class="type">List</span>[<span class="built_in">int</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._value = []</span><br><span class="line">        self._cache_result = &#123;&#125;</span><br><span class="line">        self._cache_index = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self._value.append(num)</span><br><span class="line">        self._cache_index.clear()</span><br><span class="line">        self._cache_result.clear()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getProduct</span>(<span class="params">self, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> k <span class="keyword">in</span> self._cache_result:</span><br><span class="line">            <span class="keyword">return</span> self._cache_result[k]</span><br><span class="line">        cache_index = bisect.bisect(self._cache_index, k) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cache_index &gt;= <span class="number">0</span>:</span><br><span class="line">            last_k = self._cache_index[cache_index]</span><br><span class="line">            result = self._cache_result[last_k]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cache_index + <span class="number">1</span>):</span><br><span class="line">                temp_last_k = last_k + i</span><br><span class="line">                <span class="keyword">if</span> temp_last_k &gt;= <span class="built_in">len</span>(self._value):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                result *= self._value[-last_k]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp_value = (</span><br><span class="line">                self._value[-<span class="number">1</span> : -k - <span class="number">1</span> : -<span class="number">1</span>] <span class="keyword">if</span> k &lt;= <span class="built_in">len</span>(self._value) <span class="keyword">else</span> self._value</span><br><span class="line">            )</span><br><span class="line">            result = reduce(mul, temp_value, <span class="number">1</span>)</span><br><span class="line">        bisect.bisect_left(self._cache_index, k)</span><br><span class="line">        self._cache_result[k] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="1353-Maximum-Number-of-Events-That-Can-Be-Attended"><a href="#1353-Maximum-Number-of-Events-That-Can-Be-Attended" class="headerlink" title="1353. Maximum Number of Events That Can Be Attended"></a>1353. Maximum Number of Events That Can Be Attended</h2><p>题面：</p><blockquote><p>Given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi.<br>You can attend an event i at any day d where startTimei &lt;= d &lt;= endTimei. Notice that you can only attend one event at any time d.<br>Return the maximum number of events you can attend.</p></blockquote><p>示例</p><p><img src="https://user-images.githubusercontent.com/7054676/75112667-e110d200-5680-11ea-8686-80f04332fe44.png" alt="image"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: events = [[1,2],[2,3],[3,4]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You can attend all the three events.</span><br><span class="line">One way to attend them all is as shown.</span><br><span class="line">Attend the first event on day 1.</span><br><span class="line">Attend the second event on day 2.</span><br><span class="line">Attend the third event on day 3.</span><br></pre></td></tr></table></figure><p>给定一个数组，数组中每个元素 x 代表一个活动，x[0], x[i] 代表该活动的起始与结束时间，一个用户一天只能参加一个活动，求用户最多能参加多少个活动。经典的一个贪心题目，首先对活动列表以结束时间进行排序，然后依次遍历每个时间，确认具体哪一天可以参加，整体时间复杂度为 O(max(nlogn,n*m))</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxEvents</span>(<span class="params">self, events: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> events:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        events_size = <span class="built_in">len</span>(events)</span><br><span class="line">        <span class="keyword">if</span> events_size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        events = <span class="built_in">sorted</span>(events)</span><br><span class="line">        _day_map: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">bool</span>] = &#123;&#125;</span><br><span class="line">        _event_map: <span class="type">Dict</span>[<span class="built_in">int</span>, <span class="built_in">bool</span>] = &#123;&#125;</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(events_size):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(events[i][<span class="number">0</span>], events[i][<span class="number">1</span>]+<span class="number">1</span>):</span><br><span class="line">                temp = <span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(j)</span><br><span class="line">                <span class="keyword">if</span> temp <span class="keyword">not</span> <span class="keyword">in</span> _day_map <span class="keyword">and</span> i <span class="keyword">not</span> <span class="keyword">in</span> _event_map:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    _day_map[temp] = <span class="literal">True</span></span><br><span class="line">                    _event_map[i] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h2 id="1354-Construct-Target-Array-With-Multiple-Sums"><a href="#1354-Construct-Target-Array-With-Multiple-Sums" class="headerlink" title="1354. Construct Target Array With Multiple Sums"></a>1354. Construct Target Array With Multiple Sums</h2><p>题面</p><blockquote><p>Given an array of integers target. From a starting array, A consisting of all 1’s, you may perform the following procedure :</p><ul><li>let x be the sum of all elements currently in your array.</li><li>choose index i, such that 0 &lt;= i &lt; target.size and set the value of A at index i to x.</li><li>You may repeat this procedure as many times as needed.<br>Return True if it is possible to construct the target array from A otherwise return False.</li></ul></blockquote><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: target = [9,3,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Start with [1, 1, 1] </span><br><span class="line">[1, 1, 1], sum = 3 choose index 1</span><br><span class="line">[1, 3, 1], sum = 5 choose index 2</span><br><span class="line">[1, 3, 5], sum = 9 choose index 0</span><br><span class="line">[9, 3, 5] Done</span><br></pre></td></tr></table></figure><p>这题算是一个数学题吧，我们首先知道数组中所有的元素的和一定大于数组中每个元素（这不是废话），然后我们假定有这样一个数组 [1,1,9,17,63] ，我们可以往回迭代上一个数组结构是 [1,1,9.17,33] ，然后我们还可以向前迭代一次 [1,1,9,17,5]  然后当前的数字已经不再是数组中最大的数字，于是我们开始寻找下一个数组中最大的数字进行迭代</p><p>这里我们也可以发现，数组中最大数字的最原始版本的值是当前数字对其余数字的和的模，于是我们就这样一直迭代就 OK 了</p><p>好了，上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPossible</span>(<span class="params">self, target: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        total = <span class="built_in">sum</span>(target)</span><br><span class="line">        target = <span class="built_in">sorted</span>([-x <span class="keyword">for</span> x <span class="keyword">in</span> target])</span><br><span class="line">        heapq.heapify(target)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            a = -heapq.heappop(target)</span><br><span class="line">            total -= a</span><br><span class="line">            <span class="keyword">if</span> a == <span class="number">1</span> <span class="keyword">or</span> total == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> a &lt; total <span class="keyword">or</span> total == <span class="number">0</span> <span class="keyword">or</span> a % total == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            a %= total</span><br><span class="line">            total += a</span><br><span class="line">            heapq.heappush(target, -a)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次的题还是周赛的常规水平，然而我刷题实在是太少了QAQ</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> leetcode </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode BiWeekly Contest 19 题解</title>
      <link href="//posts/2020/02/10/leetcode-biweekly-contest-19/"/>
      <url>//posts/2020/02/10/leetcode-biweekly-contest-19/</url>
      
        <content type="html"><![CDATA[<p>例行 Leetcode 周赛，这周双周赛，两场赛打下来，有点酸爽，先写个 BiWeekly 19 Contest 的题解吧</p><span id="more"></span><h2 id="1342-Number-of-Steps-to-Reduce-a-Number-to-Zer"><a href="#1342-Number-of-Steps-to-Reduce-a-Number-to-Zer" class="headerlink" title="1342. Number of Steps to Reduce a Number to Zer"></a>1342. Number of Steps to Reduce a Number to Zer</h2><p>题面：</p><blockquote><p>Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.</p></blockquote><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: num = 14</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">    Step 1) 14 is even; divide by 2 and obtain 7. </span><br><span class="line">    Step 2) 7 is odd; subtract 1 and obtain 6.</span><br><span class="line">    Step 3) 6 is even; divide by 2 and obtain 3. </span><br><span class="line">    Step 4) 3 is odd; subtract 1 and obtain 2. </span><br><span class="line">    Step 5) 2 is even; divide by 2 and obtain 1. </span><br><span class="line">    Step 6) 1 is odd; subtract 1 and obtain 0.</span><br></pre></td></tr></table></figure><p>这个题题面很简单，一个非负整数，偶数除2，奇数减1，求需要多少步到0</p><p>暴力写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfSteps</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        result = num</span><br><span class="line">        <span class="keyword">while</span> result &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> result % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                result = <span class="built_in">int</span>(result / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result -= <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count + <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="Number-of-Sub-arrays-of-Size-K-and-Average-Greater-than-or-Equal-to-Threshold"><a href="#Number-of-Sub-arrays-of-Size-K-and-Average-Greater-than-or-Equal-to-Threshold" class="headerlink" title="Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold"></a>Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold</h2><p>题面：</p><blockquote><p>Given an array of integers arr and two integers k and threshold.<br>Return the number of sub-arrays of size k and average greater than or equal to threshold.</p></blockquote><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold)</span><br></pre></td></tr></table></figure><p>给定一个数组和一个长度 k，和一个阈值 threshold ，求这个数组中的所有长度为 K 且平均数大于等于阈值的子数组的个数。这个题，暴力写很简单，一个简单的数组的拆分，<code>sum(arr[i:i+k])/k &gt;= threshold</code> 即可，但是这里有个问题，如果实时求和，那么时间复杂度为 O(M*K) M 为数组的长度，这个时候暴力会 T </p><p>因此需要做个小技巧的优化。可以考虑这样这样一个做法，假设当前 i 及其后 k 个数的和为 sum[i]，那么有这样一个公式，sum[i]=sum[i-1]-arr[i]+arr[i+k-1]，这样每次计算和都是 O(1) 的复杂度，那么整体就是一个 O(N) 的做法</p><p>好了，暴力开写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numOfSubarrays</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, threshold: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        length = <span class="built_in">len</span>(arr)</span><br><span class="line">        sum_threshold = [<span class="number">0.0</span>] * length</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        last_index = length</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length - k, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == length - k:</span><br><span class="line">                total_sum = <span class="built_in">sum</span>(arr[i:i + k])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                total_sum = sum_threshold[i + <span class="number">1</span>] - arr[last_index] + arr[i]</span><br><span class="line">            sum_threshold[i] = total_sum</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> total_sum / k &gt;= threshold:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            last_index -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h3 id="1344-Angle-Between-Hands-of-a-Clock"><a href="#1344-Angle-Between-Hands-of-a-Clock" class="headerlink" title="1344. Angle Between Hands of a Clock"></a>1344. Angle Between Hands of a Clock</h3><p>题面：</p><blockquote><p>Given two numbers, hour and minutes. Return the smaller angle (in sexagesimal units) formed between the hour and the minute hand.</p></blockquote><p>示例：</p><p><img src="https://user-images.githubusercontent.com/7054676/74172911-0b6b9400-4c6c-11ea-8c8b-07e22630428b.png" alt="image"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: hour = 12, minutes = 30</span><br><span class="line">Output: 165</span><br></pre></td></tr></table></figure><p>求某个时刻，时针与分针的夹角，，，啊，，我的上帝呀，一度梦回小升初。。。一个数学题，首先科普如下知识</p><ol><li><p>普通钟表相当于圆，其时针或分针走一圈均相当于走过360°角；</p></li><li><p>钟表上的每一个大格（时针的一小时或分针的5分钟）对应的角度是：360°/12=30°；</p></li><li><p>时针每走过1分钟对应的角度应为：360°/(12*60)=0.5°；</p></li><li><p>分针每走过1分钟对应的角度应为：360°/60=6°。</p></li></ol><p>好了，那么就暴力做吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">angleClock</span>(<span class="params">self, hour: <span class="built_in">int</span>, minutes: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        hour %= <span class="number">12</span></span><br><span class="line">        result = <span class="built_in">abs</span>((minutes * <span class="number">6</span>) - (hour * <span class="number">30</span> + minutes * <span class="number">0.5</span>))</span><br><span class="line">        <span class="keyword">return</span> result <span class="keyword">if</span> result &lt; <span class="number">360</span> <span class="keyword">else</span> <span class="number">360</span> - result</span><br></pre></td></tr></table></figure><h2 id="1345-Jump-Game-IV"><a href="#1345-Jump-Game-IV" class="headerlink" title="1345. Jump Game IV"></a>1345. Jump Game IV</h2><p>题面：</p><blockquote><p>Given an array of integers arr, you are initially positioned at the first index of the array.<br>In one step you can jump from index i to index:</p><ol><li>i + 1 where: i + 1 &lt; arr.length.</li><li>i - 1 where: i - 1 &gt;= 0.</li><li>j where: arr[i] == arr[j] and i != j.<br>Return the minimum number of steps to reach the last index of the array.<br>Notice that you can not jump outside of the array at any time.</li></ol></blockquote><p>示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [100,-23,-23,404,100,23,23,23,3,404]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array.</span><br></pre></td></tr></table></figure><p>还是跳格子，给定一个数组，里面会有一些具体的值，现在从 index = 0 的地方起跳，跳跃规则如下：</p><ol><li><p>在 i+1 或 i-1 都在数组的范围内</p></li><li><p>如果存在 index=j 且 arr[i]==arr[j] 且 i!=j 的时候，可以直接从 i 跳到 j</p></li></ol><p>求从 index=0 跳到 index=arr.length-1 最小的次数</p><p>这题我还是没 A，后面琢磨了下，一个搜索的题目</p><ol><li><p>构建一个字典，值为key，index 为 value（相同的值之间可以直接跳）</p></li><li><p>利用一个 set 来保存跳过的点</p></li><li><p>从 index = 0 开始进行 BFS ，求每个点在一步之内可以跳到哪个点，然后不断的 BFS  直到到达终点</p></li><li><p>更新被访问过的点</p></li></ol><p>emmmm，好吧 BFS ，开写吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Set</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minJumps</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arr <span class="keyword">or</span> length == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        value_index = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr):</span><br><span class="line">            value_index[value].append(index)</span><br><span class="line">        visited: <span class="type">Set</span>[<span class="built_in">int</span>] = <span class="built_in">set</span>()</span><br><span class="line">        traversal_queue = collections.deque([(<span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> traversal_queue:</span><br><span class="line">            next_step_queue = collections.deque()</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(traversal_queue)):</span><br><span class="line">                cur_index, cur_step = traversal_queue.popleft()</span><br><span class="line">                cur_value = arr[cur_index]</span><br><span class="line">                visited.add(cur_index)</span><br><span class="line">                <span class="keyword">for</span> next_index <span class="keyword">in</span> [cur_index + <span class="number">1</span>, cur_index - <span class="number">1</span>] + value_index[</span><br><span class="line">                    cur_value</span><br><span class="line">                ]:</span><br><span class="line">                    <span class="keyword">if</span> (length &gt; next_index &gt;= <span class="number">0</span>) <span class="keyword">and</span> (next_index <span class="keyword">not</span> <span class="keyword">in</span> visited):</span><br><span class="line">                        <span class="keyword">if</span> next_index == length - <span class="number">2</span>:</span><br><span class="line">                            <span class="keyword">return</span> cur_step + <span class="number">2</span></span><br><span class="line">                        <span class="keyword">if</span> next_index == length - <span class="number">1</span>:</span><br><span class="line">                            <span class="keyword">return</span> cur_step + <span class="number">1</span></span><br><span class="line">                        next_step_queue.append((next_index, cur_step + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">del</span> value_index[cur_value]</span><br><span class="line">            traversal_queue = next_step_queue</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这周的题，还是不难，但是需要小心，比如第二题我太大意直接暴力吃了一发T，然后第三题没仔细读题（求最小的度数）吃了一发 WA，不过和第二天周赛比起来，真的是幸福，175 第三题的题面直接让心态崩了，，明天写题解。</p><p>好了，滚去睡觉</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> leetcode </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode Weekly Contest 174 题解</title>
      <link href="//posts/2020/02/02/leetcode-weekly-contest-174/"/>
      <url>//posts/2020/02/02/leetcode-weekly-contest-174/</url>
      
        <content type="html"><![CDATA[<p>最近因为生病好久没刷题，今早开始打了一场 Leetcode 的周赛，来写个题解，今早状态还行，，BTW 以后每周都会打周赛，争取写题解</p><span id="more"></span><h2 id="Leetcode-1341-The-K-Weakest-Rows-in-a-Matrix"><a href="#Leetcode-1341-The-K-Weakest-Rows-in-a-Matrix" class="headerlink" title="Leetcode 1341. The K Weakest Rows in a Matrix"></a>Leetcode 1341. The K Weakest Rows in a Matrix</h2><p>描述：</p><blockquote><p>Given a m * n matrix mat of ones (representing soldiers) and zeros (representing civilians), return the indexes of the k weakest rows in the matrix ordered from the weakest to the strongest.<br>A row i is weaker than row j, if the number of soldiers in row i is less than the number of soldiers in row j, or they have the same number of soldiers but i is less than j. Soldiers are always stand in the frontier of a row, that is, always ones may appear first and then zeros.</p></blockquote><p>Example 1:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input: mat = </span><br><span class="line">[[1,1,0,0,0],</span><br><span class="line"> [1,1,1,1,0],</span><br><span class="line"> [1,0,0,0,0],</span><br><span class="line"> [1,1,0,0,0],</span><br><span class="line"> [1,1,1,1,1]], </span><br><span class="line">k = 3</span><br><span class="line">Output: [2,0,3]</span><br><span class="line">Explanation: </span><br><span class="line">The number of soldiers for each row is: </span><br><span class="line">row 0 -&gt; 2 </span><br><span class="line">row 1 -&gt; 4 </span><br><span class="line">row 2 -&gt; 1 </span><br><span class="line">row 3 -&gt; 2 </span><br><span class="line">row 4 -&gt; 5 </span><br><span class="line">Rows ordered from the weakest to the strongest are [2,0,3,1,4]</span><br></pre></td></tr></table></figure><p>题面很简单，其实这道题就是二进制的处理，Python 里面就暴力出奇迹了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kWeakestRows</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> mat:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        number = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mat)):</span><br><span class="line">            number.append((<span class="built_in">int</span>(<span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> mat[i]]), <span class="number">2</span>), i))</span><br><span class="line">        number.sort()</span><br><span class="line">        <span class="keyword">return</span> [x <span class="keyword">for</span> _, x <span class="keyword">in</span> number[<span class="number">0</span>:k]]</span><br></pre></td></tr></table></figure><h2 id="1342-Reduce-Array-Size-to-The-Half"><a href="#1342-Reduce-Array-Size-to-The-Half" class="headerlink" title="1342. Reduce Array Size to The Half"></a>1342. Reduce Array Size to The Half</h2><p>描述：</p><blockquote><p>Given an array arr.  You can choose a set of integers and remove all the occurrences of these integers in the array.<br>Return the minimum size of the set so that at least half of the integers of the array are removed.</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [3,3,3,3,5,5,5,2,2,7]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Choosing &#123;3,7&#125; will make the new array [5,5,5,2,2] which has size 5 (i.e equal to half of the size of the old array).</span><br><span class="line">Possible sets of size 2 are &#123;3,5&#125;,&#123;3,2&#125;,&#123;5,2&#125;.</span><br><span class="line">Choosing set &#123;2,7&#125; is not possible as it will make the new array [3,3,3,3,5,5,5] which has size greater than half of the size of the old array.</span><br></pre></td></tr></table></figure><p>这个题题面也很简单，给定一个数组，选择一组数字移除，被移除后的数组数量小于等于之前的一半，求最少选择多少数字能达到要求</p><p>哈希表，O(N) 的做法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSetSize</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        counter = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            counter[i] = counter.setdefault(i, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        counter = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">sorted</span>(counter.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>)&#125;</span><br><span class="line">        total_count = <span class="number">0</span></span><br><span class="line">        result_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, count <span class="keyword">in</span> counter.items():</span><br><span class="line">            total_count += count</span><br><span class="line">            result_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> total_count &gt;= <span class="built_in">len</span>(arr) / <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> result_count</span><br></pre></td></tr></table></figure><h3 id="1343-Maximum-Product-of-Splitted-Binary-Tree"><a href="#1343-Maximum-Product-of-Splitted-Binary-Tree" class="headerlink" title="1343. Maximum Product of Splitted Binary Tree"></a>1343. Maximum Product of Splitted Binary Tree</h3><p>描述：</p><blockquote><p>Given a binary tree root. Split the binary tree into two subtrees by removing 1 edge such that the product of the sums of the subtrees are maximized.<br>Since the answer may be too large, return it modulo 10^9 + 7.</p></blockquote><p>Example 1:</p><p><img src="https://assets.leetcode.com/uploads/2020/01/21/sample_1_1699.png" alt=""></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,6]</span><br><span class="line">Output: 110</span><br><span class="line">Explanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)</span><br></pre></td></tr></table></figure><p>这个题的题面也很简单，给定一个带值的二叉树，移除某个二叉树的边，使之分割成为两个新的二叉树，求两个二叉树和的乘积最大</p><p>最开始很多人会被这道题唬到，但是实际上这道题就是一个二叉树的遍历，无论前中后序遍历，先遍历一次二叉树，求出二叉树节点值的总和，以及每个节点的左子树的和 left_sum 以及右子树的总和 <code>right_sum</code> </p><p>然后再次遍历，<code>result=max((total_sum-left_sum)*left_sum),(total_sum-right_sum)*right_sum),result)</code> 暴力求解即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        total_sum = self.sum_node(root)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                result = <span class="built_in">max</span>(result, ((total_sum - node.left_sum) * node.left_sum))</span><br><span class="line">                result = <span class="built_in">max</span>(result, ((total_sum - node.right_sum) * node.right_sum))</span><br><span class="line">                node = node.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            node = node.right</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                result = <span class="built_in">max</span>(result, ((total_sum - node.right_sum) * node.right_sum))</span><br><span class="line">                result = <span class="built_in">max</span>(result, ((total_sum - node.left_sum) * node.left_sum))</span><br><span class="line">        <span class="keyword">return</span> result % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sum_node</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left_sum = self.sum_node(root.left)</span><br><span class="line">        right_sum = self.sum_node(root.right)</span><br><span class="line">        root.left_sum = left_sum</span><br><span class="line">        root.right_sum = right_sum</span><br><span class="line">        <span class="keyword">return</span> left_sum + right_sum + root.val</span><br></pre></td></tr></table></figure><p>BTW 这段代码的 type hint 使用其实有点问题，我后面比赛完了改了一版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span>, <span class="type">Tuple</span>, <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    val: <span class="built_in">int</span></span><br><span class="line">    left: <span class="type">Optional</span>[<span class="string">&quot;TreeNode&quot;</span>]</span><br><span class="line">    right: <span class="type">Optional</span>[<span class="string">&quot;TreeNode&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNodeWithSum</span>:</span><br><span class="line">    val: <span class="built_in">int</span></span><br><span class="line">    left: <span class="type">Optional</span>[<span class="string">&quot;TreeNodeWithSum&quot;</span>]</span><br><span class="line">    right: <span class="type">Optional</span>[<span class="string">&quot;TreeNodeWithSum&quot;</span>]</span><br><span class="line">    left_sum: <span class="built_in">int</span></span><br><span class="line">    right_sum: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        x: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">        left: <span class="type">Optional</span>[<span class="string">&quot;TreeNodeWithSum&quot;</span>],</span></span><br><span class="line"><span class="params">        right: <span class="type">Optional</span>[<span class="string">&quot;TreeNodeWithSum&quot;</span>],</span></span><br><span class="line"><span class="params">        left_sum: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">        right_sum: <span class="built_in">int</span>,</span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">        self.left_sum = left_sum</span><br><span class="line">        self.right_sum = right_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        total_sum,new_root = self.sum_node(root)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        stack:<span class="type">List</span>[TreeNodeWithSum] = []</span><br><span class="line">        node = new_root</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                result = <span class="built_in">max</span>(result, ((total_sum - node.left_sum) * node.left_sum))</span><br><span class="line">                result = <span class="built_in">max</span>(result, ((total_sum - node.right_sum) * node.right_sum))</span><br><span class="line">                node = node.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            node = node.right</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                result = <span class="built_in">max</span>(result, ((total_sum - node.right_sum) * node.right_sum))</span><br><span class="line">                result = <span class="built_in">max</span>(result, ((total_sum - node.left_sum) * node.left_sum))</span><br><span class="line">        <span class="keyword">return</span> result % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sum_node</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self, root: <span class="type">Optional</span>[TreeNode]</span></span><br><span class="line"><span class="params">    </span>) -&gt; <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="type">Optional</span>[TreeNodeWithSum]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">None</span></span><br><span class="line">        left_sum, new_left_node = self.sum_node(root.left)</span><br><span class="line">        right_sum, new_right_node = self.sum_node(root.right)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            left_sum + right_sum + root.val,</span><br><span class="line">            TreeNodeWithSum(</span><br><span class="line">                root.val, new_left_node, new_right_node, left_sum, right_sum</span><br><span class="line">            ),</span><br><span class="line">        )</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>BTW，这道题因为数据太大，需要对 10^9+7 取模，我智障的忘了取模，WA 了两次，罚时罚哭。。。我真的太菜了。。</p><h2 id="1344-Jump-Game-V"><a href="#1344-Jump-Game-V" class="headerlink" title="1344. Jump Game V"></a>1344. Jump Game V</h2><p>描述：</p><blockquote><p>Given an array of integers arr and an integer d. In one step you can jump from index i to index:<br>i + x where: i + x &lt; arr.length and 0 &lt; x &lt;= d.<br>i - x where: i - x &gt;= 0 and 0 &lt; x &lt;= d.<br>In addition, you can only jump from index i to index j if arr[i] &gt; arr[j] and arr[i] &gt; arr[k] for all indices k between i and j (More formally min(i, j) &lt; k &lt; max(i, j)).<br>You can choose any index of the array and start jumping. Return the maximum number of indices you can visit.<br>Notice that you can not jump outside of the array at any time.</p></blockquote><p><img src="https://assets.leetcode.com/uploads/2020/01/23/meta-chart.jpeg" alt=""></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: You can start at index 10. You can jump 10 --&gt; 8 --&gt; 6 --&gt; 7 as shown.</span><br><span class="line">Note that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 &gt; 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 &gt; 9.</span><br><span class="line">Similarly You cannot jump from index 3 to index 2 or index 1.</span><br></pre></td></tr></table></figure><p>这题的题面是这样，一个数组，里面有若干值，你可以从任意一个位置开始跳跃，一次只能跳一个，跳的时候需要满足规则，假定你从数组 i 位置起跳，每次可跳的范围是 x，那么你需要满足</p><ol><li><p>i+x &lt; arr.length 和 0&lt;x&lt;=d</p></li><li><p>i-x &gt;=0 和 0&lt;x&lt;=d</p></li></ol><p>同时假设你从 i 跳往 j，那么你需要保证 arr[i]&gt;arr[j] 且 i 到 j 中的每个元素都满足 arr[j]&lt;x&lt;arr[i]，求最多能跳多少个元素</p><p>最开始觉得这题是一个双头 DP 的题，嫌写起来恶心就懒得写，，但是后面比赛完了发现其实这个题其实单 DP 就能解决的，因为我们只能从高往低跳，于是我们可以先将元素排序后依次遍历，可以得出公式为 <code>dp[i]=max(dp[i]+dp[j]+1)</code> 其中 j 是从 i 起可以到达的索引值，DP 部分的复杂度为 O(DN) 但是因为需要提前排序，因此整体的时间复杂度为 O(logN+DN)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxJumps</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], d: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(arr)</span><br><span class="line">        dp = [<span class="number">1</span>] * length</span><br><span class="line">        <span class="keyword">for</span> a, i <span class="keyword">in</span> <span class="built_in">sorted</span>([a, i] <span class="keyword">for</span> i, a <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr)):</span><br><span class="line">            <span class="keyword">for</span> di <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + di, i + d * di + di, di):</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= j &lt; length <span class="keyword">and</span> arr[j] &lt; arr[i]):</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很久没刷题了，手还是有点生，在前面几个签到题上花了时间，，而且犯了低级错误，，所以以后一定要坚持刷题了。。BTW 这次的周赛题感觉都很简单，感觉像是被泄题后找的 Backup，好了就先这样吧，我继续卧床养病了。。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> leetcode </category>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单安利 Rime 输入法</title>
      <link href="//posts/2020/01/28/simple-config-for-rime-input/"/>
      <url>//posts/2020/01/28/simple-config-for-rime-input/</url>
      
        <content type="html"><![CDATA[<p>唉，最近因为气胸大过年的住院，春节颓废了好久，今天开始回北京，干脆来安利一个输入法— Rime</p><span id="more"></span><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>如同大多数人一样，我之前也是使用搜狗输入法作为自己的主力输入法，但是搜狗输入法的一些缺陷让我放弃了使用搜狗输入法</p><ol><li><p>作为传统艺能，搜狗输入法隐私保护成迷，在 MacOS 上某几个版本的搜狗在寻求获取我的通讯录和日历读取权限</p></li><li><p>作为传统艺能，搜狗输入法的广告推送实在是一言难尽，特别是在 Windows 上，已经禁了一些组件，但是还是防不胜防</p></li><li><p>因为和港澳台和国外社区朋友的交流需要，我需要输入法能够比较好的支持繁体，而搜狗输入法的繁体支持也是一言难尽</p></li><li><p>搜狗输入法的定制能力也着实不满足我的需求。。</p></li></ol><p>因此我在18年开始在寻求一种开源，可控，可定制，对简/繁输入都比较友好的输入法。经过寻找之后，Rime 输入法进入了我的视线，经过一年多的使用，我觉得这个真的是一款非常棒的输入法</p><h2 id="Rime-是什么？"><a href="#Rime-是什么？" class="headerlink" title="Rime 是什么？"></a>Rime 是什么？</h2><p><code>Rime</code> （又名 <code>中州韻</code>）是一款开源的跨平台的输入法引擎，完全开源，完全可定制，你甚至可以基于 <a href="https://github.com/rime">Rime</a> 的源码，来封装一套自己的输入法引擎。同时因为 <code>Rime</code> 极其高的定制性，你可以基于 <code>Rime</code> 制作自己的输入法。</p><p><code>Rime</code> 的优势主要在于通过配置文件的方式，对扩展提供了极好的支持，而且繁体支持非常棒</p><p>举个例子</p><p><img src="https://user-images.githubusercontent.com/7054676/73233134-98204780-41c0-11ea-92a0-1476e13a3513.png" alt="非常好的繁体支持"></p><p>在这里，「才」「纔」不一樣。还有很多的例子，大家可以自行体验。</p><p>但是 <code>Rime</code> 成也极高的定制性，败也极高的定制性，对于使用者而言，纯 YAML 配置文件的定制方式，准入门槛太高</p><h2 id="让你的-Rime-更好用"><a href="#让你的-Rime-更好用" class="headerlink" title="让你的 Rime 更好用"></a>让你的 Rime 更好用</h2><p>首先上一下我的 Rime 配置的效果</p><p><img src="https://user-images.githubusercontent.com/7054676/73233509-b8043b00-41c1-11ea-9ed4-84fd3defb3cc.png" alt=""></p><p><img src="https://user-images.githubusercontent.com/7054676/73233538-cf432880-41c1-11ea-9365-f94d5d4942cf.png" alt=""></p><p><img src="https://user-images.githubusercontent.com/7054676/73233565-e124cb80-41c1-11ea-840e-4298cf21c5b2.png" alt=""></p><p><img src="https://user-images.githubusercontent.com/7054676/73233572-e84bd980-41c1-11ea-96e6-9eeff08f167c.png" alt=""></p><p><img src="https://user-images.githubusercontent.com/7054676/73233587-f0a41480-41c1-11ea-94e0-a1c8807ed470.png" alt=""></p><p><img src="https://user-images.githubusercontent.com/7054676/73233626-07e30200-41c2-11ea-8993-74daed08c45d.png" alt=""></p><p>好了，我们开始来聊聊怎么安装配置 <code>Rime</code></p><h3 id="Rime-基础安装"><a href="#Rime-基础安装" class="headerlink" title="Rime 基础安装"></a>Rime 基础安装</h3><p>没啥好说的，从<a href="https://rime.im/download/">官网</a> 下载对应平台的安装包安装即可，在 MacOS 下，<code>Rime</code> 的配置在 <code>~/Library/Rime</code> 下，大家可以用 VSCode 之类的文本编辑器打开对应的目录，进行编辑</p><p>官方并不建议直接修改原始的配置文件，因为输入法更新时会重新覆盖默认配置，可能导致某些自定义配置丢失；推荐作法是创建一系列的 patch 配置，通过类似打补丁替换这种方式来实现无感的增加自定义配置；</p><h3 id="Rime-配色"><a href="#Rime-配色" class="headerlink" title="Rime 配色"></a>Rime 配色</h3><p><code>Rime</code> 的配色管理文件是 <code>squirrel.custom.yaml</code>，我自己使用了网友贡献的<a href="https://github.com/ryekee/rime-color-scheme">即刻黄</a>配色</p><p>想要切换皮肤配色只需要修改 style/color_scheme 为相应的皮肤配色名称既可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">app_options:</span></span><br><span class="line">    <span class="attr">&quot;com.runningwithcrayons.Alfred-3&quot;:</span></span><br><span class="line">      <span class="attr">ascii_mode:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">com.google.android.studio:</span></span><br><span class="line">      <span class="attr">ascii_mode:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">com.jetbrains.intellij:</span></span><br><span class="line">      <span class="attr">ascii_mode:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">show_notifications_when:</span> <span class="string">appropriate</span> <span class="comment"># 状态通知，适当(appropriate)，开（always）关（never）</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">style:</span></span><br><span class="line">    <span class="attr">color_scheme:</span> <span class="string">jike</span></span><br><span class="line">  <span class="attr">preset_color_schemes:</span></span><br><span class="line">    <span class="attr">apathy:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&quot;冷漠 / Apathy&quot;</span></span><br><span class="line">      <span class="attr">author:</span> <span class="string">&quot;LIANG Hai &quot;</span></span><br><span class="line">      <span class="attr">horizontal:</span> <span class="literal">true</span> <span class="comment"># 水平排列</span></span><br><span class="line">      <span class="attr">inline_preedit:</span> <span class="literal">true</span> <span class="comment">#单行显示，false双行显示</span></span><br><span class="line">      <span class="attr">candidate_format:</span> <span class="string">&quot;%c\u2005%@\u2005&quot;</span> <span class="comment"># 编号 %c 和候选词 %@ 前后的空间</span></span><br><span class="line">      <span class="attr">corner_radius:</span> <span class="number">5</span> <span class="comment">#候选条圆角</span></span><br><span class="line">      <span class="attr">border_height:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">border_width:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">back_color:</span> <span class="number">0xFFFFFF</span> <span class="comment">#候选条背景色</span></span><br><span class="line">      <span class="attr">font_face:</span> <span class="string">&quot;PingFangSC-Regular,HanaMinB&quot;</span> <span class="comment">#候选词字体</span></span><br><span class="line">      <span class="attr">font_point:</span> <span class="number">16</span> <span class="comment">#候选字词大小</span></span><br><span class="line">      <span class="attr">text_color:</span> <span class="number">0x424242</span> <span class="comment">#高亮选中词颜色</span></span><br><span class="line">      <span class="attr">label_font_face:</span> <span class="string">&quot;STHeitiSC-Light&quot;</span> <span class="comment">#候选词编号字体</span></span><br><span class="line">      <span class="attr">label_font_point:</span> <span class="number">12</span> <span class="comment">#候选编号大小</span></span><br><span class="line">      <span class="attr">hilited_candidate_text_color:</span> <span class="number">0xEE6E00</span> <span class="comment">#候选文字颜色</span></span><br><span class="line">      <span class="attr">hilited_candidate_back_color:</span> <span class="number">0xFFF0E4</span> <span class="comment">#候选文字背景色</span></span><br><span class="line">      <span class="attr">comment_text_color:</span> <span class="number">0x999999</span> <span class="comment">#拼音等提示文字颜色</span></span><br><span class="line">    <span class="attr">jike:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">即刻黄</span></span><br><span class="line">      <span class="attr">author:</span> <span class="string">Ryekee</span></span><br><span class="line">      <span class="attr">back_color:</span> <span class="number">0x11E4FF</span></span><br><span class="line">      <span class="attr">corner_radius:</span> <span class="number">5</span> <span class="comment">#候选条圆角</span></span><br><span class="line">      <span class="attr">border_height:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">border_width:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">candidate_format:</span> <span class="string">&quot;%c\u2005%@\u2005&quot;</span></span><br><span class="line">      <span class="attr">candidate_text_color:</span> <span class="number">0x362915</span></span><br><span class="line">      <span class="attr">comment_text_color:</span> <span class="number">0x000000</span></span><br><span class="line">      <span class="attr">font_face:</span> <span class="string">&quot;PingFangSC-Regular,HanaMinB&quot;</span></span><br><span class="line">      <span class="attr">font_point:</span> <span class="number">16</span> <span class="comment">#候选字词大小</span></span><br><span class="line">      <span class="attr">hilited_candidate_back_color:</span> <span class="number">0xF4B95F</span></span><br><span class="line">      <span class="attr">hilited_candidate_text_color:</span> <span class="number">0xFFFFFF</span></span><br><span class="line">      <span class="attr">horizontal:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">inline_preedit:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">label_font_face:</span> <span class="string">&quot;STHeitiSC-Light&quot;</span></span><br><span class="line">      <span class="attr">label_font_point:</span> <span class="number">12</span></span><br><span class="line">      <span class="attr">text_color:</span> <span class="number">0xFFFFFF</span></span><br></pre></td></tr></table></figure><h3 id="Rime-快捷键字符"><a href="#Rime-快捷键字符" class="headerlink" title="Rime 快捷键字符"></a>Rime 快捷键字符</h3><p>在 <code>Rime</code> 中，可以设置一些快捷键帮助输入一些特殊字符和表情。默认自带了很多，</p><p>比如输入 <code>/bg</code> 会给出八卦图案的列表</p><p><img src="https://user-images.githubusercontent.com/7054676/73234311-6e691f80-41c4-11ea-9855-2c3c11768027.png" alt="八卦"></p><p>比如输入 <code>/xl</code> 会给出希腊字符的列表</p><p><img src="https://user-images.githubusercontent.com/7054676/73234337-8f317500-41c4-11ea-80c2-91cec9c2480b.png" alt="希腊字符"></p><p>更多的快捷输入可以参看 <code>symbols.yaml</code> 下的列表，其中一些比较好玩的给大家看看</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#月份、日期、曜日等</span></span><br><span class="line">    <span class="string">&#x27;/yf&#x27;</span><span class="string">:</span> [ <span class="string">㋀</span>, <span class="string">㋁</span>, <span class="string">㋂</span>, <span class="string">㋃</span>, <span class="string">㋄</span>, <span class="string">㋅</span>, <span class="string">㋆</span>, <span class="string">㋇</span>, <span class="string">㋈</span>, <span class="string">㋉</span>, <span class="string">㋊</span>, <span class="string">㋋</span> ]</span><br><span class="line">    <span class="string">&#x27;/rq&#x27;</span><span class="string">:</span> [ <span class="string">㏠</span>, <span class="string">㏡</span>, <span class="string">㏢</span>, <span class="string">㏣</span>, <span class="string">㏤</span>, <span class="string">㏥</span>, <span class="string">㏦</span>, <span class="string">㏧</span>, <span class="string">㏨</span>, <span class="string">㏩</span>, <span class="string">㏪</span>, <span class="string">㏫</span>, <span class="string">㏬</span>, <span class="string">㏭</span>, <span class="string">㏮</span>, <span class="string">㏯</span>, <span class="string">㏰</span>, <span class="string">㏱</span>, <span class="string">㏲</span>, <span class="string">㏳</span>, <span class="string">㏴</span>, <span class="string">㏵</span>, <span class="string">㏶</span>, <span class="string">㏷</span>, <span class="string">㏸</span>, <span class="string">㏹</span>, <span class="string">㏺</span>, <span class="string">㏻</span>, <span class="string">㏼</span>, <span class="string">㏽</span>, <span class="string">㏾</span> ]</span><br><span class="line">    <span class="string">&#x27;/yr&#x27;</span><span class="string">:</span> [ <span class="string">月</span>, <span class="string">火</span>, <span class="string">水</span>, <span class="string">木</span>, <span class="string">金</span>, <span class="string">土</span>, <span class="string">日</span>, <span class="string">㊊</span>, <span class="string">㊋</span>, <span class="string">㊌</span>, <span class="string">㊍</span>, <span class="string">㊎</span>, <span class="string">㊏</span>, <span class="string">㊐</span>, <span class="string">㊗</span>, <span class="string">㊡</span>, <span class="string">㈪</span>, <span class="string">㈫</span>, <span class="string">㈬</span>, <span class="string">㈭</span>, <span class="string">㈮</span>, <span class="string">㈯</span>, <span class="string">㈰</span>, <span class="string">㈷</span>, <span class="string">㉁</span>, <span class="string">㉀</span> ]</span><br><span class="line"><span class="comment">#時間</span></span><br><span class="line">    <span class="string">&#x27;/sj&#x27;</span><span class="string">:</span> [ <span class="string">㍘</span>, <span class="string">㍙</span>, <span class="string">㍚</span>, <span class="string">㍛</span>, <span class="string">㍜</span>, <span class="string">㍝</span>, <span class="string">㍞</span>, <span class="string">㍟</span>, <span class="string">㍠</span>, <span class="string">㍡</span>, <span class="string">㍢</span>, <span class="string">㍣</span>, <span class="string">㍤</span>, <span class="string">㍥</span>, <span class="string">㍦</span>, <span class="string">㍧</span>, <span class="string">㍨</span>, <span class="string">㍩</span>, <span class="string">㍪</span>, <span class="string">㍫</span>, <span class="string">㍬</span>, <span class="string">㍭</span>, <span class="string">㍮</span>, <span class="string">㍯</span>, <span class="string">㍰</span> ]</span><br><span class="line"><span class="comment">#天干、地支、干支</span></span><br><span class="line">    <span class="string">&#x27;/tg&#x27;</span><span class="string">:</span> [ <span class="string">甲</span>, <span class="string">乙</span>, <span class="string">丙</span>, <span class="string">丁</span>, <span class="string">戊</span>, <span class="string">己</span>, <span class="string">庚</span>, <span class="string">辛</span>, <span class="string">壬</span>, <span class="string">癸</span> ]</span><br><span class="line">    <span class="string">&#x27;/dz&#x27;</span><span class="string">:</span> [ <span class="string">子</span>, <span class="string">丑</span>, <span class="string">寅</span>, <span class="string">卯</span>, <span class="string">辰</span>, <span class="string">巳</span>, <span class="string">午</span>, <span class="string">未</span>, <span class="string">申</span>, <span class="string">酉</span>, <span class="string">戌</span>, <span class="string">亥</span> ]</span><br><span class="line">    <span class="string">&#x27;/gz&#x27;</span><span class="string">:</span> [ <span class="string">甲子</span>, <span class="string">乙丑</span>, <span class="string">丙寅</span>, <span class="string">丁卯</span>, <span class="string">戊辰</span>, <span class="string">己巳</span>, <span class="string">庚午</span>, <span class="string">辛未</span>, <span class="string">壬申</span>, <span class="string">癸酉</span>, <span class="string">甲戌</span>, <span class="string">乙亥</span>, <span class="string">丙子</span>, <span class="string">丁丑</span>, <span class="string">戊寅</span>, <span class="string">己卯</span>, <span class="string">庚辰</span>, <span class="string">辛巳</span>, <span class="string">壬午</span>, <span class="string">癸未</span>, <span class="string">甲申</span>, <span class="string">乙酉</span>, <span class="string">丙戌</span>, <span class="string">丁亥</span>, <span class="string">戊子</span>, <span class="string">己丑</span>, <span class="string">庚寅</span>, <span class="string">辛卯</span>, <span class="string">壬辰</span>, <span class="string">癸巳</span>, <span class="string">甲午</span>, <span class="string">乙未</span>, <span class="string">丙申</span>, <span class="string">丁酉</span>, <span class="string">戊戌</span>, <span class="string">己亥</span>, <span class="string">庚子</span>, <span class="string">辛丑</span>, <span class="string">壬寅</span>, <span class="string">癸卯</span>, <span class="string">甲辰</span>, <span class="string">乙巳</span>, <span class="string">丙午</span>, <span class="string">丁未</span>, <span class="string">戊申</span>, <span class="string">己酉</span>, <span class="string">庚戌</span>, <span class="string">辛亥</span>, <span class="string">壬子</span>, <span class="string">癸丑</span>, <span class="string">甲寅</span>, <span class="string">乙卯</span>, <span class="string">丙辰</span>, <span class="string">丁巳</span>, <span class="string">戊午</span>, <span class="string">己未</span>, <span class="string">庚申</span>, <span class="string">辛酉</span>, <span class="string">壬戌</span>, <span class="string">癸亥</span> ]</span><br><span class="line"><span class="comment">#節氣</span></span><br><span class="line">    <span class="string">&#x27;/jq&#x27;</span><span class="string">:</span> [ <span class="string">立春</span>, <span class="string">雨水</span>, <span class="string">驚蟄</span>, <span class="string">春分</span>, <span class="string">清明</span>, <span class="string">穀雨</span>, <span class="string">立夏</span>, <span class="string">小滿</span>, <span class="string">芒種</span>, <span class="string">夏至</span>, <span class="string">小暑</span>, <span class="string">大暑</span>, <span class="string">立秋</span>, <span class="string">處暑</span>, <span class="string">白露</span>, <span class="string">秋分</span>, <span class="string">寒露</span>, <span class="string">霜降</span>, <span class="string">立冬</span>, <span class="string">小雪</span>, <span class="string">大雪</span>, <span class="string">冬至</span>, <span class="string">小寒</span>, <span class="string">大寒</span> ]</span><br><span class="line"><span class="comment">#單位</span></span><br><span class="line">    <span class="string">&#x27;/dw&#x27;</span><span class="string">:</span> [ <span class="string">Å</span>, <span class="string">℃</span>, <span class="string">％</span>, <span class="string">‰</span>, <span class="string">‱</span>, <span class="string">°</span>, <span class="string">℉</span>, <span class="string">㏃</span>, <span class="string">㏆</span>, <span class="string">㎈</span>, <span class="string">㏄</span>, <span class="string">㏅</span>, <span class="string">㎝</span>, <span class="string">㎠</span>, <span class="string">㎤</span>, <span class="string">㏈</span>, <span class="string">㎗</span>, <span class="string">㎙</span>, <span class="string">㎓</span>, <span class="string">㎬</span>, <span class="string">㏉</span>, <span class="string">㏊</span>, <span class="string">㏋</span>, <span class="string">㎐</span>, <span class="string">㏌</span>, <span class="string">㎄</span>, <span class="string">㎅</span>, <span class="string">㎉</span>, <span class="string">㎏</span>, <span class="string">㎑</span>, <span class="string">㏍</span>, <span class="string">㎘</span>, <span class="string">㎞</span>, <span class="string">㏎</span>, <span class="string">㎢</span>, <span class="string">㎦</span>, <span class="string">㎪</span>, <span class="string">㏏</span>, <span class="string">㎸</span>, <span class="string">㎾</span>, <span class="string">㏀</span>, <span class="string">㏐</span>, <span class="string">㏓</span>, <span class="string">㎧</span>, <span class="string">㎨</span>, <span class="string">㎡</span>, <span class="string">㎥</span>, <span class="string">㎃</span>, <span class="string">㏔</span>, <span class="string">㎆</span>, <span class="string">㎎</span>, <span class="string">㎒</span>, <span class="string">㏕</span>, <span class="string">㎖</span>, <span class="string">㎜</span>, <span class="string">㎟</span>, <span class="string">㎣</span>, <span class="string">㏖</span>, <span class="string">㎫</span>, <span class="string">㎳</span>, <span class="string">㎷</span>, <span class="string">㎹</span>, <span class="string">㎽</span>, <span class="string">㎿</span>, <span class="string">㏁</span>, <span class="string">㎁</span>, <span class="string">㎋</span>, <span class="string">㎚</span>, <span class="string">㎱</span>, <span class="string">㎵</span>, <span class="string">㎻</span>, <span class="string">㏘</span>, <span class="string">㎩</span>, <span class="string">㎀</span>, <span class="string">㎊</span>, <span class="string">㏗</span>, <span class="string">㏙</span>, <span class="string">㏚</span>, <span class="string">㎰</span>, <span class="string">㎴</span>, <span class="string">㎺</span>, <span class="string">㎭</span>, <span class="string">㎮</span>, <span class="string">㎯</span>, <span class="string">㏛</span>, <span class="string">㏜</span>, <span class="string">㎔</span>, <span class="string">㏝</span>, <span class="string">㎂</span>, <span class="string">㎌</span>, <span class="string">㎍</span>, <span class="string">㎕</span>, <span class="string">㎛</span>, <span class="string">㎲</span>, <span class="string">㎶</span>, <span class="string">㎼</span> ]</span><br><span class="line"><span class="comment">#貨幣</span></span><br><span class="line">    <span class="string">&#x27;/hb&#x27;</span><span class="string">:</span> [ <span class="string">￥</span>, <span class="string">¥</span>, <span class="string">¤</span>, <span class="string">￠</span>, <span class="string">＄</span>, <span class="string">$</span>, <span class="string">￡</span>, <span class="string">£</span>, <span class="string">৳</span>, <span class="string">฿</span>, <span class="string">₠</span>, <span class="string">₡</span>, <span class="string">₢</span>, <span class="string">₣</span>, <span class="string">₤</span>, <span class="string">₥</span>, <span class="string">₦</span>, <span class="string">₧</span>, <span class="string">₩</span>, <span class="string">₪</span>, <span class="string">₫</span>, <span class="string">€</span>, <span class="string">₭</span>, <span class="string">₮</span>, <span class="string">₯</span>, <span class="string">₰</span>, <span class="string">₱</span>, <span class="string">₲</span>, <span class="string">₳</span>, <span class="string">₴</span>, <span class="string">₵</span>, <span class="string">₶</span>, <span class="string">₷</span>, <span class="string">₸</span>, <span class="string">₹</span>, <span class="string">₺</span>, <span class="string">₨</span>, <span class="string">﷼</span> ]</span><br></pre></td></tr></table></figure><p>而我参考<a href="https://mritd.me/2019/03/23/oh-my-rime/">漠然</a>的配置，在 <code>luna_pinyin_simp.custom.yaml</code> 中添加了一些配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">punctuator:</span></span><br><span class="line">  <span class="attr">import_preset:</span> <span class="string">symbols</span></span><br><span class="line">  <span class="attr">symbols:</span></span><br><span class="line">    <span class="string">&quot;/fs&quot;</span><span class="string">:</span> [<span class="string">½</span>,<span class="string">‰</span>,<span class="string">¼</span>,<span class="string">⅓</span>,<span class="string">⅔</span>,<span class="string">¾</span>,<span class="string">⅒</span>]</span><br><span class="line">    <span class="string">&quot;/dq&quot;</span><span class="string">:</span> [<span class="string">🌍</span>,<span class="string">🌎</span>,<span class="string">🌏</span>,<span class="string">🌐</span>,<span class="string">🌑</span>,<span class="string">🌒</span>,<span class="string">🌓</span>,<span class="string">🌔</span>,<span class="string">🌕</span>,<span class="string">🌖</span>,<span class="string">🌗</span>,<span class="string">🌘</span>,<span class="string">🌙</span>,<span class="string">🌚</span>,<span class="string">🌛</span>,<span class="string">🌜</span>,<span class="string">🌝</span>,<span class="string">🌞</span>,<span class="string">⭐</span>,<span class="string">🌟</span>,<span class="string">🌠</span>,<span class="string">⛅</span>,<span class="string">⚡</span>,<span class="string">❄</span>,<span class="string">🔥</span>,<span class="string">💧</span>,<span class="string">🌊</span>]</span><br><span class="line">    <span class="string">&quot;/jt&quot;</span><span class="string">:</span> [<span class="string">⬆</span>,<span class="string">↗</span>,<span class="string">➡</span>,<span class="string">↘</span>,<span class="string">⬇</span>,<span class="string">↙</span>,<span class="string">⬅</span>,<span class="string">↖</span>,<span class="string">↕</span>,<span class="string">↔</span>,<span class="string">↩</span>,<span class="string">↪</span>,<span class="string">⤴</span>,<span class="string">⤵</span>,<span class="string">🔃</span>,<span class="string">🔄</span>,<span class="string">🔙</span>,<span class="string">🔚</span>,<span class="string">🔛</span>,<span class="string">🔜</span>,<span class="string">🔝</span>]</span><br><span class="line">    <span class="string">&quot;/sg&quot;</span><span class="string">:</span> [<span class="string">🍇</span>,<span class="string">🍈</span>,<span class="string">🍉</span>,<span class="string">🍊</span>,<span class="string">🍋</span>,<span class="string">🍌</span>,<span class="string">🍍</span>,<span class="string">🍎</span>,<span class="string">🍏</span>,<span class="string">🍐</span>,<span class="string">🍑</span>,<span class="string">🍒</span>,<span class="string">🍓</span>,<span class="string">🍅</span>,<span class="string">🍆</span>,<span class="string">🌽</span>,<span class="string">🍄</span>,<span class="string">🌰</span>,<span class="string">🍞</span>,<span class="string">🍖</span>,<span class="string">🍗</span>,<span class="string">🍔</span>,<span class="string">🍟</span>,<span class="string">🍕</span>,<span class="string">🍳</span>,<span class="string">🍲</span>,<span class="string">🍱</span>,<span class="string">🍘</span>,<span class="string">🍙</span>,<span class="string">🍚</span>,<span class="string">🍛</span>,<span class="string">🍜</span>,<span class="string">🍝</span>,<span class="string">🍠</span>,<span class="string">🍢</span>,<span class="string">🍣</span>,<span class="string">🍤</span>,<span class="string">🍥</span>,<span class="string">🍡</span>,<span class="string">🍦</span>,<span class="string">🍧</span>,<span class="string">🍨</span>,<span class="string">🍩</span>,<span class="string">🍪</span>,<span class="string">🎂</span>,<span class="string">🍰</span>,<span class="string">🍫</span>,<span class="string">🍬</span>,<span class="string">🍭</span>,<span class="string">🍮</span>,<span class="string">🍯</span>,<span class="string">🍼</span>,<span class="string">🍵</span>,<span class="string">🍶</span>,<span class="string">🍷</span>,<span class="string">🍸</span>,<span class="string">🍹</span>,<span class="string">🍺</span>,<span class="string">🍻</span>,<span class="string">🍴</span>]</span><br><span class="line">    <span class="string">&quot;/dw&quot;</span><span class="string">:</span> [<span class="string">🙈</span>,<span class="string">🙉</span>,<span class="string">🙊</span>,<span class="string">🐵</span>,<span class="string">🐒</span>,<span class="string">🐶</span>,<span class="string">🐕</span>,<span class="string">🐩</span>,<span class="string">🐺</span>,<span class="string">🐱</span>,<span class="string">😺</span>,<span class="string">😸</span>,<span class="string">😹</span>,<span class="string">😻</span>,<span class="string">😼</span>,<span class="string">😽</span>,<span class="string">🙀</span>,<span class="string">😿</span>,<span class="string">😾</span>,<span class="string">🐈</span>,<span class="string">🐯</span>,<span class="string">🐅</span>,<span class="string">🐆</span>,<span class="string">🐴</span>,<span class="string">🐎</span>,<span class="string">🐮</span>,<span class="string">🐂</span>,<span class="string">🐃</span>,<span class="string">🐄</span>,<span class="string">🐷</span>,<span class="string">🐖</span>,<span class="string">🐗</span>,<span class="string">🐽</span>,<span class="string">🐏</span>,<span class="string">🐑</span>,<span class="string">🐐</span>,<span class="string">🐪</span>,<span class="string">🐫</span>,<span class="string">🐘</span>,<span class="string">🐭</span>,<span class="string">🐁</span>,<span class="string">🐀</span>,<span class="string">🐹</span>,<span class="string">🐰</span>,<span class="string">🐇</span>,<span class="string">🐻</span>,<span class="string">🐨</span>,<span class="string">🐼</span>,<span class="string">🐾</span>,<span class="string">🐔</span>,<span class="string">🐓</span>,<span class="string">🐣</span>,<span class="string">🐤</span>,<span class="string">🐥</span>,<span class="string">🐦</span>,<span class="string">🐧</span>,<span class="string">🐸</span>,<span class="string">🐊</span>,<span class="string">🐢</span>,<span class="string">🐍</span>,<span class="string">🐲</span>,<span class="string">🐉</span>,<span class="string">🐳</span>,<span class="string">🐋</span>,<span class="string">🐬</span>,<span class="string">🐟</span>,<span class="string">🐠</span>,<span class="string">🐡</span>,<span class="string">🐙</span>,<span class="string">🐚</span>,<span class="string">🐌</span>,<span class="string">🐛</span>,<span class="string">🐜</span>,<span class="string">🐝</span>,<span class="string">🐞</span>,<span class="string">🦋</span>]</span><br><span class="line">    <span class="string">&quot;/bq&quot;</span><span class="string">:</span> [<span class="string">😀</span>,<span class="string">😁</span>,<span class="string">😂</span>,<span class="string">😃</span>,<span class="string">😄</span>,<span class="string">😅</span>,<span class="string">😆</span>,<span class="string">😉</span>,<span class="string">😊</span>,<span class="string">😋</span>,<span class="string">😎</span>,<span class="string">😍</span>,<span class="string">😘</span>,<span class="string">😗</span>,<span class="string">😙</span>,<span class="string">😚</span>,<span class="string">😇</span>,<span class="string">😐</span>,<span class="string">😑</span>,<span class="string">😶</span>,<span class="string">😏</span>,<span class="string">😣</span>,<span class="string">😥</span>,<span class="string">😮</span>,<span class="string">😯</span>,<span class="string">😪</span>,<span class="string">😫</span>,<span class="string">😴</span>,<span class="string">😌</span>,<span class="string">😛</span>,<span class="string">😜</span>,<span class="string">😝</span>,<span class="string">😒</span>,<span class="string">😓</span>,<span class="string">😔</span>,<span class="string">😕</span>,<span class="string">😲</span>,<span class="string">😷</span>,<span class="string">😖</span>,<span class="string">😞</span>,<span class="string">😟</span>,<span class="string">😤</span>,<span class="string">😢</span>,<span class="string">😭</span>,<span class="string">😦</span>,<span class="string">😧</span>,<span class="string">😨</span>,<span class="string">😬</span>,<span class="string">😰</span>,<span class="string">😱</span>,<span class="string">😳</span>,<span class="string">😵</span>,<span class="string">😡</span>,<span class="string">😠</span>]</span><br><span class="line">    <span class="string">&quot;/ss&quot;</span><span class="string">:</span> [<span class="string">💪</span>,<span class="string">👈</span>,<span class="string">👉</span>,<span class="string">👆</span>,<span class="string">👇</span>,<span class="string">✋</span>,<span class="string">👌</span>,<span class="string">👍</span>,<span class="string">👎</span>,<span class="string">✊</span>,<span class="string">👊</span>,<span class="string">👋</span>,<span class="string">👏</span>,<span class="string">👐</span>]</span><br><span class="line">    <span class="string">&quot;/dn&quot;</span><span class="string">:</span> [<span class="string">⌘</span>, <span class="string">⌥</span>, <span class="string">⇧</span>, <span class="string">⌃</span>, <span class="string">⎋</span>, <span class="string">⇪</span>, <span class="string"></span>, <span class="string">⌫</span>, <span class="string">⌦</span>, <span class="string">↩︎</span>, <span class="string">⏎</span>, <span class="string">↑</span>, <span class="string">↓</span>, <span class="string">←</span>, <span class="string">→</span>, <span class="string">↖</span>, <span class="string">↘</span>, <span class="string">⇟</span>, <span class="string">⇞</span>]</span><br><span class="line">    <span class="string">&quot;/fh&quot;</span><span class="string">:</span> [<span class="string">©</span>,<span class="string">®</span>,<span class="string">℗</span>,<span class="string">ⓘ</span>,<span class="string">℠</span>,<span class="string">™</span>,<span class="string">℡</span>,<span class="string">␡</span>,<span class="string">♂</span>,<span class="string">♀</span>,<span class="string">☉</span>,<span class="string">☊</span>,<span class="string">☋</span>,<span class="string">☌</span>,<span class="string">☍</span>,<span class="string">☑︎</span>,<span class="string">☒</span>,<span class="string">☜</span>,<span class="string">☝</span>,<span class="string">☞</span>,<span class="string">☟</span>,<span class="string">✎</span>,<span class="string">✄</span>,<span class="string">♻</span>,<span class="string">⚐</span>,<span class="string">⚑</span>,<span class="string">⚠</span>]</span><br><span class="line">    <span class="string">&quot;/xh&quot;</span><span class="string">:</span> [<span class="string">＊</span>,<span class="string">×</span>,<span class="string">✱</span>,<span class="string">★</span>,<span class="string">☆</span>,<span class="string">✩</span>,<span class="string">✧</span>,<span class="string">❋</span>,<span class="string">❊</span>,<span class="string">❉</span>,<span class="string">❈</span>,<span class="string">❅</span>,<span class="string">✿</span>,<span class="string">✲</span>]</span><br></pre></td></tr></table></figure><h3 id="设置输入法"><a href="#设置输入法" class="headerlink" title="设置输入法"></a>设置输入法</h3><p>大家可以在 <code>default.custom.yaml</code> 中设置自己喜欢的输入法，我目前使用的是明月拼音，默认切换输入法的快捷键是 <code>Ctrl+~</code> 但是因为这个快捷键和 VSCode 快捷键冲突，所以我将其改为 <code>Ctrl+Shift+F12</code> </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">patch:</span></span><br><span class="line">  <span class="attr">menu:</span></span><br><span class="line">    <span class="attr">page_size:</span> <span class="number">8</span></span><br><span class="line">  <span class="attr">schema_list:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">schema:</span> <span class="string">luna_pinyin_simp</span>      <span class="comment"># 朙月拼音 简化字</span></span><br><span class="line">  <span class="attr">&quot;switcher/hotkeys&quot;:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;Control+Shift+F12&quot;</span></span><br></pre></td></tr></table></figure><h3 id="调教词库"><a href="#调教词库" class="headerlink" title="调教词库"></a>调教词库</h3><p>这里引用<a href="https://mritd.me/2019/03/23/oh-my-rime/">漠然</a>的讲解：</p><blockquote><p>Rime 默认的词库稍为有点弱，我们可以下载一些搜狗词库来进行扩展；不过搜狗词库格式默认是无法解析的，好在有人开发了工具可以方便的将搜狗细胞词库转化为 Rime 的格式(工具点击这里下载)；目前该工具只支持 Windows(也有些别人写的 py 脚本啥的，但是我没用)，所以词库转换这种操作还得需要一个 Windows 虚拟机；<br>转换过程很简单，先从搜狗词库下载一系列的 scel 文件，然后批量选中，接着调整一下输入和输出格式点击转换，最后保存成一个 txt 文本<br>光有这个文本还不够，我们要将它塞到词库的 yaml 配置里，所以新建一个词库配置文件 luna_pinyin.sougou.dict.yaml，然后写上头部说明(注意最后三个点后面加一个换行)</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rime dictionary</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"><span class="comment"># 搜狗词库 目前包含如下:</span></span><br><span class="line"><span class="comment"># IT计算机 实用IT词汇 亲戚称呼 化学品名 数字时间 数学词汇 淘宝词库 编程语言 软件专业 颜色名称 程序猿词库 开发专用词库 搜狗标准词库</span></span><br><span class="line"><span class="comment"># 摄影专业名词 计算机专业词库 计算机词汇大全 保险词汇 最详细的全国地名大全 饮食大全 常见花卉名称 房地产词汇大全 中国传统节日大全 财经金融词汇大全</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">luna_pinyin.sougou</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="attr">sort:</span> <span class="string">by_weight</span></span><br><span class="line"><span class="attr">use_preset_vocabulary:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><blockquote><p>接着只需要把生成好的词库 txt 文件内容粘贴到三个点下面既可；但是词库太多的话你会发现这个文本有好几十 M，一般编辑器打开都会卡死，解决这种情况只需要用命令行 cat 一下就行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> sougou.txt &gt;&gt; luna_pinyin.sougou.dict.yaml</span><br></pre></td></tr></table></figure><blockquote><p>最后修改 luna_pinyin.extended.dict.yaml 中的 import_tables 字段，加入刚刚新建的词库既可</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">luna_pinyin.extended</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;2016.06.26&quot;</span></span><br><span class="line"><span class="attr">sort:</span> <span class="string">by_weight</span>  <span class="comment">#字典初始排序，可選original或by_weight</span></span><br><span class="line"><span class="attr">use_preset_vocabulary:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#此處爲明月拼音擴充詞庫（基本）默認鏈接載入的詞庫，有朙月拼音官方詞庫、明月拼音擴充詞庫（漢語大詞典）、明月拼音擴充詞庫（詩詞）、明月拼音擴充詞庫（含西文的詞彙）。如果不需要加載某个詞庫請將其用「#」註釋掉。</span></span><br><span class="line"><span class="comment">#雙拼不支持 luna_pinyin.cn_en 詞庫，請用戶手動禁用。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">import_tables:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">luna_pinyin</span></span><br><span class="line">  <span class="comment"># 加入搜狗词库</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">luna_pinyin.sougou</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">luna_pinyin.poetry</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">luna_pinyin.cn_en</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">luna_pinyin.kaomoji</span></span><br></pre></td></tr></table></figure><p>在我的配置中，我加入了来自搜狗的医学，古诗词，军事等词库（逃</p><h3 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h3><p>这里参考了 <code>Rime</code> 作者的一个 <a href="https://gist.github.com/lotem/2981316">Gist</a> 对快捷键做了一些配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ascii_composer/good_old_caps_lock:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">ascii_composer/switch_key:</span></span><br><span class="line">  <span class="attr">Caps_Lock:</span> <span class="string">commit_code</span></span><br><span class="line">  <span class="attr">Control_L:</span> <span class="string">noop</span></span><br><span class="line">  <span class="attr">Control_R:</span> <span class="string">noop</span></span><br><span class="line">  <span class="comment"># 按下左 shift 英文字符直接上屏，不需要再次回车，输入法保持英文状态</span></span><br><span class="line">  <span class="attr">Shift_L:</span> <span class="string">commit_code</span></span><br><span class="line">  <span class="attr">Shift_R:</span> <span class="string">noop</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过这一系列折腾下来，我们 <code>Rime</code> 应该就能满足我们日常的使用了，文中的配置都可以直接用我放在 GitHub 上的配置实现开箱即用 <a href="https://github.com/Zheaoli/RimeConfig">RimeConfig</a></p><p>可能有人想问，为什么对于一个输入法都需要这么多的时间进行调教？是这样，我觉得对于一些关系我们日常使用的基础工具，花一定量的时间去寻找合适自己，并且将其按照的自己的需求进行调教，是一件非常有意义的事。在后续的工作生活学习中，这也将极大的提升我们的幸福感与效率</p><p>嗯差不多这样吧，新年第一篇文章，祝大家新年快乐！</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 输入法 </category>
          
          <category> Rime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 输入法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单聊聊 SQL 中的 Prepared Statements</title>
      <link href="//posts/2020/01/05/simple-introdution-about-sql-prepared/"/>
      <url>//posts/2020/01/05/simple-introdution-about-sql-prepared/</url>
      
        <content type="html"><![CDATA[<p>好久没写文章了，新年还是得写点技术水文来保证下状态，正好最近遇到一个比较有意思的问题，就来简单聊聊一下关于 MySQL 中 Prepared Statements 吧</p><span id="more"></span><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p><a href="https://github.com/jinzhu/gorm">gorm</a> 是大家在使用 Go 开发时的比较常用的 ORM 了，最近在使用 gORM 的时候遇到一个很有意思的问题。首先我大概描述一下这个问题</p><p>在使用 gORM 的 <code>Raw</code> 方法进行 SQL 查询时，构造了如下类似的 SQL </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo <span class="keyword">where</span> <span class="keyword">match</span>(name) AGAINST(<span class="string">&#x27;+?&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE)</span><br></pre></td></tr></table></figure><p>在随后传入参数的时候，返回 <code>Error</code> : <strong>sql: expected 0 arguments, got 1</strong>。而其余的诸如如下的查询就正常执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo <span class="keyword">where</span> name <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure><p>最开始我以为这是 <code>gORM</code> 中拼接 SQL 模块的问题，但是看了下代码后发现一个很有趣的逻辑。<strong>gORM</strong> 中并没有拼接 <code>Raw SQL</code> 的相关逻辑，它会直接调用 Golang 中的标准库 <code>database/sql</code> 来进行 SQL 的处理，而 <code>database/sql</code> 将会直接调用对应数据库驱动的实现，我们先来看看在 <code>databse/sql</code> 中关于 Query 的逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> queryDC(ctx, txctx context.Context, dc *driverConn, releaseConn <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">error</span>)</span></span>, query <span class="type">string</span>, args []<span class="keyword">interface</span>&#123;&#125;) (*Rows, <span class="type">error</span>) &#123;</span><br><span class="line">queryerCtx, ok := dc.ci.(driver.QueryerContext)</span><br><span class="line"><span class="keyword">var</span> queryer driver.Queryer</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">queryer, ok = dc.ci.(driver.Queryer)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">var</span> nvdargs []driver.NamedValue</span><br><span class="line"><span class="keyword">var</span> rowsi driver.Rows</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">withLock(dc, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">nvdargs, err = driverArgsConnLocked(dc.ci, <span class="literal">nil</span>, args)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">rowsi, err = ctxDriverQuery(ctx, queryerCtx, queryer, query, nvdargs)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != driver.ErrSkip &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">releaseConn(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Note: ownership of dc passes to the *Rows, to be freed</span></span><br><span class="line"><span class="comment">// with releaseConn.</span></span><br><span class="line">rows := &amp;Rows&#123;</span><br><span class="line">dc:          dc,</span><br><span class="line">releaseConn: releaseConn,</span><br><span class="line">rowsi:       rowsi,</span><br><span class="line">&#125;</span><br><span class="line">rows.initContextClose(ctx, txctx)</span><br><span class="line"><span class="keyword">return</span> rows, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> si driver.Stmt</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">withLock(dc, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 比较有意思的地方</span></span><br><span class="line">si, err = ctxDriverPrepare(ctx, dc.ci, query)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">releaseConn(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ds := &amp;driverStmt&#123;Locker: dc, si: si&#125;</span><br><span class="line">rowsi, err := rowsiFromStatement(ctx, dc.ci, ds, args...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ds.Close()</span><br><span class="line">releaseConn(err)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: ownership of ci passes to the *Rows, to be freed</span></span><br><span class="line"><span class="comment">// with releaseConn.</span></span><br><span class="line">rows := &amp;Rows&#123;</span><br><span class="line">dc:          dc,</span><br><span class="line">releaseConn: releaseConn,</span><br><span class="line">rowsi:       rowsi,</span><br><span class="line">closeStmt:   ds,</span><br><span class="line">&#125;</span><br><span class="line">rows.initContextClose(ctx, txctx)</span><br><span class="line"><span class="keyword">return</span> rows, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>database/sql</code> 执行 <strong>QueryDC</strong> 逻辑时，会调用 <code>ctxDriverPrepare</code> 方法来进行 SQL Query 的预处理，我们来看看这段逻辑 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ctxDriverPrepare</span><span class="params">(ctx context.Context, ci driver.Conn, query <span class="type">string</span>)</span></span> (driver.Stmt, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ciCtx, is := ci.(driver.ConnPrepareContext); is &#123;</span><br><span class="line"><span class="keyword">return</span> ciCtx.PrepareContext(ctx, query)</span><br><span class="line">&#125;</span><br><span class="line">si, err := ci.Prepare(query)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">si.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> si, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其中，<code>ctxDriverPrepare</code> 会调用 <code>ci.Prepare(query)</code> 来执行对应 SQL Driver 实现的 <code>Prepare</code> 或者 <code>PrepareContext</code> 方法来对 SQL 预处理，在 <a href="https://github.com/go-sql-driver/mysql/blob/v1.4.1/connection_go18.go#L92">go-mysql-driver</a> 中，对应的实现是这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *mysqlConn)</span></span> PrepareContext(ctx context.Context, query <span class="type">string</span>) (driver.Stmt, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> err := mc.watchCancel(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stmt, err := mc.Prepare(query)</span><br><span class="line">mc.finish()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">stmt.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stmt, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段的逻辑是 <code>go-mysql-driver</code> 会向 MySQL 发起 <code>prepared statement</code> 请求，获取到对应的 <code>Stmt</code> 后将其返回</p><p>在 <code>stmt</code> 中包含了对应的参数数量，<code>stmt name</code> 等信息。在这里，SQL 会将 ? 等参数占位符进行解析，并告知客户端需要传入的参数数量</p><p>问题也出在这里，我们重新看一下之前的 SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> demo <span class="keyword">where</span> <span class="keyword">match</span>(name) AGAINST(<span class="string">&#x27;+?&#x27;</span> <span class="keyword">IN</span> <span class="type">BOOLEAN</span> MODE)</span><br></pre></td></tr></table></figure><p>在这里，我使用了 MySQL 5.7 后支持的 Full Text Match ，在这里，我们待匹配的字符串 <code>+?</code> 会被 MySQL 解析成为一个待查询的字符串，而不会作为占位符进行解析，那么返回 <code>stmt</code> 中，需要传入的参数数量为0，而 <code>database/sql</code> 会在后续的逻辑中对我们传入的参数和需要传入的参数数量进行匹配，如果不一致则会抛出 <code>Error</code> 。</p><p>好了，问题找到了，那么 <code>Prepared Statement</code> 究竟是什么东西，而我们为什么又需要这个？</p><h2 id="Prepared-Statement"><a href="#Prepared-Statement" class="headerlink" title="Prepared Statement"></a>Prepared Statement</h2><h3 id="什么是-Prepared-Statement？"><a href="#什么是-Prepared-Statement？" class="headerlink" title="什么是 Prepared Statement？"></a>什么是 Prepared Statement？</h3><p>其实大致的内容前面已经聊的比较清楚了，我们来重新复习下：<code>Prepared Statement</code> 是一种 MySQL（其余的诸如 PGSQL 也有类似的东西）的机制，用于预处理 SQL，将 SQL 和查询数据分离，以期保证程序的健壮性。</p><p>在 MySQL 官方的介绍中，Prepared Statement 有如下的好处</p><blockquote><ol><li>Less overhead for parsing the statement each time it is executed. Typically, database applications process large volumes of almost-identical statements, with only changes to literal or variable values in clauses such as <code>WHERE</code> for queries and deletes, <code>SET</code> for updates, and <code>VALUES</code> for inserts.</li><li>Protection against SQL injection attacks. The parameter values can contain unescaped SQL quote and delimiter characters.</li></ol></blockquote><p>简而言之是：</p><ol><li>提升性能，避免重复解析 SQL 带来的开销</li><li>避免  SQL 注入</li></ol><p>MySQL 的 <code>Prepared Statement</code> 有两种使用方式，一种是使用二进制的 <code>Prepared Protocol</code>（这个不在今天的文章的范围内，改天再写篇文章来聊聊 MySQL 中的一些二进制协议） ，一种是使用 SQL 进行处理</p><p>在 <code>Prepared Statement</code> 中有着三种命令</p><ol><li><a href="https://dev.mysql.com/doc/refman/8.0/en/prepare.html"><code>PREPARE</code></a> 用于创建一个 <code>Prepared Statement</code></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/execute.html"><code>EXECUTE</code></a> 用于执行一个 <code>Prepared Statement</code></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/deallocate-prepare.html"><code>DEALLOCATE PREPARE</code></a> 用于销毁一个 <code>Prepared Statement</code> </li></ol><p>这里需要注意一点的是，<code>Prepared Statement</code> 存在 Session 限制，一般情况下一个 <code>Prepared Statement</code> 仅存活于它被创建的 <code>Session</code> 。当连接断开，者在其余情况下 Session 失效的时候，<code>Prepared Statement</code> 会自动被销毁。</p><p>接下来，我们来动手实验下</p><h3 id="怎么使用-Prepared-Statement"><a href="#怎么使用-Prepared-Statement" class="headerlink" title="怎么使用 Prepared Statement"></a>怎么使用 Prepared Statement</h3><p>首先我们先创建一个 测试表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> `<span class="keyword">user</span>`</span><br><span class="line">(</span><br><span class="line">    `id`   <span class="type">bigint</span>(<span class="number">20</span>)   <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    <span class="keyword">primary</span> key (`id`)</span><br><span class="line">) engine <span class="operator">=</span> InnoDB</span><br><span class="line">  charset <span class="operator">=</span> <span class="string">&#x27;utf8mb4&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (`name`) <span class="keyword">values</span> (<span class="string">&#x27;abc&#x27;</span>);</span><br></pre></td></tr></table></figure><p>好了，我们先按照传统的方式进行查询下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure><p>好了，我们现在来使用 <code>Prepared Statement</code> </p><p>首先使用 <code>Prepared</code> 关键字创建一个 <code>statement</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@s</span> <span class="operator">=</span> <span class="string">&#x27;select * from user where name=?&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">PREPARE</span> demo1 <span class="keyword">from</span> <span class="variable">@s</span>;</span><br></pre></td></tr></table></figure><p>然后使用 <code>Execute</code> 关键字来执行 <code>Statement</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@a</span> <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXECUTE</span> demo1 <span class="keyword">using</span> <span class="variable">@a</span>;</span><br></pre></td></tr></table></figure><p>嗯，还是很简单的对吧</p><h3 id="为什么要使用-Prepared-Statement？"><a href="#为什么要使用-Prepared-Statement？" class="headerlink" title="为什么要使用 Prepared Statement？"></a>为什么要使用 Prepared Statement？</h3><p>其中一个很重要的理由是可以避免 <code>SQL Injection Attack</code> （SQL 注入）的情况出现，而问题在于，为什么 <code>Prepared Statement</code> 能够避免 SQL 注入？</p><p>其实很简单，我们将 <code>Query</code> 和 <code>Data</code> 进行了分离</p><p>还是以之前的表作为例子</p><p>在没有手动处理 SQL 和 参数的情况下，我们往往使用字符串拼接，那么这样会利用 SQL 语法来构造一些非法 SQL，以 Python 为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="string">&quot;&#x27;abc&#x27;;drop table user&quot;</span></span><br><span class="line">a = <span class="string">f&quot;select * from user where name=<span class="subst">&#123;b&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>那么这样一段代码将会生成这样的 SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;abc&#x27;</span>;<span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><p>嗯，，，，数据库从入门到删表跑路.pdf</p><p>那么，我们来使用 <code>Prepared Statement</code> 来看看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@a</span> <span class="operator">=</span> <span class="string">&#x27;\&#x27;</span>abc\<span class="string">&#x27;;drop table user&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXECUTE</span> demo1 <span class="keyword">using</span> <span class="variable">@a</span>;</span><br></pre></td></tr></table></figure><p>然后我们最后执行的语句是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;\&#x27;</span>abc\<span class="string">&#x27;;drop table user&#x27;</span></span><br></pre></td></tr></table></figure><p>因为我们将 Query 与 Query Params 在结构上进行了区分，这个时候我们无论输入什么，都会将其作为 Query Params 的一部分进行处理，从而避免了注入的风险</p><h3 id="Prepared-Statement-的优劣"><a href="#Prepared-Statement-的优劣" class="headerlink" title="Prepared Statement 的优劣"></a>Prepared Statement 的优劣</h3><p>好处显而易见</p><ol><li>因为数据库会对 <code>Prepared Statement</code> 进行缓存，从而免去了客户端重复处理 SQL 带来的开销</li><li>避免 <code>SQL Injection Attack</code> </li><li>语义清楚</li></ol><p>缺点也有不少</p><ol><li><code>Prepared Statement</code> 的二进制协议存在客户端兼容的问题，有些语言的客户端不一定会对 <code>Prepared Statement</code> 提供二进制的协议支持</li><li>因为存在两次与数据库的通信，在密集进行 SQL 查询的情况下，可能会出现 I/O 瓶颈</li></ol><p>所以具体还是要根据场景来做 Trade-off 了</p><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>飞机上写下这篇文章算是作为新年的一个新开始吧，争取多写文章，规范作息，好好照顾女朋友。对了，通过这段时间的一些折腾（比如解析 Binlog 之类的），突然发现 MySQL 是个宝库，后面会写几篇文章来聊聊踩坑 MySQL 中的 <code>Binlog</code> 和 <code>Protocol</code> 中的一些坑和好玩的地方（嗯 Flag ++，千万别催稿（逃</p><p>好了，今晚就先这样，飞机要落地了，我先关电脑了（逃</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>年轻人第一台 Mac，来自一个开发者的 Macbook Pro 2019 16寸简评</title>
      <link href="//posts/2019/11/25/simple-test-about-new-macbook-pro/"/>
      <url>//posts/2019/11/25/simple-test-about-new-macbook-pro/</url>
      
        <content type="html"><![CDATA[<p>从工作开始，一直就想买个 Mac，但是一直没有买成，虽说有公司配发的 Mac（这也让我从 Macbook Pro 2015 13寸到 Macbook Pro 2017 15寸，到 Macbook Pro 2017 15寸，到 Macbook Pro 2018 13寸，到 Macbook Pro 2018 15寸用了个遍，23333），但是没有自己的 Mac<br>始终是一个比较遗憾的事，所以这次新款 Mac 出来后，就瞬时公司员工优惠（官网95折）+12期免息分期入手了，现在我来从一个开发者的角度来给一个简单的评测吧</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="为什么会考虑-Mac"><a href="#为什么会考虑-Mac" class="headerlink" title="为什么会考虑 Mac"></a>为什么会考虑 Mac</h3><p>写这个文章之前，我需要介绍下我买 Mac 的背景。目前我的主力机是来自蓝天的准系统，P775TM，配置是 i7 8700+32G+512G SSD+1070。工作系统是 Manjaro（一个 Linux 发型版）。在目前开发的时候觉得非常舒服，但是我也遇到了几个问题</p><ol><li><p>太重了，有些时候临时有事需要出门带着并不方便</p></li><li><p>Linux 下日常软件的缺少还是会给开发带来一些不便</p></li></ol><p>所以在11月之后，我就在慎重考虑需要换一台电脑，而我自己是偏基础设施的后端开发者，所以对 Unix/类 Unix 比较好的支持是必须的。同时因为有些时候会参与一些大型的开源项目，我也需要电脑有足够的性能来支撑多虚拟机以提供多平台的调试能力。<br>因此当时摆在我面前的有两个选择</p><ol><li><p>买一个硬件友好的机器，装黑苹果和 Linux 双系统</p></li><li><p>买一个 Macbook Pro</p></li></ol><p>由于我算是有点版权洁癖，黑苹果严格意义上来讲是违规的。因此 Macbook Pro 是我最好的选择了，恰逢新款的 16 寸的 Macbook Pro 上市，我就决定入手</p><p>我最后选择的配置是 i9 2.3 Ghz + 64G RAM + 1T SSD + 5500M 4G。选择这样的配置的逻辑是这样的，因为根据目前的评测，这一款 Mac 散热表现不错。因为我日常会在本地编译调试东西，所以果断选择了 i9，1T SSD 则是默认标配。而我不是视频工作者，同时<br>我也不会在 Mac 上玩游戏， 所以显存 4G 版显卡对我来说完全够用。唯一的纠结点在于 RAM，16G 肯定不够用，到底是 32G 还是 64G 这是个问题。考虑了下，咬咬牙上了 64G （后面也说明这是一个正确的决策）</p><p>定了之后果断分期下单，18号下单，23号拿到机器（这里要感谢女朋友大力支持，要不是她，我估计最后也舍不得买）。</p><p>好了，开始进入开箱，评测环节</p><h3 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h3><p>23号一早跑去公司拿了快递，然后回家开箱</p><p>献祭一只猫后，打开快递箱</p><p><img src="https://user-images.githubusercontent.com/7054676/69540790-894fc580-0fc2-11ea-9390-8f6afdc2e13a.jpg" alt="据说献祭一只猫能让电脑用的更久"></p><p>苹果的包装一如既往的简洁</p><p><img src="https://user-images.githubusercontent.com/7054676/69541163-7e496500-0fc3-11ea-8c9b-bbeb7b678185.jpg" alt="包装盒"></p><p>下面几张图，是真机原貌</p><p><img src="https://user-images.githubusercontent.com/7054676/69541369-f021ae80-0fc3-11ea-9ce6-c9610ad241d0.jpg" alt="IMG_20191123_122230"></p><p><img src="https://user-images.githubusercontent.com/7054676/69541370-f021ae80-0fc3-11ea-8ac2-eb8051a9d28d.jpg" alt="IMG_20191123_122251"></p><p><img src="https://user-images.githubusercontent.com/7054676/69541371-f021ae80-0fc3-11ea-9151-c775737f2e84.jpg" alt="IMG_20191123_122411"></p><p><img src="https://user-images.githubusercontent.com/7054676/69541372-f0ba4500-0fc3-11ea-891a-5fe6fb67463e.jpg" alt="IMG_20191123_123116"></p><p>机器到手默认是 MacOS 10.15.1 即 MacOS Catalina 。不得不说，这一代 MacOS 与 iOS 都是 Bug 奇多，堪称 BugOS = =，让人怀疑果家的项目管理是不是彻底失效了</p><p>至于机器外观，我选择的是银色版，不得不说，颜值是真高，但是也容易脏qaq，可能也有朋友关系 Macbook Pro 16 寸有多大，下面做了一个图大家可以感受一下</p><p><img src="https://user-images.githubusercontent.com/7054676/69541606-7dfd9980-0fc4-11ea-974d-18c9b47a01b5.jpg" alt="IMG_20191123_195649"></p><p>从上往下分别是：</p><ol><li><p>女朋友的 Macbook Air</p></li><li><p>公司配发的 Macbook Pro 2018 15 寸（后面还会有他的细分）</p></li><li><p>Macbook Pro 16 寸</p></li><li><p>蓝天 P775TM</p></li></ol><p>从这样一个角度大家能看出来，其实新款的 Macbook Pro 16 寸比 Macbook Pro 15 寸只大出一点点，而在新款出来后，官网也下架了 Macbook Pro 15 寸，所以看起来以后 Macbook Pro 16 寸就是 15 寸的替代品</p><h3 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h3><p>其实到手时间还相对较短，比较深的体验暂时没有2333，这一部分可能就相对较短了</p><ol><li><p>屏幕是保持了苹果一如既往的水准，很舒服，不过这一代默认显示分辨率是 1792x1120，  较 15 寸的 1680x1050 更大，很多人可能会觉得字体比较小，需要额外调整（此处推荐 RDM</p></li><li><p>键盘终于舒服了，蝶式键盘对于我来说有点敲钢板的感觉（不过各有所爱啦）</p></li><li><p>ESC 键的恢复对于 VIM 党来说是重大利好（逃（然而我不是（逃x2，2333333</p></li></ol><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>首先，我们来看下新款 Mac 的 CPU 测试成绩</p><p><img src="https://user-images.githubusercontent.com/7054676/69557120-01c57f00-0fe1-11ea-8100-be3575ac761d.png" alt="image"></p><p>不过，说实话，我觉得利用日常的一些场景来做测试可能更有价值，所以我选取了两个项目来做编译测试，一个是 Dubbo （基于 <a href="https://github.com/apache/dubbo/tree/dubbo-2.7.4.1">Dubbo 2.7.4.1</a> 进行编译, Maven 3.6.2, JDK 8),另外一个是基于 <a href="https://github.com/python/cpython">CPython</a> Master 最新代码进行编译，下面是编译命令</p><ol><li><p>Dubbo: <code>mvn clean package -U -Dmaven.test.skip=true</code>  (两台机器都已经搞定依赖)</p></li><li><p>CPython: <code>./configure --with-pydebug --with-openssl=/usr/local/opt/openssl &amp;&amp; make -j</code></p></li></ol><p>两台机器分别为</p><p><img src="https://user-images.githubusercontent.com/7054676/69559174-69c99480-0fe4-11ea-9b55-d80631d8afb1.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/7054676/69559204-777f1a00-0fe4-11ea-98dd-018d522c421d.png" alt="image"></p><p>最后的测试结果如下图所示（单位都为秒）</p><p><img src="https://user-images.githubusercontent.com/7054676/69559265-91b8f800-0fe4-11ea-9181-f3b3af1df7b2.png" alt="image"></p><p>看起来性能提升还是很明显，不过因为编译涉及到频繁的小文件读写，所以导致差距没有理论上的那么大，但是随着代码规模的扩大，i9 的优势会更为明显。后续有时间我会找几个科学计算的例子来进行场景补充</p><p>说道编译，大家可能也关心新款的 Mac 的散热怎么样，我大概测试了一下，</p><p><img src="https://user-images.githubusercontent.com/7054676/69559388-d2b10c80-0fe4-11ea-98b3-b186733db92d.png" alt="image"></p><p>结论为，降频无法避免，但是满负载的时候，能在81度左右的温度，将 CPU 频率稳定在 3.5 Ghz。虽然这个结果还是没有其余的高性能本那么显眼，但是对于一个轻薄高性能本来说，我觉得还算不错，毕竟凡事总得做一个 trade-off 对吧</p><p>最后，测一下硬盘速度</p><p><img src="https://user-images.githubusercontent.com/7054676/69559599-33404980-0fe5-11ea-908b-c50492568bfb.png" alt="image"></p><p>嗯，还是一如既往的暴力。。。</p><p>啊对了，其实有朋友可能会关心，64G 的内存是否浪费，嗯，我看了下，其实对我而言，不算浪费</p><p><img src="https://user-images.githubusercontent.com/7054676/69617885-e35c9380-1073-11ea-91ec-05b2b0ab424f.png" alt="image"></p><p>这是我写这篇文章时候的内存使用率，机器上开了三个 IDEA 项目，两个 Goland 项目，一个 PyCharm 项目，浏览器窗口若干，VSCode 窗口若干，用 Docker 跑了三个 ElasticSearch 节点做 HA 测试，一个 Kibana 节点，如果后续在开<br>几个虚拟机，可能 64G 对我来说就是非常适合的了。不过每个人的场景不一样，这里我也就不对大家的选机做一个建议了（不然选错了可能就要被打QAQ）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实 Macbook Pro 是个水桶机，整体配置相对均衡，适合大多数场景（需要 Office 的除外），而且今年的官方也提供了更为灵活的配置选项让大家来进行组合。所以我建议如果对于大尺寸 Mac 有需求的朋友，其实真的可以考虑入手</p><p>千言万语汇成一句话：</p><p><img src="https://user-images.githubusercontent.com/7054676/69560169-4bfd2f00-0fe6-11ea-8cd3-088025809cef.gif" alt="74cea299b2f87d690d12a6ff38c2441e"></p><p>最后再次感谢女朋友对我的支持！mua！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 电子产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电子产品 </tag>
            
            <tag> Apple </tag>
            
            <tag> 评测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在一周年</title>
      <link href="//posts/2019/11/04/for-one-year-anniversary/"/>
      <url>//posts/2019/11/04/for-one-year-anniversary/</url>
      
        <content type="html"><![CDATA[<p>说实话，突然体会到了老祖宗说的『光阴似箭，日月如梭』的感觉了，感觉告白还在昨天，但是转眼就一年了。所以来写篇文章纪念这短短却有很丰富的一年吧</p><span id="more"></span><h2 id="起初"><a href="#起初" class="headerlink" title="起初"></a>起初</h2><p>说实话，我现在都没搞清楚是她撩的我，还是我撩的她，估计暂时也不会搞清楚了？</p><p>在去年的11月7号凌晨，当时聊着双十一，然后她突然说，“要是双十一能脱单就好了”，然后我直接没过大脑的来了一句 ”我保佑你啊“，然后你能以肉眼可见的速度感觉到屏幕对面的人不开心了</p><p>然后我就纳闷了，这女生咋这么难以琢磨呢？咋这就生气了呢？我说错啥了我？等等，她不会是喜欢我吧？我这么一个沙雕程序员咋会被她看上呢？喵？然后在我反复逼问下她承认了，然后就顺其自然的在一起了</p><p>后续她吐槽我：</p><ol><li><p>你咋能拷问一个女孩子喜不喜欢你呢？</p></li><li><p>当时你说”我保佑你啊“，我第一反应，这男的白撩了</p></li></ol><h2 id="相处"><a href="#相处" class="headerlink" title="相处"></a>相处</h2><p>她是一个很棒的钢琴专业的学生，非常棒，而且堪称学霸（偶然间知道她当年高考的时候即便缺席了半年文化课，高考成绩也超一本线50多分，当时就给跪了），而我是一个屌丝学渣程序员，按道理说我们两个人是毫无交集的，所以可能很多人想问，你们两是怎么相处的？</p><p>嘛，首先，我日常被嫌弃这是必然的，然后她有时会傻傻的，然后我也会吐槽她</p><p>讲两个故事</p><ol><li><p>某天我给她讲，亲爱的你知道么？我们金牛座超屌的，她惊了：哟，你还信星座的啊？然后我兴致勃勃的给她说，你知道么，人类历史上最早有记录的超新星爆发之一就在金牛座（SN 1054，公元1054年），她无语了十分钟</p></li><li><p>某天晚上，我哄她去睡觉，我说，亲爱的，快睡了，现在快十二点了，她当时直接来了句”现在日本才11点“，我当时愣了十分钟（喵？？</p></li></ol><p>好了，其实开个玩笑啦。虽然看起来是两个世界的人，但是我们彼此都还是有不少共同点，同时我们日常也会刻意的去靠近对方的习惯。比如我们会一起去看音乐剧（音乐剧看多了的结果就是钱包抗不住），然后一起吐槽比如法扎那场演员不咋样，比如堂吉诃德的演员有啥瑕疵，当然我也会日常给她普及某些电子产品有多好用，然后给她安利哪些软件比较好用（当然她日常吐槽我：你这个之前就给我说过啦白痴！）（然后我成功把她带入了 RSS 订阅的坑）</p><p>当然，要问她为什么能看上我，唯一的理由：她眼瞎（逃</p><h2 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h2><p>其实作为普通人的我们，日常其实也还是如同大部分普通人一样，一部分是温暖与惊喜，一部分是嫌弃与包容吧？</p><p>我自己来说，作为一个程序员，特别是在这两年经历了很多重大的改变，也经历不少的关键时候，同时因为我自己职业的关系，虽不至于996，但是每天清早出门，晚上回家，一天下来精疲力竭也是常态，而且说实话我自己的身体一直欠佳，去年到今年，大大小小的毛病也一堆，在这样一个时候，有一个人陪在你的身边，我觉得这对于我来说意义重大</p><p>我之前给她说过，她给我带来最直接改变就是让我对于这个城市有了归属感，每天早晨出门的时候有一个抱抱，晚上回家的时候也有一个抱抱，这样一个颇具有仪式感的行为让我对北京这个城市有了难得归属感。让我曾经在不同的城市之间飘荡的数字游民式的想法彻底消失。</p><p>而且她也是一个擅长个给我小惊喜和有着生活情趣的人，无论是在入职之前给我准备的一束花，还是有些时候在家里养的小花，满天星，茉莉，让你觉得家里有了生机，而有时你觉得很你难过的时候，她也会duang的一下跳出来，带着你最爱吃得东西来犒劳你，让你继续安心前行</p><p><img src="https://user-images.githubusercontent.com/7054676/68135636-f55c8200-ff5e-11e9-90ed-3520f89072ea.png" alt="最近的小惊喜"></p><p>当然一段感情中，除了温暖与惊喜，就是不断的嫌弃与包容吧</p><p>比如我因为工作繁忙+自己实在是懒，日常会把家里搞的很乱，然后她一遍嘟囔着我要和你分手，一遍收拾家里。然后之前她调雪球酒，然后我贪杯多喝了几杯在床上装死狗的时候，她一边嫌弃的骂我是傻狗，一遍隔一会儿来确认下我是否有事</p><p>嘛，所以日子，等等，我突然忘了说了，其实我们两人的日常还有一个很重要的组成部分！那就是虐狗！</p><p>啊，每当我在技术群里有意/无意的虐狗后，她总是很担(xin)心(xi)的问，你这样会不会被打啊！我说会，然后她说噢，那我就放心了</p><p>233333！</p><h2 id="宠物"><a href="#宠物" class="headerlink" title="宠物"></a>宠物</h2><p>嘛，宠物是我们日常中很重要的一部分，所以我就开个单节来聊聊</p><p>首先来介绍下家里四只猫</p><p><img src="https://user-images.githubusercontent.com/7054676/68136813-d8c14980-ff60-11e9-81fc-318acbf457f1.png" alt="image"></p><p>小舅子大雄，现居于山东，喜欢唱、抓、rap、捞鱼，目前在背《沁园春.雪》</p><p><img src="https://user-images.githubusercontent.com/7054676/68136952-0efec900-ff61-11e9-8a37-971d68d996e9.png" alt="image"></p><p>懂事的大闺女，肚兜，前流浪猫，极为懂事，在她/我身体不舒服的时候，会过去看着，也导致她经常吐槽：”你还没肚兜爱我！“</p><p><img src="https://user-images.githubusercontent.com/7054676/68137070-4cfbed00-ff61-11e9-945c-6290f84659ba.png" alt="image"></p><p>叛逆期的外孙女，秋千，颜值波动极大，有时喜欢捣乱</p><p>我们当时因为这三只猫结实，我记得我们俩最开始的话题是如何给大雄做绝育，借着给大雄做绝育的契机，我们俩加深了感情，加深了对于彼此的认识，啊，伟大的大雄同志，万岁！</p><p>然后突然想起关于秋千还有一个故事，去年10月，当时做保洁。秋千因为害怕躲在了家里一个未知的角落，回家的我一度以为秋千丢了，哭着满小区找秋千，亲爱的一直在安慰，别哭，别哭，我来陪你找</p><p>嗯，这三只猫，某种意义上是我们俩的媒人。嗯，纪念日开罐头</p><p>最后一只小猫，对我们来讲，是第一只一起救下来的小猫，嗯在儿童节那天，亲爱的说，这是我收到的最好的儿童节礼物</p><p><img src="https://user-images.githubusercontent.com/7054676/68137661-50dc3f00-ff62-11e9-9723-b9b00310fd3b.png" alt="image"></p><p>曾经的点点</p><p><img src="https://user-images.githubusercontent.com/7054676/68137739-710bfe00-ff62-11e9-8ca8-8ac6b5a218f0.png" alt="image"></p><p>现在的点点</p><p><img src="https://user-images.githubusercontent.com/7054676/68137823-8f71f980-ff62-11e9-8a5a-da6c6cf9c1df.png" alt="image"></p><p>睡死了的点点</p><p>嘛，这四只猫，分别出现在不同的时候，对于我们有着不一样的意义，当然家里养猫的日常是，当猫偷吃/打碎化妆品后，亲爱的总会对着我抱怨：”看你养的好猫！你赔我”，欲哭无泪.jpg</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>在过去这一年里，很幸运的是虽然大大小小的争端不断，没有吵架。一起养猫，一起看书，一起做陶艺，然后一起走到纪念日。在这一年里面，我们也一起立下了很多的 Flag 和对未来的希望，比如一起去加拿大读书，一起工作赚钱买 Dream House，一起去日本京都 Gap Year，等等。</p><p>虽然这句话说过很多次，但是我是还想再说一次：“亲爱的，我感激并享受着你的爱”</p><p>爱你亲爱的，一周年快乐！</p><p>啊对了，很多人都会问，你文中的她是谁呀，再次介绍下，她叫荆澈（也是我的花名），山东人，这里两位荆澈一起，在这里向大家问好啦！</p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我与 PyCon China 这两年</title>
      <link href="//posts/2019/11/03/somethng-between-me-pycon-china/"/>
      <url>//posts/2019/11/03/somethng-between-me-pycon-china/</url>
      
        <content type="html"><![CDATA[<p>其实这篇文章最开始动笔是写于9月份，PyCon China 2019 上海场的工作结束后。后续因为还有北京，成都场的工作，所以拖到了现在。正好我自己的三年计划刚刚落下帷幕。下一个三年计划正在开展。我也来聊聊在这三年里面，<br>让我花费精力最多，也是最为重要的部分组成之一吧。 PyCon China，嗯这三年的时间里，我有两年都在与这个熟悉而陌生的名字关联在了一起</p><span id="more"></span><h2 id="我与-PyCon-China-的结识"><a href="#我与-PyCon-China-的结识" class="headerlink" title="我与 PyCon China 的结识"></a>我与 PyCon China 的结识</h2><p>说实话，之前 Laike9M 的一句话让我产生了共鸣</p><blockquote><p>Kenneth Reitz 曾经说，他的一年是按 PyCon 计算的。尽管围绕他有很多争议，这句话依然让我有了奇妙的共鸣。对他来说，”PyCon”自然是指 PyCon US，而对我来说，则是 PyCon China</p></blockquote><p>而我18/19年这两年的时间里，有很大一部分时间都在围绕着 PyCon China</p><p>要说最早结识 PyCon，应该能追溯到的 2016 年，当时初学 Python 的我，看到 David Beazley 在 PyCon US 2009 上分享的一个名为 <a href="http://dabeaz.com/coroutines/">A Curious Course on Coroutines and Concurrency</a> 的分享，简直惊为天人</p><p>也让我当时立下来几个 Flag</p><ol><li><p>在 PyCon China 做一次分享</p></li><li><p>组织一次 PyCon China</p></li><li><p>提一个被接受的 PEP 提案</p></li><li><p>晋升成为大陆第一位 Python Core Developer（不过在16年11月，来自华为的 <a href="https://github.com/zhangyangyu">angwer</a> 晋升成为大陆第一位 Core 后，这个 Flag 就有所修改了23333)</p></li></ol><p>嗯，后续我也在持续关注 PyCon China 的进展，却发现，历年 PyCon China 口碑在不断的下滑，也感觉十分的痛心</p><p>在17年，PyCon China 口碑进入谷底，当时年少轻狂的我，跑去邮件组喷了一圈后，又在考虑，我自己的能力是不是足够支撑一场大型会务筹办，可能需要先试试水。所以决定和小伙伴以『Python 北京开发者社区』的名义，组织了一场<a href="http://www.huodongxing.com/event/1408930902000">『Python 北京开发者活动第一期』</a>。借用 Thoughtworks 的场地在北京自行发起了一场活动。从事后的反馈来看，这个活动还是相对成功的，因此我也坚定了参与进 PyCon China 的意向。BTW，这次活动也收获了很多很棒的朋友，比如18年北京场的志愿者负责人姚前，19年组织者刘玉龙等人，都结识于此。</p><p>18年3月，我正式通过邮件的形式向大妈提出参与进 PyCon China 中来，7月，和 PyCon China 幕后的负责人辛庆老师见面后，我正式参与进18年 PyCon China 的筹办中来。然后入坑之后没法逃脱，，我也全程参与了19年的筹备工作</p><h2 id="聊聊-PyCon-China-这两年"><a href="#聊聊-PyCon-China-这两年" class="headerlink" title="聊聊 PyCon China 这两年"></a>聊聊 PyCon China 这两年</h2><p>说实话，我不止一次向辛老师吐槽过</p><blockquote><p>我觉得只有傻逼才会来参与办这个会</p></blockquote><p>辛老师说：</p><blockquote><p>不用你说，我们所有人都觉得自己是傻逼</p></blockquote><p>办会真的太苦了。。。。我是18年北京场负责人、成都场负责人/讲师，19年北京/上海/成都负责人，成都场讲师。说实话，这两年结束之后，我基本都有半个月缓不过劲来。嗯，就是那种基本要虚脱的感觉</p><p>很多人要问，办会真的这么惨么？</p><p>是的，很惨。我大概说一下目前 PyCon China 的运作模式吧</p><p>PyCon China 目前由一群志愿者在承担幕后的会务工作，大概从每年3到4月开始，进入今年的 PyCon China 的筹备状态</p><p>我们的工作包括不仅限于下面这样一些部分</p><ol><li><p>场地的选取</p></li><li><p>讲师的征集</p></li><li><p>今年周边的设计</p></li><li><p>主题的审核以及讲师预讲服务</p></li><li><p>赞助</p></li><li><p>国内外社区沟通</p></li><li><p>媒体稿的准备</p></li><li><p>会务现场</p></li></ol><p>基本进入每年的8月开始，到10月结束，基本每个人都处于高度紧张模式，基本每天大家都需要折腾到凌晨1/2点才能完成当天的准备工作（因为大家都是志愿准备工作）</p><p>而一旦各个城市开始进入会时，各位组织者也将迎来更大的挑战，无论是体能上还是具体的事务中，举个例子，我上海场/北京场都是两天睡了4个小时不到，而成都场更惨，因为日本讲师因为台风将缺席上午的分享，我需要临时做 PPT 进行补位，因此72小时也就睡了6个小时。</p><p>所以说，做会，无论是对于体能，还是自己各方面的能力，都会提出很高的要求。</p><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>其实我也不知道为什么，可能真的是傻逼吧？</p><p>说实话，这两年 PyCon China 在我人生最重要的职业初期的两年中扮演了非常非常重要的角色，在这里一直被大家溺爱，包容着，也教会了我许许多多。所以吧，我感恩，痛苦，然后快乐着</p><p>有朋友说：<strong>以我片面的视角来看，Manjusaka 正是让 PyCon China 涅槃重生的关键人物。</strong> 其实我非常感谢大家的认可，但是不得不说，我只是这两年中微不足道的一环，在幕后，有太多让人感动并产生对这个群体的归属感的事情发生。比如18年垫付了20多万亏损的辛庆老师，做设计做到哭，但是边哭边做还是把设计成功的交出来的错姐，在背后一直默默支持的志愿者大管家倩姨，财务大管家大猫，因为台风取消航班但是依旧选择来到中国的日本小姐姐藤井美娜等等等。正是因为这样一群人的存在，PyCon China 才能不断的进步与成长</p><p>所以吧，很荣幸能在人生最重要的几年时间里有这样的一段难以忘怀的经历。嗯，一下也不知道怎么说了</p><h2 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h2><p>关于未来的话，职业方面的话，目前刚调动到阿里云做中间件相关的开发，应该还是会继续在技术这条路上走很长的一段时间吧。然后对于 PyCon China 2020，目前的筹备工作已经开展，不过因为我自己的身体原因，还不确定是否会参与，不过不出以外的话，虽然可能没法像18/19年这样支撑多城市（因为我们各城市的志愿者也成长起来啦！），但是大家也会见到我的身影</p><p>最后两张图镇楼</p><p><img src="https://user-images.githubusercontent.com/7054676/68086989-6c751600-fe8c-11e9-9d8e-8cc8f33f8019.jpeg" alt="EIcHI0SX0AEQtlu"></p><p><img src="https://user-images.githubusercontent.com/7054676/68086992-7f87e600-fe8c-11e9-9a60-f0ebfd399c03.jpeg" alt="EH-fxAJUwAEoZaZ"></p><p>最后 PyCon China 2020 已经开始筹备工作，欢迎大家加入！</p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 上关于 inotify 的小笔记</title>
      <link href="//posts/2019/07/02/something-about-file-system-watch/"/>
      <url>//posts/2019/07/02/something-about-file-system-watch/</url>
      
        <content type="html"><![CDATA[<p>最近还是无心写啥文章，说好的写几篇关于 Raft 的论文也因为一些事 delay 了。但是想了想还是准备写点什么，于是写个小的水文来记录下关于今天碰到的一个 Linux 内核参数的问题， 顺便做个笔记</p><span id="more"></span><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我是一个不太喜欢 Mac 的人，所以我自己在家使用的开发环境是 Manjaro（这里打个广告，非常棒的发行版，堪称开箱即用，广告五毛一条）。然后代码工具就是 Jetbrains 的全家桶和 VSCode 搭配使用。</p><p>今天打开 Goland 的时候，发现 IDE 给了这样一个 Warning ，<code>External file changes sync may be slow: The current inotify(7) watch limit is too low.</code></p><p>于是大家知道，我是个看着这些 warning 有强迫症的人，于是我就去查了查</p><h2 id="简单聊聊"><a href="#简单聊聊" class="headerlink" title="简单聊聊"></a>简单聊聊</h2><p>我们平常经常会有需求，去监控一个文件或者一个目录下的变化，比如创建文件，删除文件等。我们常规的做法可能是一个直接暴力轮询的方式来做</p><p>但是这样的性能会极差。那么我们有没有什么手段来处理一下这个事么？</p><p>有的！ Linux 提供了对应的 API 来处理这事，这就是我们今天要聊到的 <code>inotify</code></p><p>按照官方的说法，<code>inotify</code> 其实很简单，</p><blockquote><p>The inotify API provides a mechanism for monitoring file system events. Inotify can be used to monitor individual files, or to monitor directories. When a directory is monitored, inotify will return events for the directory itself, and for files inside the directory.</p></blockquote><p>大意就是说 <code>inotify</code> 是用来监控文件系统事件的。可以使用在单个文件或者目录上。被监听的文件目录本身的变化或者内部文件的变化都在监听范围内。</p><p>在监听了对应的文件后，<code>inotify</code> 将返回如下事件 </p><ol><li><p>IN_ACCESS 文件可读</p></li><li><p>IN_ATTRIB 元数据变化</p></li><li><p>IN_CLOSE_WRITE File opened for writing was closed</p></li><li><p>IN_CLOSE_NOWRITE File not opened for writing was closed</p></li><li><p>IN_CREATE 被监听的目录下有文件/目录被创建</p></li><li><p>IN_DELETE 被监听的目录下有文件/目录被删除</p></li><li><p>IN_DELETE_SELF 被监听的文件/目录被删除</p></li><li><p>IN_MODIFY 文件被修改</p></li><li><p>IN_MOVE_SELF 被监听的文件/目录被移动</p></li><li><p>IN_MOVED_FROM 有文件/目录从被监听的目录中被移出</p></li><li><p>IN_MOVED_TO 有文件/目录移动至被监听的目录中</p></li><li><p>IN_OPEN 文件被打开</p></li></ol><p>总共12类事件，已经能涵盖住我们常见的需求。但是 <code>inotify</code> 也有其自己的弊端。</p><ol><li><p>不支持递归监听。举个例子，我监听 A 目录，我可以捕获到在 A 目录下创建 B 目录这个事件。但是我们没法监听到 B 目录下事件，除非将 B 目录也添加到监听队列中</p></li><li><p>Python 可用的 inotify 很少</p></li></ol><p>对于第一个缺陷。常见的解决手段，是我们自行实现递归监听。当主目录下存在创建文件/目录事件的时候，我们将对应的文件/目录也添加到监听队列中。</p><p>但是这样就带来一个新的问题。如果一个非常大的项目，我们按照这样的方式去做，那么最后对应的内存损耗是很吓人的。所以在 <code>inotify</code> 设计之初，就通过一些内核参数做了一些限制</p><p>我们常见的有两个</p><ol><li><p>/proc/sys/fs/inotify/max_queued_events  限制事件队列长度，一旦出现事件堆积，那么新的事件将被废弃</p></li><li><p>/proc/sys/fs/inotify/max_user_watches 限制每个 User ID 能够创建的 watcher 数，以免监听过多导致内存爆炸</p></li></ol><p>在默认情况下 <code>max_user_watches</code> 的值取决于不同的 Linux 发行版，对于大多数发行版而言，其值相对较小。也就是说一旦达到限制，那么将没法添加新的 watcher。这也是 IDE 为什么会提示<br><code>External file changes sync may be slow: The current inotify(7) watch limit is too low.</code> 的原因</p><p>可以通过修改 <code>/etc/sysctl.conf</code> 来修改对应的参数，最后解决这个问题</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Linux 果然是个宝库。感觉隔三差五就会遇到自己没涉及到的东西。所以还是记录下来，当作一篇水文，顺便供自己参阅</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Linux </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随便聊聊 PEP570</title>
      <link href="//posts/2019/04/27/something-about-pep-570/"/>
      <url>//posts/2019/04/27/something-about-pep-570/</url>
      
        <content type="html"><![CDATA[<p>最近沉迷与 MIT 6.824 这门分布式系统的课，无心写文章。不过看到 <a href="https://www.python.org/dev/peps/pep-0570">PEP570</a> 被接受了，决定还是写篇水文随便聊聊 PEP 570</p><span id="more"></span><h2 id="Python-的-argument"><a href="#Python-的-argument" class="headerlink" title="Python 的 argument"></a>Python 的 argument</h2><p>在聊 PEP570 之前，我们先要来看看 Python 的 argument 变迁</p><p>早在 Python 1.0 或更早，Python 的 argument 系统就已经支持我们现在主要使用的两种参数形式了，一种是 positional 一种是 keyword，举几个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">abc</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">abc(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">abc(<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">abc(*(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">abc(**&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是不是我们常见的集中使用方式？</p><p>在发展了很长一段时间后，虽然期间有一些提案对 Python 的 argument 系统做优化和增强，但是一直都被 Reject，直到 <a href="https://www.python.org/dev/peps/pep-3102/">PEP3102</a> 的出现</p><p>3102 主要引入了一个概念叫做 Keyword-Only Arguments，给个例子</p><p>有这样一个函数定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">abc</span>(<span class="params">a, *, b, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>那么这个函数只支持这样几种方式调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">abc</span>(<span class="params">a, *, b, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abc(**&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;)</span><br><span class="line">abc(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">abc(<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>OK，大概聊完 Argument 一个迭代的过程，我们来聊聊 570 这个提案</p><h2 id="随便聊聊-PEP-570"><a href="#随便聊聊-PEP-570" class="headerlink" title="随便聊聊 PEP 570"></a>随便聊聊 PEP 570</h2><p>570 做的事情其和 3102 类似，3102 是引入语法糖，让函数支持 keyword-only 的使用方式，那么 570 就是让函数支持 positional-only 的使用方式</p><p>假定有这样一个函数定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">abc</span>(<span class="params">a, b, /, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>那么 570 使得函数只支持这样的调用方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">abc</span>(<span class="params">a, b, /, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abc(<span class="number">1</span>, <span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">abc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>如果不这样做会怎么样呢？我们可以来试试，目前 PEP570 有一个实现，参见 <a href="https://github.com/python/cpython/pull/12701">bpo-36540: PEP 570 — Implementation</a>，我们来编译测试一下，效果如下</p><p><img src="https://user-images.githubusercontent.com/7054676/56848232-032eac00-6919-11e9-9312-d2d73b641f12.png" alt="image"></p><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>很多人其实没想清楚关于 570 的存在意义，PEP 570 上也提到了很多 Motivation 。不过我自己觉得，它和 3102 一样都是在践行一个理念，则</p><blockquote><p>explicit is better than implicit</p></blockquote><p>换句话说，如果要尽可能的保证代码风格的一致性，我们需要一定程度上语法特性的支持。而 570 和 3102 就是解决这样的问题。</p><p>所以从我自己的角度来说，我觉得 570 是个蛮重要的提案，也是很有意义的提案（都是 PEP57x ，为啥大家待遇能差这么多呢？（笑</p><p>对了，讲个段子， Python 的 Core 之一 Serhiy Storchaka 非常喜欢这个 PEP，然后在 PEP570 的实现没合并到主分支之前，就已经先把内置的一些库给改良了一下，大家可以去围观一下 PR <a href="https://github.com/python/cpython/pull/12620">[WIP] Use PEP 570 syntax for positional-only parameters</a></p><p>好了，今天的水文就到此结束了。。我写文章真的是越来越水了。。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 编程技巧 </tag>
            
            <tag> PEP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊网络事件中的惊群效应</title>
      <link href="//posts/2019/03/28/somthing-about-thundering-herd/"/>
      <url>//posts/2019/03/28/somthing-about-thundering-herd/</url>
      
        <content type="html"><![CDATA[<p>关于惊群问题，其实我是在去年开始去关注的。然后向 CPython 提了一个关于解决 <code>selector</code> 的惊群问题的补丁 <a href="https://bugs.python.org/issue35517">BPO-35517</a>。现在大概来聊聊关于惊群问题那点事吧</p><span id="more"></span><h2 id="惊群问题的过去"><a href="#惊群问题的过去" class="headerlink" title="惊群问题的过去"></a>惊群问题的过去</h2><h3 id="惊群问题是什么？"><a href="#惊群问题是什么？" class="headerlink" title="惊群问题是什么？"></a>惊群问题是什么？</h3><p>惊群问题又名惊群效应。简单来说就是多个进程或者线程在等待同一个事件，当事件发生时，所有线程和进程都会被内核唤醒。唤醒后通常只有一个进程获得了该事件并进行处理，其他进程发现获取事件失败后又继续进入了等待状态，在一定程度上降低了系统性能。</p><p>可能很多人想问，惊群效应为什么会占用系统资源？降低系统性能？</p><ol><li>多进程/线程的唤醒，涉及到的一个问题是上下文切换问题。频繁的上下文切换带来的一个问题是数据将频繁的在寄存器与运行队列中流转。极端情况下，时间更多的消耗在进程/线程的调度上，而不是执行</li></ol><p>接下来我们来聊聊我们网络编程中常见的惊群问题。</p><h3 id="常见的惊群问题"><a href="#常见的惊群问题" class="headerlink" title="常见的惊群问题"></a>常见的惊群问题</h3><p>在 Linux 下，我们常见的惊群效应发生于我们使用 <code>accept</code> 以及我们 <code>select</code> 、<code>poll</code> 或 <code>epoll</code> 等系统提供的 API 来处理我们的网络链接。</p><h4 id="accept-惊群"><a href="#accept-惊群" class="headerlink" title="accept 惊群"></a>accept 惊群</h4><p>首先我们用一个流程图来复习下我们传统的 <code>accept</code> 使用方式</p><p><img src="https://user-images.githubusercontent.com/7054676/55270168-e467d600-52d6-11e9-9779-8ba62b0b42e1.png" alt="image"></p><p>那么在这里存在一种情况，即当一个请求到达时，所有进程/线程都开始 accept ，但是最终只有一个获取成功，我们来写段代码看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_ADDRESS <span class="string">&quot;0.0.0.0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 10086</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORKER_COUNT 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">worker_process</span><span class="params">(<span class="type">int</span> listenfd, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am work %d, my pid is %d, begin to accept connections \n&quot;</span>, i,</span><br><span class="line">           getpid());</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_info</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_info_len = <span class="keyword">sizeof</span>(client_info);</span><br><span class="line">    <span class="type">int</span> connection =</span><br><span class="line">        accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_info, &amp;client_info_len);</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;worker %d accept success\n&quot;</span>, i);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ip :%s\t&quot;</span>, inet_ntoa(client_info.sin_addr));</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;port: %d \n&quot;</span>, client_info.sin_port);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;worker %d accept failed&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    close(connection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">  bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">  address.sin_family = AF_INET;</span><br><span class="line">  inet_pton(AF_INET, SERVER_ADDRESS, &amp;address.sin_addr);</span><br><span class="line">  address.sin_port = htons(SERVER_PORT);</span><br><span class="line">  <span class="type">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> ret = bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">  ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; WORKER_COUNT; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Create worker %d\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">/*child  process */</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">      worker_process(listenfd, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*wait child process*/</span></span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  wait(&amp;status);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们来看看运行的结果</p><p><img src="https://user-images.githubusercontent.com/7054676/55270562-2135cc00-52db-11e9-8ad8-71efe6e7962a.png" alt="image"></p><p>诶？怎么回事？为什么这里没有出现我们想要的现象（一个进程 accept 成功，三个进程 accept 失败）？原因在于在 Linux 2.6 之后，Accept 的惊群问题从内核上被处理了</p><p>好，我们接着往下看</p><h4 id="select-poll-epoll-惊群"><a href="#select-poll-epoll-惊群" class="headerlink" title="select/poll/epoll 惊群"></a>select/poll/epoll 惊群</h4><p>我们以 <code>epoll</code> 为例，我们来看看传统的工作模式</p><p><img src="https://user-images.githubusercontent.com/7054676/55270670-a1a8fc80-52dc-11e9-96c2-49be1aa78e7f.png" alt="image"></p><p>好了，我们来看段代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_ADDRESS <span class="string">&quot;0.0.0.0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 10087</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORKER_COUNT 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEVENTS 64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">create_and_bind_socket</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">  server_address.sin_family = AF_INET;</span><br><span class="line">  inet_pton(AF_INET, SERVER_ADDRESS, &amp;server_address.sin_addr);</span><br><span class="line">  server_address.sin_port = htons(SERVER_PORT);</span><br><span class="line">  bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_address, <span class="keyword">sizeof</span>(server_address));</span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">make_non_blocking_socket</span><span class="params">(<span class="type">int</span> sfd)</span> &#123;</span><br><span class="line">  <span class="type">int</span> flags, s;</span><br><span class="line">  flags = fcntl(sfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  flags |= O_NONBLOCK;</span><br><span class="line">  s = fcntl(sfd, F_SETFL, flags);</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fcntl set error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">worker_process</span><span class="params">(<span class="type">int</span> listenfd, <span class="type">int</span> epoll_fd, <span class="keyword">struct</span> epoll_event *events,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span> k)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    n = epoll_wait(epoll_fd, events, MAXEVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Worker %d pid is %d get value from epoll_wait\n&quot;</span>, k, getpid());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) ||</span><br><span class="line">          (!(events[i].events &amp; EPOLLIN))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll err\n&quot;</span>);</span><br><span class="line">        close(events[i].data.fd);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listenfd == events[i].data.fd) &#123;</span><br><span class="line">        <span class="keyword">struct</span> sockaddr in_addr;</span><br><span class="line">        <span class="type">socklen_t</span> in_len;</span><br><span class="line">        <span class="type">int</span> in_fd;</span><br><span class="line">        in_len = <span class="keyword">sizeof</span>(in_addr);</span><br><span class="line">        in_fd = accept(listenfd, &amp;in_addr, &amp;in_len);</span><br><span class="line">        <span class="keyword">if</span> (in_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;worker %d accept failed\n&quot;</span>, k);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;worker %d accept success\n&quot;</span>, k);</span><br><span class="line">        close(in_fd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> listen_fd, s;</span><br><span class="line">  <span class="type">int</span> epoll_fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line">  listen_fd = create_and_bind_socket();</span><br><span class="line">  <span class="keyword">if</span> (listen_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  s = make_non_blocking_socket(listen_fd);</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  s = listen(listen_fd, SOMAXCONN);</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  epoll_fd = epoll_create(MAXEVENTS);</span><br><span class="line">  <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  event.data.fd = listen_fd;</span><br><span class="line">  event.events = EPOLLIN;</span><br><span class="line">  s = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &amp;event);</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  events = <span class="built_in">calloc</span>(MAXEVENTS, <span class="keyword">sizeof</span>(event));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; WORKER_COUNT; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create worker %d\n&quot;</span>, i);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">      worker_process(listen_fd, epoll_fd, events, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  wait(&amp;status);</span><br><span class="line">  <span class="built_in">free</span>(events);</span><br><span class="line">  close(listen_fd);</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们用 <code>telnet</code> 发送一下 TCP 请求，看看效果，，我们能得到这样的结果</p><p><img src="https://user-images.githubusercontent.com/7054676/55273414-f4e37500-5305-11e9-8782-a31912228867.png" alt="image"></p><p>恩，我们能看到当一个请求到达时，我们四个进程都被唤醒了。现在为了更直观的看到这一个过程，我们用 <code>strace</code> 来 profile 一下</p><p><img src="https://user-images.githubusercontent.com/7054676/55273457-966ac680-5306-11e9-8666-2ce6ef90dd35.png" alt="image"></p><p>我们还是能看到，四个进程都被唤醒，但是只有 Worker 3 成功 <code>accept</code> ，而其余的进程在 <code>accept</code> 的时候，都获取到了 <code>EAGAIN</code> 错误，</p><p>而 <a href="http://man7.org/linux/man-pages/man2/accept.2.html">Linux 文档</a> 对于 <code>EAGAIN</code> 的描述是</p><blockquote><p>The socket is marked nonblocking and no connections are present to be accepted.  POSIX.1-2001 and POSIX.1-2008 allow<br>either error to be returned for this case, and do not require these constants to have the same value, so a portable<br>application should check for both possibilities.</p></blockquote><p>现在我们对于 EPOLL 的惊群问题是不是有了直观的了解？那么怎么样去解决惊群问题呢？</p><h2 id="惊群问题的现在"><a href="#惊群问题的现在" class="headerlink" title="惊群问题的现在"></a>惊群问题的现在</h2><h3 id="从内核解决惊群问题"><a href="#从内核解决惊群问题" class="headerlink" title="从内核解决惊群问题"></a>从内核解决惊群问题</h3><p>首先如前面所说，Accept 的惊群问题在 Linux Kernel 2.6 之后就被从内核的层面上解决了。但是 EPOLL 怎么办？在 2016 年一月，Linux 之父 Linus 向内核提交了一个补丁</p><p>参见 <a href="https://github.com/torvalds/linux/commit/df0108c5da561c66c333bb46bfe3c1fc65905898">epoll: add EPOLLEXCLUSIVE flag</a></p><p>其中的关键代码是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (epi-&gt;event.events &amp; EPOLLEXCLUSIVE)</span><br><span class="line">add_wait_queue_exclusive(whead, &amp;pwq-&gt;wait);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br></pre></td></tr></table></figure><p>简而言之，通过增加一个 <code>EPOLLEXCLUSIVE</code> 标志位作为辅助。如果用户开启了 <code>EPOLLEXCLUSIVE</code> ，那么在加入内核等待队列时，使用 <code>add_wait_queue_exclusive</code> 否则则使用 <code>add_wait_queue</code></p><p>至于这两个函数的用法，可以参考这篇文章<a href="https://www.halolinux.us/kernel-reference/handling-wait-queues.html">Handing wait queues</a></p><p>其中有这样一段描述</p><blockquote><p>The add_wait_queue( ) function inserts a nonexclusive process in the first position of a wait queue list. The add_wait_queue_exclusive( ) function inserts an exclusive process in the last position of a wait queue list. </p></blockquote><p>好了，我们现在来改一下我们的代码（内核版本要在 Linux Kernel 4.5）之后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_ADDRESS <span class="string">&quot;0.0.0.0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 10086</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WORKER_COUNT 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXEVENTS 64</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">create_and_bind_socket</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">  server_address.sin_family = AF_INET;</span><br><span class="line">  inet_pton(AF_INET, SERVER_ADDRESS, &amp;server_address.sin_addr);</span><br><span class="line">  server_address.sin_port = htons(SERVER_PORT);</span><br><span class="line">  bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_address, <span class="keyword">sizeof</span>(server_address));</span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">make_non_blocking_socket</span><span class="params">(<span class="type">int</span> sfd)</span> &#123;</span><br><span class="line">  <span class="type">int</span> flags, s;</span><br><span class="line">  flags = fcntl(sfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (flags == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fcntl error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  flags |= O_NONBLOCK;</span><br><span class="line">  s = fcntl(sfd, F_SETFL, flags);</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fcntl set error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">worker_process</span><span class="params">(<span class="type">int</span> listenfd, <span class="type">int</span> epoll_fd, <span class="keyword">struct</span> epoll_event *events,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span> k)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    n = epoll_wait(epoll_fd, events, MAXEVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Worker %d pid is %d get value from epoll_wait\n&quot;</span>, k, getpid());</span><br><span class="line">    sleep(<span class="number">0.2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((events[i].events &amp; EPOLLERR) || (events[i].events &amp; EPOLLHUP) ||</span><br><span class="line">          (!(events[i].events &amp; EPOLLIN))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;epoll err\n&quot;</span>);</span><br><span class="line">        close(events[i].data.fd);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listenfd == events[i].data.fd) &#123;</span><br><span class="line">        <span class="keyword">struct</span> sockaddr in_addr;</span><br><span class="line">        <span class="type">socklen_t</span> in_len;</span><br><span class="line">        <span class="type">int</span> in_fd;</span><br><span class="line">        in_len = <span class="keyword">sizeof</span>(in_addr);</span><br><span class="line">        in_fd = accept(listenfd, &amp;in_addr, &amp;in_len);</span><br><span class="line">        <span class="keyword">if</span> (in_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;worker %d accept failed\n&quot;</span>, k);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;worker %d accept success\n&quot;</span>, k);</span><br><span class="line">        close(in_fd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> listen_fd, s;</span><br><span class="line">  <span class="type">int</span> epoll_fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line">  listen_fd = create_and_bind_socket();</span><br><span class="line">  <span class="keyword">if</span> (listen_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  s = make_non_blocking_socket(listen_fd);</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  s = listen(listen_fd, SOMAXCONN);</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  epoll_fd = epoll_create(MAXEVENTS);</span><br><span class="line">  <span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  event.data.fd = listen_fd;</span><br><span class="line">  <span class="comment">// add EPOLLEXCLUSIVE support</span></span><br><span class="line">  event.events = EPOLLIN | EPOLLEXCLUSIVE;</span><br><span class="line">  s = epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &amp;event);</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  events = <span class="built_in">calloc</span>(MAXEVENTS, <span class="keyword">sizeof</span>(event));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; WORKER_COUNT; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create worker %d\n&quot;</span>, i);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">      worker_process(listen_fd, epoll_fd, events, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  wait(&amp;status);</span><br><span class="line">  <span class="built_in">free</span>(events);</span><br><span class="line">  close(listen_fd);</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们来看看效果</p><p><img src="https://user-images.githubusercontent.com/7054676/55273709-c2d41200-5309-11e9-959e-927c1bfbd410.png" alt="image"></p><p>诶？为什么还是有两个进程被唤醒了？原因在于 <code>EPOLLEXCLUSIVE</code> 只保证唤醒的进程数小于等于我们开启的进程数，而不是直接唤醒所有进程，也不是只保证唤醒一个进程</p><p>我们来看看官方的<a href="http://man7.org/linux/man-pages/man2/epoll_ctl.2.html">描述</a></p><blockquote><p>Sets an exclusive wakeup mode for the epoll file descriptor<br>  that is being attached to the target file descriptor, fd.<br>  When a wakeup event occurs and multiple epoll file descriptors<br>  are attached to the same target file using EPOLLEXCLUSIVE, one<br>  or more of the epoll file descriptors will receive an event<br>  with epoll_wait(2).  The default in this scenario (when<br>  EPOLLEXCLUSIVE is not set) is for all epoll file descriptors<br>  to receive an event.  EPOLLEXCLUSIVE is thus useful for avoid‐<br>  ing thundering herd problems in certain scenarios.</p></blockquote><p>恩，换句话说，就目前而言，系统并不能严格保证惊群问题的解决。很多时候我们还是要依靠应用层自身的设计来解决</p><h3 id="应用层解决"><a href="#应用层解决" class="headerlink" title="应用层解决"></a>应用层解决</h3><p>目前而言，应用解决惊群有两种策略</p><ol><li><p>这是可以接受的代价，那么我们暂时不管。这是我们大多数的时候的策略</p></li><li><p>通过加锁或其余的手段来解决这个问题，最典型的例子是 Nginx</p></li></ol><p>我们来看看 Nginx 怎么解决这样的问题的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ngx_process_events_and_timers</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ngx_uint_t</span>  flags;</span><br><span class="line">    <span class="type">ngx_msec_t</span>  timer, delta;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_timer_resolution) &#123;</span><br><span class="line">        timer = NGX_TIMER_INFINITE;</span><br><span class="line">        flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        timer = ngx_event_find_timer();</span><br><span class="line">        flags = NGX_UPDATE_TIME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_use_accept_mutex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ngx_accept_disabled &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ngx_accept_disabled--;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">                flags |= NGX_POST_EVENTS;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (timer == NGX_TIMER_INFINITE</span><br><span class="line">                    || timer &gt; ngx_accept_mutex_delay)</span><br><span class="line">                &#123;</span><br><span class="line">                    timer = ngx_accept_mutex_delay;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delta = ngx_current_msec;</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>) ngx_process_events(cycle, timer, flags);</span><br><span class="line"></span><br><span class="line">    delta = ngx_current_msec - delta;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&gt;<span class="built_in">log</span>, <span class="number">0</span>,</span><br><span class="line">                   <span class="string">&quot;timer delta: %M&quot;</span>, delta);</span><br><span class="line"></span><br><span class="line">    ngx_event_process_posted(cycle, &amp;ngx_posted_accept_events);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">        ngx_shmtx_unlock(&amp;ngx_accept_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (delta) &#123;</span><br><span class="line">        ngx_event_expire_timers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngx_event_process_posted(cycle, &amp;ngx_posted_events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里能看到，Nginx 主体的思想是通过锁的形式来处理这样问题。我们每个进程在监听 FD 事件之前，我们先要通过 <code>ngx_trylock_accept_mutex</code> 去获取一个全局的锁。如果拿锁成功，那么则开始通过<br><code>ngx_process_events</code> 尝试去处理事件。如果拿锁失败，则放弃本次操作。所以从某种意义上来讲，对于某一个 FD ，Nginx 同时只有一个 Worker 来处理 FD 上的事件。从而避免惊群。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章从去年到现在拖了很久了，惊群问题一直是我们日常工作中遇到的问题，我自己觉得，还是有必要写篇详细的笔记，记录下去年到现在的一些学习记录。差不多就这样吧，祝各位看的好。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Unix </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 pyright</title>
      <link href="//posts/2019/03/24/something-about-pyright/"/>
      <url>//posts/2019/03/24/something-about-pyright/</url>
      
        <content type="html"><![CDATA[<h1 id="关于-pyright"><a href="#关于-pyright" class="headerlink" title="关于 pyright"></a>关于 pyright</h1><p><a href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a>，出来也快四年了。正好今天看到一个新库，写个短文，安利下&amp;吐槽下。</p><span id="more"></span><h2 id="关于-PEP-484"><a href="#关于-PEP-484" class="headerlink" title="关于 PEP 484"></a>关于 PEP 484</h2><p><a href="https://www.python.org/dev/peps/pep-0484/">PEP 484</a>，14年正式提出，15年正式接纳，成为 Python 3.5 以后的标准的一部分。简而言之是通过额外的语法，来为 Python 引入静态类型检查的例子</p><p>举个简单例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">return_callback</span>(<span class="params">flag: <span class="built_in">bool</span>, callback: typing.<span class="type">Callable</span>[[<span class="built_in">int</span>, <span class="built_in">int</span>], <span class="built_in">int</span>]</span>)-&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> callback(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>我们通过这样的类型静态标注，来增加可读性以及静态检查的能力。具体内容，可以参看我去年在 BPUG 上的分享的 slide。我最近也会抽出时间，详细聊聊 Type Hint 的前世今生（flag+1）</p><h2 id="静态检查"><a href="#静态检查" class="headerlink" title="静态检查"></a>静态检查</h2><p>静态检查的意义在于，能及时发现低级错误，及时检查，可以很方便的集成进 CI 或者 Git Hook 中</p><p>举个简单例子</p><p><img src="https://user-images.githubusercontent.com/7054676/41104530-2c265722-6a9e-11e8-8166-31983d7ae482.png" alt="image"></p><p>目前而言，主流的静态检查工具有两种</p><ol><li><p>Python 官方和 484 配套出的 <a href="https://github.com/python/mypy">mypy</a></p></li><li><p>Google 出的 <a href="https://github.com/google/pytype">pytype</a></p></li></ol><p><a href="https://github.com/python/mypy">mypy</a> 目前的问题有：</p><ol><li><p>性能较差</p></li><li><p>对于新特性接入持保守态度</p></li></ol><p>所以后续 Google 选择了推出自己的静态检查方案 <a href="https://github.com/google/pytype">pytype</a> ，其性能相对于 mypy 来讲，性能和易用性也有了比较大的提升，</p><p>而目前，“开源急先锋“微软也在今天推出了自己的静态检查工具 <a href="https://github.com/Microsoft/pyright">pyright</a>。目前在保证了对 Type Hint 周边特性兼容的情况下，宣称性能相较于 mypy 有5倍的提升</p><p>而这对于大项目的 CI 来讲是一个极大的利好</p><p>不过目前，关于 pyright 的潜在风险点可能还有这样的问题</p><ol><li><p>基于 TypeScript 开发，运行环境基于 node，这可能会带来 CI 集成的难度。</p></li><li><p>易用性和可靠性还存在不足</p></li><li><p>可能和 IDE编辑器等配套的插件不足（官方也说，目前 VSCode 的插件还在开发中）</p></li></ol><p>不过，pyright 还是值得大家在私下尝鲜的。后续我也会尝试阅读下 pyright 的实现，看看微软的实现思路（flag+2)</p><p>嗯，本文就到这里，这应该是我写过最水的文章了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
          <category> PEP484 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 吐槽 </tag>
            
            <tag> PEP484 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018，我，2019，未来</title>
      <link href="//posts/2018/12/31/about-me-2019/"/>
      <url>//posts/2018/12/31/about-me-2019/</url>
      
        <content type="html"><![CDATA[<h1 id="2018，我，2019，未来"><a href="#2018，我，2019，未来" class="headerlink" title="2018，我，2019，未来"></a>2018，我，2019，未来</h1><p>本来以为年前没有机会发这篇年终总结以及新年展望。不过目前去向已经确定，所以准备还是写一篇文章纪念下2018这一年，赶在农历戊戌年的末尾发一篇文章出来吧。</p><span id="more"></span><h2 id="2018，我"><a href="#2018，我" class="headerlink" title="2018，我"></a>2018，我</h2><p>2018 的这一年算是很特殊的一年，我的本命年，24岁，第二次有意识的状态下过农历狗年。但是可能因为我一整年都没穿红内裤吧。所以整个人生算是起起伏伏，跌跌撞撞。</p><p>原本以为自己可能有很多话想说，但是真正要写的时候却发现不知道从何说起。所以干脆随意记点流水账吧</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>一整年的工作算是有条不紊的进行，去年，阿不，前年一整年都在做基础组件和快照这类基础服务的开发。今年因为搭档出差和转组的关系接触了下业务。虽然期间发生了不少的意外，但是也算是有一个不错的结果。也认识了不少的朋友。</p><p>但是最大的收获还是在于对自己的认知发生了改变。曾经以为自己能妥善的处理业务与基础服务的不同场景。过早的把自己定位在一个万金油的角色上，但是就目前看来，当时的认知是错误的。我自己对于业务可能兴趣并不是太大，可能需要去专注的<br>做基础服务的开发学习，才是比较好的出路。</p><p>而这样的认知的改变也直接造成了我后续的计划的改变和未来走向的变动</p><p>在工作之余，我选择建立了一些私人项目来进行练手，在这样一个从0到1的过程中，进一步确认了我的想法。</p><p>不过今年学到最深的一句话还是“做一件事，做一件有结果的事”</p><p>不过今年的认知的改变和身体原因直接造成了我选择裸辞在家休息，也直接让我存款降为0，这也是年初没有想到的。</p><h3 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h3><p>11月，在光棍节之前脱单，算是在知乎上认识的一位很优秀的女孩子，山东人，中国音乐学院的钢琴生。</p><p>她是一个很优秀的女孩子，至少比我优秀的多。至少我现在都还在思考一个问题：“当时她怎么眼瞎看上我的”</p><p>最开始我有点担心，某种意义上讲，我们算是两个不同世界的人，这样凑在一起是不是不太好，会不会缺少话题。但是目前看起来，我们彼此都在适应对方，我会告诉她互联网圈的趣闻，她告诉我艺术圈的趣闻，一起看话剧/音乐剧，一起吐槽分析<br>一起做菜，一起买糖葫芦，目前看来这样的日子很舒服，很幸福。</p><p>对了，可能有朋友在担心，她会不会需要我照顾人之类的，实话实说，她是一个很独立的女孩子，也很会照顾我。在离职后两个月里，我几次生病（有几次还比较惨）都是她在照顾我，所以请大家放心啦</p><p>至于照片，她说你敢放就打死你，出于男女朋友间和谐生活的角度考虑，我就不单独放啦！</p><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>2018年初给自己立了几个目标</p><ul><li><p>《Unix 网络编程卷一》刷一遍</p></li><li><p>配合 15-213 刷《深入理解计算机系统》</p></li><li><p>CPython 源码……也争取吃一下吧……</p></li></ul><p>目前来看，完成度都还不错</p><ul><li><p>UNP 刷了</p></li><li><p>CSAPP 没有刷，但是刷了 AUP（Unix 高级编程》</p></li><li><p>CPython 源码刷了一部分，并且作为作业向 CPython 提交两个代码补丁，一个文档补丁</p></li></ul><p>另外还有些奇奇怪怪的收获</p><ul><li><p>作为 PyCon China 2018 的主要参与者，筹办了北京场，成都场</p></li><li><p>作为讲师参加成都场的活动，做了一次关于黑 asyncio 的演讲</p></li></ul><p>另外再去阅读了一些奇奇怪怪的源码，比如 Redis/Nginx 之类的。也写了点 Golang/Java 服务。</p><p>所以整体来看，预期达到并有所超出，但是缺陷也很明显，局限于某一部分分支，而缺乏方法论，系统设计方面的学习，可能这也是一位 HR 对我说我的格局可能还是相对较小的原因所在。</p><h2 id="2019，未来"><a href="#2019，未来" class="headerlink" title="2019，未来"></a>2019，未来</h2><p>在18年11月因为个人规划选择离开上家公司后，经过两个月休息，目前去向已经定了。去饿了么基础框架部 Huskar 组师从张江阁（松鼠奥利奥/tongseek）老师做服务注册治理平台方向的开发。整体薪资和定级出于隐私原因，我就不在这里透露了。只能说比我预期的还要好一些。所以在昨晚得到消息的时候<br>很明确的告诉 HR 选择接受 Offer。</p><p>所以未来几年的发展方向应该会是在中间件和分布式服务这一块深入耕耘，同时也会在业余时间折腾不同的东西。</p><p>关于2019，首先争取多回家几次，陪陪父母。然后和女朋友好好的走下去，多去玩不同的地方，吃不同的好吃的，看不同音乐剧。</p><p>关于职业和技术方面。在我看来这次 Offer 算是一个破例 Offer 了（因为小跳大，而且只有两年经验非科班，不过因为三轮面试官对我的评价都蛮高，所以最后结果让我有一些惊喜）。所以先在饿了么立足，拿一个不错的绩效这会是一个首要的目标，为了我自己，也为了三位面试官不会后悔他们给出的评价。</p><p>社区方面，我会持续为 CPython 提交 Patch，争取有天能晋升成为核心开发者。同时我也会全程参与 PyCon China 2019 的筹办，恩，继续去学习一些技术之外的事</p><p>其余的话，就是继续补补计算机基础，补一些这次面试暴露出来的薄弱点，然后去按部就班学习新的东西。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>前天饿了么三面结束后，我给师父说谢谢你带我不断地学习。师父说谢你自己啊白痴。其实年前一个月的面试不管结果如何，我最开心可能还是我终于有资格能认为自己是个合格的开发者了吧。算不上优秀，但是能算及格。这也是市场对我的肯定吧</p><p>我问师父，你徒弟没给你丢脸吧？师父说丢什么？你很厉害的。恩所以下一步的目标大概就是朝着有资格说自己是个不错的开发者努力了吧。</p><p>这一年，跌跌撞撞的走过来，哭过很多次，也难受过很多次，但是最后算是有个 happy ending，也算是一种幸运了。期间承蒙许多人的照顾，父母，女朋友，师父，leader，同事，我的密友们。至少在我想哭的时候，会有人陪着我。也在不断地支持我去看看更大的世界。</p><p>不管2019年这一年，会怎么样，会不会如同18年一样的不顺，我还是得努力让自己的每一天都变得精彩一点，有意义的一点。为我自己，也为所有照顾帮助过我的人。我不想让我和他们失望。</p><p>有道是，诗酒趁年华</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 总结 </category>
          
          <category> 秀恩爱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>听说我有女朋友</title>
      <link href="//posts/2018/12/31/i-have-girlfriend/"/>
      <url>//posts/2018/12/31/i-have-girlfriend/</url>
      
        <content type="html"><![CDATA[<h1 id="听说我有女朋友"><a href="#听说我有女朋友" class="headerlink" title="听说我有女朋友"></a>听说我有女朋友</h1><p>我很喜欢写听说系列文章，从入行开始写的第一篇《听说你会 Python》。所以半年了，我干脆也来写一篇《听说你有女朋友》。为啥要今天写？因为明天她送的新键盘要到了，正好老键盘退役，写点啥纪念下</p><span id="more"></span><h2 id="怎么认识的？"><a href="#怎么认识的？" class="headerlink" title="怎么认识的？"></a>怎么认识的？</h2><p>很多人都会问我这样的问题：”你一个技术男咋和学音乐的认识了？“，我一般这么回答：”知乎认识的“（请知乎给我广告费，明天之前打到我支付宝上</p><p>好了，正经说，我们的确算是在知乎上认识的（广告费+1）。当时我们在一个知乎群里，然后后面加上了好友。</p><p>很多时候，我这个人有个毛病，加了女孩子之后不怎么聊的。不过幸好，我们最开始有个共同的爱好，养猫。她家的是一只橘猫。我家是母女两。某种意义上讲，这三只猫是我们俩的媒人（回去加罐头）</p><p>正式开始聊起来，应该是开学的时候，她当时睡眠不太好。某天晚上，睡前戏称保佑她肯定睡得好之后。第二天她说昨晚居然还真睡得不错（直男如我我现在都不知道我的功力是不是有那么强。问她她也不说，摔）</p><p>借着这个契机，就开始聊了起来，包括不限于互相点外卖犒劳对方上课/上班的无奈。出来约了两次火锅（直男撩妹法）</p><p>11月初，当时做完18年的 PyCon，她说要送我一份礼物。找个周一兴高采烈的约了井格，拿到了第一份礼物，一条爱马仕的领带和领带夹。花纹是我最喜欢的樱花。然而我现在都还没一个合适的机会用上这条领带。所以请各位大佬行行好。如果有什么可以穿正装的场合。包括不仅限于伴郎，主持，放贷，打架，搞传销等，请务必通知我一声。</p><p>说道怎么正式在一起的。说起来也足够的戏剧性和充满了直男的无奈（她现在都还会嫌弃我）</p><p>11月6号晚上，当时突然聊到双十一的话题。她说希望这个月底能找到男朋友。我当时没有过大脑，直接说，我奶你没问题！瞬间这话一出口，能明显她感觉不开心了。我当时就在纳闷，不会吧，她不会是喜欢我吧？恩？不可能吧？于是我就正儿八经的向她反复询问这个问题。然后她承认：“没错，我是挺喜欢你的”<br>（后来被她吐槽你咋能反复问女孩子喜不喜欢你呢！）（直男如我）。于是就这么在一起了</p><p>看完这一套下来，大家是不是觉得，我这样的人怎么都能找到女朋友呢？如果非要问我为什么能找到女朋友的话，我给大家分享三个原则：</p><ol><li><p>她足够瞎</p></li><li><p>她足够瞎</p></li><li><p>她足够瞎</p></li></ol><p>噢，对了，忘了向大家介绍她了，真名就不告诉大家了。她艺名叫荆澈（这也是我的花名），山东人，有很多身份啦，比如李者璈同志的女朋友，大三的钢琴生等等。总之携她向大家问好，请多指教啦！</p><h2 id="恋爱日常"><a href="#恋爱日常" class="headerlink" title="恋爱日常"></a>恋爱日常</h2><p>恋爱什么感觉呢？荆澈同学（非我）有一段比较好的总结：“和你谈恋爱，感觉就像养了一只大狗，这狗还贼会撒娇”</p><p>给大家分享一下我们的恋爱日常</p><ol><li><p>第一次去电影院，当时在无名之辈和无敌破坏王之间纠结。她说去电影院看动画片么？于是我记着这句话了。后续，某次又要去看电影的时候，在海王和蜘蛛侠平行宇宙之间纠结。当时贼想看海王，于是我说蜘蛛侠是动画片！她说好吧，看海王。后续她吐槽，哼，我早就知道你想看海王了，当我不知道是吧。</p></li><li><p>当时她之前在参加校园卡设计大赛获奖后，某天晚上突然给我说，我奖金，一半给我买了个神仙水，一半给你买了一套海盗船键鼠（然而因为学校的坑爹，我明天才能拿到）好不好？我当时：哇！开心！等等你为啥要鼓励我玩游戏？</p></li><li><p>某天去看莎翁的第十二夜，我最开始不习惯，然后差点睡着，荆澈同学一直在旁边捏我。</p></li><li><p>还是去看莎翁的第十二夜，当时突然想起我们买了一月份的《我，堂吉诃德》的话剧票。然后突然我问她。我们是不是要去看堂诃吉德？她一脸嫌弃，你这个文盲，是堂吉诃德！嫌弃！当时我一脸委屈的马上去京东下单了一套《堂吉诃德》（现在也没看）。后续她感叹，你这个人咋这么容易委屈呢？</p></li><li><p>11月裸辞后，一直在家休息，在拿了饿了么的 offer 消息后，给她说，她表示：早知道了。我说，窝草？她说，哼我可是梦见自己中考分数的女人！怎么样！棒不棒。我：棒棒棒，半仙，，半仙</p></li><li><p>两个人都喜欢吃糖葫芦，草莓的。有次一起去看新房子（租的），然后将草莓糖葫芦放在新屋子里忘了拿！</p></li><li><p>某天晚上，你要是不给我吃糖葫芦我就通宵！她：哦，熬得住你就熬吧（这是亲女朋友么</p></li><li><p>入职之前，荆澈同学问要不要送一束花给我，我说要啊！然后她一脸无辜的问，要是你因为虐狗被开了怎么办！我一脸正气：不允许员工虐狗的公司不是好公司。第二周周一，刚到办公室，收到一束花(事实证明，这束花来的真及时)</p></li><li><p>荆澈同学回调酒，某天晚上她调了一杯雪球，我给你讲，贼好喝，当时贪嘴，喝的多了点，然后晚上就在床上装死狗。荆澈同学一脸无奈的说：以后你不准喝酒！一滴酒也不能喝！</p></li><li><p>2月份，北京下雪，当时我没忍住，晚上出去吃饭的时候去雪地里滚了一圈。然后把手机搞丢了。第二天从派出所捡回手机。荆澈同学一脸无奈：你以后还滚不滚了？</p></li><li><p>3月6号，下班回家。回家一看，哇一个大大的蛋糕，然后荆澈同学一脸开心的蹦出来！今天120天啦！一起庆祝一下！</p></li><li><p>在荆澈同学回学校之前，每天下班回家都会有个抱抱（出门也有的（回学校就没了（哭</p></li></ol><h2 id="恋爱总结"><a href="#恋爱总结" class="headerlink" title="恋爱总结"></a>恋爱总结</h2><p>其实很多人都会好奇，你们完全是两个世界的人，怎么会在一起呢？说实话，起初我也担心这个问题。但是其实发现。自己很多的顾虑也是多余。恋爱是一个相互磨合与了解的过程。我们会一起去看剧，一起吐槽，给对方讲我们各自领域的故事，会分享各自的心情与家庭。当然我们也会日常打闹，互黑。</p><p>某种意义上来讲，恋爱是一个相互认可，相互成就的过程。有些时候，我笑称她眼瞎才遇上我。她会很认真的给我说，我才不瞎呢。所以很庆幸我自己能遇到这样一个可爱，知性，懂事的女孩子。我也会和她一起好好的经营这一段感情。</p><p>最后的最后，喂了这么多狗粮。还是要收尾一下的。祝每一个看这篇文章的人，如果你已经有自己的爱人，那么祝福你和你的爱人一切平安喜乐。如果你还没有遇见那个人，那么请不要着急，请相信，在不远的一天，你终将找到你所爱之人。</p><p>（另外，这篇文章的封面，就是我亲爱的荆澈同学啦！（</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 总结 </category>
          
          <category> 秀恩爱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秀恩爱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>去 async/await 之路</title>
      <link href="//posts/2018/10/04/why-i-dont-use-async/"/>
      <url>//posts/2018/10/04/why-i-dont-use-async/</url>
      
        <content type="html"><![CDATA[<h1 id="去-async-await-之路"><a href="#去-async-await-之路" class="headerlink" title="去 async/await 之路"></a>去 async/await 之路</h1><p>看到彭总写的文章<a href="https://zhuanlan.zhihu.com/p/45936509">这破 Python</a>，感慨颇多，我也来灌水吧。</p><p>首先，我司算是在国内比较敢于尝试新东西的公司吧，最直接的提现就在于我们会及时跟进社区相关基础服务的迭代，并且敢于去尝试新的东西。嗯，从去年6月到现在，我司在线上推行了很长一段时间的 async/await ，并且引入新的注入 Sanic 这样全新的框架，但是不得不说，我们现在要对 async/await 暂时的说再见了。</p><span id="more"></span><h2 id="我们为什么选用-async-await-？"><a href="#我们为什么选用-async-await-？" class="headerlink" title="我们为什么选用 async/await ？"></a>我们为什么选用 async/await ？</h2><p>和我们组具体场景有关，我们组有相当一部分场景，是根据不同的 URL 去不同的子服务请求数据，组合之后，再进行下一步的统一处理。那么这个时候，传统的同步的方式在数据源越来越杂的情况下就显得很无奈。</p><p>我们当时有这样几个选择：</p><ol><li><p>维护进程/线程池，利用通用的进程/线程来处理请求</p></li><li><p>利用 Gevent 这样第三方的 coroutine+EventLoop 方案</p></li><li><p>使用 async/await + asyncio 这一套</p></li></ol><p>首先，1被我们排除了，原因很简单，太重了。2最开始也被我们暂时性的排除，当时我们对于 monkey-patch 这样看起来不太清真的方式心存畏惧</p><p><img src="https://user-images.githubusercontent.com/7054676/46499914-06b2f680-c854-11e8-8404-cc1a3e96f02e.gif" alt="588d9201f5b14873b0504e3a6ab7b402"></p><p>于是我们就很欢喜鼓舞的选择了3，利用 async/await + asyncio 这一套方案</p><p>事实上最开始的效果还是很美妙的。然而，在后面会发现这一套操作其实是在吃屎QwQ</p><h2 id="去-async-await"><a href="#去-async-await" class="headerlink" title="去 async/await"></a>去 async/await</h2><h3 id="我们为什么放弃-async-await"><a href="#我们为什么放弃-async-await" class="headerlink" title="我们为什么放弃 async/await?"></a>我们为什么放弃 async/await?</h3><p>其实几个老生重谈的问题</p><h4 id="1-代码层面的传染性"><a href="#1-代码层面的传染性" class="headerlink" title="1. 代码层面的传染性"></a>1. 代码层面的传染性</h4><p>Python 官方的 coroutine 实现，其实是基于 yield/yield from 这一套生成器的魔改的，那么这也意味着你需要入口处开始，往下逐渐的遵循 async/await 的方式进行使用。那么在同一个项目里，充斥着同步/异步的代码，相信我，维护起来，某种意义上来讲算是一种灾难。</p><h4 id="2-生态与兼容性"><a href="#2-生态与兼容性" class="headerlink" title="2. 生态与兼容性"></a>2. 生态与兼容性</h4><p>async/await 目前的兼容性真的让人很头大，目前 async/await 的生效范围仅限于 Pure Python Code。这里有个问题，我们很多在项目中使用的诸如 mysqlclient 这样的 C Extension ，async/await 并不能覆盖。</p><p>同时，目前而言，async/await 的周边真的堪称一个非常非常大的问题，可以说处于一个 Bug 随处见，发现没人修的状态。比如 aiohttp 的对于 https 链接所存在的链接泄漏的问题。再比如 Sanic 的一团乱麻的设计结构。</p><p>我们在为生产项目调研一门新的技术的时候，我们往往会着重去考察一个新的东西，它对于现有的技术是否能覆盖我们的服务，它的周边是否能满足我们日常的需求？目前而言 async/await 周边一套并不能满足</p><h4 id="3-性能问题"><a href="#3-性能问题" class="headerlink" title="3. 性能问题"></a>3. 性能问题</h4><p>目前而言，PEP 3156 提出的 asyncio 是 async/await 官方推荐的事件循环的搭配。但是目前而言官方的实现欠缺很多，比如之前 aiohttp 针对于 https 的链接泄漏的问题，底层其实可以追溯至 asyncio 的 SSL 相关的实现。所以我们在使用的时候，往往会选用第三方的 loop 进行搭配。而目前而言第三方的 Loop 而言目前主流的实现方式均是基于 libuv/libev 进行魔改。而这样一来，其性能和 Gevent 不相上下，甚至更低（毕竟 Greenlet 避免了维护 PyFrameObject 的开销）</p><p>所以，为了我们的头发着想，目前我们将选择逐渐的将 async/await 从我们的线上代码中退役，最迟今年年底前，完成我们的去 async/await 的操作。</p><h3 id="我们替代品是什么？"><a href="#我们替代品是什么？" class="headerlink" title="我们替代品是什么？"></a>我们替代品是什么？</h3><p>目前而言，我们准备使用 Gevent 作为替代品（嗯，真香）</p><p>原因很简单：</p><ol><li><p>目前发展成熟，无明显大的 Bug</p></li><li><p>周边发展成熟，对于 Pure Python Code，可以 Monkey-Patch 一把梭迁移存量代码，对于 C Extension 有豆瓣内部生产验证过的 Greenify 来作为解决方案</p></li><li><p>底层的 Greenlet 提供了对应的 API ，在必要的时候可以方便的对协程的切换做上下文的 trace。</p></li></ol><h2 id="关于-async-await-其他一些想说的东西"><a href="#关于-async-await-其他一些想说的东西" class="headerlink" title="关于 async/await 其他一些想说的东西"></a>关于 async/await 其他一些想说的东西</h2><p>首先而言，async/await 是个好东西，但是现在不实用。这一点其实要看社区去进一步摸索相关的使用方法。</p><p>说到这里，很多人又想问我，你对于 ASGI 和 Django Channel 这样的东西怎么看？</p><p>首先我们要明确一点 ASGI 其实并不是为了 async/await 所设计，其最初的设计思路，是为了解决 PEP333/PEP3333 WSGI 协议在面对越来越复杂的网络协议模型力不从心的问题。而 Django Channel 也是为了解决这个问题，从而对于 ASGI 进行实现的产物（最开始是解决 Websocket？）。这一套的确解决了很多问题，比如 Django Channel 2.0 中可以很方便的实现 WebSocket Boardcast，但是他们和 async/await 其实关联并不大。</p><p>今年 PyCon 2018 上，Django 组的 Core 来介绍说，Channel 2.0 增加了对 async/await 的支持。未来 Django 也可能会增加对应的支持。但是问题在于，一旦到了使用 async/await 的时候，目前整体的生态，依旧是让人最为担心的，也是最为薄弱的点 。</p><p>所以，你好 async/await，再见 async/await！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>她曾以为自己能逃开教授的手丨人间</title>
      <link href="//posts/2018/07/07/She-thought-she-can-survive-from-sexual-assualt/"/>
      <url>//posts/2018/07/07/She-thought-she-can-survive-from-sexual-assualt/</url>
      
        <content type="html"><![CDATA[<h1 id="她曾以为自己能逃开教授的手丨人间"><a href="#她曾以为自己能逃开教授的手丨人间" class="headerlink" title="她曾以为自己能逃开教授的手丨人间"></a>她曾以为自己能逃开教授的手丨人间</h1><p><img src="https://user-images.githubusercontent.com/7054676/42421767-b353f268-830d-11e8-838e-4ab7ea759299.png" alt="image"></p><blockquote><p>《不能说的夏天》剧照  </p><p>之前听舍友笑薇被教授性骚扰时，小柯还以为那只是老师对好学生的亲昵行为，安慰她说：“这应该是老师表达欣赏你的一种方式吧。”但几天后她就也被教授性骚扰了。</p></blockquote><p>陈静越来越焦虑。</p><p>她又梦见去上课，楼梯里遇到教授张鹏，转身想跑，对方一把手抓住她，恶毒地问：你为什么举报我？你把我逼急了，我也不让你活……</p><p>在惊恐中醒来，陈静大汗淋漓。</p><p>早在今年“五四”青年节，她们五个女生给中大纪委发去了举报信，指控张鹏从2011年到2017年持续性骚扰女学生和女老师，是田野中名副其实的“叫兽”。</p><p>张鹏，中山大学社会学与人类学学院（下称“社人院”）兼生命科学大学院教授，跨学科博士生导师（生态学、社会学方向），兼任国际自然保护联盟（IUCN）物种生存委员会委员，2016年青年长江学者。在网络上搜索他的名字，无论是文艺青年的社交网路，或者是著名的科普网站，他会经常跟“灵长类动物研究”出现在一起。</p><span id="more"></span><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>陈静的噩梦始于2016年1月底的内伶仃猕猴种群数量田野调查。</p><p>田野调查是中大社人院每年组织的特色研究活动。张鹏每年寒假都会带队去不同的岛“蹲点”和“环岛”，以此来评估岛上有多少猕猴。陈静喜欢观察猴子的行为模式，田野中一直在蹲点观测。</p><p>田野调查最后一天，学员们相互体验，陈静从蹲点观测转为环岛两圈。第一圈时，她遇到在其中一段路蹲点观测的张鹏。</p><p>注意到独自环岛的陈静，张鹏说：“我陪你走一段吧。”当时的陈静觉得，陈教授“真亲民”——大一时她听过张鹏的人类学系列讲座，感觉“内容丰富，氛围活跃”，对灵长类研究产生了浓烈的兴趣，也对授课的张鹏心怀敬意。</p><p>路上，陈静话不多，张鹏一会儿称赞陈静的长相，“你长得真可爱”，一会儿又分析她的性格，“有南方姑娘温柔气质，又有北方人的豪爽”。逐渐地，张鹏向陈静靠得越来越近，聊得越来越具体，“你的头发真好”，顺势把玩起陈静的长发，还时不时闻一下说，“真香啊。”</p><p>陈静先是觉得尴尬，后来越来越不舒服，她隐隐觉得这不应该是一个教授应有的举动，却又不知如何是好，只能加快脚步赶到下一段有同学在的地方。</p><p>环岛第二圈，陈静再次遇上张鹏时，张鹏又上前提出“一起走吧”，还很自然地把手搭在陈静肩膀上。陈静不适，碍于师生情面，并未明确拒绝。走过泥泞路段，张鹏突然拉着陈静比起了身高，“感觉你没1米6啊”，比完身高又说“想看看你有多重”，就在陈静不知要如何回答还未及时拒绝时，张鹏一把抱起了陈静，还顺势把头埋到陈静胸口深深吸了一口气。</p><p>“那时候整个人完全懵了，不敢相信。”陈静说，想起他在自己胸口闻的那个动作，至今仍想干呕，有一股强烈的羞耻感。陈静挣扎起来，张鹏才把她放下，一放下，陈静就快步跑开，拿出手机，紧张地给她姐姐以及姐姐的男朋友所在的群发信息：“感觉张教授是‘叫兽’。”</p><p>陈静姐姐的男友、中山大学2013届历史系学生陈翰元，向我佐证了陈静的讲述。他坦言，当时看到陈静的那条信息，并没太当回事，“以为张鹏也就是在她面前讲了个黄色笑话”。等陈静回到住处，详细和他们讲起具体细节时，陈翰元才意识到这是性骚扰。当时的陈翰元也只是从男性的角度猜测，问：“张鹏是不是很喜欢你啊？”</p><p>陈翰元建议陈静去了解一下张鹏的为人，他听过张鹏不少光鲜的头衔，主持如国家自然科学基金及中日国际交流等不少国家级科研项目，也听说过张鹏还有个被广为流传事迹：据说，做研究时，张鹏曾给一个猴群里最漂亮的一只母猴以他女朋友的名字命名，靠此来排解在山上几个月里对女朋友的思念。后来者也跟着张鹏叫起这个名字，于是就在观察笔记写：xxx（张鹏女朋友名字）今天和一只雄猴打情骂俏，明天和另一只雄猴交配。张鹏也津津乐道。</p><p>陈翰元担心陈静因为张鹏一次偶尔的“低级错误”影响她对学业的追求，曾尝试劝解。但是，后来好几次聚餐，陈静都会跟姐姐和陈翰元谈起被张鹏性骚扰的经历，越发变得压抑，情绪低落，还持续做噩梦。</p><p>陈静无法理解和接受张鹏的举动，也不能让别人理解自己的感受，“感觉自己在孤岛里转”，只好选择了暂时性遗忘。此后她再遇到张鹏，就能躲多远就躲多远，即便上曾经最喜欢的“灵长类进化论”，都变成一种煎熬。</p><p>后来，陈静陆陆续续听到张鹏性骚扰其他女生的事情。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>其实，张鹏对女学生更频繁的性骚扰集中在2015年。</p><p>那一年暑假，张鹏带队到海南南湾猴岛进行为期一个月的野外实习。当时大二的笑薇和小柯在这次田野实习中，先后遭受了张鹏的性骚扰。</p><p>电话里寒暄时，笑薇说话轻快爽朗；谈到张鹏，她的语速变得缓慢而坚定：“张鹏真的伤害了一群女生，他没有资格做中大教授。”</p><p>笑薇向我缓缓了讲述她遭遇张鹏性骚扰的经历：</p><p>一天开完组会后，约深夜11点，张鹏喊住她“来办公室改论文”。笑薇想，白天都在外观察猴群，晚上讨论也是情理之中；而且张鹏从日本回来，看起来对科研十分严格，于是毫无担忧地去了。</p><p>笑薇原本坐在张鹏对面，张鹏指着电脑屏幕招呼她坐到自己同侧。开始笑薇还跟他保持了半米的礼貌距离，张鹏又叫她坐近一点，“坐过来看得清楚”。</p><p>出于对张鹏教授身份的尊敬，笑薇没多想，论文讲到一半，张鹏指出她论文问题，同时右手环住她的肩膀久久不拿开，笑薇感到窘迫。</p><p>“他先是说了论文这里不对、那里有问题，然后拍拍我的肩膀，拍完手就放着不走了。”笑薇当时思绪复杂，一边想着论文，一边莫名害怕，“还安慰自己，长辈拍晚辈肩膀是常有的，是自己胡思乱想”。</p><p>然而，张鹏的话暧昧起来，“你长得真漂亮啊”，手还拍起笑薇的手背。“那时我真是害怕，紧张，窘迫，他却表现得很自然。”笑薇说，回想起来她才发现张鹏的恐怖，“他一边指出你论文各种问题，让你害怕，一边又似乎安慰你，挽肩膀拍手，让你难以理解他动作的真实含义；他控制着你的情绪，让你的注意力都在论文问题上，一时辨识不了他行为的性质。”</p><p>在笑薇此前的认知中，张鹏教授常年在野外，年轻有为，风趣幽默——“眼前这个人跟课堂上谈笑风生的让人尊敬的教授完全不是一个人啊！怎么会这样？他不是日本回来的学者吗？”</p><p>在坐立不安中笑薇艰难度过了讲论文的一个小时。回到寝室，她跟几个舍友说起张鹏对她的举动。</p><p>舍友小柯问她：“是不是你想多了？”</p><p>小柯后来在接受采访时向我解释，她当时这样问，并不是质疑笑薇——她从小学到高中，一直都幸运地遇上各种好老师，所以一直觉得老师都是高山仰止，会爱护学生，形象正直高大。所以当笑薇说张鹏“有点不对劲”、对自己动手动脚的时候，小柯还以为那只是老师对好学生的亲昵行为，安慰她说：“这应该是老师表达欣赏你的一种方式吧。”</p><p>笑薇的另一位舍友对我说，那晚她听到笑薇说张鹏讲暧昧的话、还摸手搭背时十分惊讶，“我虽没听过张鹏的课，但很多人都说他课讲得好，没想到是这样的老师”。田野回来后，笑薇也曾多次向她透露对张鹏的反感，“她说不想写这个田野报告，不喜欢张鹏，不想见到他”。</p><p>笑薇和小柯都坦率告诉我，她们那时未曾意识到、或者意识到了却不愿意相信备受尊敬的教授会性骚扰自己，“如果是陌生人，他随便搭着你的肩膀，摸你的背，拍你的手，闻你的头发，又说‘你很漂亮’此类的话我肯定知道这是性骚扰，但这个人是老师啊，是自己原本尊敬的教授，他那么威严，怎么去辨识他的行为呢？”</p><p>女孩们讨论最终得出的解决方案是：不再单独与张鹏相处，找张鹏改论文的时候舍友们要在门口等着。</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>然而，小柯很快就“被现实啪啪啪地打脸了”：张鹏也性骚扰了她。</p><p>几天后的一次组会结束，小柯让两舍友在门外等，自己带着报告进去张鹏办公室。问完问题小柯想走，张鹏却开始跟她聊起无关田野实习和论文的事，还紧挨着她坐下，一边笑着说奉承话，一边抓起她手腕看，“你的手好细啊”，等小柯把手抽开，张鹏又摸起小柯的头发，“你的头发发质好好啊”，还抓起她一缕头发把玩起来。</p><p>小柯尴尬极了，忐忑不已，却手足无措。突然，张鹏起身，走到门口探出身子左右张望——直到后来，小柯才意识到他当时探出头是为了看外面有没有人。</p><p>当时小柯还安慰自己，舍友就在外面，不用害怕。然而，她却见张鹏以“外面虫子多”为由把门关上了。关上门的那一刻，小柯懵了。后来她才知道，由于张鹏拖得时间过长，舍友们先行回了宿舍。</p><p>关了门后的张鹏言语越发露骨：“我看你这么努力，总让我想到我小时候，也这么努力。你就像一个小妹妹……让我抱一下……”不等小柯拒绝，张鹏便一把抱住了她，“我脑袋一片空白，他一松开的时候，我就赶紧跑走了”。</p><p>小柯满脸通红跑出张鹏办公室的一幕，正好被路过的笑薇看见。两个女孩难以理解，张鹏作为一名已婚教授，行为为何如此不堪？她们也不懂，事后张鹏为什么可以没有丝毫避讳，还毫无廉耻之心出现在女学生们面前。</p><p>“他看起来那么理直气壮，那么自然，让你怀疑，是不是自己太敏感了？”小柯曾猜测，女学生或许是张鹏心血来潮的戏弄对象？——可她后来才知道是自己后知后觉，张鹏对她的骚扰行为其实早就有了苗头。2015年春，小柯曾和同学们跟随张鹏到上川岛进行一个“小田野”。傍晚休息时，同学们和张鹏商量看第二天的日出，小柯应和并着手查询次日的天气。就在此时，张鹏走到她后面，把手心贴在小柯后背心上，久久不曾放开。当时，小柯按下内心的不适，将这一动作看作长辈对晚辈的一种亲昵，“没想到他是一步步试探”。</p><p>即便看到了张鹏的“叫兽”面目，女生们也不知道如何是好：岛上只有他们一个调研组，只有张鹏一个教授，她们不知道该向谁申诉。而且，田野报告需要张鹏打分，她们还有张鹏的课，甚至已经选了张鹏做论文指导导师。</p><p>她们能做的，只是不再与张鹏正面接触。</p><p>“那段日子有巨大的阴影笼罩在身上，世界仿佛到处都是黑暗。”电话那头，原本激动着控诉张鹏恶行的小柯突然放低了声音，“你知道吗？黄记者，那时感觉自己在地狱。”</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>其实，女生们也曾做出力所能及的反抗。</p><p>因为项目和论文，小柯还是需要时常与张鹏接触，她曾认为掌握了张鹏的“套路”，“感觉可以保护自己了”。</p><p>每次要向张鹏当面汇报时，小柯都会提高警惕：“他把手放在了我大腿上，我直接把腿移开了；他用眼神从上到下扫一遍，那种眼神让人很不舒服，但我没办法控制他的眼神；他问你买了新衣服了？是不是烫头发了、变漂亮了？我都会说‘不是’，并且把话题立刻转移到论文或项目上。”</p><p>强硬起来对抗老师，小柯觉得结果没有想象中那么糟糕——那时，她并不知道还有更多女生受到了张鹏更为放肆的性骚扰。</p><p>张鹏也并未收敛。</p><p>小柯清楚记得，2017年4月的一个夜里，晚上8点多，张鹏走到她自习的桌前当面邀约，“再谈谈论文”，小柯不好当面拒绝，也不好当张鹏的面拿出手机提前给舍友发信息通风，只能跟着他去了办公室。</p><p>在办公室里留到快10点，张鹏就坐到了小柯身边，她担心起来，偷偷地快速给舍友发信息：“等我。”</p><p>张鹏看到小柯发信息的动作，立刻火了：“老师专门辅导，你竟玩手机？！”然后，张鹏开始用带有侮辱性言语攻击她：“没教养，自私自利”，“老师为了你的论文到现在都没吃饭，你呢？为老师做了什么？我把实验室的资源都提供给你，你又为实验室做了什么？”</p><p>小柯被张鹏的翻脸吓坏了，只得道歉，然而，张鹏并未停止责骂：“老师为你付出那么多，你是不是把老师当工具？是不是想快毕业了，可以远走高飞，翻脸不认人，什么都不为我做了？”</p><p>小柯难以相信，一个教授，为人师表，竟然说出这样的话。她后来和其他女生交流才得知，张鹏会抓住不同的女生们犯下的各种“错误”，在性骚扰不遂或被拒绝后都复制着一样的骂人模式，试图控制女生们的思想。</p><p>“他骂很多女生自私自利，可是，这个实验室本身就是人类学系系里为学生教学投资的，我们应当都有权力正当使用。然而，每次在实验室时，张鹏都要让我们觉得，（能使用实验室）这都是因为他的好心和慷慨，这个道德包袱太重了。”</p><p>后来，被张鹏性骚扰过的女生们聚集起来才发现，张鹏通常会选择性格温和、家庭背景普通、独立无援的女学生为骚扰对象。他的性骚扰行为在多人身上重复出现，呈现某种模式化特点：</p><p>他不明目张胆地胁迫，而是策划和利用情境（如修改论文、做田野项目），逐步拉近距离；他还会操控受害者心理，找到不同理由和借口严厉训斥，先打击、摧毁女生的自尊自信，使得学生战战兢兢；然后柔声抚慰，诉说欣赏、喜欢之情，打着“师长的关爱”的幌子借机拍背、捏手、拥抱、甚至亲吻，让惊慌的女生无法辨识其动作的真实目的。</p><p>小柯和笑薇感到庆幸——她俩及时毕业了，并未遭遇张鹏更为严重的骚扰。</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>一次偶然借书机会，陈静认识了师姐小柯。熟悉后，小柯叮嘱师妹，“要小心张鹏”。两人细聊才知道，原来张鹏的性骚扰对象涉及各个年级的女生。</p><p>这个结论让她们感到更大的震惊，不约而同萌发了举报张鹏的念头，尤其是后来听到消息后：张鹏性骚扰了2017届的大一师妹，情节严重，接近性侵害。女孩告知了父母，其父亲来到中大评理，因有视频佐证，张鹏无法抵赖，被党内处分。</p><p>两个中大2017届的人类学专业的学生向我佐证了这个消息，他们承认“级里都在传”。其中一位学生透露，事发2018年4月3日晚上约10点半，张鹏与受害者女生单独在实验室，张鹏关了灯，对女生进行了严重的性骚扰。第二天，受害者女生父亲气冲冲地来到学校，他们刚好那时在同一栋大楼，看到有两名保安前往实验室取证，还调取了实验室走廊的视频。有当时在实验室的学生匿名向我证实，确实有保安前来调取视频。</p><p>知情学生透露说，视频画面里，张鹏先是从他办公室出来，到其他办公室敲了敲门，然后关了灯，又回到了自己的办公室，近半小时后，张鹏先走出办公室，就在走廊里提了提裤子，并把露在外面的衣角重新塞进裤子里，随后女生出来，两人一同离开。</p><p>办公室里具体发生了什么，该学生并不清楚，但知道第二天女孩的父亲就来了学校，去了纪委办公室。</p><p>张鹏终于被处分，这让学生们看到了一丝希望；但一个“党内处分”，并未平息学生们的愤怒。</p><p>“张鹏性骚扰学生的消息就没停过，但是他还是一直在性骚扰学生，而且情况越来越严重”。陈静说，她感觉“不能发生了不可逆转的性侵才举报，那就太迟了”。</p><p>小柯也气愤学校的保守处理：“张鹏的行为越来越大胆，一年比一年严重，真的要造成性侵这样实实在在的伤害、有视频证据，才能处罚他吗？”</p><p>得知情况的陈翰元也坐不住了：“他不是一次性的冲动，而是一而再再而三性骚扰学生，是一个惯犯，中大怎么能容忍这样的教授？”</p><p>受过张鹏性骚扰的女学生们自觉组成举报联盟，笑薇在班级群里实名告知师妹们：“如果选了张鹏的课和‘田野’，一定要格外小心保护自己。”</p><p>这引来了更多当事人响应。举报人们收集到了4封实名举报信和1封匿名举报信，让她们没想到的是，举报信中，竟然有一封是一名女老师写的。</p><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>女老师的举报把张鹏最初的性骚扰行为时点提前到2011年，而且张鹏对这位女老师的性骚扰更为直接、严重。</p><p>因为这位女老师已经给纪委实名举报交代，并签下协议不再向外透露其他信息，我只能引用此前早已掌握的举报信材料。</p><p>女老师在举报信里称，2011年她刚入职中大外国语学院，在往返于中大南校区与东校区（大学城）的校车上，张鹏与她搭讪，“（他）坐我旁边座位，没说几句就开始摸，先是肩膀，再到大腿和大腿内侧，那个时候我很怕，车上有老师有学生，我不敢喊。只能闪避，比如背对他或者甩开他的手。”</p><p>当天晚上，她坐校车返回南校时，又遇到张鹏。张鹏借机坐在她身边，“他先是不断找我攀谈，讲述家里的烦心事，妻子不了解他等等。看我没有怎么搭理，就又开始动手动脚，把我的头拉向他的肩膀，并试图亲吻我的耳朵，并继续向胸部和大腿内侧摸。我跟他说，张老师，您这么做可不妥当。他说，我就是很喜欢你啊！当时校车已近校门，我赶紧甩开他下车了！”</p><p>之后，张鹏尾随她，并变本加厉进行骚扰，“上课下课都跟着我，找到机会就凑过来……动作越来越过分，往耳朵吹气，抚摸胸部，语言上多次要求发生男女关系，我没有办法，只好每次课都尽可能地约学生陪同搭车。当时我认识了一个住在南校、跟我一样需要搭校车往返的女学生。下课后，留意到张又在尾随我，为了不引起他的注意，我都用外语小声告诉学生这件事，希望她保护我。至此之后，该女生便一直陪同我，每次都坐在我的座位旁边。她也亲眼看到了张鹏的一些性骚扰行为。”</p><p>经多方打听，我只得知这位随行的女生是当时旅游管理学院的一位学生，但后来去了法国留学，没有留下有效的联系方式，我至今没有联系到对方进行佐证。</p><p>张鹏的性骚扰后来越发露骨和恶劣。另一知情的学生透露，女老师在写举报信前曾跟她说过：2012年初，张鹏平均每天发两三条短信或者打电话给她，言辞暧昧，直接要求去酒店开房或去办公室约会。</p><p>2012年春季，女老师调到珠海校区上课，张鹏不知道通过什么方式找到她在珠海校区的教师公寓住址，来到她门口不断敲门，“一敲就敲差不多一个小时，教师公寓的住客比较少，周围没什么人，我吓得不敢动弹。他又不断给我发短信，用词非常露骨，我只能不断地删除，并且把他拉黑名单，因为他，我换了三次号码。”</p><p>这段骚扰持续了几年，女老师已经结婚生子，直到2017年，张鹏依然尝试添加她的微信，纠缠不止。</p><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><p>2017届女生和女老师的遭遇给学子们敲醒了警钟：若继续沉默，只能成为待宰羔羊。2018年5月4日，青年节的时候，女生们实名给中大纪委寄出了五个当事人的举报信。</p><p>女生们的举报在学院里传开，支持当事人的学生们自主成立了“中山大学人类学系反性骚扰小组”（下称小组），草拟了建议信并半公开征集联署，很快把《人类学系学子关于本系的舆论事件及加快建立本院反性骚扰机制的建议信》发送至院长、副院长、系主任的邮箱。</p><p>学生们提出，他们查阅了《中山大学学生手册》、《中山大学学生申诉处理暂行办法》以及附录中的《高等学校校园秩序管理若干规定》和《学生伤害事故处理办法》，都没有找到关于性骚扰问题向何处申诉、哪个机构/部门负责处理、如何处理等信息。“文件多，却都没有实质操作意义”。</p><p>他们还查阅了《中山大学关于建立健全师德建设长效机制的实施办法》，文件中确实有指出纪检监察部门负责接收师德相关的举报：“只是，我们发现，里面邮箱负责人都不知道是谁；查到的联系电话，大多是党政办公室的电话，也是外部联系社人院的联系通路，其繁忙程度可想而知。在无专人负责、事务繁杂的情况下，我们有理由质疑，通过这部电话进行的申诉能否得到重视和处理。”</p><p>小组建议，尽快出台有效的校园反性骚扰机制，进行性骚扰的师生教育、田野行前培训；在院系层面设立公开渠道接受关于性骚扰的投诉举报、设立专门的负责人受理相关事宜等。</p><p>还有中大学生在“为学校发展规划建言献策之‘十大提案’活动”中上交了“关于中山大学师风师德规范细则的建议”的提案，提案详细分析了《中山大学关于建立健全师德建设长效机制的实施办法》和《中山大学教师考核实施办法（试行）》，指出，“中山大学在制度层面上已经有师德建设与师德考核制度，但既存的不同制度之间的重叠、区分甚至相互矛盾，不同渠道的程序的复杂，都让受害者望而却步，让既有的好制度失去其应有的作用。”</p><p>然而，提案上交后，一些校领导多次找了提交提案的学子们谈话，表示提案做得很好，但“这个话题太敏感不宜公开讨论”，甚至拒绝了让学生公开对提案进行答辩，在提案优秀奖的奖状上，也不能出现提案具体名称。</p><p>我联系中大相关部门对张鹏性骚扰事件以及学子们对反性骚扰机制的建议和提案进行回应，对方表示“不能接受采访，所有采访通过中大宣传部”。我于7月5日、6日的上午和下午的办公时间，分别打了4次电话致电中大宣传部，一直无人接听。</p><h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><p>陈翰元告诉我，最终触发他实名站出来的原因是，他看到张静的焦虑以及她对学术的失望。</p><p>“她以前对灵长类很有兴趣的，说起猴子的属性，观察它们群居生活，给它们一一命名，说起来她都是神飞色舞的。她去岛上田野，住得不好，吃得不好，蚊子多，被咬得一身包，她一句怨言都没有，都是兴致勃勃的。现在呢，因为张鹏，她都放弃了原本最感兴趣的研究。对学术的热爱一下子被打破了。张鹏这样性骚扰女生，是断了女孩子一条学术路，伤害女孩子平等受教育的权利。”陈翰元十分惋惜，“她那么聪明、勤奋，如果遇到的是个好导师，肯定会继续做科研的。”</p><p>陈静坦言，后来张鹏叫她参加暑假期间印尼苏门答腊的一个研究项目，她因不想再与张鹏接触，放弃了机会。</p><p>小柯原本也想尝试在同一个方向做科研，但课题结束后，完全失去了对灵长类的兴趣。她发现自己对张鹏有很强的心理抵触，“国内的灵长类研究领域里张鹏有一定的权威性，教授都这样了，还有什么意思呢？”多种原因下，她放弃了这个研究方向，甚至放弃了在中大的读研机会。</p><p>笑薇也告诉我，虽然张鹏的性骚扰不是导致她放弃灵长类研究的唯一原因，但也是主要原因之一。2017级的女孩子，在被张鹏性侵害后，同样选择了放弃。</p><p>“你说，他伤害了那么多的女学生，为什么还能继续留在中大？”陈静久久不能释怀，“为什么学校会认为‘老师对学生的捏捏抱抱、亲亲吻吻是小事一桩’呢？”</p><p>举报两个月了。中大纪委与女孩们一一座谈了，但对张鹏的处罚仍是未知之数。</p><p>女生们说，纪委调查期间也问话了张鹏，张鹏把一切都否认了。</p><p>我打电话采访张鹏，问他女孩们举报信上的内容是否属实？张鹏说了一句“你没有工作单位，我不认识你”，便挂掉了我的电话，不再回应。</p><p>张鹏仍如往常一样，在实验室里来来回回，若无其事。张鹏的妻子也走进了实验室，要求实验室学生们写一份“张鹏老师无不当行为”的证明，但遭到实验室学生的拒绝。</p><p>陈静和其他还留在学校的当事人担心事件再一次被压下去，她们害怕如果学校继续纵容，那以后张鹏必然会更加肆无忌惮伤害更多的人。</p><p>更让她们寒心的是，在一个课程群里，仍有老师把名为《你还敢报中山大学人类学的在职研究生吗》的帖子贴到群里，还公开发表了“不要过分纠结”、“有些社会对带色笑话能够容忍，可以舒缓工作压力”等言论。</p><p>举报者们好不容易积累起来的勇气和信心正在一点点流逝。</p><p>“难道真的需要用生命做祭品，像庆阳女孩一样，才能让他的行为看起来恶劣吗？我们该怎么办？”</p><p>陈静又焦虑起来，这一天她的噩梦里，张鹏拿着刀，准备杀了她。</p><p>（应受访者要求：陈静、笑薇、小柯为化名）</p><p>编辑：许智博</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI0MjAwNTQzOA==&amp;mid=2649890140&amp;idx=2&amp;sn=b72d5c487c22b27fb2b030ff3284ba1b&amp;chksm=f104598dc673d09be96d6071fd6abbcd59a95b24e428c9dba8ef34f1027539a5a208aa1390c7&amp;scene=21#wechat_redirect">点击联系人间编辑</a></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="">  </p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt=""></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 人间世 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人间世 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外国语学院-情况说明</title>
      <link href="//posts/2018/04/24/A-Fact-Sheet-By-PKU/"/>
      <url>//posts/2018/04/24/A-Fact-Sheet-By-PKU/</url>
      
        <content type="html"><![CDATA[<h1 id="情况说明"><a href="#情况说明" class="headerlink" title="情况说明"></a>情况说明</h1><p>2018年4月23日上午，有微信公众号发布我院岳昕同学的《公开信》。学院第一时间向有关老师和同学了解情况，现作说明如下：</p><span id="more"></span><p>2018年4月22日下午和晚上，学院辅导员出于对学生的关心，通过多种方式、多次联系岳昕同学，均未能联系上，这种情况下，辅导员感到担忧。到23:30左右，该同学还未回到寝室。出于对同学安全的关心，辅导员与同学的母亲联系，询问岳昕同学是否回家等情况。该同学的母亲表示，孩子并未回家；之后，家长拨打电话未接，发微信未回，因此感到着急，随后赶到宿舍。此时，该同学已回到宿舍，母亲与其进行沟通。因担心影响其他同学休息，母亲决定和同学一起回家。</p><p>2018年4月23日上午，学院关注到网络上的相关信息后，与家长进一步沟通了情况，表达了关心。学院的老师与家长一样，都真心爱护学生、关心学生，既关心学生的学习，也关心学生的健康、安全与成长，老师和家长是善意的，态度也是一致的。</p><p>据了解，该同学已提交了毕业论文的部分初稿，指导老师也非常关心，给予了积极评价和悉心指导，并希望注意写作进度。</p><p>学院是学生成长成才的家园，老师们尽一切努力关心爱护学生，而这份关爱也意味着责任所在，学院、老师与家长都同样担负着教育的责任。与此同时，我们始终尊重每一位同学的基本权利、努力保障每一位同学的合法权益。</p><p>我们感谢师生、校友对学院工作的关心。</p><p>北京大学外国语学院<br>2018年4月23日</p>]]></content>
      
      
      <categories>
          
          <category> 社会 </category>
          
          <category> PKU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会 </tag>
            
            <tag> PKU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>岳昕：致北大师生与北大外国语学院的一封公开信</title>
      <link href="//posts/2018/04/24/A-public-letter-to-PKU/"/>
      <url>//posts/2018/04/24/A-public-letter-to-PKU/</url>
      
        <content type="html"><![CDATA[<h1 id="岳昕：致北大师生与北大外国语学院的一封公开信"><a href="#岳昕：致北大师生与北大外国语学院的一封公开信" class="headerlink" title="岳昕：致北大师生与北大外国语学院的一封公开信"></a>岳昕：致北大师生与北大外国语学院的一封公开信</h1><p>北京大学的老师和同学：<br>你们好！<br>我是2014级外国语学院的岳昕，是4月9日早上向北京大学递交《信息公开申请表》的八位到场同学之一。我拖着极疲惫的身躯写下这段文字，说明近来发生在我身上的一些事情。</p><span id="more"></span><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>4月9日之后，我不断被学院学工老师、领导约谈，并两次持续到凌晨一点甚至两点。在谈话中，学工老师多次提到“能否顺利毕业”、“做这个你母亲和姥姥怎么看”、“学工老师有权不经过你直接联系你的家长”。而我近期正在准备毕业论文，频繁的打扰和后续的心理压力严重影响了我的论文写作。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>4月20日中午，我收到了校方的回复。外国语学院党委书记、学工老师、班主任在场，党委书记向我宣读了学校对于本次信息公开申请的答复：</p><ol><li>讨论沈阳师德的会议级别不够记录</li><li>公安局调查结果不在学校的管理范围里</li><li>沈阳公开检讨的内容因中文系工作失误也没有找到</li></ol><p>这样的回复结果令我失望。但毕业论文提交即将截止，我只能先将心思放在论文写作上。</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>4月22日晚上十一点左右，辅导员突然给我打来电话，但因为时间已晚，我并没有接到。凌晨一点，辅导员和母亲突然来到我的宿舍，强行将我叫醒，要求我删除手机、电脑中所有与信息公开事件相关的资料，并于天亮后到学工老师处作出书面保证不再介入此事。有同楼层的同学可以作证。随后，我被家长带回家中，目前无法返校。<br>我和母亲都彻夜未眠。学校在联系母亲时歪曲事实，导致母亲受到过度惊吓、情绪崩溃。因为学校强行无理的介入，我和母亲关系几乎破裂。学院目前的行动已突破底线，我感到恐惧而震怒。<br>申请信息公开何罪之有？我没有做错任何事，也不会后悔曾经提交《信息公开申请表》，行使我作为北大学生的光荣权利。<br>二十年孺慕情深，我爱我的母亲。面对她的嚎啕痛哭、自扇耳光、下跪请求、以自杀相胁，我的内心在滴血。在她的哀求下我只能暂时回到家中，但原则面前退无可退，妥协不能解决任何问题，我别无他法，只有写下这篇声明，陈述原委。<br>情绪激动，请大家原谅我的语无伦次。</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>在此，我正式向北京大学外国语学院提出以下诉求：</p><ol><li>北京大学外国语学院应公开书面说明越过我向家长施压、凌晨到宿舍强行约谈我、要求我删除申请信息公开一事的相关资料所依据的规章制度，对此过程中违法违规操作予以明确，并采取措施避免此类事件再次发生。</li><li>北京大学外国语学院应立即停止一切对我家人的施压行为，向我已经遭受惊吓的母亲正式道歉并澄清事实，帮助修复因此事导致的家庭紧张关系。</li><li>北京大学外国语学院必须公开书面保证此事不会对本人毕业一事产生影响，并不会再就此事继续干扰我的论文写作进程。</li><li>北京大学外国语学院负责消除此事对本人学业、未来就业和家人的其他一切不良影响。</li><li>北京大学外国语学院应明确就以上诉求进行公开书面回复，给关注此事的大家一个交代。</li></ol><p>我将保留通过法律手段进一步追究相关个人和单位责任的一切权利，包括但不限于向北京大学和上级主管部门举报外国语学院严重违反校纪的行为。</p><p>北京大学外国语学院14级本科生岳昕<br>2018年4月23日</p>]]></content>
      
      
      <categories>
          
          <category> 社会 </category>
          
          <category> PKU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会 </tag>
            
            <tag> PKU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>申请公开信息事件经过（量产基地）</title>
      <link href="//posts/2018/04/24/A-Fact-Sheet/"/>
      <url>//posts/2018/04/24/A-Fact-Sheet/</url>
      
        <content type="html"><![CDATA[<h1 id="转自公众号：量产基地"><a href="#转自公众号：量产基地" class="headerlink" title="转自公众号：量产基地"></a>转自公众号：量产基地</h1><h2 id="文章已被404"><a href="#文章已被404" class="headerlink" title="文章已被404"></a>文章已被404</h2><p>4月22日，我采访了岳昕和其他一同申请信息公开的同学，希望了解关于信息公开结果的更多情况。就在采访结束后的凌晨一点，岳昕的母亲与辅导员来到她的宿舍，将她叫醒，要求她删除手机电脑中所有与信息公开事件相关的资料，并要求她书面保证不再介入此事。随后，她被母亲带回家中，无法返校。</p><span id="more"></span><p>12个小时后，岳昕通过公众号“深约一丈”发表了面对北京大学师生及北京大学外国语学院的公开信，表示自己因学校的介入“恐惧而震怒”，并希望学院作出公开说明。</p><p><strong>“我不能打一百分”</strong></p><p>4月9日上午10点整，十名同学（实际到场八名）向北京大学提交关于1998年7月前后讨论沈阳‘师德’问题的系列会议记录的信息公开申请。4月20日，提交申请的同学们，及其余十五名通过邮件申请信息公开的同学均收到了来自北京大学信息公开办公室的答复。</p><p>岳昕是申请信息公开的十名同学之一。4月20日中午11时30分，她和其他同学一样，被邀请前往自己所在院系行政楼的会议室内。学工老师向她出示了校方的答复函，并问：“这个回复可以打一百分吗？”</p><p>岳昕回答：“我肯定不能打一百分。”</p><p>老师说：“如果我们学校的同学都不能打一百分，那校外的人会打多少分呢？是不是会打负分呢？”</p><p>岳昕说，她和同学们收到的答复，其实并无太多有效信息——答复函中表示，学校已在2018年4月8日向社会主动公开了《关于给予沈阳行政警告处分的决定》和中文系《关于给予沈阳警告处分的决定》，并给出查询网址链接。但对于信息申请中提及的“党委相关会议记录”“西城区公安局对此事的调查结果通报”“中文系相关会议记录”及“沈阳在大会上公开检讨的内容”，均表示现有档案并无相关信息。答复函承认当时学校和院系管理工作并不规范健全，并以“不断加强师德建设，认真落实立德树人的根本任务”作为结尾。</p><p>答复函中援引了《高等学校信息公开办法》第十八条（三）：“不属于本校职责范围的或该信息不存在的，应当告知申请人”。</p><p>岳昕想拿走答复函的纸质文件，被老师拒绝了：“给你有百害而无一利，搞不好你以后不能顺利毕业。”岳昕说，由于她参与过大量媒体工作的缘故，校方或许担心她将文件交给媒体。她从这样的拒绝中读出不信任，并再次和学工老师协商。院系学工老师在斟酌后，最终将纸质文件交给她。</p><p>在得到回复的25人中，只有岳昕和另一位同学保留了纸质文件。张震林是同样曾申请信息公开的同学之一，当他申请保留纸质文件时，院系学工老师以“规定”必须将纸质文件留在院系里为由，拒绝了他，并表示学生如有需要，可以随时来院系查看。张震林无奈同意。事后他翻阅文件，发现并无具体规定禁止。</p><p>在收取回复函期间，同学们被禁止录音。岳昕表示学工老师曾试图拿起她的手机检查，她于是将手机往自己的方向“拨了一下”。但出于种种顾虑，部分同学依然保留了当时的录音。<br>同学们的顾虑并非全无缘由——对张震林来说，保留录音曾成为他保护自己的方式之一。<br>“什么是明确的表态呢？”</p><p>在4月9日张震林申请信息公开的当天，院系辅导员曾给他打电话，表示学校学工部曾找自己了解学生情况，被她“挡回去了”。辅导员随后联系了张震林的同学，次日下午，同学转告张震林，称提请信息公开一事背后或有境外势力支持，让他谨言慎行。张震林“感到害怕”，于是主动联系辅导员，4月11上午9点，张震林和辅导员见面谈话。看见有两个手机倒扣在桌面上，他怀疑辅导员在现场秘密录音。因此，他也录了音。</p><p>据张震林回忆，辅导员先和他聊了聊学业及职业规划，并问他是否认识提请信息公开的其他同学。这些问题以“你显然和xxx交情不浅”的方式提出。张震林认为“这些都是诱导性提问”，他承认自己由于同处一个专业，和一位同学关系不错，但是“她一直认为我们是一个组织的”，对于这个问题，他表示否认。</p><p>辅导员向张震林提出“三条指控”：前去提交信息公开申请表的同学统一着装且佩戴口罩，极可能是有组织有预谋的行动，而张震林是他们的组织者之一；这一行动受到了境外组织的资金支持，张震林作为组织者对此知情；张震林在当天联系了境外媒体。<br>据岳昕回忆，当时前去的同学并非统一着装，“我穿了一件米色风衣”；有部分同学因害怕被媒体拍到的缘故佩戴口罩，但并非人人如此；提交信息公开申请表的当天早上有十余家媒体在校门口以“拍摄花鸟”为由试图进校，其中确有外媒。但是张震林表示对这件事毫不知情。而是后来辅导员告诉他的。</p><p>张震林自认并不活跃，只是一同去提交信息公开申请。在被辅导员质问时，甚至觉得不可思议，“笑得很开心”——他随后否认以上指控。约谈现场有另一名他不认识的同学在场，“明显偏向辅导员一方”。这令他觉得很奇怪。</p><p>辅导员并不相信张震林，最后表示“我护你到什么程度取决于你说了多少”。事后，她再次联系张震林的同学，希望同学劝说张震林坦白实情。张震林认为她并不信任自己，因为他“说话吞吐且前后不一”“当提到有外媒时表现得很镇定，像是早已经知道了一样”。他还得知，辅导员对他的同学说，会向学校汇报关于他的约谈材料，如果他的同学“表现得不错”，材料将不会涉及被辅导员找来劝说自己的那位同学。</p><p>张震林托同学转告辅导员自己已坦白一切，但辅导员又找到另一位同学劝说张震林，再次询问他和境外组织的关系。张震林为此十分恐惧，4月12日，他向辅导员发微信表示自己的确和境外组织无任何瓜葛。辅导员以几段语音回复他：“心情差可以找我聊天”“反性侵可以从别的渠道”“给我一个明确的表态”。</p><p>“什么是明确的表态呢？”张震林问。</p><p>辅导员拒绝在微信上回答，要求面谈。</p><p>4月13日早上，辅导员给他的父亲打去电话，告知相关情况并希望他来学校。当晚八点左右，父亲到达张震林宿舍楼下，但张震林已因害怕辅导员来宿舍找自己的缘故，选择去北京八中附近的一家宾馆住宿。父亲和辅导员及张震林所在院系的党委副书记老师见面。次日，张震林见到父亲，父亲并不相信辅导员的几条指控，但依然为他担忧。“他有想调和的意思。”张震林认为，父亲是被“吓住了”。</p><p>张震林从辅导员处要到老师的电话，通话中，他表示自己有当天约谈的录音，希望学院能为此公开道歉并消除不良影响。一番协商后，老师当面向他道歉，并向他的父亲与同学澄清此事。次日，张震林和熟识的同学聊起此事，向公众号“深约一丈”讲述了这件事。4月14日，公众号“深约一丈”发表文章《沈阳事件近期情况汇总》，文章中提及这次约谈，随后以“违反网络信息安全法”为由被删除，公众号被禁言七天。</p><p>岳昕表示，通过家长渠道去做学生工作是“非常常见的威胁手法”。4月20日她收取学校答复时，也被学工老师提醒：学工部门有权不经过学生直接联系家长。</p><p><strong>“我们对此表示遗憾”</strong></p><p>岳昕对自己的经历感到“非常憋屈”。提请信息公开后，她同样多次收到了来自院系辅导员的约谈要求。4月10日，学工老师不断给她打电话，她因忙于毕业论文的缘故未能接听，回复短信表示已经收到消息。</p><p>4月11日晚上10点左右，岳昕在寝室换上睡衣准备开始写论文，学工老师出现在寝室门口，将她带去约谈。</p><p>此次约谈后不久，她得知张震林同被约谈的消息。正值规划毕业去向之际，母亲打来电话，她害怕母亲知情，又害怕母亲的顾虑会让她放弃自己喜爱的工作，心理压力大到一度不敢同母亲通话。她开始同朋友商量“最坏的可能性与对策”——4月15日下午，她正在思考此事时，社会学系的一位老师发来邀请，希望她能列席参与次日的“反性骚扰暂行规定学生意见征集会”，晚上10点，她收到了具体的时间地点信息。</p><p>据后来学工老师与她的约谈内容，学工老师称，在相关老师向她发出邀请时，曾有其他老师提出质疑。学工老师认为这是锻炼和成长机会，于是同意岳昕参加。张震林从岳昕处得知意见征集会的消息，向老师申请参加，得到了主办方的同意。</p><p>4月16日，意见征集会举行，该会议并未公开，而是邀请了学生常代表和部分学生。公众号“北门静悄悄”为此发文询问为何不公开征集意见。会上讨论了性骚扰的概念界定、反性骚扰专门委员会的代表产生、性骚扰的投诉与受理、调解机制、师生恋问题、资源对接、委员会监督、保护、保密及信息公开等问题。岳昕及张震林作为列席成员，提出许多问题。</p><p>主持人不希望同学在会后带走材料或将材料传到网上，但并未规定是否可以将会议内容录音或者在网上转述。4月17日晚上，张震林在未名BBS“三角地”板块和自己的公众号“境外事例”上发表了会议内容记录，并在未名BBS“校长信箱”板块提出自己的8条建议，校方回复说：“同学，你好！学校专家组会对你的意见进行研究， 感谢你的建议。”</p><p>北京大学学生会常代会回复了BBS的会议内容记录帖子：“有网友未经会议主办方确认，自行在互联网上发布本次会议‘记录整理’，我们对此表示遗憾。”</p><p>据北京大学新闻中心报道，2018年4月17日下午，学校召开第935次校长办公会议，专题研究反性骚扰暂行规定。</p><p>4月19日，老师再次约谈张震林，询问BBS的帖子是否由他发布。张震林认为他“管不着”，但又不想撒谎，于是拒绝回答。老师询问次日上午，他是否有时间来院系一趟——时间定在11时30分。次日11时25分，张震林来到院系办公楼门口，发现老师已久候多时。</p><p>他随后收到了11天前，关于信息公开申请的回复函。院长、党委书记和副书记及其他学工老师均在场。张震林认为，整个学院“精锐部队”全部出动的阵仗，可能会让很多同学觉得“压力非常大”。</p><p>老师在他吃午餐时，私下提醒他“这事到此为止，不要公开，也不要发BBS说自己收到回复的事。”</p><p>岳昕则表示，在得到回复的同时，老师们也略带威胁地同她聊天，甚至屡屡谈及“顺利毕业”的话题。</p><p>回顾从提请信息公开申请至收到回复函的过程，岳昕首先进行了反思：她对自己的表现还是不太满意，在她认为学工老师谈话有明显不合理、体现权力不对等的地方，她表现得还不够强硬。同时，她也认为自己没能发动更多同学：只有十名同学当场提交信息公开申请表，十五名同学通过邮箱提交申请表，这个数量并不算多；她也未能和更多同学交流自己的想法。<br>但她始终认为，做事应当有始有终，才能让敢于发声的同学不致失望，也不会让其他同学们失去对自己的信任。毕业在即，她认为这才是一个爱北大的同学该做的事——“而不是为了120周年校庆歌舞升平”。</p><p>目前，同学们可以通过校长信箱或BBS其他版面向学校提出自己的意见，也可参与学生会主办的“我的校园我做主”座谈会参与校园事务，当然也可以申请信息公开。但岳昕认为这还远远不够——同学发在BBS上的意见，往往不能从根本上解决问题，“可能只是扣掉后勤工友的工资”。她曾参与过第三次“我的校园我做主”座谈会，那次座谈会针对保卫部和共享单车的管理问题，但她参与之后，却认为同学们在座谈会上很难做好充足的准备，发声较为分散，容易被校方目为幼稚，“依然是信息不对等的结果”。</p><p>由于她是4月9日上午第三名提交信息公开申请表的同学，她拿到的回复函抬头为“北大信息公开[2018]3号”。这意味着在本次申请信息公开之前，尚无其他同学就其他可能关心的事件向学校申请信息公开。</p><p>4月19日下午16时44分，她再次被学工老师约谈。最后，她们在未名湖边聊了四个多小时。老师不断劝说她考虑家人的感受，“不必走到申请信息公开的最后一步”“反正最后也会告诉你”。岳昕暂时没有回复她。</p><p>4月20日5时33分，岳昕向老师发信息，表示仍希望走完信息公开的整个流程。</p><p>7时09分，她收到短信回复：“你真的想清楚了吗？还是再想想吧。”</p><p><strong><em>不是尾声的尾声</em></strong></p><p>4月23日下午12时57分，公众号“深约一丈”刊载岳昕的公开信；13时18分，公众号显示“此内容因违规无法查看”。</p>]]></content>
      
      
      <categories>
          
          <category> 社会 </category>
          
          <category> PKU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会 </tag>
            
            <tag> PKU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么样去理解 Python 中的装饰器</title>
      <link href="//posts/2018/02/22/something-about-decorator/"/>
      <url>//posts/2018/02/22/something-about-decorator/</url>
      
        <content type="html"><![CDATA[<h1 id="怎么样去理解-Python-中的装饰器"><a href="#怎么样去理解-Python-中的装饰器" class="headerlink" title="怎么样去理解 Python 中的装饰器"></a>怎么样去理解 Python 中的装饰器</h1><p>首先，本垃圾文档工程师又来了。开始日常的水文写作。起因是看到这个问题<a href="https://www.zhihu.com/question/26930016/">如何理解Python装饰器？</a>，正好不久前给人讲过这些，本垃圾于是又开始新的一轮辣鸡文章写作行为了。</p><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>首先要理解装饰器，首先要先理解在 Python 中很重要的一个概念就是：“函数是 First Class Member” 。这句话再翻译一下，函数是一种特殊类型的变量，可以和其余变量一样，作为参数传递给函数，也可以作为返回值返回。</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">abc</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">abc1</span>(<span class="params">func</span>):</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line">abc1(abc)</span><br></pre></td></tr></table></figure><p>这段代码的输出就是我们在函数 <code>abc</code> 中输出的 <code>abc</code> 字符串。过程很简单，我们将函数 <code>abc</code> 作为一个参数传递给 <code>abc1</code> ，然后，在 <code>abc1</code> 中调用传入的函数</p><p>再来看一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">abc1</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">abc</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> abc</span><br><span class="line">abc1()()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码输出和之前的一样，这里我们将在 <code>abc1</code> 内部定义的函数 <code>abc</code> 作为一个变量返回，然后我们在调用 <code>abc1</code> 获取到返回值后，继续调用返回的函数。</p><p>好了，我们再来做一个思考题，实现一个函数 <code>add</code> ，达到 <code>add(m)(n)</code> 等价于 <code>m+n</code> 的效果。这题如果把之前的 First-Class Member 这一概念理清楚后，我们便能很清楚的写出来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">temp</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">return</span> m+n</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>)(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>嗯，这里输出就是 3 。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>看了前面的预备知识后，我们便可以开始今天的主题了</p><h3 id="先来看一个需求吧"><a href="#先来看一个需求吧" class="headerlink" title="先来看一个需求吧"></a>先来看一个需求吧</h3><p>现在我们有一个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br></pre></td></tr></table></figure><p>现在我们要给这个函数加上一些代码，来计算这个函数的运行时间。</p><p>我们大概一想，写出了这样的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop</span>(<span class="params">a,b</span>):</span><br><span class="line">    time_flag=time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="built_in">print</span>(time.time()-time_flag)</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br></pre></td></tr></table></figure><p>先且不论，这样计算时间是不是准确的，现在我们要给如下很多函数加上一个时间计算的功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop</span>(<span class="params">a,b</span>):</span><br><span class="line">    time_flag=time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="built_in">print</span>(time.time()-time_flag)</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop1</span>(<span class="params">a,b</span>):</span><br><span class="line">    time_flag=time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="built_in">print</span>(time.time()-time_flag)</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop2</span>(<span class="params">a,b</span>):</span><br><span class="line">    time_flag=time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="built_in">print</span>(time.time()-time_flag)</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br></pre></td></tr></table></figure><p>我们初略一想，嗯，Ctrl+C,Ctrl+V。emmmm 好了，现在你们不觉得这段代码特别脏么？我们想让他变得干净点怎么办？</p><p>我们想了想，按照之前说的 First-Class Member 的概念。然后写出了如下的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">time_count</span>(<span class="params">func,a,b</span>):</span><br><span class="line">    time_flag=time.time()</span><br><span class="line">    temp_result=func(a,b)</span><br><span class="line">    <span class="built_in">print</span>(time.time()-time_flag)</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop1</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop2</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line">time_count(range_loop,a,b)</span><br><span class="line">time_count(range_loop1,a,b)</span><br><span class="line">time_count(range_loop2,a,b)</span><br></pre></td></tr></table></figure><p>嗯，看起来像那么回事，好了好了，我们现在新的问题又来了，我们现在是假设，我们所有函数都只有两个参数传入，那么现在如果想支持任意参数的传入怎么办？我们眉头一皱，写下了如下的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">time_count</span>(<span class="params">func,*args,**kwargs</span>):</span><br><span class="line">    time_flag=time.time()</span><br><span class="line">    temp_result=func(*args,**kwargs)</span><br><span class="line">    <span class="built_in">print</span>(time.time()-time_flag)</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop1</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop2</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line">time_count(range_loop,a,b)</span><br><span class="line">time_count(range_loop1,a,b)</span><br><span class="line">time_count(range_loop2,a,b)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好了，现在看起来，有点像模像样了，但是我们再想想，这段代码实际上改变了我们的函数调用方式，比如我们直接运行 <code>range_loop(a,b)</code> 还是没有办法获取到函数执行时间。那么现在我们如果不想改变函数的调用方式，又想获取到函数的运行时间怎么办？</p><p>很简单嘛，替换一下不就好了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">time_count</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrap</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        time_flag=time.time()</span><br><span class="line">        temp_result=func(*args,**kwargs)</span><br><span class="line">        <span class="built_in">print</span>(time.time()-time_flag)</span><br><span class="line">        <span class="keyword">return</span> temp_result</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop1</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop2</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line">range_loop=time_count(range_loop)</span><br><span class="line">range_loop1=time_count(range_loop1)</span><br><span class="line">range_loop2=time_count(range_loop2)</span><br><span class="line">range_loop(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">range_loop1(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">range_loop2(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>emmmm，这样看起来感觉舒服多了？既没有改变原有的运行方式，也输出了函数运行时间。</p><p>但是。。。你们不觉得手动替换太恶心了么？？？喵喵喵？？？还有什么可以简化下的么？？</p><p>好了，Python 知道我们是爱吃糖的孩子，给我们提供了一个新的语法糖，这也是今天的男一号，Decorator 装饰器</p><h3 id="说说-Decorator"><a href="#说说-Decorator" class="headerlink" title="说说 Decorator"></a>说说 Decorator</h3><p>我们前面已经实现了，在不改变函数特性的情况下，给原有的代码新增一点功能，但是我们也觉得这样手动的替换，太恶心了，是的 Python 官方也觉得这样很恶心，所以新的语法糖来了</p><p>我们上面的代码可以写成这样了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">time_count</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrap</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        time_flag=time.time()</span><br><span class="line">        temp_result=func(*args,**kwargs)</span><br><span class="line">        <span class="built_in">print</span>(time.time()-time_flag)</span><br><span class="line">        <span class="keyword">return</span> temp_result</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line"><span class="meta">@time_count    </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line"><span class="meta">@time_count</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop1</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line"><span class="meta">@time_count</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop2</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line">range_loop(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">range_loop1(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">range_loop2(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>哇，写到这里，你是不是恍然大悟！まさか？？？是的，其实 <code>@</code> 符号其实是一个语法糖，他将我们之前的手动替换的过程交给了环境执行。好了用人话描述下，<code>@</code> 的作用是将被包裹的函数作为一个变量传递给装饰函数/类，将装饰函数/类返回的值替换原本的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">abc</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>如同前面所讲的一样，实际上是发生了一个特殊的替换过程 <code>abc=decorator(abc)</code> ，好了我们来做几个题来练习下吧？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">abc</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">abc()</span><br></pre></td></tr></table></figure><p>这段代码会发生什么？答：会抛出异常。为啥啊？答：因为装饰的时候发生了替换，<code>abc=decorator(abc)</code> ，替换后 <code>abc</code> 的值为 1 。整数默认不能作为一个函数进行调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">time_count</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrap</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        time_flag=time.time()</span><br><span class="line">        temp_result=func(*args,**kwargs)</span><br><span class="line">        <span class="built_in">print</span>(time.time()-time_flag)</span><br><span class="line">        <span class="keyword">return</span> temp_result</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrap</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        temp_result=func(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> temp_result</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decorator1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrap</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        temp_result=func(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> temp_result</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line"></span><br><span class="line"><span class="meta">@time_count</span></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="meta">@decorator1    </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br></pre></td></tr></table></figure><p>这段代码怎么替换的？答：<code>time_count(decorator(decorator1(range_loop)))</code> </p><p>嗯，现在是不是对装饰器什么的有了基本的了解？</p><h3 id="扩展一下"><a href="#扩展一下" class="headerlink" title="扩展一下"></a>扩展一下</h3><p>现在，我想修改下前面写的 <code>time_count</code> 函数，让他支持传入一个 <code>flag</code> 参数，当 <code>flag</code> 为 <code>True</code> 的时候，输出函数运行时间，为 <code>False</code> 的时候不输出时间</p><p>我们一步步来，我们先假设新的函数叫做 <code>time_count_plus</code></p><p>我们想实现的效果是这样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@time_count_plus(<span class="params">flag=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br></pre></td></tr></table></figure><p>嗯，我们看了下，首先我们调用了 <code>time_count_plus(flag=True)</code> 一次，将它返回的值作为一个装饰函数来替换 <code>range_loop</code> ，OK 那么我们首先 <code>time_count_plus</code> 要接收一个参数，返回一个函数对吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">time_count_plus</span>(<span class="params">flag=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrap1</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> wrap1</span><br></pre></td></tr></table></figure><p>好了，现在返回了一个函数来作为装饰函数，然后我们说了 <code>@</code> 其实触发了一次替换过程，好那么我们现在的替换是不是 <code>range_loop=time_count_plus(flag=True)(range_loop)</code> 好了，现在大家应该很清楚了，我们在 <code>wrap1</code> 里面是不是还应该有一个函数并返回？</p><p>嗯，最终的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">time_count_plus</span>(<span class="params">flag=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrap1</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrap2</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                time_flag=time.time()</span><br><span class="line">                temp_result=func(*args,**kwargs)</span><br><span class="line">                <span class="built_in">print</span>(time.time()-time_flag)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp_result=func(*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> temp_result</span><br><span class="line">        <span class="keyword">return</span> wrap2</span><br><span class="line">    <span class="keyword">return</span> wrap1</span><br><span class="line"><span class="meta">@time_count_plus(<span class="params">flag=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">range_loop</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b):</span><br><span class="line">        temp_result=a+b</span><br><span class="line">    <span class="keyword">return</span> temp_result</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>是不是这样就清楚多啦！</p><h3 id="扩展两下"><a href="#扩展两下" class="headerlink" title="扩展两下"></a>扩展两下</h3><p>好了，我们现在有新的需求来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">m=<span class="number">3</span></span><br><span class="line">n=<span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a*b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a/b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我们有字符串 <code>a</code> , <code>a</code> 的值可能为 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 那么现在，我们想根据 <code>a</code> 的值来调用对应的函数怎么办？</p><p>我们煎蛋一想，嗯，逻辑判断嘛</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">m=<span class="number">3</span></span><br><span class="line">n=<span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a*b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a/b</span><br><span class="line">a=<span class="built_in">input</span>(<span class="string">&#x27;请输入 + - * / 中的任意一个\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> a==<span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(add(m,n))</span><br><span class="line"><span class="keyword">elif</span> a==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(sub(m-n))</span><br><span class="line"><span class="keyword">elif</span> a==<span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(mul(m,n))</span><br><span class="line"><span class="keyword">elif</span> a==<span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(div(m,n))</span><br></pre></td></tr></table></figure><p>但是这段代码，if else 是不是太多了点？我们仔细一想，用一下 First-Class Member 的特性，然后配合 dict 实现操作符和函数之间的关联。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">m=<span class="number">3</span></span><br><span class="line">n=<span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a*b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a/b</span><br><span class="line">func_dict=&#123;<span class="string">&quot;+&quot;</span>:add,<span class="string">&quot;-&quot;</span>:sub,<span class="string">&quot;*&quot;</span>:mul,<span class="string">&quot;/&quot;</span>:div&#125;</span><br><span class="line">a=<span class="built_in">input</span>(<span class="string">&#x27;请输入 + - * / 中的任意一个\n&#x27;</span>)</span><br><span class="line">func_dict[a](m,n)</span><br></pre></td></tr></table></figure><p>emmmm，看起来不错啊，但是我们注册的过程能不能再简化一点？ 嗯，这个时候装饰器语法特性就能用上了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">m=<span class="number">3</span></span><br><span class="line">n=<span class="number">2</span></span><br><span class="line">func_dict=&#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">operator</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrap</span>(<span class="params">func</span>):</span><br><span class="line">        func_dict[operator]=func</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line"><span class="meta">@register(<span class="params">operator=<span class="string">&quot;+&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"><span class="meta">@register(<span class="params">operator=<span class="string">&quot;-&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line"><span class="meta">@register(<span class="params">operator=<span class="string">&quot;*&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a*b</span><br><span class="line"><span class="meta">@register(<span class="params">operator=<span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a/b</span><br><span class="line"></span><br><span class="line">a=<span class="built_in">input</span>(<span class="string">&#x27;请输入 + - * / 中的任意一个\n&#x27;</span>)</span><br><span class="line">func_dict[a](m,n)</span><br></pre></td></tr></table></figure><p>嗯，还记得我们前面说的使用 <code>@</code> 语法的时候，实际上是触发了一个替换的过程么？这里就是利用这一特性，在装饰器触发的时候，注册函数映射，这样我们直接根据 ‘a’ 的值来获取函数处理数据。另外请注意一点，我们这里没有必要修改原函数，所以我们没有必要写第三层的函数。</p><p>如果有熟悉 Flask 同学就知道，在调用 <code>route</code> 方法注册路由的时候，也是使用了这一特性 ，可以参考另外一篇很久前写的垃圾水文 <a href="http://manjusaka.itscoder.com/2016/08/09/reading-the-fucking-flask-source-code-Part1/">菜鸟阅读 Flask 源码系列（1）：Flask的router初探</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实全文下来，大家应该能知道这样一点东西。Python 中的装饰器其实是 First-Class Member 概念的更进一层应用，我们将函数传递给其余函数，包裹上新的功能后再行返回。<code>@</code> 其实只是将这样一个过程进行了简化而已。在 Python 中，装饰器无处不在，很多官方库中的实现也依赖于装饰器，比如很久之前写过这样一篇垃圾水文 <a href="http://manjusaka.itscoder.com/2016/10/12/Something-about-Descriptor/">菜鸟阅读 Flask 源码系列（1）：Flask的router初探</a>。</p><p>嗯，今天就先写到这里吧！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> Flask </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sanic 的若干吐槽</title>
      <link href="//posts/2018/02/22/why-i-dont-recommend-sanic/"/>
      <url>//posts/2018/02/22/why-i-dont-recommend-sanic/</url>
      
        <content type="html"><![CDATA[<h1 id="Sanic-的若干吐槽"><a href="#Sanic-的若干吐槽" class="headerlink" title="Sanic 的若干吐槽"></a>Sanic 的若干吐槽</h1><p>刚刚和红姐，在 <a href="https://www.zhihu.com/question/24590883/answer/286407918">哪些 Python 库让你相见恨晚？</a> 这个答案下面讨论了一下 Sanic 的优劣。</p><p>突然想起，我司算是国内应该比较少见的把 Sanic 用在正式生产线上的公司了，作为一个主力推（da）动（shui）者（bi），我这个辣鸡文档工程师觉得有必要来说一下我们在使用 Sanic 过程中所采用的一系列深坑。</p><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先 <a href="http://sanic.readthedocs.io/en/latest/">Sanic 官方</a> 的口号是一个 <strong>Flask Like</strong> 的 web framework 。这回让很多人有一种错觉，就是 Sanic 内部的实现和 Flask 近乎一致，但是事实真的是这样么？</p><p>我们首先来看一下一组 Hello World </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Flask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Sanic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sanic <span class="keyword">import</span> Sanic</span><br><span class="line"></span><br><span class="line">app = Sanic()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello_world</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>大家有没有发现什么不同之处？嗯？是不是 Sanic 的 View 函数多了一个参数是为什么呢？</p><p>Flask 众所周知的一个最典型的 Feature 就是，它有个 Global Variable 的概念，比如全局的 g 变量，以及 request 变量，这个是借助 werkzurg 里面独立实现的一套类似于 Thread.Local 的机制。在一个请求周期内，在我们业务逻辑，我们可以通过 <code>from flask import request</code> 来获取当前的 <code>request</code> 变量。我们也可以通过这样的机制，在上面挂一些数据来实现数据的全局使用。</p><p>但是 Sanic 则没有这个 Global Variable  这个概念，也就是说，我们需要在业务逻辑中使用 <code>request</code> 变量的话，就需要不断的传递一个 <code>request</code> 变量，直到一个请求周期的终结。</p><p>这样方式处理，有好，也有坏，不过我们的吐槽刚刚开始</p><h2 id="坑点一：扩展极为不方便"><a href="#坑点一：扩展极为不方便" class="headerlink" title="坑点一：扩展极为不方便"></a>坑点一：扩展极为不方便</h2><p>比如，我们现在有个需求，我们需要写一个插件，提供给其余部门的同事使用，在插件中，我们需要给原本的 <code>Request</code> 类以及 <code>Response</code> 类新增一些功能，在 Flask 中我们可以这么做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Request,Response</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">APIRequest</span>(<span class="title class_ inherited__">Request</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">APIResponse</span>(<span class="title class_ inherited__">Response</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewFlask</span>(<span class="title class_ inherited__">Flask</span>):</span><br><span class="line">    request_class = APIRequest</span><br><span class="line">    response_class = APIResponse</span><br></pre></td></tr></table></figure><p>Flask 中可以通过设置 <code>Flask</code> 类中的两个属性 <code>request_class</code> 以及 <code>response_class</code> 来替换原本的  <code>Request</code> 类，以及 <code>Response</code> 类。</p><p>就如同上面这段代码一样，我们很轻松的就可以为 <code>Request</code> 以及 <code>Response</code> 添加一些额外的功能。</p><p>但是在 Sanic 中呢？很蛋疼</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sanic</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="literal">None</span>, router=<span class="literal">None</span>, error_handler=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 load_env=<span class="literal">True</span>, request_class=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 strict_slashes=<span class="literal">False</span>, log_config=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 configure_logging=<span class="literal">True</span></span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get name from previous stack frame</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            frame_records = stack()[<span class="number">1</span>]</span><br><span class="line">            name = getmodulename(frame_records[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># logging</span></span><br><span class="line">        <span class="keyword">if</span> configure_logging:</span><br><span class="line">            logging.config.dictConfig(log_config <span class="keyword">or</span> LOGGING_CONFIG_DEFAULTS)</span><br><span class="line"></span><br><span class="line">        self.name = name</span><br><span class="line">        self.router = router <span class="keyword">or</span> Router()</span><br><span class="line">        self.request_class = request_class</span><br><span class="line">        self.error_handler = error_handler <span class="keyword">or</span> ErrorHandler()</span><br><span class="line">        self.config = Config(load_env=load_env)</span><br><span class="line">        self.request_middleware = deque()</span><br><span class="line">        self.response_middleware = deque()</span><br><span class="line">        self.blueprints = &#123;&#125;</span><br><span class="line">        self._blueprint_order = []</span><br><span class="line">        self.configure_logging = configure_logging</span><br><span class="line">        self.debug = <span class="literal">None</span></span><br><span class="line">        self.sock = <span class="literal">None</span></span><br><span class="line">        self.strict_slashes = strict_slashes</span><br><span class="line">        self.listeners = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        self.is_running = <span class="literal">False</span></span><br><span class="line">        self.is_request_stream = <span class="literal">False</span></span><br><span class="line">        self.websocket_enabled = <span class="literal">False</span></span><br><span class="line">        self.websocket_tasks = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Register alternative method names</span></span><br><span class="line">        self.go_fast = self.run</span><br></pre></td></tr></table></figure><p>这是 Sanic 中 <code>Sanic</code> 类的初始化代码，首先在 <code>Sanic</code> 中，我们没办法很轻松的替换 <code>Response</code> ,其次，我们通过查看其 <code>__init__</code> 方法，我们就可以知道，如果要替换默认的 <code>Request</code> 我们需要给其初始化的时候传递一个参数 <code>request_class</code>。这就是让人感觉很迷的地方，这个东西，怎么可以让用传入呢？</p><p>诚然我们可以通过重载 <code>Sanic</code> 类的 <code>__init__</code> 方法，修改其默认的参数来解决这个问题。</p><p>但是新的问题也来了，我一直觉得写组件要默认一个假设，就是所有用你东西的人，智商emmmm都不太高。</p><p>好了，因为我们是提供的是插件，如果用户在使用的时候重新继承了我们的定制的 <code>Sanic</code> 类，同时没有使用 <code>super</code> 调用我们魔改后的 <code>__init__</code> 方法。那么这个时候，就会出一些很有趣的乱子。</p><p>同时，Sanic 内部耦合严重，也会造成我们构建插件的时候的困难。</p><h2 id="坑点二-内部耦合严重"><a href="#坑点二-内部耦合严重" class="headerlink" title="坑点二: 内部耦合严重"></a>坑点二: 内部耦合严重</h2><p>现在，我们写插件，想在生成 <code>Response</code> 的时候进行一些额外的处理，在 Flask 中，我们可以这样做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewFlask</span>(<span class="title class_ inherited__">Flask</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_response</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们直接可以重载 <code>Flask</code> 类中的 <code>make_response</code> 方法来完成我们 <code>Response</code> 生成的时候新增的一些额外操作。</p><p>这个看似简单的操作，在 Sanic 中就变得很恶心</p><p>Sanic 中没有像 Flask 这样，一个请求周期内的不同阶段的数据流的处理有着各自独立的方法，比如 <code>dispatch_request</code>,<code>after_request</code> , <code>teardown_request</code> 等等，Request 的处理和 Response 的处理也有着很清晰的界限，我们按需重载就好</p><p>Sanic 将一个请求周期类的 <code>Request</code> 数据和 <code>Response</code> 数据的处理，都统一包裹在一个大的 <code>handle_request</code> 方法内</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sanic</span>:</span><br><span class="line">    <span class="comment">#.....</span></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_request</span>(<span class="params">self, request, write_callback, stream_callback</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Take a request from the HTTP Server and return a response object</span></span><br><span class="line"><span class="string">        to be sent back The HTTP Server only expects a response object, so</span></span><br><span class="line"><span class="string">        exception handling must be done here</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param request: HTTP Request object</span></span><br><span class="line"><span class="string">        :param write_callback: Synchronous response function to be</span></span><br><span class="line"><span class="string">            called with the response as the only argument</span></span><br><span class="line"><span class="string">        :param stream_callback: Coroutine that handles streaming a</span></span><br><span class="line"><span class="string">            StreamingHTTPResponse if produced by the handler.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return: Nothing</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># -------------------------------------------- #</span></span><br><span class="line">            <span class="comment"># Request Middleware</span></span><br><span class="line">            <span class="comment"># -------------------------------------------- #</span></span><br><span class="line"></span><br><span class="line">            request.app = self</span><br><span class="line">            response = <span class="keyword">await</span> self._run_request_middleware(request)</span><br><span class="line">            <span class="comment"># No middleware results</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> response:</span><br><span class="line">                <span class="comment"># -------------------------------------------- #</span></span><br><span class="line">                <span class="comment"># Execute Handler</span></span><br><span class="line">                <span class="comment"># -------------------------------------------- #</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># Fetch handler from router</span></span><br><span class="line">                handler, args, kwargs, uri = self.router.get(request)</span><br><span class="line">                request.uri_template = uri</span><br><span class="line">                <span class="keyword">if</span> handler <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">raise</span> ServerError(</span><br><span class="line">                        (<span class="string">&quot;&#x27;None&#x27; was returned while requesting a &quot;</span></span><br><span class="line">                         <span class="string">&quot;handler from the router&quot;</span>))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Run response handler</span></span><br><span class="line">                response = handler(request, *args, **kwargs)</span><br><span class="line">                <span class="keyword">if</span> isawaitable(response):</span><br><span class="line">                    response = <span class="keyword">await</span> response</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># -------------------------------------------- #</span></span><br><span class="line">            <span class="comment"># Response Generation Failed</span></span><br><span class="line">            <span class="comment"># -------------------------------------------- #</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                response = self.error_handler.response(request, e)</span><br><span class="line">                <span class="keyword">if</span> isawaitable(response):</span><br><span class="line">                    response = <span class="keyword">await</span> response</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="keyword">if</span> self.debug:</span><br><span class="line">                    response = HTTPResponse(</span><br><span class="line">                        <span class="string">&quot;Error while handling error: &#123;&#125;\nStack: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                            e, format_exc()))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    response = HTTPResponse(</span><br><span class="line">                        <span class="string">&quot;An error occurred while handling an error&quot;</span>)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># -------------------------------------------- #</span></span><br><span class="line">            <span class="comment"># Response Middleware</span></span><br><span class="line">            <span class="comment"># -------------------------------------------- #</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                response = <span class="keyword">await</span> self._run_response_middleware(request,</span><br><span class="line">                                                               response)</span><br><span class="line">            <span class="keyword">except</span> BaseException:</span><br><span class="line">                error_logger.exception(</span><br><span class="line">                    <span class="string">&#x27;Exception occurred in one of response middleware handlers&#x27;</span></span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># pass the response to the correct callback</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(response, StreamingHTTPResponse):</span><br><span class="line">            <span class="keyword">await</span> stream_callback(response)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            write_callback(response)</span><br></pre></td></tr></table></figure><p>这就造成了一个现象，我们只需要对于某一个阶段数据进行额外的操作的时候，我们势必要重载 <code>handle_request</code> 这个大方法。就比如前面说的，我们只需要在 <code>Response</code> 生成的时候，进行一些额外操作，在 Flask 中我们只需要重载对应的 <code>make_response</code> 方法即可，而在 <code>Sanic</code> 中我们需要重载整个 <code>handle_request</code> 。可谓牵一发动全身。</p><p>同时，Sanic 不像 Flask 一样，做到了 WSGI 层的请求处理和 Framework 层的逻辑相互分离。这样一种分离，有时会给我们带来很多方便。</p><p>比如我之前写过这样一篇辣鸡文章<a href="https://zhuanlan.zhihu.com/p/28540965">你所不知道的 Flask Part1:Route 初探</a>，里面提到了这样一个场景。</p><p>之前遇到一个很奇怪的需求，需要在flask中支持正则表达式比如，<code>@app.route(&#39;/api/(.*?)&#39;)</code></p><p>这样，在视图函数被调用的时候，能传入 URL 中正则匹配的值。不过 Flask 路由中默认不支持这样的方法，那么我们该怎么办？</p><p>解决方案很简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> BaseConverter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RegexConverter</span>(<span class="title class_ inherited__">BaseConverter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">map</span>, *args</span>):</span><br><span class="line">        self.<span class="built_in">map</span> = <span class="built_in">map</span></span><br><span class="line">        self.regex = args[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.url_map.converters[<span class="string">&#x27;regex&#x27;</span>] = RegexConverter</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在经过这样的设置后我们便可以按照我们刚才的需求写代码了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/docs/model_utils/&lt;regex(&quot;.*&quot;):url&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">url=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(url)</span><br></pre></td></tr></table></figure><p>大家可以看到，由于 Flask 的 WSGI 层的处理是基于 Werkzurg 来做的，也就是说，我们有些时候对于 <code>URL</code> 或者其余涉及到 <code>WSGI</code> 层的东西的时候，我们只需要重载/使用 Werkzurg 给我们提供的相关的类或者函数就可以了。同时 <code>app.url_map.converters[&#39;regex&#39;] = RegexConverter</code> 这个操作，看了源码的同学就知道，<code>url_map</code> 这个是 <code>werkzurg.routing</code> 类中的 <code>Map</code> 类的一个子类，我们对它的操作，其实本质上也是对于 Werkzurg 的操作，而与 Flask 的框架逻辑无关。</p><p>但是在 Sanic 中，并没有这样的分离机制，比如就上面这个场景而言</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sanic</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="literal">None</span>, router=<span class="literal">None</span>, error_handler=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 load_env=<span class="literal">True</span>, request_class=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 strict_slashes=<span class="literal">False</span>, log_config=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 configure_logging=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="comment">#....</span></span><br><span class="line">        self.router = router <span class="keyword">or</span> Router()</span><br><span class="line">        <span class="comment">#....</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Sanic 中对 URL 的解析是由 <code>Router()</code> 实例来触发的，我们如果需要定制我们自己的 URL 解析，我们需要替换 <code>self.router</code> ，这实际上是对 Sanic 本身进行了修改，感觉略有不妥。</p><p>同时这里的 <code>Router</code> 类中，如果我们需要定制自己的解析，需要重载 Router 中的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span>:</span><br><span class="line">    routes_static = <span class="literal">None</span></span><br><span class="line">    routes_dynamic = <span class="literal">None</span></span><br><span class="line">    routes_always_check = <span class="literal">None</span></span><br><span class="line">    parameter_pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;(.+?)&gt;&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>parameter_pattern</code> 属性及其余几个解析方法。这里的 Router 并没有像 Werkzurg 中的 Router 一样，实现 <code>Route</code> 和 <code>Parser</code> 以及 <code>Forammter</code>（就是 Converter) 彼此相互分离的特性，我们只需要按需重构添加即可，如同文中所举的例子。</p><p>整个这一部分，其实就在吐槽，Sanic 内部耦合严重，如果想实现一些额外的操作，可以说牵一发动全身。</p><h2 id="坑点三：细节以及其余的坑"><a href="#坑点三：细节以及其余的坑" class="headerlink" title="坑点三：细节以及其余的坑"></a>坑点三：细节以及其余的坑</h2><p>这一部分大概有几方面要说。</p><p>第一，Sanic 依赖的库，其实，emmmmmm，不太稳定，比如 10 月份的时候，触发了一个 bug ，其所依赖的 <code>ujson</code> 在序列化一些特定数据的时候，会抛出异常，这个问题，14年就已经爆出来了，不过到目前没修，2333333，同时当时的版本，如果要使用内置的函数的话，是不可以让用户选择具体的 parser 的，具体可以参考当时我提的 <a href="https://github.com/channelcat/sanic/pull/924">PR</a></p><p>第二，Sanic 一些东西实现的并不严谨，比如这篇文章有吐槽过<a href="https://zhuanlan.zhihu.com/p/28930188">日常辣鸡水文:一个关于 Sanic 的小问题的思考</a></p><p>第三，Sanic 现在不支持 UWSGI ，同时和 Gunicorn 配合部署的话，是自己实现了一套 Gunicorn Worker ，在我们生产环境下，会有一些诸如未知原因 504 这样的玄学 BUG，不过我们还在追查（另外有消息声称，Sanic 的 Server 部分并不严格遵守 <a href="https://www.python.org/dev/peps/pep-0333/">PEP333</a>即 WSGI 协议，= =我改天核查一下）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Sanic 的性能的确很棒，当时技术验证时，测试的时候，不同业务逻辑下，基本都能保证其性能在 Flask 的 1.5 倍以上。但是就目前的使用经验来说 Sanic 距离真正生产可用，还有相当长一段路要走。无论是内部的架构，还是周边的生态，亦或者是其他。大家可以没事拿来玩玩，但是如果要上生产线，请做好被坑的准备。</p><p>最后祝大家新年快乐，Live Long And Prosper!</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> Flask </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常辣鸡水文:一个关于 Sanic 的小问题的思考</title>
      <link href="//posts/2018/02/22/a-little-idea-about-sanic/"/>
      <url>//posts/2018/02/22/a-little-idea-about-sanic/</url>
      
        <content type="html"><![CDATA[<h2 id="日常辣鸡水文-一个关于-Sanic-的小问题的思考"><a href="#日常辣鸡水文-一个关于-Sanic-的小问题的思考" class="headerlink" title="日常辣鸡水文:一个关于 Sanic 的小问题的思考"></a>日常辣鸡水文:一个关于 Sanic 的小问题的思考</h2><p>睡不着，作为一个 API 复制粘贴工程师来日常辣鸡水文一篇</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>最近迁移组内代码到 Sanic ，遇到一个很有意思的情况</p><p>首先标准的套路应该是这样的</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sanic <span class="keyword">import</span> Sanic,reponse</span><br><span class="line">app=Sanic(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_value</span>(<span class="params">controller_fun</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    返回参数的装饰器</span></span><br><span class="line"><span class="string">    :param controller_fun:  控制层函数</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__decorator</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        ret_value = &#123;</span><br><span class="line">            <span class="string">&quot;version&quot;</span>: server_current_config.version,</span><br><span class="line">            <span class="string">&quot;success&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: <span class="string">u&quot;fail query&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        ret_data, code = <span class="keyword">await</span> controller_fun(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> is_blank(ret_data):</span><br><span class="line">            ret_value[<span class="string">&quot;data&quot;</span>] = &#123;&#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret_value[<span class="string">&quot;success&quot;</span>] = <span class="number">1</span></span><br><span class="line">            ret_value[<span class="string">&quot;message&quot;</span>] = <span class="string">u&quot;succ query&quot;</span></span><br><span class="line">            ret_value[<span class="string">&quot;data&quot;</span>] = ret_data</span><br><span class="line">            ret_value[<span class="string">&quot;update_time&quot;</span>] = convert_time_to_time_str(get_now())</span><br><span class="line">        <span class="built_in">print</span>(ret_value)</span><br><span class="line">        <span class="keyword">return</span> response.json(body=ret_value, status=code)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __decorator</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span><span class="string">&quot;&#125;</span></span><br><span class="line"><span class="string">@return_value</span></span><br><span class="line"><span class="string">async def test2():</span></span><br><span class="line"><span class="string">    return await test1(),200</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@app.route(&quot;</span>/wt<span class="string">f&quot;)</span></span><br><span class="line"><span class="string">async def test3():</span></span><br><span class="line"><span class="string">    return await test2()</span></span><br></pre></td></tr></table></figure><p>中规中举，没什么太大问题</p><p>不过如果上面的代码变成下面这样 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sanic <span class="keyword">import</span> Sanic,reponse</span><br><span class="line">app=Sanic(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span><span class="string">&quot;&#125;</span></span><br><span class="line"><span class="string">@return_value</span></span><br><span class="line"><span class="string">async def test2():</span></span><br><span class="line"><span class="string">    return await test1()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@app.route(&quot;</span>/wt<span class="string">f&quot;)</span></span><br><span class="line"><span class="string">def test3():</span></span><br><span class="line"><span class="string">    return test2()</span></span><br></pre></td></tr></table></figure><p>一般会以为这样会产生报错的，因为没有 <code>await test2()</code> ，直接 <code>return test2()</code> 的话，返回的是一个 <code>Coroutine</code> 的对象，这样应该是会抛错的，但是实际上是正常运行的，最开始很迷，不过后面看了下 Sanic 中关于 <code>handle_request</code> 的部分，有点意思</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_request</span>(<span class="params">self, request, write_callback, stream_callback</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Take a request from the HTTP Server and return a response object</span></span><br><span class="line"><span class="string">    to be sent back The HTTP Server only expects a response object, so</span></span><br><span class="line"><span class="string">    exception handling must be done here</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param request: HTTP Request object</span></span><br><span class="line"><span class="string">    :param write_callback: Synchronous response function to be</span></span><br><span class="line"><span class="string">        called with the response as the only argument</span></span><br><span class="line"><span class="string">    :param stream_callback: Coroutine that handles streaming a</span></span><br><span class="line"><span class="string">        StreamingHTTPResponse if produced by the handler.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :return: Nothing</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># -------------------------------------------- #</span></span><br><span class="line">        <span class="comment"># Request Middleware</span></span><br><span class="line">        <span class="comment"># -------------------------------------------- #</span></span><br><span class="line"></span><br><span class="line">        request.app = self</span><br><span class="line">        response = <span class="keyword">await</span> self._run_request_middleware(request)</span><br><span class="line">        <span class="comment"># No middleware results</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> response:</span><br><span class="line">            <span class="comment"># -------------------------------------------- #</span></span><br><span class="line">            <span class="comment"># Execute Handler</span></span><br><span class="line">            <span class="comment"># -------------------------------------------- #</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Fetch handler from router</span></span><br><span class="line">            handler, args, kwargs, uri = self.router.get(request)</span><br><span class="line">            request.uri_template = uri</span><br><span class="line">            <span class="keyword">if</span> handler <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">raise</span> ServerError(</span><br><span class="line">                    (<span class="string">&quot;&#x27;None&#x27; was returned while requesting a &quot;</span></span><br><span class="line">                     <span class="string">&quot;handler from the router&quot;</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Run response handler</span></span><br><span class="line">            response = handler(request, *args, **kwargs)</span><br><span class="line">            <span class="keyword">if</span> isawaitable(response):</span><br><span class="line">                response = <span class="keyword">await</span> response</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># -------------------------------------------- #</span></span><br><span class="line">        <span class="comment"># Response Generation Failed</span></span><br><span class="line">        <span class="comment"># -------------------------------------------- #</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = self.error_handler.response(request, e)</span><br><span class="line">            <span class="keyword">if</span> isawaitable(response):</span><br><span class="line">                response = <span class="keyword">await</span> response</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> self.debug:</span><br><span class="line">                response = HTTPResponse(</span><br><span class="line">                    <span class="string">&quot;Error while handling error: &#123;&#125;\nStack: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                        e, format_exc()))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                response = HTTPResponse(</span><br><span class="line">                    <span class="string">&quot;An error occurred while handling an error&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># -------------------------------------------- #</span></span><br><span class="line">        <span class="comment"># Response Middleware</span></span><br><span class="line">        <span class="comment"># -------------------------------------------- #</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = <span class="keyword">await</span> self._run_response_middleware(request,</span><br><span class="line">                                                           response)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            log.exception(</span><br><span class="line">                <span class="string">&#x27;Exception occured in one of response middleware handlers&#x27;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass the response to the correct callback</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(response, StreamingHTTPResponse):</span><br><span class="line">        <span class="keyword">await</span> stream_callback(response)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        write_callback(response)</span><br></pre></td></tr></table></figure><p>核心代码是这样一段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">handler, args, kwargs, uri = self.router.get(request)</span><br><span class="line">request.uri_template = uri</span><br><span class="line"><span class="keyword">if</span> handler <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">raise</span> ServerError(</span><br><span class="line">        (<span class="string">&quot;&#x27;None&#x27; was returned while requesting a &quot;</span></span><br><span class="line">         <span class="string">&quot;handler from the router&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run response handler</span></span><br><span class="line">response = handler(request, *args, **kwargs)</span><br><span class="line"><span class="keyword">if</span> isawaitable(response):</span><br><span class="line">    response = <span class="keyword">await</span> response</span><br></pre></td></tr></table></figure><p>大概就是，首先按照 route-&gt;add_route 的顺序注册对应的处理函数和 <strong>URL</strong> 到一个映射里，然后当请求发过来时，取出对应的 <code>handler</code> ，然后进一步处理</p><p>最开始正常的中规中矩的做法里</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/wtf&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">test3</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> test2()</span><br></pre></td></tr></table></figure><p>注册的 <code>handler</code> 是 <code>test3</code> 这个函数，然后执行 <code>response = handler(request, *args, **kwargs)</code> ，初始化了一个 <code>Coroutine</code> 对象，紧接着这个对象是 <code>awaitable</code> 的，于是进入后面的 <code>response = await response</code> 流程。</p><p>好了，来看看非主流的做法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/wtf&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test3</span>():</span><br><span class="line">    <span class="keyword">return</span> test2()</span><br></pre></td></tr></table></figure><p>老规矩，先注册，然后取出 <code>test3</code> 这个函数作为 <code>handler</code> ，然后执行，因为是普通函数，于是 <code>response</code> 的值便是 <code>test3</code> 中初始化的那个 <code>Coroutine</code> 对象，然后同样是 <code>awaitable</code> 的，进入后面的 <code>response = await response</code> 流程。</p><p>两种方式殊途同归，这也解释了为什么第二中不清真的方式也能得到正确的结果</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>Sanic 这样的处理方式，相当于增强了整个框架的容错性。也可能让用户写出向之前那样不清真的代码。不过我也没法说这个是好是坏，各有看法吧。不过有一点是肯定的，在 <code>debug</code> 模式下，如果用户利用 <code>app.route</code> 添加了一个非 <code>async</code> 的函数，是有必要抛出一个 warning 的，不过，Sanic 还有，PR 已经提出，就不知道合不合了。。。</p><p>好了，就先这样吧。。明天还得搬砖，溜了，溜了。。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> Flask </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常辣鸡水文:关于 logging 的进程安全问题</title>
      <link href="//posts/2018/02/22/logging-process-safe/"/>
      <url>//posts/2018/02/22/logging-process-safe/</url>
      
        <content type="html"><![CDATA[<h2 id="日常辣鸡水文-关于-logging-的进程安全问题"><a href="#日常辣鸡水文-关于-logging-的进程安全问题" class="headerlink" title="日常辣鸡水文:关于 logging 的进程安全问题"></a>日常辣鸡水文:关于 logging 的进程安全问题</h2><p>团队聚餐喝了点酒，作为一个垃圾文档工程师来写一篇日常水文</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>现在团队的日志搜集方式从原本的 TCP 直传 logstash 的方式改进为写入一个单文件后，改用 FileBeat 来作为日志搜集的前端。但是这样时常带来一个问题，即日志丢失</p><p>嗯，我们线上服务是 Gunicorn 启用多个 Worker 来处理的。这就有个问题了，我们都知道，logging 模块是 Thread Safe 的，在标准的 Log Handler 内部加了一系列锁来确保线程安全，但是 logging 直写文件是不是进程安全的呢？</p><span id="more"></span><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们写文件的方式是用的是 <code>logging</code> 模块中自带的 <code>FileHandler</code> ，首先看看它源码吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandler</span>(<span class="title class_ inherited__">StreamHandler</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A handler class which writes formatted logging records to disk files.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filename, mode=<span class="string">&#x27;a&#x27;</span>, encoding=<span class="literal">None</span>, delay=<span class="literal">False</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Open the specified file and use it as the stream for logging.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Issue #27493: add support for Path objects to be passed in</span></span><br><span class="line">        filename = os.fspath(filename)</span><br><span class="line">        <span class="comment">#keep the absolute path, otherwise derived classes which use this</span></span><br><span class="line">        <span class="comment">#may come a cropper when the current directory changes</span></span><br><span class="line">        self.baseFilename = os.path.abspath(filename)</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.encoding = encoding</span><br><span class="line">        self.delay = delay</span><br><span class="line">        <span class="keyword">if</span> delay:</span><br><span class="line">            <span class="comment">#We don&#x27;t open the stream, but we still need to call the</span></span><br><span class="line">            <span class="comment">#Handler constructor to set level, formatter, lock etc.</span></span><br><span class="line">            Handler.__init__(self)</span><br><span class="line">            self.stream = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            StreamHandler.__init__(self, self._<span class="built_in">open</span>())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Closes the stream.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> self.stream:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        self.flush()</span><br><span class="line">                    <span class="keyword">finally</span>:</span><br><span class="line">                        stream = self.stream</span><br><span class="line">                        self.stream = <span class="literal">None</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="built_in">hasattr</span>(stream, <span class="string">&quot;close&quot;</span>):</span><br><span class="line">                            stream.close()</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                <span class="comment"># Issue #19523: call unconditionally to</span></span><br><span class="line">                <span class="comment"># prevent a handler leak when delay is set</span></span><br><span class="line">                StreamHandler.close(self)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_open</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Open the current base file with the (original) mode and encoding.</span></span><br><span class="line"><span class="string">        Return the resulting stream.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">open</span>(self.baseFilename, self.mode, encoding=self.encoding)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">emit</span>(<span class="params">self, record</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Emit a record.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If the stream was not opened because &#x27;delay&#x27; was specified in the</span></span><br><span class="line"><span class="string">        constructor, open it before calling the superclass&#x27;s emit.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.stream <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.stream = self._<span class="built_in">open</span>()</span><br><span class="line">        StreamHandler.emit(self, record)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        level = getLevelName(self.level)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;%s %s (%s)&gt;&#x27;</span> % (self.__class__.__name__, self.baseFilename, level)</span><br></pre></td></tr></table></figure><p>嗯，其中关注的点是 <code>_open</code> 方法，以及 <code>emit</code> 方法，首先科普一个背景知识，在我们用 <code>logging</code> 输出日志的时候，<code>logging</code> 模块会调用对应 <code>Handler</code> 中的 <code>handle</code> 方法，在 <code>handle</code> 方法中，会调用 <code>emit</code> 方法输出最后的日志。于是我们如果使用 <code>FileHandler</code> 的话，那么就是先触发 <code>handle</code> 方法的调用，然后触发 <code>emit</code> 方法，在调用 <code>_open</code> 方法获取一个 <strong>file point</strong> 后，调用父类（更准确的描述书 MRO 上一级）<strong>StreamHandler</strong> 中 <code>emit</code> 方法。</p><p>来看看 <code>StreamHandler</code> 中的 <code>emit</code> 方法吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StreamHandler</span>(<span class="title class_ inherited__">Handler</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    A handler class which writes logging records, appropriately formatted,</span></span><br><span class="line"><span class="string">    to a stream. Note that this class does not close the stream, as</span></span><br><span class="line"><span class="string">    sys.stdout or sys.stderr may be used.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    terminator = <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, stream=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize the handler.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If stream is not specified, sys.stderr is used.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        Handler.__init__(self)</span><br><span class="line">        <span class="keyword">if</span> stream <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            stream = sys.stderr</span><br><span class="line">        self.stream = stream</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flush</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Flushes the stream.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> self.stream <span class="keyword">and</span> <span class="built_in">hasattr</span>(self.stream, <span class="string">&quot;flush&quot;</span>):</span><br><span class="line">                self.stream.flush()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">emit</span>(<span class="params">self, record</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Emit a record.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If a formatter is specified, it is used to format the record.</span></span><br><span class="line"><span class="string">        The record is then written to the stream with a trailing newline.  If</span></span><br><span class="line"><span class="string">        exception information is present, it is formatted using</span></span><br><span class="line"><span class="string">        traceback.print_exception and appended to the stream.  If the stream</span></span><br><span class="line"><span class="string">        has an &#x27;encoding&#x27; attribute, it is used to determine how to do the</span></span><br><span class="line"><span class="string">        output to the stream.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            msg = self.<span class="built_in">format</span>(record)</span><br><span class="line">            stream = self.stream</span><br><span class="line">            stream.write(msg)</span><br><span class="line">            stream.write(self.terminator)</span><br><span class="line">            self.flush()</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            self.handleError(record)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        level = getLevelName(self.level)</span><br><span class="line">        name = <span class="built_in">getattr</span>(self.stream, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> name:</span><br><span class="line">            name += <span class="string">&#x27; &#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;%s %s(%s)&gt;&#x27;</span> % (self.__class__.__name__, name, level)</span><br></pre></td></tr></table></figure><p>嗯很简单，就是调用我们之前获取的 <strong>file point</strong> 往文件中写入数据</p><p>问题就在这里，在 <code>FileHandler</code> 中，<code>_open</code> 函数中调用 <code>open</code> 函数时，所选择的 <strong>mode</strong> 是 <code>&#39;a&#39;</code> ，也就是通常而言的 <code>O_APPEND</code> 模式。我们知道，通常而言 <code>O_APPEND</code> 可以视作进程安全的，因为 <code>O_APPEND</code> 能够保证内容不被别的 <strong>O_APPEND</strong> 写操作所覆盖。但是这里为什么会出现日志丢失的情况呢？</p><p>原因是在 <strong>POSIX</strong> 中存在着一种特殊设计，在 《POSIX Programmers Guide》 一书中对此描述如下：</p><ul><li>A write of fewer than PIPE_BUF bytes is atomic; the data will not be interleaved with data from other processes writing to the same pipe. A write of more than PIPE_BUF may have data interleaved in arbitrary ways.</li></ul><p>这段话翻译大概就是，在 POSIX 中存在着一个变量叫做 <code>PIPE_BUF</code> ，这个变量大小为 512 ，在进行写入操作时，如果大小小于 <code>PIPE_BUF</code> 值的写操作，是具有原子性的，即不可被打断，因此不会和其余进程写入的值产生混乱，而如果写入的内容大于 <code>PIPE_BUF</code> ，则操作系统不能保证这一点。</p><p>在 Linux 操作系统中，这个值发生了一点变化</p><ul><li>POSIX.1 says that write(2)s of less than PIPE_BUF bytes must be atomic: the output data is written to the pipe as a contiguous sequence. Writes of more than PIPE_BUF bytes may be nonatomic: the kernel may interleave the data with data written by other processes. POSIX.1 requires PIPE_BUF to be at least 512 bytes. (On Linux, PIPE_BUF is 4096 bytes.) </li></ul><p>即大于 4K 的写入操作都不能保证其原子性，可能会发生数据紊乱。</p><p>而发生数据紊乱后，其日志格式不固定，最终造成解析端没法解析，从而最终日志丢失。</p><p>这里我们复现一下，首先测试代码</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这种操作之前从未想过，今天算是打开了新的大门，最后感谢 @依云 前辈的指点= =如果没有前辈的提醒，完全想不到即便是 <code>O_APPEND</code> 模式下，数据也不能保证安全。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>文中参考了两处参考资料，链接如下</p><p>1.<a href="http://maxim.int.ru/bookshelf/OReilly__POSIX_Programmers_Guide.pdf">OReilly POSIX Programmers Guide</a></p><p>2.<a href="http://manpages.courier-mta.org/htmlman7/pipe.7.html">Linux Man: PIPE</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> Flask </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask 中的 Context 初探</title>
      <link href="//posts/2018/02/22/something-about-flask-context/"/>
      <url>//posts/2018/02/22/something-about-flask-context/</url>
      
        <content type="html"><![CDATA[<h1 id="Flask-中的-Context-初探"><a href="#Flask-中的-Context-初探" class="headerlink" title="Flask 中的 Context 初探"></a>Flask 中的 Context 初探</h1><p>大家新年好！鉴于今年春晚非常好看，我觉得承受不起，于是来写点辣鸡水文娱乐下大家，这也是之前立的若干 Flag 中的一个</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>做过 Flask 开发的朋友都知道 Flask 中存在着两个概念，一个叫 App Context , 一个叫 Request Context 。 这两个算是 Flask 中很独特的一种机制。</p><p>从一个 Flask App 读入配置并启动开始，就进入了 App Context，在其中我们可以访问配置文件、打开资源文件、通过路由规则反向构造 URL。当 WSGI Middleware 调用 Flask App 的时候开始，就进入了 Request Context 。我们可以获取到其中的 HTTP HEADER 等操作，同时也可以进行 SESSION 等操作。</p><p>不过作为辣鸡选手而言，经常分不清为什么会存在这两个 Context ，没事，我们慢慢来说一说。</p><span id="more"></span><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>首先要清楚一点，我们要在同一个进程中隔离不同线程的数据，那么我们会优先选择 <code>threading.local</code> ，来实现数据彼此隔离的需求。但是现在有个问题来了，现在我们并发模型可能并不是只有传统意义上的<strong>进程-线程</strong>模型。也有可能是 <strong>coroutine(协程)</strong> 模型。常见的就是 Greenlet/Eventlet 。在这种情况下，<code>threading.local</code> 就没法很好的满足我们的需求。于是 <strong>Werkzeug</strong> 实现了自己的 Local 即 <code>werkzeug.local.Local</code></p><p>那么 <strong>Werkzeug</strong> 自己实现的 Local 和标准的 <code>threading.local</code> 相比有什么不同呢？我们记住最大的不同点在于</p><blockquote><p>前者会在 Greenlet 可用的情况下优先使用 Greenlet 的 ID 而不是线程 ID 以支持 Gevent 或 Eventlet 的调度，后者只支持多线程调度；</p></blockquote><p>Werkzeug 另外还实现了两种数据结构，一个叫 <code>LocalStack</code> ，一个叫做 <code>LocalProxy</code> </p><p><code>LocalStack</code> 是基于 <code>Local</code> 实现的一个栈结构。栈的特性就是<strong>后入先出</strong>。当我们进入一个 Context 时，将当前的的对象推入栈中。然后我们也可以获取到栈顶元素。从而获取到当前的上下文信息。</p><p><code>LocalProxy</code> 是代理模式的一种实现。在实例化的时候，传入一个 <code>callable</code> 的参数。然后这个参数被调用后将会返回一个 <code>Local</code> 对象。我们后续的所有操作，比如属性调用，数值计算等，都会转发到这个参数返回的 <code>Local</code> 对象上。</p><p>现在大家可能不太清楚，我们为什么要用 LocalProxy 来进行操作，我们来给大家看一个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalStack</span><br><span class="line">test_stack = LocalStack()</span><br><span class="line">test_stack.push(&#123;<span class="string">&#x27;abc&#x27;</span>: <span class="string">&#x27;123&#x27;</span>&#125;)</span><br><span class="line">test_stack.push(&#123;<span class="string">&#x27;abc&#x27;</span>: <span class="string">&#x27;1234&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_item</span>():</span><br><span class="line">    <span class="keyword">return</span> test_stack.pop()</span><br><span class="line"></span><br><span class="line">item = get_item()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(item[<span class="string">&#x27;abc&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(item[<span class="string">&#x27;abc&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你看我们这里的输出的的值，都是统一的 <code>1234</code> ，但是我们这里想做到的是每次获取的值都是栈顶的最新的元素，那么我们这个时候就应该用 proxy 模式了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalStack, LocalProxy</span><br><span class="line">test_stack = LocalStack()</span><br><span class="line">test_stack.push(&#123;<span class="string">&#x27;abc&#x27;</span>: <span class="string">&#x27;123&#x27;</span>&#125;)</span><br><span class="line">test_stack.push(&#123;<span class="string">&#x27;abc&#x27;</span>: <span class="string">&#x27;1234&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_item</span>():</span><br><span class="line">    <span class="keyword">return</span> test_stack.pop()</span><br><span class="line"></span><br><span class="line">item = LocalProxy(get_item)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(item[<span class="string">&#x27;abc&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(item[<span class="string">&#x27;abc&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你看我们这里就是 Proxy 的妙用。</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>由于 Flask 基于 Werkzeug 实现，因此 App Context 以及 Request Context 是基于前文中所说的 LocalStack 实现。</p><p>从命名上，大家应该可以看出，App Context 是代表应用上下文，可能包含各种配置信息，比如日志配置，数据库配置等。而 Request Context 代表一个请求上下文，我们可以获取到当前请求中的各种信息。比如 body 携带的信息。</p><p>这两个上下文的定义是在 <strong>flask.ctx</strong> 文件中，分别是 <code>AppContext</code> 以及 <code>RequestContext</code> 。而构建上下文的操作则是将其推入在 <strong>flask.globals</strong> 文件中定义的 <code>_app_ctx_stack</code> 以及 <code>_request_ctx_stack</code> 中。前面说了 LocalStack 是“线程”（这里可能是传统意义上的线程，也有可能是 Greenlet 这种）隔离的。同时 Flask 每个线程只处理一个请求，因此可以做到请求隔离。</p><p>当 <code>app = Flask(__name__)</code> 构造出一个 Flask App 时，App Context 并不会被自动推入 Stack 中。所以此时 Local Stack 的栈顶是空的，current_app 也是 unbound 状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask.<span class="built_in">globals</span> <span class="keyword">import</span> _app_ctx_stack, _request_ctx_stack</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">_app_ctx_stack.top</span><br><span class="line">_request_ctx_stack.top</span><br><span class="line">_app_ctx_stack()</span><br><span class="line"><span class="comment"># &lt;LocalProxy unbound&gt;</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> current_app</span><br><span class="line">current_app</span><br><span class="line"><span class="comment"># &lt;LocalProxy unbound&gt;</span></span><br></pre></td></tr></table></figure><p>作为 web 时，当请求进来时，我们开始进行上下文的相关操作。整个流程如下：</p><p><img src="https://user-images.githubusercontent.com/7054676/36314635-675c086c-1370-11e8-87f1-819cb9f5f299.png" alt="image"></p><p>好了现在有点问题：</p><ol><li><p>为什么要区分 App Context 以及 Request Context</p></li><li><p>为什么要用栈结构来实现 Context ？</p></li></ol><p>很久之前看过的松鼠奥利奥老师的博文<a href="https://blog.tonyseek.com/post/the-context-mechanism-of-flask/">Flask 的 Context 机制</a> 解答了这个问题 </p><blockquote><p>这两个做法给予我们 多个 Flask App 共存 和 非 Web Runtime 中灵活控制 Context 的可能性。</p><p>我们知道对一个 Flask App 调用 app.run() 之后，进程就进入阻塞模式并开始监听请求。此时是不可能再让另一个 Flask App 在主线程运行起来的。那么还有哪些场景需要多个 Flask App 共存呢？前面提到了，一个 Flask App 实例就是一个 WSGI Application，那么 WSGI Middleware 是允许使用组合模式的，比如：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> werkzeug.wsgi <span class="keyword">import</span> DispatcherMiddleware</span><br><span class="line"><span class="keyword">from</span> biubiu.app <span class="keyword">import</span> create_app</span><br><span class="line"><span class="keyword">from</span> biubiu.admin.app <span class="keyword">import</span> create_app <span class="keyword">as</span> create_admin_app</span><br><span class="line"></span><br><span class="line">application = DispatcherMiddleware(create_app(), &#123;</span><br><span class="line">    <span class="string">&#x27;/admin&#x27;</span>: create_admin_app()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>奥利奥老师文中举了一个这样一个例子，Werkzeug 内置的 Middleware 将两个 Flask App 组合成一个一个 WSGI Application。这种情况下两个 App 都同时在运行，只是根据 URL 的不同而将请求分发到不同的 App 上处理。</p><p>但是现在很多朋友有个问题，就是为什么这里不用 Blueprint ？</p><ul><li><p>Blueprint 是在同一个 App 下运行。其挂在 App Context 上的相关信息都是一致的。但是如果要隔离彼此的信息的话，那么用 App Context 进行隔离，会比我们用变量名什么的隔离更为方便</p></li><li><p>Middleware 模式是 WSGI 中允许的特性，换句话来讲，我们将 Flask 和另外一个遵循 WSGI 协议的 web Framework （比如 Django）那么也是可行的。</p></li></ul><p>但是 Flask 的两种 Context 分离更大的意义是为了非 web 应用的场合。Flask 官方文档中有这样一段话</p><blockquote><p>The main reason for the application’s context existence is that in the past a bunch of functionality was attached to the request context for lack of a better solution. Since one of the pillars of Flask’s design is that you can have more than one application in the same Python process.</p></blockquote><p>这句话换句话说 App Context 存在的意义是针对一个进程中有多个 Flask App 场景，这样场景最常见的就是我们用 Flask 来做一些离线脚本的代码。</p><p>好了，我们来聊聊 Flask 非 Web 应用的场景</p><p>比如，我们有个插件叫 Flask-SQLAlchemy<br>然后这里有个使用场景<br>首先我们现在有这样一个代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line">database = Flask(__name__)</span><br><span class="line">database.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&#x27;sqlite:////tmp/test.db&#x27;</span></span><br><span class="line">db = SQLAlchemy(database)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(db.Model):</span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    username = db.Column(db.String(<span class="number">80</span>), unique=<span class="literal">True</span>, nullable=<span class="literal">False</span>)</span><br><span class="line">    email = db.Column(db.String(<span class="number">120</span>), unique=<span class="literal">True</span>, nullable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;User %r&gt;&#x27;</span> % self.username</span><br></pre></td></tr></table></figure><p>这里你应该注意到最开始的几个关键点，第一个，就是 <code>database.config</code>  ，是的没错，Flask-SQLAlchemy 就是从当前的 app 中获取到对应的 config 信息来建立数据库链接。那么传递 app 的方式有两种，第一种，就是直接如上图一样，直接 db = SQLAlchemy(database) ，这个很容易理解，第二种，如果我们不传的话，那么 Flask-SQLAlchemy 中通过 current_app 来获取当前的 app 然后获取对应的 config 建立链接。<br>那么问题来了，为什么会存在第二种这种方法呢</p><p>给个场景吧，现在我两个数据库配置不同的 app 共用一个  Model 那么应该怎么做？其实很简单</p><p>首先写 一个 model 文件，比如就叫 data/user_model.py 吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line">db = SQLAlchemy()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(db.Model):</span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    username = db.Column(db.String(<span class="number">80</span>), unique=<span class="literal">True</span>, nullable=<span class="literal">False</span>)</span><br><span class="line">    email = db.Column(db.String(<span class="number">120</span>), unique=<span class="literal">True</span>, nullable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;User %r&gt;&#x27;</span> % self.username</span><br></pre></td></tr></table></figure><p>好了，那么在我们的应用文件中，我们便可以这样写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> data.user_model <span class="keyword">import</span> User</span><br><span class="line">database = Flask(__name__)</span><br><span class="line">database.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&#x27;sqlite:////tmp/test.db&#x27;</span></span><br><span class="line"><span class="keyword">with</span> database.app_context():</span><br><span class="line">    db.init_app(current_app)</span><br><span class="line">    db.create_all()</span><br><span class="line">    admin = User(username=<span class="string">&#x27;admin&#x27;</span>, email=<span class="string">&#x27;admin@example.com&#x27;</span>)</span><br><span class="line">    db.session.add(admin)</span><br><span class="line">    db.session.commit()</span><br><span class="line">    <span class="built_in">print</span>(User.query.filter_by(username=<span class="string">&quot;admin&quot;</span>).first())</span><br><span class="line"></span><br><span class="line">database1 = Flask(__name__)</span><br><span class="line">database1.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">&#x27;sqlite:////tmp/test1.db&#x27;</span></span><br><span class="line"><span class="keyword">with</span> database1.app_context():</span><br><span class="line">    db.init_app(current_app)</span><br><span class="line">    db.create_all()</span><br><span class="line">    admin = User(username=<span class="string">&#x27;admin_test&#x27;</span>, email=<span class="string">&#x27;admin@example.com&#x27;</span>)</span><br><span class="line">    db.session.add(admin)</span><br><span class="line">    db.session.commit()</span><br><span class="line">    <span class="built_in">print</span>(User.query.filter_by(username=<span class="string">&quot;admin&quot;</span>).first())</span><br></pre></td></tr></table></figure><p>你看这样是不是就好懂了一些，通过 app context ，我们  Flask-SQLAlchemy 可以通过 current_app 来获取当前 app ，继而获取相关的 config 信息</p><p>这个例子还不够妥当，我们现在再来换一个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, current_app</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">app = Flask(<span class="string">&quot;app1&quot;</span>)</span><br><span class="line">app2 = Flask(<span class="string">&quot;app2&quot;</span>)</span><br><span class="line"></span><br><span class="line">app.config.logger = logging.getLogger(<span class="string">&quot;app1.logger&quot;</span>)</span><br><span class="line">app2.config.logger = logging.getLogger(<span class="string">&quot;app2.logger&quot;</span>)</span><br><span class="line"></span><br><span class="line">app.logger.addHandler(logging.FileHandler(<span class="string">&quot;app_log.txt&quot;</span>))</span><br><span class="line">app2.logger.addHandler(logging.FileHandler(<span class="string">&quot;app2_log.txt&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> app.app_context():</span><br><span class="line">    <span class="keyword">with</span> app2.app_context():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;app2 error&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            current_app.config.logger.exception(e)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;app1 error&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        current_app.config.logger.exception(e)</span><br></pre></td></tr></table></figure><p>好了，这段代码很清晰了，含义很清晰，就是通过获取当前上下文中的 app 中的 logger 来输出日志。同时这段代码也很清晰的说明了，我们为什么要用栈这样一种数据结构来维护上下文。</p><p>首先看一下 <code>app_context()</code> 的源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">app_context</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Binds the application only.  For as long as the application is bound</span></span><br><span class="line"><span class="string">    to the current context the :data:`flask.current_app` points to that</span></span><br><span class="line"><span class="string">    application.  An application context is automatically created when a</span></span><br><span class="line"><span class="string">    request context is pushed if necessary.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Example usage::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        with app.app_context():</span></span><br><span class="line"><span class="string">            ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionadded:: 0.9</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> AppContext(self)</span><br></pre></td></tr></table></figure><p>嗯，很简单，只是构建一个 AppContext 对象返回，然后我们看看相关的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppContext</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;The application context binds an application object implicitly</span></span><br><span class="line"><span class="string">    to the current thread or greenlet, similar to how the</span></span><br><span class="line"><span class="string">    :class:`RequestContext` binds request information.  The application</span></span><br><span class="line"><span class="string">    context is also implicitly created if a request context is created</span></span><br><span class="line"><span class="string">    but the application is not on top of the individual application</span></span><br><span class="line"><span class="string">    context.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, app</span>):</span><br><span class="line">        self.app = app</span><br><span class="line">        self.url_adapter = app.create_url_adapter(<span class="literal">None</span>)</span><br><span class="line">        self.g = app.app_ctx_globals_class()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Like request context, app contexts can be pushed multiple times</span></span><br><span class="line">        <span class="comment"># but there a basic &quot;refcount&quot; is enough to track them.</span></span><br><span class="line">        self._refcnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Binds the app context to the current context.&quot;&quot;&quot;</span></span><br><span class="line">        self._refcnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(sys, <span class="string">&#x27;exc_clear&#x27;</span>):</span><br><span class="line">            sys.exc_clear()</span><br><span class="line">        _app_ctx_stack.push(self)</span><br><span class="line">        appcontext_pushed.send(self.app)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self, exc=_sentinel</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Pops the app context.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._refcnt -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self._refcnt &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> exc <span class="keyword">is</span> _sentinel:</span><br><span class="line">                    exc = sys.exc_info()[<span class="number">1</span>]</span><br><span class="line">                self.app.do_teardown_appcontext(exc)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            rv = _app_ctx_stack.pop()</span><br><span class="line">        <span class="keyword">assert</span> rv <span class="keyword">is</span> self, <span class="string">&#x27;Popped wrong app context.  (%r instead of %r)&#x27;</span> \</span><br><span class="line">            % (rv, self)</span><br><span class="line">        appcontext_popped.send(self.app)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        self.push()</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, tb</span>):</span><br><span class="line">        self.pop(exc_value)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> BROKEN_PYPY_CTXMGR_EXIT <span class="keyword">and</span> exc_type <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            reraise(exc_type, exc_value, tb)</span><br></pre></td></tr></table></figure><p>emmmm，首先 <code>push</code> 方法就是将自己推入 <code>_app_ctx_stack</code> ，而 <code>pop</code> 方法则是将自己从栈顶推出。然后我们看到两个方法含义就很明确了，在进入上下文管理器的时候，将自己推入栈，然后退出上下文管理器的时候，将自己推出。</p><p>我们都知道栈的一个性质就是，后入先出，栈顶的永远是最新插入进去的元素。而看一下我们 <code>current_app</code> 的源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_find_app</span>():</span><br><span class="line">    top = _app_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(_app_ctx_err_msg)</span><br><span class="line">    <span class="keyword">return</span> top.app</span><br><span class="line">    </span><br><span class="line">current_app = LocalProxy(_find_app)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>嗯，很明了了，就是获取当前栈顶的元素，然后进行相关操作。</p><p>嗯，通过这样对于栈的不断操作，就能让 <code>current_app</code> 获取到元素是我们当前上下文中的 app 。</p><h2 id="额外的讲解-g"><a href="#额外的讲解-g" class="headerlink" title="额外的讲解: g"></a>额外的讲解: g</h2><p>g 也是我们常用的几个全局变量之一。在最开始这个变量是挂载在 Request Context 下的。但是在 0.10 以后，g 就是挂载在 App Context 下的。可能有同学不太清楚为什么要这么做。</p><p>首先，说一下 g 用来干什么</p><p>官方在上下文这一张里有这一段说明</p><blockquote><p>The application context is created and destroyed as necessary. It never moves between threads and it will not be shared between requests. As such it is the perfect place to store database connection information and other things. The internal stack object is called flask._app_ctx_stack. Extensions are free to store additional information on the topmost level, assuming they pick a sufficiently unique name and should put their information there, instead of on the flask.g object which is reserved for user code.</p></blockquote><p>大意就是说，数据库配置和其余的重要配置信息，就挂载 App 对象上。但是如果是一些用户代码，比如你不想一层层函数传数据的话，然后有一些变量需要传递，那么可以挂在 g 上。</p><p>同时前面说了，Flask 并不仅仅可以当做一个 Web Framework 使用，同时也可以用于一些非 web 的场合下。在这种情况下，如果 g 是属于 Request Context 的话，那么我们要使用 g 的话，那么就需要手动构建一个请求，这无疑是不合理的。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>大年三十写这篇文章，现在发出来，我的辣鸡也是无人可救了。Flask 的上下文机制是其最重要的特性之一。通过合理的利用上下文机制，我们可以再更多的场合下去更好的利用 flask 。嗯，本次的辣鸡文章写作活动就到此结束吧。希望大家不会扔我臭鸡蛋！然后新年快乐！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> Flask </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Supervisor 的一个隐藏坑</title>
      <link href="//posts/2017/12/28/what-the-fuck-supvisor/"/>
      <url>//posts/2017/12/28/what-the-fuck-supvisor/</url>
      
        <content type="html"><![CDATA[<p>本垃圾 API 搬运工程师又来了啊，= =今天因为 <code>Supervisor</code> 一个隐藏的参数配置，造成了一个重要项目的线上崩溃。= =我觉得还是有必要分享一波，所以写了一篇垃圾水文。</p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>写着写着代码，突然接到一堆报警邮件，让我直接觉得世界不那么可爱</p><p>然后定睛一看异常信息？卧槽？新建连接就马上传说中的 <code>[Errno 24] Too many open files</code> ？？这搞你xxx啊，开始搞呗。</p><h2 id="查-bug"><a href="#查-bug" class="headerlink" title="查 bug"></a>查 bug</h2><p>首先，众所周知，Linux 中万物皆文件= =，于是我们操作网络链接的过程，其实也就是操作 <code>File Descriptor</code> 的问题= =，诶，既然 <code>Too many open files</code> 那就优先考虑，是不是系统设置的阀值太小了，于是 <code>ulimit -a</code> 一把梭？？</p><p>诶？<code>open files</code> 一栏数字不小啊？足够啊？那这特么是什么鬼啊？</p><p>行吧，查一下网络连接吧， 一把梭，<code>netstat -n | awk &#39;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#39;</code> 统计下，当时处于各个状态的连接数量吧</p><p>诶？有点意思，TIME_WAIT 数量太多了吧？诶？有意思，那就祭出老夫的内核网络参数的半吊子功夫，魔改一下呗？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参数优化</span></span><br><span class="line"><span class="comment">#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line"><span class="comment">#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为300秒，</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = 300</span><br><span class="line"><span class="comment">#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭</span></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"><span class="comment">#表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"><span class="comment">#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭，当前TIME-WAIT 过多，所以开启快速回收</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.ip_local_port_range = 5000 65000</span><br></pre></td></tr></table></figure><p>在 <code>/etc/sysctl.conf</code> 中新增如上一些配置项。然后 <code>sysctl -p</code> 生效一波。开始看效果吧</p><p>诶！报错数量是在减小，TIME_WAIT 数量也逐渐正常</p><p>诶？？？等等？？？其余机器没 <code>TIME_WAIT</code> 过多的问题啊，那这尼玛是什么鬼？而且快速回收 <code>TIME_WAIT</code> 的连接也会带来其余的副作用（后面单章说）</p><p>= =好吧，现在怀疑，是不是 <code>Supervisor</code> 的问题，好的，文档翻阅大赛，开始</p><p>恩，，翻了半天，查到原因了，跟一个叫做 <code>minfds</code> 的参数相关</p><p>描述如下</p><blockquote><p>The minimum number of file descriptors that must be available before supervisord will start successfully. A call to setrlimit will be made to attempt to raise the soft and hard limits of the supervisord process to satisfy minfds. The hard limit may only be raised if supervisord is run as root. supervisord uses file descriptors liberally, and will enter a failure mode when one cannot be obtained from the OS, so it’s useful to be able to specify a minimum value to ensure it doesn’t run out of them during execution. These limits will be inherited by the managed subprocesses. This option is particularly useful on Solaris, which has a low per-process fd limit by default.</p></blockquote><p>大意为，Supervisor 启动时，将根据 minfds 的值来确定系统中是否有足够的空余 fd 供其使用。同时因为我们跑在 Supervisor 中的服务，都是由 Supervisord fork 而来，因为父子关系，同时保证安全，单个进程开启的描述符最多不允许超过 minfds 设置的值，默认为 1024。然后，它补了一个刀，如果你用 root 用户运行的话，我们默认给你搞到系统最大的哦！</p><p>卧槽。。。原来是这啊，你谁没事用 root 跑服务啊= =简直药丸。。。</p><p>行吧，改参数，改参数</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>最后这事就这样的结束了，趟一个雷，顺便复习了下内核的网络参数，虽然感觉美滋滋，不过感觉，贵 <code>Supervisor</code> 吃枣药丸！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 随笔 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python concurrent.future 使用教程及源码初剖</title>
      <link href="//posts/2017/11/27/something-about-concurrent-future/"/>
      <url>//posts/2017/11/27/something-about-concurrent-future/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾话"><a href="#垃圾话" class="headerlink" title="垃圾话"></a>垃圾话</h1><p>很久没写博客了，想了想不能再划水，于是给自己定了一个目标，写点 <strong>concurrent.future</strong> 的内容，于是这篇文章就是来聊聊 Python 3.2 中新增的 <strong>concurrent.future</strong> 模块。</p><span id="more"></span><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Python-的异步处理"><a href="#Python-的异步处理" class="headerlink" title="Python 的异步处理"></a>Python 的异步处理</h2><p>有一个 Python 开发工程师小明，在面试过程中，突然接到这样一个需求：去请求几个网站，拿到他们的数据，小明定睛一想，简单啊，噼里啪啦，他写了如下的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">request_url</span>(<span class="params">query_url: <span class="built_in">str</span></span>):</span><br><span class="line">    time.sleep(<span class="number">3</span>)  <span class="comment"># 请求处理逻辑</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url_list = [<span class="string">&quot;abc.com&quot;</span>, <span class="string">&quot;xyz.com&quot;</span>]</span><br><span class="line">    task_list = [multiprocessing.Process(target=request_url, args=(url,)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">    [task.start() <span class="keyword">for</span> task <span class="keyword">in</span> task_list]</span><br><span class="line">    [task.join() <span class="keyword">for</span> task <span class="keyword">in</span> task_list]</span><br></pre></td></tr></table></figure><p>Easy, 好了，现在新的需求来了，我们想获取每一个请求结果，怎么办?小明想了想，又写出如下的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">request_url</span>(<span class="params">query_url: <span class="built_in">str</span>, result_dict: <span class="built_in">dict</span></span>):</span><br><span class="line">    time.sleep(<span class="number">3</span>)  <span class="comment"># 请求处理逻辑</span></span><br><span class="line">    result_dict[query_url] = &#123;&#125;  <span class="comment"># 返回结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    process_manager = multiprocessing.Manager()</span><br><span class="line">    result_dict = process_manager.<span class="built_in">dict</span>()</span><br><span class="line">    url_list = [<span class="string">&quot;abc.com&quot;</span>, <span class="string">&quot;xyz.com&quot;</span>]</span><br><span class="line">    task_list = [multiprocessing.Process(target=request_url, args=(url, result_dict)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">    [task.start() <span class="keyword">for</span> task <span class="keyword">in</span> task_list]</span><br><span class="line">    [task.join() <span class="keyword">for</span> task <span class="keyword">in</span> task_list]</span><br><span class="line">    <span class="built_in">print</span>(result_dict)</span><br></pre></td></tr></table></figure><p>好了，面试官说，恩看起来不错，好了，我再改改题目，首先，我们不能阻塞主进程，主进程需要根据任务当前的状态（结束/未结束）来及时的获取对应的结果，怎么改？，小明想了想，要不，我们直接用信号量，让任务完成后，向父进程发送一个信号量？然后直接暴力出奇迹？还有更简单的方法么？貌似没了？最后面试官心理说了一句 naive ，脸上笑而不语，让小明回去慢慢等消息。</p><p>从小明的窘境，我们可以看出一个这样的问题，就是我们最常用的 <code>multiprocessing</code> 或者是 <code>threding</code> 两个模块，对于我们想实现异步任务的场景来说，其实略有一点不友好的，我们往往需要做一些额外的工作，才能比较干净的实现一些异步的需求。为了解决这样的窘境，09 年 10 月，Brian Quinlan 先生提出了 <a href="https://www.python.org/dev/peps/pep-3148/">PEP 3148</a> ，在这个提案中，他提出将我们常用的 <code>multiprocessing</code> 和 <code>threding</code> 模块进行进一步封装，达成较好的支持异步操作的目的。最终这个提案在 Python 3.2 中被引入。也就是我们今天要聊聊的 <strong>concurrent.future</strong> 。</p><h2 id="Future-模式"><a href="#Future-模式" class="headerlink" title="Future 模式"></a>Future 模式</h2><p>在我们正式开始聊新模块之前，我们需要去了解关于 <code>Future</code> 模式的相关姿势</p><p>首先 <code>Future</code> 模式，是什么？</p><p><code>Future</code> 其实是<strong>生产-消费者</strong>模型的一种扩展，在<strong>生产-消费者</strong>模型中，生产者不关心消费者什么时候处理完数据，也不关心消费者处理的结果。比如我们经常写出如下的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> multiprocessing, Queue</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span>(multiprocessing.Process):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, queue</span>):</span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.queue = queue</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.queue.put(<span class="string">&#x27;one product&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(multiprocessing.current_process().name + <span class="built_in">str</span>(os.getpid()) + <span class="string">&#x27; produced one product, the no of queue now is: %d&#x27;</span> %self.queue.qsize())</span><br><span class="line">            sleep(randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span>(multiprocessing.Process):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, queue</span>):</span><br><span class="line">        multiprocessing.Process.__init__(self)</span><br><span class="line">        self.queue = queue</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            d = self.queue.get(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> d != <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(multiprocessing.current_process().name + <span class="built_in">str</span>(os.getpid()) + <span class="string">&#x27; consumed  %s, the no of queue now is: %d&#x27;</span> %(d,self.queue.qsize()))</span><br><span class="line">                sleep(randint(<span class="number">1</span>, <span class="number">4</span>))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">#create queue</span></span><br><span class="line">queue = multiprocessing.Queue(<span class="number">40</span>)</span><br><span class="line">       </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Excited!&quot;)</span></span><br><span class="line"><span class="string">    #create processes    </span></span><br><span class="line"><span class="string">    processed = []</span></span><br><span class="line"><span class="string">    for i in range(3):</span></span><br><span class="line"><span class="string">        processed.append(Producer(queue))</span></span><br><span class="line"><span class="string">        processed.append(Consumer(queue))</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    #start processes        </span></span><br><span class="line"><span class="string">    for i in range(len(processed)):</span></span><br><span class="line"><span class="string">        processed[i].start()</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    #join processes    </span></span><br><span class="line"><span class="string">    for i in range(len(processed)):</span></span><br><span class="line"><span class="string">        processed[i].join()  </span></span><br></pre></td></tr></table></figure><p>这就是<strong>生产-消费者</strong>模型的一个简单的实现，我们利用一个 <code>multiprocessing</code> 中的 <code>Queue</code> 来作为通信渠道，我们的生产者负责往队列中传入数据，消费者负责从队列中获取数据并处理。不过就如同上面所说的一样，在这种模式中，生产者并不关心消费者何时处理完数据，也不关心处理的结果。而在 <code>Future</code> 中，我们可以让生产者等待消息处理完成，如果需要的话，我们还可以获取相关的计算结果。</p><p>比如，大家可以看看下面这样一段 Java 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataProcessThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Thread.sleep(<span class="number">10000</span>);<span class="comment">//模拟数据处理</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;数据返回&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们负责处理数据的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainThread</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException,</span><br><span class="line">ExecutionException &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="type">DataProcessThread</span> <span class="variable">dataProcessThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataProcessThread</span>();</span><br><span class="line">FutureTask&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(dataProcessThread);</span><br><span class="line"></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">executor.submit(future);</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">10000</span>);<span class="comment">//模拟继续处理自身其他业务</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (future.isDone()) &#123;</span><br><span class="line">System.out.println(future.get());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是我们主线程，大家可以看到，我们可以很方便的获取数据处理任务的状态。同时获取相关的结果。</p><h2 id="Python-中的-concurrent-futures"><a href="#Python-中的-concurrent-futures" class="headerlink" title="Python 中的 concurrent.futures"></a>Python 中的 concurrent.futures</h2><p>前面说了，在 Python 3.2 以后，<strong>concurrent.futures</strong>　是内置的模块，我们可以直接使用</p><blockquote><p><strong>Note</strong>: 如果你需要在 Python 2.7 中使用 <strong>concurrent.futures</strong> , 那么请用 pip 进行安装，<code>pip install futures</code> </p></blockquote><p>好了，准备就绪后，我们来看看怎么使用这个东西呢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">return_future_result</span>(<span class="params">message</span>):</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> message</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(max_workers=<span class="number">2</span>)  <span class="comment"># 创建一个最大可容纳2个task的进程池</span></span><br><span class="line">    future1 = pool.submit(return_future_result, (<span class="string">&quot;hello&quot;</span>))  <span class="comment"># 往进程池里面加入一个task</span></span><br><span class="line">    future2 = pool.submit(return_future_result, (<span class="string">&quot;world&quot;</span>))  <span class="comment"># 往进程池里面加入一个task</span></span><br><span class="line">    <span class="built_in">print</span>(future1.done())  <span class="comment"># 判断task1是否结束</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(future2.done())  <span class="comment"># 判断task2是否结束</span></span><br><span class="line">    <span class="built_in">print</span>(future1.result())  <span class="comment"># 查看task1返回的结果</span></span><br><span class="line">    <span class="built_in">print</span>(future2.result())  <span class="comment"># 查看task2返回的结果</span></span><br></pre></td></tr></table></figure><p>首先 <code>from concurrent.futures import ProcessPoolExecutor</code> 从 <code>concurrent.futures</code> 引入 <code>ProcessPoolExecutor</code> 作为我们的进程池，处理我们后面的数据。(在 <code>concurrent.futures</code> 中，为我们提供了两种 <code>Executor</code> ，一种是我们现在用的 <code>ProcessPoolExecutor</code>, 一种是 <code>ThreadPoolExecutor</code> 他们对外暴露的方法一致，大家可以根据自己的实际需求选用。)</p><p>紧接着，初始化一个最大容量为 2 的进程池。然后我们调用进程池中的 <code>submit</code> 方法提交一个任务。好了有意思的点来了，我们在调用 <code>submit</code> 方法后，得到了一个特殊的变量，这个变量是 <code>Future</code> 类的实例，代表着一个在未来完成的操作。换句话说，当 <code>submit</code> 返回 <code>Future</code> 实例的时候，我们的任务可能还没有完成，我们可以通过调用 <code>Future</code> 实例中的 <code>done</code> 方法来获取当前任务的运行状态，如果任务结束后，我们可以通过 <code>result</code> 方法来获取返回的结果。如果在执行后续的逻辑时，我们因为一些原因想要取消任务时，我们可以通过调用 <code>cancel</code> 方法来取消当前的任务。</p><p>现在新的问题来了，我们如果想要提交很多个任务应该怎么办呢？<code>concurrent.future</code> 为我们提供了 <code>map</code> 方法来方便我们批量添加任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">task_url = [(<span class="string">&#x27;http://www.baidu.com&#x27;</span>, <span class="number">40</span>), (<span class="string">&#x27;http://example.com/&#x27;</span>, <span class="number">40</span>), (<span class="string">&#x27;https://www.github.com/&#x27;</span>, <span class="number">40</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_url</span>(<span class="params">params: <span class="built_in">tuple</span></span>):</span><br><span class="line">    <span class="keyword">return</span> requests.get(params[<span class="number">0</span>], timeout=params[<span class="number">1</span>]).text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="keyword">for</span> url, data <span class="keyword">in</span> <span class="built_in">zip</span>(task_url, executor.<span class="built_in">map</span>(load_url, task_url)):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%r page is %d bytes&#x27;</span> % (url, <span class="built_in">len</span>(data)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>恩，<code>concurrent.future</code> 中线程/进程池所提供的 <code>map</code> 方法和标准库中的 <code>map</code> 函数使用方法一样。</p><h2 id="剖一下-concurrent-futures"><a href="#剖一下-concurrent-futures" class="headerlink" title="剖一下 concurrent.futures"></a>剖一下 concurrent.futures</h2><p>前面讲了怎么使用 <code>concurrent.futures</code> 后，我们都比较好奇，<code>concurrent.futures</code> 是怎么实现 <code>Future</code> 模式的。里面是怎么将任务和结果进行关联的。我们现在开始从 <code>submit</code> 方法着手来简单看一下 <code>ProcessPoolExecutor</code> 的实现。</p><p>首先，在初始化 <code>ProcessPoolExecutor</code> 时，它的 <code>__init__</code> 方法中进行了一些关键变量的初始化操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProcessPoolExecutor</span>(_base.Executor):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, max_workers=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Initializes a new ProcessPoolExecutor instance.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            max_workers: The maximum number of processes that can be used to</span></span><br><span class="line"><span class="string">                execute the given calls. If None or not given then as many</span></span><br><span class="line"><span class="string">                worker processes will be created as the machine has processors.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        _check_system_limits()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> max_workers <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._max_workers = os.cpu_count() <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> max_workers &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&quot;max_workers must be greater than 0&quot;</span>)</span><br><span class="line"></span><br><span class="line">            self._max_workers = max_workers</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Make the call queue slightly larger than the number of processes to</span></span><br><span class="line">        <span class="comment"># prevent the worker processes from idling. But don&#x27;t make it too big</span></span><br><span class="line">        <span class="comment"># because futures in the call queue cannot be cancelled.</span></span><br><span class="line">        self._call_queue = multiprocessing.Queue(self._max_workers +</span><br><span class="line">                                                 EXTRA_QUEUED_CALLS)</span><br><span class="line">        <span class="comment"># Killed worker processes can produce spurious &quot;broken pipe&quot;</span></span><br><span class="line">        <span class="comment"># tracebacks in the queue&#x27;s own worker thread. But we detect killed</span></span><br><span class="line">        <span class="comment"># processes anyway, so silence the tracebacks.</span></span><br><span class="line">        self._call_queue._ignore_epipe = <span class="literal">True</span></span><br><span class="line">        self._result_queue = SimpleQueue()</span><br><span class="line">        self._work_ids = queue.Queue()</span><br><span class="line">        self._queue_management_thread = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># Map of pids to processes</span></span><br><span class="line">        self._processes = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Shutdown is a two-step process.</span></span><br><span class="line">        self._shutdown_thread = <span class="literal">False</span></span><br><span class="line">        self._shutdown_lock = threading.Lock()</span><br><span class="line">        self._broken = <span class="literal">False</span></span><br><span class="line">        self._queue_count = <span class="number">0</span></span><br><span class="line">        self._pending_work_items = &#123;&#125;</span><br></pre></td></tr></table></figure><p>好了，我们来看看我们今天的入口 <code>submit</code> 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">submit</span>(<span class="params">self, fn, *args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">with</span> self._shutdown_lock:</span><br><span class="line">        <span class="keyword">if</span> self._broken:</span><br><span class="line">            <span class="keyword">raise</span> BrokenProcessPool(<span class="string">&#x27;A child process terminated &#x27;</span></span><br><span class="line">                <span class="string">&#x27;abruptly, the process pool is not usable anymore&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self._shutdown_thread:</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;cannot schedule new futures after shutdown&#x27;</span>)</span><br><span class="line">        f = _base.Future()</span><br><span class="line">        w = _WorkItem(f, fn, args, kwargs)</span><br><span class="line">        self._pending_work_items[self._queue_count] = w</span><br><span class="line">        self._work_ids.put(self._queue_count)</span><br><span class="line">        self._queue_count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># Wake up queue management thread</span></span><br><span class="line">        self._result_queue.put(<span class="literal">None</span>)</span><br><span class="line">        self._start_queue_management_thread()</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure><p>首先，传入的参数 <code>fn</code> 是我们的处理函数，<code>args</code> 以及 <code>kwargs</code> 是我们要传递 <code>fn</code> 函数的参数。在 <code>submit</code> 函数最开始，首先根据 <code>_broken</code> 和 <code>_shutdown_thread</code> 的值来判断当前进程池中处理进程的状态以及目前进程池的状态。如果处理进程突然被销毁或者进程池已经被关闭，那么将抛出异常表明目前不再接受新的 <code>submit</code> 操作。</p><p>如果前面状态没有问题，首先，实例化 <code>Future</code> 类，然后将这个实例和处理函数和相关参数一起，作为参数来实例化 <code>_WorkItem</code> 类，然后将实例 w 作为 value ，<code>_queue_count</code> 作为 key 存入 <code>_pending_work_items</code> 中。然后调用 <code>_start_queue_management_thread</code> 方法开启进程池中的管理线程。现在来看看这部分代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_start_queue_management_thread</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># When the executor gets lost, the weakref callback will wake up</span></span><br><span class="line">    <span class="comment"># the queue management thread.</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">weakref_cb</span>(<span class="params">_, q=self._result_queue</span>):</span><br><span class="line">        q.put(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self._queue_management_thread <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># Start the processes so that their sentinels are known.</span></span><br><span class="line">        self._adjust_process_count()</span><br><span class="line">        self._queue_management_thread = threading.Thread(</span><br><span class="line">            target=_queue_management_worker,</span><br><span class="line">            args=(weakref.ref(self, weakref_cb),</span><br><span class="line">                  self._processes,</span><br><span class="line">                  self._pending_work_items,</span><br><span class="line">                  self._work_ids,</span><br><span class="line">                  self._call_queue,</span><br><span class="line">                  self._result_queue))</span><br><span class="line">        self._queue_management_thread.daemon = <span class="literal">True</span></span><br><span class="line">        self._queue_management_thread.start()</span><br><span class="line">        _threads_queues[self._queue_management_thread] = self._result_queue</span><br></pre></td></tr></table></figure><p>这一部分很简单，首先运行 <code>_adjust_process_count</code> 方法，然后开启一个守护线程，运行 <code>_queue_management_worker</code> 方法。我们首先来看看 <code>_adjust_process_count</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_adjust_process_count</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self._processes), self._max_workers):</span><br><span class="line">        p = multiprocessing.Process(</span><br><span class="line">                target=_process_worker,</span><br><span class="line">                args=(self._call_queue,</span><br><span class="line">                      self._result_queue))</span><br><span class="line">        p.start()</span><br><span class="line">        self._processes[p.pid] = p</span><br></pre></td></tr></table></figure><p>根据在 <code>__init__</code> 方法中设定的 <code>_max_workers</code> 来开启对应数量的进程，在进程中运行 <code>_process_worker</code> 函数。</p><p>恩，顺藤摸瓜，我们先来看看 <code>_process_worker</code> 函数吧？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_process_worker</span>(<span class="params">call_queue, result_queue</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Evaluates calls from call_queue and places the results in result_queue.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This worker is run in a separate process.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        call_queue: A multiprocessing.Queue of _CallItems that will be read and</span></span><br><span class="line"><span class="string">            evaluated by the worker.</span></span><br><span class="line"><span class="string">        result_queue: A multiprocessing.Queue of _ResultItems that will written</span></span><br><span class="line"><span class="string">            to by the worker.</span></span><br><span class="line"><span class="string">        shutdown: A multiprocessing.Event that will be set as a signal to the</span></span><br><span class="line"><span class="string">            worker that it should exit when call_queue is empty.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        call_item = call_queue.get(block=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> call_item <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Wake up queue management thread</span></span><br><span class="line">            result_queue.put(os.getpid())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            r = call_item.fn(*call_item.args, **call_item.kwargs)</span><br><span class="line">        <span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">            exc = _ExceptionWithTraceback(e, e.__traceback__)</span><br><span class="line">            result_queue.put(_ResultItem(call_item.work_id, exception=exc))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result_queue.put(_ResultItem(call_item.work_id,</span><br><span class="line">                                         result=r))</span><br></pre></td></tr></table></figure><p>首先，这里搞了一个死循环，紧接着，我们从 <code>call_queue</code> 队列中获取一个 <code>_WorkItem</code> 实例，然后如果获取的值为 <code>None</code> 的话，那么证明没有新的任务进来了，我们可以把当前进程的 <code>pid</code> 放入结果队列中。然后结束进程。</p><p>如果收到了任务，那么执行这个任务。不管是在执行过程中发生异常，亦或者是得到最终的结果，都将其封装为 <code>_ResultItem</code> 实例，并将其放入结果队列中。</p><p>好了，我们回到刚刚看了一半的 <code>_start_queue_management_thread</code> 函数，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_start_queue_management_thread</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># When the executor gets lost, the weakref callback will wake up</span></span><br><span class="line">    <span class="comment"># the queue management thread.</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">weakref_cb</span>(<span class="params">_, q=self._result_queue</span>):</span><br><span class="line">        q.put(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self._queue_management_thread <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># Start the processes so that their sentinels are known.</span></span><br><span class="line">        self._adjust_process_count()</span><br><span class="line">        self._queue_management_thread = threading.Thread(</span><br><span class="line">            target=_queue_management_worker,</span><br><span class="line">            args=(weakref.ref(self, weakref_cb),</span><br><span class="line">                  self._processes,</span><br><span class="line">                  self._pending_work_items,</span><br><span class="line">                  self._work_ids,</span><br><span class="line">                  self._call_queue,</span><br><span class="line">                  self._result_queue))</span><br><span class="line">        self._queue_management_thread.daemon = <span class="literal">True</span></span><br><span class="line">        self._queue_management_thread.start()</span><br><span class="line">        _threads_queues[self._queue_management_thread] = self._result_queue</span><br></pre></td></tr></table></figure><p>在执行完 <code>_adjust_process_count</code> 函数后，我们进程池中的 <code>_processes</code> 变量（它是一个 dict ）便关联了一些处理进程。然后我们开启一个后台守护线程，来执行 <code>_queue_management_worker</code> 函数，我们给它传了几个变量，首先 <code>_processes</code> 是我们的进程映射，<code>_pending_work_items</code> 中存放着我们待处理任务，还有 <code>_call_queue</code> 和 <code>_result_queue</code> 。好了还有一个参数大家可能不太理解，就是 <code>weakref.ref(self, weakref_cb)</code> 这货。</p><p>首先，Python 是一门具有垃圾回收机制的语言，有着 GC (Garbage Collection) 机制意味着我们在大多数时候，不太需要去关注内存的分配与回收。在 Python 中，什么时候对象会被回收是由其引用计数所决定的。当引用计数为 0 的时候，这个对象会被回收。在有一些情况下，我们对象因为交叉引用或者其余的一些原因，造成引用计数始终不为0，这意味着这个对象无法被回收。造成内存泄露<br>。因此区别于我们普通的引用，Python 中新增了一个引用机制叫做弱引用，弱引用的意义在于，某个变量持有一个对象，却不会增加这个对象的引用计数。因此 <code>weakref.ref(self, weakref_cb)</code> 在大多数而言，等价于 <code>self</code> （至于这里为什么要使用弱引用，我们这里先不讲，会开一个单章来说）</p><p>好了，这一部分代码看完，我们来看看，<code>_queue_management_worker</code> 怎么实现的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_queue_management_worker</span>(<span class="params">executor_reference,</span></span><br><span class="line"><span class="params">                             processes,</span></span><br><span class="line"><span class="params">                             pending_work_items,</span></span><br><span class="line"><span class="params">                             work_ids_queue,</span></span><br><span class="line"><span class="params">                             call_queue,</span></span><br><span class="line"><span class="params">                             result_queue</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Manages the communication between this process and the worker processes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function is run in a local thread.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        executor_reference: A weakref.ref to the ProcessPoolExecutor that owns</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        process: A list of the multiprocessing.Process instances used as</span></span><br><span class="line"><span class="string">            this thread. Used to determine if the ProcessPoolExecutor has been</span></span><br><span class="line"><span class="string">            garbage collected and that this function can exit.</span></span><br><span class="line"><span class="string">            workers.</span></span><br><span class="line"><span class="string">        pending_work_items: A dict mapping work ids to _WorkItems e.g.</span></span><br><span class="line"><span class="string">            &#123;5: &lt;_WorkItem...&gt;, 6: &lt;_WorkItem...&gt;, ...&#125;</span></span><br><span class="line"><span class="string">        work_ids_queue: A queue.Queue of work ids e.g. Queue([5, 6, ...]).</span></span><br><span class="line"><span class="string">        call_queue: A multiprocessing.Queue that will be filled with _CallItems</span></span><br><span class="line"><span class="string">            derived from _WorkItems for processing by the process workers.</span></span><br><span class="line"><span class="string">        result_queue: A multiprocessing.Queue of _ResultItems generated by the</span></span><br><span class="line"><span class="string">            process workers.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    executor = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shutting_down</span>():</span><br><span class="line">        <span class="keyword">return</span> _shutdown <span class="keyword">or</span> executor <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> executor._shutdown_thread</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shutdown_worker</span>():</span><br><span class="line">        <span class="comment"># This is an upper bound</span></span><br><span class="line">        nb_children_alive = <span class="built_in">sum</span>(p.is_alive() <span class="keyword">for</span> p <span class="keyword">in</span> processes.values())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, nb_children_alive):</span><br><span class="line">            call_queue.put_nowait(<span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># Release the queue&#x27;s resources as soon as possible.</span></span><br><span class="line">        call_queue.close()</span><br><span class="line">        <span class="comment"># If .join() is not called on the created processes then</span></span><br><span class="line">        <span class="comment"># some multiprocessing.Queue methods may deadlock on Mac OS X.</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> processes.values():</span><br><span class="line">            p.join()</span><br><span class="line"></span><br><span class="line">    reader = result_queue._reader</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        _add_call_item_to_queue(pending_work_items,</span><br><span class="line">                                work_ids_queue,</span><br><span class="line">                                call_queue)</span><br><span class="line"></span><br><span class="line">        sentinels = [p.sentinel <span class="keyword">for</span> p <span class="keyword">in</span> processes.values()]</span><br><span class="line">        <span class="keyword">assert</span> sentinels</span><br><span class="line">        ready = wait([reader] + sentinels)</span><br><span class="line">        <span class="keyword">if</span> reader <span class="keyword">in</span> ready:</span><br><span class="line">            result_item = reader.recv()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Mark the process pool broken so that submits fail right now.</span></span><br><span class="line">            executor = executor_reference()</span><br><span class="line">            <span class="keyword">if</span> executor <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                executor._broken = <span class="literal">True</span></span><br><span class="line">                executor._shutdown_thread = <span class="literal">True</span></span><br><span class="line">                executor = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># All futures in flight must be marked failed</span></span><br><span class="line">            <span class="keyword">for</span> work_id, work_item <span class="keyword">in</span> pending_work_items.items():</span><br><span class="line">                work_item.future.set_exception(</span><br><span class="line">                    BrokenProcessPool(</span><br><span class="line">                        <span class="string">&quot;A process in the process pool was &quot;</span></span><br><span class="line">                        <span class="string">&quot;terminated abruptly while the future was &quot;</span></span><br><span class="line">                        <span class="string">&quot;running or pending.&quot;</span></span><br><span class="line">                    ))</span><br><span class="line">                <span class="comment"># Delete references to object. See issue16284</span></span><br><span class="line">                <span class="keyword">del</span> work_item</span><br><span class="line">            pending_work_items.clear()</span><br><span class="line">            <span class="comment"># Terminate remaining workers forcibly: the queues or their</span></span><br><span class="line">            <span class="comment"># locks may be in a dirty state and block forever.</span></span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> processes.values():</span><br><span class="line">                p.terminate()</span><br><span class="line">            shutdown_worker()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(result_item, <span class="built_in">int</span>):</span><br><span class="line">            <span class="comment"># Clean shutdown of a worker using its PID</span></span><br><span class="line">            <span class="comment"># (avoids marking the executor broken)</span></span><br><span class="line">            <span class="keyword">assert</span> shutting_down()</span><br><span class="line">            p = processes.pop(result_item)</span><br><span class="line">            p.join()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> processes:</span><br><span class="line">                shutdown_worker()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> result_item <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            work_item = pending_work_items.pop(result_item.work_id, <span class="literal">None</span>)</span><br><span class="line">            <span class="comment"># work_item can be None if another process terminated (see above)</span></span><br><span class="line">            <span class="keyword">if</span> work_item <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> result_item.exception:</span><br><span class="line">                    work_item.future.set_exception(result_item.exception)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    work_item.future.set_result(result_item.result)</span><br><span class="line">                <span class="comment"># Delete references to object. See issue16284</span></span><br><span class="line">                <span class="keyword">del</span> work_item</span><br><span class="line">        <span class="comment"># Check whether we should start shutting down.</span></span><br><span class="line">        executor = executor_reference()</span><br><span class="line">        <span class="comment"># No more work items can be added if:</span></span><br><span class="line">        <span class="comment">#   - The interpreter is shutting down OR</span></span><br><span class="line">        <span class="comment">#   - The executor that owns this worker has been collected OR</span></span><br><span class="line">        <span class="comment">#   - The executor that owns this worker has been shutdown.</span></span><br><span class="line">        <span class="keyword">if</span> shutting_down():</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># Since no new work items can be added, it is safe to shutdown</span></span><br><span class="line">                <span class="comment"># this thread if there are no pending work items.</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pending_work_items:</span><br><span class="line">                    shutdown_worker()</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">except</span> Full:</span><br><span class="line">                <span class="comment"># This is not a problem: we will eventually be woken up (in</span></span><br><span class="line">                <span class="comment"># result_queue.get()) and be able to send a sentinel again.</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        executor = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>熟悉的大循环，循环的第一步，利用 <code>_add_call_item_to_queue</code> 函数来将等待队列中的任务加入到调用队列中去，先来看看这一部分代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_add_call_item_to_queue</span>(<span class="params">pending_work_items,</span></span><br><span class="line"><span class="params">                            work_ids,</span></span><br><span class="line"><span class="params">                            call_queue</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Fills call_queue with _WorkItems from pending_work_items.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function never blocks.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        pending_work_items: A dict mapping work ids to _WorkItems e.g.</span></span><br><span class="line"><span class="string">            &#123;5: &lt;_WorkItem...&gt;, 6: &lt;_WorkItem...&gt;, ...&#125;</span></span><br><span class="line"><span class="string">        work_ids: A queue.Queue of work ids e.g. Queue([5, 6, ...]). Work ids</span></span><br><span class="line"><span class="string">            are consumed and the corresponding _WorkItems from</span></span><br><span class="line"><span class="string">            pending_work_items are transformed into _CallItems and put in</span></span><br><span class="line"><span class="string">            call_queue.</span></span><br><span class="line"><span class="string">        call_queue: A multiprocessing.Queue that will be filled with _CallItems</span></span><br><span class="line"><span class="string">            derived from _WorkItems.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> call_queue.full():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            work_id = work_ids.get(block=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">except</span> queue.Empty:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            work_item = pending_work_items[work_id]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> work_item.future.set_running_or_notify_cancel():</span><br><span class="line">                call_queue.put(_CallItem(work_id,</span><br><span class="line">                                         work_item.fn,</span><br><span class="line">                                         work_item.args,</span><br><span class="line">                                         work_item.kwargs),</span><br><span class="line">                               block=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">del</span> pending_work_items[work_id]</span><br><span class="line">                <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>首先，判断调用队列是不是已经满了，如果满了，则放弃这次循环。紧接着从 <code>work_id</code> 队列中取出，然后从等待任务中取出对应的 <code>_WorkItem</code> 实例。紧接着，调用实例中绑定的 <code>Future</code> 实例的 <code>set_running_or_notify_cancel</code> 方法来设置任务的状态，紧接着将其扔入调用队列中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_running_or_notify_cancel</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Mark the future as running or process any cancel notifications.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Should only be used by Executor implementations and unit tests.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the future has been cancelled (cancel() was called and returned</span></span><br><span class="line"><span class="string">    True) then any threads waiting on the future completing (though calls</span></span><br><span class="line"><span class="string">    to as_completed() or wait()) are notified and False is returned.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the future was not cancelled then it is put in the running state</span></span><br><span class="line"><span class="string">    (future calls to running() will return True) and True is returned.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This method should be called by Executor implementations before</span></span><br><span class="line"><span class="string">    executing the work associated with this future. If this method returns</span></span><br><span class="line"><span class="string">    False then the work should not be executed.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        False if the Future was cancelled, True otherwise.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        RuntimeError: if this method was already called or if set_result()</span></span><br><span class="line"><span class="string">            or set_exception() was called.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> self._condition:</span><br><span class="line">        <span class="keyword">if</span> self._state == CANCELLED:</span><br><span class="line">            self._state = CANCELLED_AND_NOTIFIED</span><br><span class="line">            <span class="keyword">for</span> waiter <span class="keyword">in</span> self._waiters:</span><br><span class="line">                waiter.add_cancelled(self)</span><br><span class="line">            <span class="comment"># self._condition.notify_all() is not necessary because</span></span><br><span class="line">            <span class="comment"># self.cancel() triggers a notification.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> self._state == PENDING:</span><br><span class="line">            self._state = RUNNING</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            LOGGER.critical(<span class="string">&#x27;Future %s in unexpected state: %s&#x27;</span>,</span><br><span class="line">                            <span class="built_in">id</span>(self),</span><br><span class="line">                            self._state)</span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Future in unexpected state&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这一部分内容很简单，检查当前实例如果处于等待状态，就返回 True ，如果处于被取消的状态，就返回 False , 在 <code>_add_call_item_to_queue</code> 函数中，会将已经处于 <code>cancel</code> 状态的 <code>_WorkItem</code> 从等待任务中移除。</p><p>好了，我们继续回到 <code>_queue_management_worker</code> 函数中去，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_queue_management_worker</span>(<span class="params">executor_reference,</span></span><br><span class="line"><span class="params">                             processes,</span></span><br><span class="line"><span class="params">                             pending_work_items,</span></span><br><span class="line"><span class="params">                             work_ids_queue,</span></span><br><span class="line"><span class="params">                             call_queue,</span></span><br><span class="line"><span class="params">                             result_queue</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Manages the communication between this process and the worker processes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function is run in a local thread.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        executor_reference: A weakref.ref to the ProcessPoolExecutor that owns</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        process: A list of the multiprocessing.Process instances used as</span></span><br><span class="line"><span class="string">            this thread. Used to determine if the ProcessPoolExecutor has been</span></span><br><span class="line"><span class="string">            garbage collected and that this function can exit.</span></span><br><span class="line"><span class="string">            workers.</span></span><br><span class="line"><span class="string">        pending_work_items: A dict mapping work ids to _WorkItems e.g.</span></span><br><span class="line"><span class="string">            &#123;5: &lt;_WorkItem...&gt;, 6: &lt;_WorkItem...&gt;, ...&#125;</span></span><br><span class="line"><span class="string">        work_ids_queue: A queue.Queue of work ids e.g. Queue([5, 6, ...]).</span></span><br><span class="line"><span class="string">        call_queue: A multiprocessing.Queue that will be filled with _CallItems</span></span><br><span class="line"><span class="string">            derived from _WorkItems for processing by the process workers.</span></span><br><span class="line"><span class="string">        result_queue: A multiprocessing.Queue of _ResultItems generated by the</span></span><br><span class="line"><span class="string">            process workers.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    executor = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shutting_down</span>():</span><br><span class="line">        <span class="keyword">return</span> _shutdown <span class="keyword">or</span> executor <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> executor._shutdown_thread</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shutdown_worker</span>():</span><br><span class="line">        <span class="comment"># This is an upper bound</span></span><br><span class="line">        nb_children_alive = <span class="built_in">sum</span>(p.is_alive() <span class="keyword">for</span> p <span class="keyword">in</span> processes.values())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, nb_children_alive):</span><br><span class="line">            call_queue.put_nowait(<span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># Release the queue&#x27;s resources as soon as possible.</span></span><br><span class="line">        call_queue.close()</span><br><span class="line">        <span class="comment"># If .join() is not called on the created processes then</span></span><br><span class="line">        <span class="comment"># some multiprocessing.Queue methods may deadlock on Mac OS X.</span></span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> processes.values():</span><br><span class="line">            p.join()</span><br><span class="line"></span><br><span class="line">    reader = result_queue._reader</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        _add_call_item_to_queue(pending_work_items,</span><br><span class="line">                                work_ids_queue,</span><br><span class="line">                                call_queue)</span><br><span class="line"></span><br><span class="line">        sentinels = [p.sentinel <span class="keyword">for</span> p <span class="keyword">in</span> processes.values()]</span><br><span class="line">        <span class="keyword">assert</span> sentinels</span><br><span class="line">        ready = wait([reader] + sentinels)</span><br><span class="line">        <span class="keyword">if</span> reader <span class="keyword">in</span> ready:</span><br><span class="line">            result_item = reader.recv()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Mark the process pool broken so that submits fail right now.</span></span><br><span class="line">            executor = executor_reference()</span><br><span class="line">            <span class="keyword">if</span> executor <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                executor._broken = <span class="literal">True</span></span><br><span class="line">                executor._shutdown_thread = <span class="literal">True</span></span><br><span class="line">                executor = <span class="literal">None</span></span><br><span class="line">            <span class="comment"># All futures in flight must be marked failed</span></span><br><span class="line">            <span class="keyword">for</span> work_id, work_item <span class="keyword">in</span> pending_work_items.items():</span><br><span class="line">                work_item.future.set_exception(</span><br><span class="line">                    BrokenProcessPool(</span><br><span class="line">                        <span class="string">&quot;A process in the process pool was &quot;</span></span><br><span class="line">                        <span class="string">&quot;terminated abruptly while the future was &quot;</span></span><br><span class="line">                        <span class="string">&quot;running or pending.&quot;</span></span><br><span class="line">                    ))</span><br><span class="line">                <span class="comment"># Delete references to object. See issue16284</span></span><br><span class="line">                <span class="keyword">del</span> work_item</span><br><span class="line">            pending_work_items.clear()</span><br><span class="line">            <span class="comment"># Terminate remaining workers forcibly: the queues or their</span></span><br><span class="line">            <span class="comment"># locks may be in a dirty state and block forever.</span></span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> processes.values():</span><br><span class="line">                p.terminate()</span><br><span class="line">            shutdown_worker()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(result_item, <span class="built_in">int</span>):</span><br><span class="line">            <span class="comment"># Clean shutdown of a worker using its PID</span></span><br><span class="line">            <span class="comment"># (avoids marking the executor broken)</span></span><br><span class="line">            <span class="keyword">assert</span> shutting_down()</span><br><span class="line">            p = processes.pop(result_item)</span><br><span class="line">            p.join()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> processes:</span><br><span class="line">                shutdown_worker()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> result_item <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            work_item = pending_work_items.pop(result_item.work_id, <span class="literal">None</span>)</span><br><span class="line">            <span class="comment"># work_item can be None if another process terminated (see above)</span></span><br><span class="line">            <span class="keyword">if</span> work_item <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> result_item.exception:</span><br><span class="line">                    work_item.future.set_exception(result_item.exception)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    work_item.future.set_result(result_item.result)</span><br><span class="line">                <span class="comment"># Delete references to object. See issue16284</span></span><br><span class="line">                <span class="keyword">del</span> work_item</span><br><span class="line">        <span class="comment"># Check whether we should start shutting down.</span></span><br><span class="line">        executor = executor_reference()</span><br><span class="line">        <span class="comment"># No more work items can be added if:</span></span><br><span class="line">        <span class="comment">#   - The interpreter is shutting down OR</span></span><br><span class="line">        <span class="comment">#   - The executor that owns this worker has been collected OR</span></span><br><span class="line">        <span class="comment">#   - The executor that owns this worker has been shutdown.</span></span><br><span class="line">        <span class="keyword">if</span> shutting_down():</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># Since no new work items can be added, it is safe to shutdown</span></span><br><span class="line">                <span class="comment"># this thread if there are no pending work items.</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> pending_work_items:</span><br><span class="line">                    shutdown_worker()</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">except</span> Full:</span><br><span class="line">                <span class="comment"># This is not a problem: we will eventually be woken up (in</span></span><br><span class="line">                <span class="comment"># result_queue.get()) and be able to send a sentinel again.</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        executor = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><code>result_item</code> 变量</p><p>我们看看</p><p>首先，大家可能在这里有点疑问了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sentinels = [p.sentinel <span class="keyword">for</span> p <span class="keyword">in</span> processes.values()]</span><br><span class="line"><span class="keyword">assert</span> sentinels</span><br><span class="line">ready = wait([reader] + sentinels)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个 <code>wait</code> 是什么鬼啊，<code>reader</code> 又是什么鬼啊。一步步来。首先，我们看到，前面，<code>reader = result_queue._reader</code> 也会引起大家的疑问，这里我们 <code>result_queue</code> 是 <code>multiprocess</code> 里面的 <code>SimpleQueue</code> 啊，它没有 <code>_reader</code> 方法啊QAQ</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleQueue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *, ctx</span>):</span><br><span class="line">        self._reader, self._writer = connection.Pipe(duplex=<span class="literal">False</span>)</span><br><span class="line">        self._rlock = ctx.Lock()</span><br><span class="line">        self._poll = self._reader.poll</span><br><span class="line">        <span class="keyword">if</span> sys.platform == <span class="string">&#x27;win32&#x27;</span>:</span><br><span class="line">            self._wlock = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._wlock = ctx.Lock()</span><br></pre></td></tr></table></figure><p>上面这贴出来的，是 <code>SimpleQueue</code> 的部分代码，我们可以很清楚的看到，<code>SimpleQueue</code> 本质是利用一个 <code>Pipe</code> 来进行进程间通信的，然后 <code>_reader</code> 是读取 <code>Pipe</code> 的一个变量。</p><blockquote><p><strong>Note</strong> : 大家可以复习下其余几种进程间通信的方法了</p></blockquote><p>好了，这一部分看懂后，我们来看看 <code>wait</code> 方法吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wait</span>(<span class="params">object_list, timeout=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Wait till an object in object_list is ready/readable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns list of those objects in object_list which are ready/readable.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> _WaitSelector() <span class="keyword">as</span> selector:</span><br><span class="line">        <span class="keyword">for</span> obj <span class="keyword">in</span> object_list:</span><br><span class="line">            selector.register(obj, selectors.EVENT_READ)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            deadline = time.time() + timeout</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            ready = selector.select(timeout)</span><br><span class="line">            <span class="keyword">if</span> ready:</span><br><span class="line">                <span class="keyword">return</span> [key.fileobj <span class="keyword">for</span> (key, events) <span class="keyword">in</span> ready]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    timeout = deadline - time.time()</span><br><span class="line">                    <span class="keyword">if</span> timeout &lt; <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">return</span> ready</span><br></pre></td></tr></table></figure><p>这一部分代码很简单，首先将我们待读取的对象，进行一次注册，然后当 <code>timeout</code> 为 None 的时候，就一直等待到有对象读取数据成功为止</p><p>好了，我们继续回到前面的 <code>_queue_management_worker</code> 函数中去，来看看这样一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ready = wait([reader] + sentinels)</span><br><span class="line"><span class="keyword">if</span> reader <span class="keyword">in</span> ready:</span><br><span class="line">    result_item = reader.recv()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># Mark the process pool broken so that submits fail right now.</span></span><br><span class="line">    executor = executor_reference()</span><br><span class="line">    <span class="keyword">if</span> executor <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        executor._broken = <span class="literal">True</span></span><br><span class="line">        executor._shutdown_thread = <span class="literal">True</span></span><br><span class="line">        executor = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># All futures in flight must be marked failed</span></span><br><span class="line">    <span class="keyword">for</span> work_id, work_item <span class="keyword">in</span> pending_work_items.items():</span><br><span class="line">        work_item.future.set_exception(</span><br><span class="line">            BrokenProcessPool(</span><br><span class="line">                <span class="string">&quot;A process in the process pool was &quot;</span></span><br><span class="line">                <span class="string">&quot;terminated abruptly while the future was &quot;</span></span><br><span class="line">                <span class="string">&quot;running or pending.&quot;</span></span><br><span class="line">            ))</span><br><span class="line">        <span class="comment"># Delete references to object. See issue16284</span></span><br><span class="line">        <span class="keyword">del</span> work_item</span><br><span class="line">    pending_work_items.clear()</span><br><span class="line">    <span class="comment"># Terminate remaining workers forcibly: the queues or their</span></span><br><span class="line">    <span class="comment"># locks may be in a dirty state and block forever.</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes.values():</span><br><span class="line">        p.terminate()</span><br><span class="line">    shutdown_worker()</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>我们用 <code>wait</code> 函数来读取一系列对象，因为我们没有设置 <code>Timeout</code> ，所以当我们拿到可读取对象的结果时，如果 <code>result_queue._reader</code> 没有在列表中，那么意味着，有处理进程突然异常关闭了，这个时候，我们开始执行后面的语句来执行目前进程池的关闭操作。如果在列表中，我们读取数据，得到 <code>result_item</code> 变量</p><p>我们再看看下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(result_item, <span class="built_in">int</span>):</span><br><span class="line">    <span class="comment"># Clean shutdown of a worker using its PID</span></span><br><span class="line">    <span class="comment"># (avoids marking the executor broken)</span></span><br><span class="line">    <span class="keyword">assert</span> shutting_down()</span><br><span class="line">    p = processes.pop(result_item)</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> processes:</span><br><span class="line">        shutdown_worker()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"><span class="keyword">elif</span> result_item <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    work_item = pending_work_items.pop(result_item.work_id, <span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># work_item can be None if another process terminated (see above)</span></span><br><span class="line">    <span class="keyword">if</span> work_item <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> result_item.exception:</span><br><span class="line">            work_item.future.set_exception(result_item.exception)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            work_item.future.set_result(result_item.result)</span><br><span class="line">        <span class="comment"># Delete references to object. See issue16284</span></span><br><span class="line">        <span class="keyword">del</span> work_item</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先，如果 <code>result_item</code> 变量是 int 类型的话，不知道大家还记不记得在 <code>_process_worker</code> 函数中有这样一段逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">call_item = call_queue.get(block=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">if</span> call_item <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># Wake up queue management thread</span></span><br><span class="line">    result_queue.put(os.getpid())</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>当调用队列中没有新的任务时，将进程 <code>pid</code> 放入 <code>result_queue</code> 中。那么我们 <code>result_item</code> 如果值为 <code>int</code> 那么意味着，我们之前任务处理工作已经完毕，于是开始清理，关闭我们的进程池。</p><p>如果 <code>result_item</code> 既不为 <code>int</code> 也不为 <code>None</code> , 那么必然是 <code>_ResultItem</code> 的实例，我们根据 <code>work_id</code> 取出 <code>_WorkItem</code> 实例，并将产生的异常或者值和 <code>_WorkItem</code> 实例中的 <code>Future</code> 实例（也就是我们 submit 后返回的那货）进行绑定。</p><p>最后，删除这个 <code>work_item</code> ，完事儿，手工</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>洋洋洒洒写了一大篇辣鸡文章，希望大家不要介意，其实我们能看到 <code>concurrent.future</code> 的实现，其实并没有用什么高深的黑魔法，但是其中细节值得我们一一品味，所以这篇文章我们先写到这里。后面有机会的话，我们再去看看 <code>concurrent.future</code> 其余部分代码。也有蛮多值得品味的地方。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>1.<a href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.SimpleQueue">Python 3 multiprocessing</a></p><p>2.<a href="https://docs.python.org/3/library/weakref.html">Python 3 weakref</a></p><p>3.<a href="https://my.oschina.net/u/1255754/blog/207331">并发编程之Future模式</a></p><p>4.<a href="https://www.ziwenxie.site/2016/12/24/python-concurrent-futures/">Python并发编程之线程池/进程池</a></p><p>5.<a href="http://zha-zi.iteye.com/blog/1408189">Future 模式详解（并发使用）</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 编程技巧 </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> 源码剖析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你所不知道的 Flask Part1:Route 初探</title>
      <link href="//posts/2017/08/13/what-the-fuck-about-flask-part1/"/>
      <url>//posts/2017/08/13/what-the-fuck-about-flask-part1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我自己都记不清楚上一次写博客是什么时候了（笑），上一次挖的坑现在还没填完，干脆，开个新坑吧，你不知道的 Flask ，记录下自己用 Flask 过程中一些很好玩的东西，当然很大可能我又会中途弃坑</p><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>之前遇到一个很奇怪的需求，需要在flask中支持正则表达式比如，<code>@app.route(&#39;/api/(.*?)&#39;)</code> 这样，在视图函数被调用的时候，能传入 URL 中正则匹配的值。不过 Flask 路由中默认不支持这样的方法，那么我们该怎么办？我们先思考五分钟吧？</p><p>好了，我先给出解决方案吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> BaseConverter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RegexConverter</span>(<span class="title class_ inherited__">BaseConverter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">map</span>, *args</span>):</span><br><span class="line">        self.<span class="built_in">map</span> = <span class="built_in">map</span></span><br><span class="line">        self.regex = args[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.url_map.converters[<span class="string">&#x27;regex&#x27;</span>] = RegexConverter</span><br></pre></td></tr></table></figure><span id="more"></span><p>在经过这样的设置后我们便可以按照我们刚才的需求写代码了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/docs/model_utils/&lt;regex(&quot;.*&quot;):url&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">url=<span class="literal">None</span></span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(url)</span><br></pre></td></tr></table></figure><p>在这里，我们函数中传入的url变量，就是我们代码中所匹配到的值 </p><p>但是为什么这样就OK了呢？</p><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>首先，我们要弄清楚一个东西，Flask 是 基于 Werkzurg 的一个框架，Flask 的 Route 机制基于 Werkzurg 上更进一步封装所得到的，OK，我们上面所以实现的 Converter 便是利用了 Werkzurg 中的 Route 的特性</p><p>好了，我先给出官方文档 <a href="http://werkzeug.pocoo.org/docs/0.12/routing/#custom-converters">custom-converters</a> </p><p>然后我们来仔细讲讲，</p><p>首先，Werkzurg 中存在着一种机制叫做 Converter ，简而言之就是通过一定的特殊语法，将 URL 中的特定部分，转化成特定的 Python 变量，其语法格式为 <code>/url/&lt;converter_name(&quot;表达式&quot;):变量名&gt;</code> 看起来有点复杂对吧，OK 用我们之前的例子来讲一下吧，你看，我们之前定义了一个 <code>&#39;/docs/model_utils/&lt;regex(&quot;.*&quot;):url&gt;&#39;</code> 的 URL ，其中后面部分就是利用了我们提到的 Converter 语法。具体的含义是，这个部分的 url 交给 regex 这个 Converter 来处理，最终生成的变量名为 <code>url</code>。</p><p>好了，我们来说说自定义 Converter 参数中的注意事项，在构建一个自己的 Converter 过程中，我们将按照如下的方式编写代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RegexConverter</span>(<span class="title class_ inherited__">BaseConverter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">map</span>, regex,*args</span>):</span><br><span class="line">        self.<span class="built_in">map</span> = <span class="built_in">map</span></span><br><span class="line">        self.regex = regex</span><br></pre></td></tr></table></figure><p>map 是指 werkzurg.routing 中的 Map 对象，而 regex 则是指你所写的表达式。其中 map 的作用我们将放在下一章进行讲解，（又立flag了，笑）。</p><p>好了这里差不多完成了，我们来看看 Flask 喔，不，werkzurg 中怎么实现的这样的方法吧</p><h3 id="简明代码剖析"><a href="#简明代码剖析" class="headerlink" title="简明代码剖析"></a>简明代码剖析</h3><p>最前面，你首先得有一点 flask 装饰器路由的知识，详情可以参考这篇文章，<a href="http://manjusaka.itscoder.com/2016/08/09/reading-the-fucking-flask-source-code-Part1/">菜鸟阅读 Flask 源码系列（1）：Flask的router初探</a></p><p>首先在 werkzurg 框架的 routing 文件中，存在着这样一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_rule_re = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    (?P&lt;static&gt;[^&lt;]*)                           # static rule data</span></span><br><span class="line"><span class="string">    &lt;</span></span><br><span class="line"><span class="string">    (?:</span></span><br><span class="line"><span class="string">        (?P&lt;converter&gt;[a-zA-Z_][a-zA-Z0-9_]*)   # converter name</span></span><br><span class="line"><span class="string">        (?:\((?P&lt;args&gt;.*?)\))?                  # converter arguments</span></span><br><span class="line"><span class="string">        \:                                      # variable delimiter</span></span><br><span class="line"><span class="string">    )?</span></span><br><span class="line"><span class="string">    (?P&lt;variable&gt;[a-zA-Z_][a-zA-Z0-9_]*)        # variable name</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>, re.VERBOSE)</span><br><span class="line">_simple_rule_re = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;([^&gt;]+)&gt;&#x27;</span>)</span><br><span class="line">_converter_args_re = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    ((?P&lt;name&gt;\w+)\s*=\s*)?</span></span><br><span class="line"><span class="string">    (?P&lt;value&gt;</span></span><br><span class="line"><span class="string">        True|False|</span></span><br><span class="line"><span class="string">        \d+.\d+|</span></span><br><span class="line"><span class="string">        \d+.|</span></span><br><span class="line"><span class="string">        \d+|</span></span><br><span class="line"><span class="string">        \w+|</span></span><br><span class="line"><span class="string">        [urUR]?(?P&lt;stringval&gt;&quot;[^&quot;]*?&quot;|&#x27;[^&#x27;]*&#x27;)</span></span><br><span class="line"><span class="string">    )\s*,</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>, re.VERBOSE | re.UNICODE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_converter_args</span>(<span class="params">argstr</span>):</span><br><span class="line">    argstr += <span class="string">&#x27;,&#x27;</span></span><br><span class="line">    args = []</span><br><span class="line">    kwargs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> _converter_args_re.finditer(argstr):</span><br><span class="line">        value = item.group(<span class="string">&#x27;stringval&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            value = item.group(<span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">        value = _pythonize(value)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> item.group(<span class="string">&#x27;name&#x27;</span>):</span><br><span class="line">            args.append(value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            name = item.group(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">            kwargs[name] = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tuple</span>(args), kwargs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_rule</span>(<span class="params">rule</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Parse a rule and return it as generator. Each iteration yields tuples</span></span><br><span class="line"><span class="string">    in the form ``(converter, arguments, variable)``. If the converter is</span></span><br><span class="line"><span class="string">    `None` it&#x27;s a static url part, otherwise it&#x27;s a dynamic one.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :internal:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    end = <span class="built_in">len</span>(rule)</span><br><span class="line">    do_match = _rule_re.<span class="keyword">match</span></span><br><span class="line">    used_names = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> pos &lt; end:</span><br><span class="line">        m = do_match(rule, pos)</span><br><span class="line">        <span class="keyword">if</span> m <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        data = m.groupdict()</span><br><span class="line">        <span class="keyword">if</span> data[<span class="string">&#x27;static&#x27;</span>]:</span><br><span class="line">            <span class="keyword">yield</span> <span class="literal">None</span>, <span class="literal">None</span>, data[<span class="string">&#x27;static&#x27;</span>]</span><br><span class="line">        variable = data[<span class="string">&#x27;variable&#x27;</span>]</span><br><span class="line">        converter = data[<span class="string">&#x27;converter&#x27;</span>] <span class="keyword">or</span> <span class="string">&#x27;default&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> variable <span class="keyword">in</span> used_names:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;variable name %r used twice.&#x27;</span> % variable)</span><br><span class="line">        used_names.add(variable)</span><br><span class="line">        <span class="keyword">yield</span> converter, data[<span class="string">&#x27;args&#x27;</span>] <span class="keyword">or</span> <span class="literal">None</span>, variable</span><br><span class="line">        pos = m.end()</span><br><span class="line">    <span class="keyword">if</span> pos &lt; end:</span><br><span class="line">        remaining = rule[pos:]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;&gt;&#x27;</span> <span class="keyword">in</span> remaining <span class="keyword">or</span> <span class="string">&#x27;&lt;&#x27;</span> <span class="keyword">in</span> remaining:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;malformed url rule: %r&#x27;</span> % rule)</span><br><span class="line">        <span class="keyword">yield</span> <span class="literal">None</span>, <span class="literal">None</span>, remaining</span><br></pre></td></tr></table></figure><p>首先，<code>_rule_re</code> 以及 <code>_converter_args_re</code> 两段是很骚的正则表达式，不过作者已经给出了足够的注释，大家可以对照着正则表达式的语法进行学习一个，然后 <code>parse_converter_args</code> 以及 <code>parse_rule</code> 则是利用正则表达式对其进行解析操作。</p><p>OK，我们紧接着往下查看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compile</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Compiles the regular expression and stores it.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> self.<span class="built_in">map</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&#x27;rule not bound&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.<span class="built_in">map</span>.host_matching:</span><br><span class="line">        domain_rule = self.host <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        domain_rule = self.subdomain <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    self._trace = []</span><br><span class="line">    self._converters = &#123;&#125;</span><br><span class="line">    self._weights = []</span><br><span class="line">    regex_parts = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_build_regex</span>(<span class="params">rule</span>):</span><br><span class="line">        <span class="keyword">for</span> converter, arguments, variable <span class="keyword">in</span> parse_rule(rule):</span><br><span class="line">            <span class="keyword">if</span> converter <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                regex_parts.append(re.escape(variable))</span><br><span class="line">                self._trace.append((<span class="literal">False</span>, variable))</span><br><span class="line">                <span class="keyword">for</span> part <span class="keyword">in</span> variable.split(<span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">                    <span class="keyword">if</span> part:</span><br><span class="line">                        self._weights.append((<span class="number">0</span>, -<span class="built_in">len</span>(part)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> arguments:</span><br><span class="line">                    c_args, c_kwargs = parse_converter_args(arguments)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c_args = ()</span><br><span class="line">                    c_kwargs = &#123;&#125;</span><br><span class="line">                convobj = self.get_converter(</span><br><span class="line">                    variable, converter, c_args, c_kwargs)</span><br><span class="line">                regex_parts.append(<span class="string">&#x27;(?P&lt;%s&gt;%s)&#x27;</span> % (variable, convobj.regex))</span><br><span class="line">                self._converters[variable] = convobj</span><br><span class="line">                self._trace.append((<span class="literal">True</span>, variable))</span><br><span class="line">                self._weights.append((<span class="number">1</span>, convobj.weight))</span><br><span class="line">                self.arguments.add(<span class="built_in">str</span>(variable))</span><br><span class="line"></span><br><span class="line">    _build_regex(domain_rule)</span><br><span class="line">    regex_parts.append(<span class="string">&#x27;\\|&#x27;</span>)</span><br><span class="line">    self._trace.append((<span class="literal">False</span>, <span class="string">&#x27;|&#x27;</span>))</span><br><span class="line">    _build_regex(self.is_leaf <span class="keyword">and</span> self.rule <span class="keyword">or</span> self.rule.rstrip(<span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.is_leaf:</span><br><span class="line">        self._trace.append((<span class="literal">False</span>, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.build_only:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    regex = <span class="string">r&#x27;^%s%s$&#x27;</span> % (</span><br><span class="line">        <span class="string">u&#x27;&#x27;</span>.join(regex_parts),</span><br><span class="line">        (<span class="keyword">not</span> self.is_leaf <span class="keyword">or</span> <span class="keyword">not</span> self.strict_slashes) <span class="keyword">and</span></span><br><span class="line">        <span class="string">&#x27;(?&lt;!/)(?P&lt;__suffix__&gt;/?)&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    self._regex = re.<span class="built_in">compile</span>(regex, re.UNICODE)</span><br></pre></td></tr></table></figure><p>这是 werkzurg 框架的 routing 文件中 Rule 类种的一部分的源码，其中在 <code>def _build_regex(rule):</code> 之前的是一些准备代码，然后我们接着往下看，<code>for converter, arguments, variable in parse_rule(rule):</code> 这一段代码，就是 URL 解析，通过调用 <code>parse_rule</code> 函数来实现对我们之前提到的 converter 语法进行解析，紧接着，如果 URL 里不存在我们 Converter 的语法，则 <code>converter</code> 为空，我们执行处理其余 URL 的逻辑，如果 <code>converter</code> 存在，进行下面的流程，首先，如果我们在 Converter 语法中设定了解析表达式，那么我们利用 <code>parse_converter_args</code> 函数来处理我们的表达式，方便后续的操作，处理完成后，我们利用 <code>get_converter</code> 方法来初始化我们的 Converter , 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_converter</span>(<span class="params">self, variable_name, converter_name, args, kwargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Looks up the converter for the given parameter.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionadded:: 0.9</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> converter_name <span class="keyword">not</span> <span class="keyword">in</span> self.<span class="built_in">map</span>.converters:</span><br><span class="line">        <span class="keyword">raise</span> LookupError(<span class="string">&#x27;the converter %r does not exist&#x27;</span> % converter_name)</span><br><span class="line">    <span class="keyword">return</span> self.<span class="built_in">map</span>.converters[converter_name](self.<span class="built_in">map</span>, *args, **kwargs)</span><br></pre></td></tr></table></figure><p>以我们之前的 demo 为例，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> werkzeug.routing <span class="keyword">import</span> BaseConverter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RegexConverter</span>(<span class="title class_ inherited__">BaseConverter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">map</span>, *args</span>):</span><br><span class="line">        self.<span class="built_in">map</span> = <span class="built_in">map</span></span><br><span class="line">        self.regex = args[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.url_map.converters[<span class="string">&#x27;regex&#x27;</span>] = RegexConverter</span><br></pre></td></tr></table></figure><p>我们已经添加了一个名为 <code>regex</code> 的 Converter 对象，在 <code>get_converter</code> 方法中我们传入了值为 <code>regex</code> 的 <code>converter_name</code> 变量，紧接着，我们初始化了一个 <code>RegexConverter</code> 对象的实例，然后返回这个实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">def</span> <span class="title function_">compile</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Compiles the regular expression and stores it.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> self.<span class="built_in">map</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&#x27;rule not bound&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.<span class="built_in">map</span>.host_matching:</span><br><span class="line">            domain_rule = self.host <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            domain_rule = self.subdomain <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        self._trace = []</span><br><span class="line">        self._converters = &#123;&#125;</span><br><span class="line">        self._weights = []</span><br><span class="line">        regex_parts = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">_build_regex</span>(<span class="params">rule</span>):</span><br><span class="line">            <span class="keyword">for</span> converter, arguments, variable <span class="keyword">in</span> parse_rule(rule):</span><br><span class="line">                <span class="keyword">if</span> converter <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    regex_parts.append(re.escape(variable))</span><br><span class="line">                    self._trace.append((<span class="literal">False</span>, variable))</span><br><span class="line">                    <span class="keyword">for</span> part <span class="keyword">in</span> variable.split(<span class="string">&#x27;/&#x27;</span>):</span><br><span class="line">                        <span class="keyword">if</span> part:</span><br><span class="line">                            self._weights.append((<span class="number">0</span>, -<span class="built_in">len</span>(part)))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> arguments:</span><br><span class="line">                        c_args, c_kwargs = parse_converter_args(arguments)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        c_args = ()</span><br><span class="line">                        c_kwargs = &#123;&#125;</span><br><span class="line">                    convobj = self.get_converter(</span><br><span class="line">                        variable, converter, c_args, c_kwargs)</span><br><span class="line"><span class="comment">############################################################# 无耻分割线</span></span><br><span class="line">                    regex_parts.append(<span class="string">&#x27;(?P&lt;%s&gt;%s)&#x27;</span> % (variable, convobj.regex))</span><br><span class="line">                    self._converters[variable] = convobj</span><br><span class="line">                    self._trace.append((<span class="literal">True</span>, variable))</span><br><span class="line">                    self._weights.append((<span class="number">1</span>, convobj.weight))</span><br><span class="line">                    self.arguments.add(<span class="built_in">str</span>(variable))</span><br><span class="line"></span><br><span class="line">        _build_regex(domain_rule)</span><br><span class="line">        regex_parts.append(<span class="string">&#x27;\\|&#x27;</span>)</span><br><span class="line">        self._trace.append((<span class="literal">False</span>, <span class="string">&#x27;|&#x27;</span>))</span><br><span class="line">        _build_regex(self.is_leaf <span class="keyword">and</span> self.rule <span class="keyword">or</span> self.rule.rstrip(<span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_leaf:</span><br><span class="line">            self._trace.append((<span class="literal">False</span>, <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.build_only:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        regex = <span class="string">r&#x27;^%s%s$&#x27;</span> % (</span><br><span class="line">            <span class="string">u&#x27;&#x27;</span>.join(regex_parts),</span><br><span class="line">            (<span class="keyword">not</span> self.is_leaf <span class="keyword">or</span> <span class="keyword">not</span> self.strict_slashes) <span class="keyword">and</span></span><br><span class="line">            <span class="string">&#x27;(?&lt;!/)(?P&lt;__suffix__&gt;/?)&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        )</span><br><span class="line">        self._regex = re.<span class="built_in">compile</span>(regex, re.UNICODE)</span><br></pre></td></tr></table></figure><p>在分割线后面的代码中，我们对处理后的 url 进行一些收尾的操作，以我们之前的 demo 为例，我们设定的 <code>/docs/model_utils/&lt;regex(&quot;.*&quot;):url&gt;</code> URL 最终转化成 <code>/docs/model_utils/(?P&lt;url&gt;.*)</code> ，编译成 re 对象后赋值给 Rule 实例中的 _regex 变量</p><p>好了，我们知道处理的部分后，我们大致来看一下怎么匹配并生成值的吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">match</span>(<span class="params">self, path, method=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Check if the rule matches a given path. Path is a string in the</span></span><br><span class="line"><span class="string">    form ``&quot;subdomain|/path&quot;`` and is assembled by the map.  If</span></span><br><span class="line"><span class="string">    the map is doing host matching the subdomain part will be the host</span></span><br><span class="line"><span class="string">    instead.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If the rule matches a dict with the converted values is returned,</span></span><br><span class="line"><span class="string">    otherwise the return value is `None`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :internal:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.build_only:</span><br><span class="line">        m = self._regex.search(path)</span><br><span class="line">        <span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            groups = m.groupdict()</span><br><span class="line">            <span class="comment"># we have a folder like part of the url without a trailing</span></span><br><span class="line">            <span class="comment"># slash and strict slashes enabled. raise an exception that</span></span><br><span class="line">            <span class="comment"># tells the map to redirect to the same url but with a</span></span><br><span class="line">            <span class="comment"># trailing slash</span></span><br><span class="line">            <span class="keyword">if</span> self.strict_slashes <span class="keyword">and</span> <span class="keyword">not</span> self.is_leaf <span class="keyword">and</span> \</span><br><span class="line">                    <span class="keyword">not</span> groups.pop(<span class="string">&#x27;__suffix__&#x27;</span>) <span class="keyword">and</span> \</span><br><span class="line">                    (method <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> self.methods <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span></span><br><span class="line">                     method <span class="keyword">in</span> self.methods):</span><br><span class="line">                <span class="keyword">raise</span> RequestSlash()</span><br><span class="line">            <span class="comment"># if we are not in strict slashes mode we have to remove</span></span><br><span class="line">            <span class="comment"># a __suffix__</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> self.strict_slashes:</span><br><span class="line">                <span class="keyword">del</span> groups[<span class="string">&#x27;__suffix__&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            result = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> name, value <span class="keyword">in</span> iteritems(groups):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    value = self._converters[name].to_python(value)</span><br><span class="line">                <span class="keyword">except</span> ValidationError:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                result[<span class="built_in">str</span>(name)] = value</span><br><span class="line">            <span class="keyword">if</span> self.defaults:</span><br><span class="line">                result.update(self.defaults)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.alias <span class="keyword">and</span> self.<span class="built_in">map</span>.redirect_defaults:</span><br><span class="line">                <span class="keyword">raise</span> RequestAliasRedirect(result)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这也是 werkzurg 框架的 routing 文件中 Rule 类种的一部分的源码，在这段代码中，首先利用 re 对象中的 search 方法，检测当前传入的 Path 是否匹配，如果匹配的话，进入后续的处理流程，还记得我们之前最终生成的 <code>/docs/model_utils/(?P&lt;url&gt;.*)</code> 么，这里面利用了正则表达式命名组的语法糖，在这里，匹配成功后，Python 的 re 库里给我们提供了一个 <code>groupdict</code> 让我们取出命名组里所代表的值。然后我们调用 conveter 实例里面的 to_python 方法来对我们匹配出来的值进行处理（注：这是 Converter 系列对象中的一个可重载方法，我们可以通过重载这个方法，来对我们匹配到的值进行一些逻辑处理，这个我们还是后面再讲吧，flag++），然后我们把最终的 <code>result</code> 值返回。</p><p>最后的最后，Flask 在获取 werkzurg 给出的匹配结果后，将匹配的值，放在 <code>request</code> 实例中的 <code>view_args</code> 变量上，最后通过 <code>dispatch_request</code> 对象传递给我们的视图函数，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dispatch_request</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Does the request dispatching.  Matches the URL and returns the</span></span><br><span class="line"><span class="string">    return value of the view or error handler.  This does not have to</span></span><br><span class="line"><span class="string">    be a response object.  In order to convert the return value to a</span></span><br><span class="line"><span class="string">    proper response object, call :func:`make_response`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionchanged:: 0.7</span></span><br><span class="line"><span class="string">       This no longer does the exception handling, this code was</span></span><br><span class="line"><span class="string">       moved to the new :meth:`full_dispatch_request`.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    req = _request_ctx_stack.top.request</span><br><span class="line">    <span class="keyword">if</span> req.routing_exception <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        self.raise_routing_exception(req)</span><br><span class="line">    rule = req.url_rule</span><br><span class="line">    <span class="comment"># if we provide automatic options for this URL and the</span></span><br><span class="line">    <span class="comment"># request came with the OPTIONS method, reply automatically</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">getattr</span>(rule, <span class="string">&#x27;provide_automatic_options&#x27;</span>, <span class="literal">False</span>) \</span><br><span class="line">       <span class="keyword">and</span> req.method == <span class="string">&#x27;OPTIONS&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> self.make_default_options_response()</span><br><span class="line">    <span class="comment"># otherwise dispatch to the handler for that endpoint</span></span><br><span class="line">    <span class="keyword">return</span> self.view_functions[rule.endpoint](**req.view_args)</span><br></pre></td></tr></table></figure><p>好了，我们的代码剖析就到此结束</p><h2 id="最后想说几句"><a href="#最后想说几句" class="headerlink" title="最后想说几句"></a>最后想说几句</h2><p>Flask + Werkzurg 是一套设计实现的非常精妙的组合，不过我们在日常的使用中常常忽略了里面的美丽的风景，所以这也是我想写这样剖析代码笔记的文章的原因</p><p>好了，给老铁们留几个思考题，欢迎评论区讨论</p><ul><li><p>Flask 为什么不默认支持正则表达式的输入</p></li><li><p>诸如 <code>PathConverter</code> 这样 Werkzurg 内置的 Converter 为什么在写表达式的时候可以这样 <code>/&lt;path:wikipage&gt;/edit</code> 写，而忽略其中的表达式</p></li><li><p>前面提到的 <code>parse_converter_args</code> 方法的代码详解</p></li></ul><p>好了，就先这样吧2333</p><p>对了，保佑我文章里立的 Flag 都能实现（笑）</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> Flask </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>asyncio 笔记</title>
      <link href="//posts/2017/06/07/some-note-for-asyncio/"/>
      <url>//posts/2017/06/07/some-note-for-asyncio/</url>
      
        <content type="html"><![CDATA[<p>来源 <a href="https://github.com/hhstore/annotated-py-asyncio">annotated-py-asyncio</a></p><h1 id="阅读补充"><a href="#阅读补充" class="headerlink" title="阅读补充:"></a>阅读补充:</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念:"></a>1. 基本概念:</h2><h3 id="1-1-协程"><a href="#1-1-协程" class="headerlink" title="1.1 协程:"></a>1.1 协程:</h3><ul><li>“协程 是为非抢占式多任务产生子程序的计算机程序组件，协程允许不同入口点在不同位置暂停或开始执行程序”。</li><li>从技术的角度来说，“协程就是你可以暂停执行的函数”。</li><li>如果你把它理解成“就像生成器一样”，那么你就想对了。</li></ul><span id="more"></span><h3 id="1-2-事件循环"><a href="#1-2-事件循环" class="headerlink" title="1.2 事件循环:"></a>1.2 事件循环:</h3><ul><li>事件循环 “是一种等待程序分配事件或消息的编程架构”。</li><li>基本上来说事件循环就是，“当A发生时，执行B”。</li><li>或许最简单的例子来解释这一概念就是用每个浏览器中都存在的JavaScript事件循环。</li><li>当你点击了某个东西（“当A发生时”），这一点击动作会发送给JavaScript的事件循环，并检查是否存在注册过的 onclick 回调来处理这一点击（“执行B”）。</li><li>只要有注册过的回调函数就会伴随点击动作的细节信息被执行。</li><li>事件循环被认为是一种循环是因为它不停地收集事件并通过循环来发如何应对这些事件。</li></ul><h3 id="1-3-Python-的事件循环"><a href="#1-3-Python-的事件循环" class="headerlink" title="1.3 Python 的事件循环:"></a>1.3 Python 的事件循环:</h3><ul><li>对 Python 来说，用来提供事件循环的 asyncio 被加入标准库中。</li><li>asyncio 重点解决网络服务中的问题，事件循环在这里将来自套接字（socket）的 I/O 已经准备好读和/或写作为“当A发生时”（通过selectors模块）。</li><li>除了 GUI 和 I/O，事件循环也经常用于在别的线程或子进程中执行代码，并将事件循环作为调节机制（例如，合作式多任务）。</li><li>如果你恰好理解 Python 的 GIL，事件循环对于需要释放 GIL 的地方很有用。</li><li>事件循环提供一种循环机制，让你可以“在A发生时，执行B”。</li><li>基本上来说事件循环就是监听当有什么发生时，同时事件循环也关心这件事并执行相应的代码。</li><li>Python 3.4 以后通过标准库 asyncio 获得了事件循环的特性。</li></ul><h3 id="1-4-async-await"><a href="#1-4-async-await" class="headerlink" title="1.4 async, await:"></a>1.4 async, await:</h3><ul><li>将 async/await 看做异步编程的 API</li><li>基本上 async 和 await 产生神奇的生成器，我们称之为协程，</li><li>同时需要一些额外的支持例如 awaitable 对象以及将普通生成器转化为协程。</li><li>所有这些加到一起来支持并发，这样才使得 Python 更好地支持异步编程。</li><li>相比类似功能的线程，这是一个更妙也更简单的方法。</li></ul><p>在 Python 3.4 中，用于异步编程并被标记为协程的函数看起来是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># This also works in Python 3.5.</span></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">py34_coro</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> stuff()</span><br></pre></td></tr></table></figure><p>Python 3.5 添加了types.coroutine 修饰器，也可以像 asyncio.coroutine 一样将生成器标记为协程。<br>你可以用 async def 来定义一个协程函数，虽然这个函数不能包含任何形式的 yield 语句；只有 return 和 await 可以从协程中返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">py35_coro</span>():</span><br><span class="line">    <span class="keyword">await</span> stuff()</span><br></pre></td></tr></table></figure><p>你将发现不仅仅是 async，Python 3.5 还引入 await 表达式（只能用于async def中）。<br>虽然await的使用和yield from很像，但await可以接受的对象却是不同的。<br>await 当然可以接受协程，因为协程的概念是所有这一切的基础。<br>但是当你使用 await 时，其接受的对象必须是awaitable 对象：必须是定义了<strong>await</strong>()方法且这一方法必须返回一个不是协程的迭代器。<br>协程本身也被认为是 awaitable 对象（这也是collections.abc.Coroutine 继承 collections.abc.Awaitable的原因）。<br>这一定义遵循 Python 将大部分语法结构在底层转化成方法调用的传统，就像 a + b 实际上是a.<strong>add</strong>(b) 或者 b.<strong>radd</strong>(a)。</p><p>为什么基于async的协程和基于生成器的协程会在对应的暂停表达式上面有所不同？<br>主要原因是出于最优化Python性能的考虑，确保你不会将刚好有同样API的不同对象混为一谈。<br>由于生成器默认实现协程的API，因此很有可能在你希望用协程的时候错用了一个生成器。<br>而由于并不是所有的生成器都可以用在基于协程的控制流中，你需要避免错误地使用生成器。</p><p>用async def可以定义得到协程。<br>定义协程的另一种方式是通过types.coroutine修饰器<br>    — 从技术实现的角度来说就是添加了 CO_ITERABLE_COROUTINE标记<br>    — 或者是collections.abc.Coroutine的子类。<br>你只能通过基于生成器的定义来实现协程的暂停。</p><p>awaitable 对象要么是一个协程要么是一个定义了<strong>await</strong>()方法的对象<br>    — 也就是collections.abc.Awaitable<br>    — 且<strong>await</strong>()必须返回一个不是协程的迭代器。</p><p>await表达式基本上与 yield from 相同但只能接受awaitable对象（普通迭代器不行）。<br>async定义的函数要么包含return语句<br>    — 包括所有Python函数缺省的return None<br>    — 和/或者 await表达式（yield表达式不行）。<br>async函数的限制确保你不会将基于生成器的协程与普通的生成器混合使用，因为对这两种生成器的期望是非常不同的。</p><h3 id="1-5-关于-python-协程-和-golang-的对比讨论"><a href="#1-5-关于-python-协程-和-golang-的对比讨论" class="headerlink" title="1.5 关于 python 协程 和 golang 的对比讨论:"></a>1.5 关于 python 协程 和 golang 的对比讨论:</h3><ul><li><a href="https://news.ycombinator.com/item?id=10402307">From Python to Go and Back Again</a><ul><li><a href="https://docs.google.com/presentation/d/1LO_WI3N-3p2Wp9PDWyv5B6EGFZ8XTOTNJ7Hd40WOUHo/mobilepresent?pli=1&amp;slide=id.g70b0035b2_1_154">PPT</a></li><li>关于此PPT 的观点: go 比 pypy 性能高不了多少, 但是复杂度和调试难度增加很高</li><li>结尾鼓吹 rust.</li></ul></li><li>异步库参考:<ul><li><a href="https://github.com/Lukasa/hyper">hyper</a></li><li><a href="https://github.com/dabeaz/curio">curio</a><ul><li>将asyncio看作是一个利用async/await API 进行异步编程的框架</li><li>David 将 async/await 看作是异步编程的API创建了 curio 项目来实现他自己的事件循环。</li><li>允许像 curio 一样的项目不仅可以在较低层面上拥有不同的操作方式</li><li>（例如 asyncio 利用 future 对象作为与事件循环交流的 API，而 curio 用的是元组）</li></ul></li></ul></li></ul><hr><h2 id="2-源码模块"><a href="#2-源码模块" class="headerlink" title="2. 源码模块:"></a>2. 源码模块:</h2><h3 id="2-1-futures-py-futures-py"><a href="#2-1-futures-py-futures-py" class="headerlink" title="2.1 (futures.py)[./futures.py]"></a>2.1 (futures.py)[./futures.py]</h3><h4 id="2-1-1-参考"><a href="#2-1-1-参考" class="headerlink" title="2.1.1 参考:"></a>2.1.1 参考:</h4><ul><li><a href="http://www.snarky.ca/how-the-heck-does-async-await-work-in-python-3-5">Python 3.5 协程究竟是个啥</a><ul><li>译: <a href="https://juejin.im/entry/56ea295ed342d300546e1e22">Python 3.5 协程究竟是个啥</a></li><li><a href="https://github.com/xitu/gold-miner/blob/master/TODO/how-the-heck-does-async-await-work-in-python-3-5.md">译: github</a></li><li><a href="http://blog.rainy.im/2016/03/10/how-the-heck-does-async-await-work-in-python-3-5/">译: 博客</a></li></ul></li></ul><ul><li><p><a href="http://www.woola.net/detail/2016-10-18-python-coprocessor.html">Python 协程：从 yield/send 到 async/await</a></p><ul><li>future 源码剖析</li></ul></li><li><p><a href="https://toutiao.io/posts/9sygwc/preview">concurrent.futures 源码阅读笔记（Python）</a></p><ul><li>concurrent.futures 是一个异步库</li><li><a href="http://pythonhosted.org/futures/index.html">concurrent.futures — Asynchronous computation</a></li></ul></li></ul><h4 id="2-1-2-生成器（Generator）VS-迭代器（iterator）"><a href="#2-1-2-生成器（Generator）VS-迭代器（iterator）" class="headerlink" title="2.1.2 生成器（Generator）VS 迭代器（iterator）:"></a>2.1.2 生成器（Generator）VS 迭代器（iterator）:</h4><ul><li><p><a href="http://www.jeffknupp.com/blog/2013/04/07/improve-your-python-yield-and-generators-explained/">improve-your-python-yield-and-generators-explained</a></p><ul><li>译文:<a href="https://www.oschina.net/translate/improve-your-python-yield-and-generators-explained">提高你的Python: 解释‘yield’和‘Generators（生成器）’</a></li><li>在Python之外，最简单的生成器应该是被称为协程（coroutines）的东西。</li><li>generator是用来产生一系列值的</li><li>yield则像是generator函数的返回结果</li><li>yield唯一所做的另一件事就是保存一个generator函数的状态</li><li>generator就是一个特殊类型的迭代器（iterator）</li><li>和迭代器相似，我们可以通过使用next()来从generator中获取下一个值</li><li>通过隐式地调用next()来忽略一些值</li></ul></li><li><p><a href="http://kuanghy.github.io/2016/05/18/python-iteration">生成器与迭代器的关系</a></p><ul><li>生成器(generator)是一个特殊的迭代器，它的实现更简单优雅。yield 是生成器实现 <strong>next</strong>() 方法的关键</li></ul></li><li><p><a href="http://www.jianshu.com/p/dcf83643deeb">python黑魔法—-迭代器（iterator）</a></p></li><li><p><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138681965108490cb4c13182e472f8d87830f13be6e88000">生成器</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 源码阅读 </tag>
            
            <tag> async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在黎明之前</title>
      <link href="//posts/2017/02/10/it-s-my-way/"/>
      <url>//posts/2017/02/10/it-s-my-way/</url>
      
        <content type="html"><![CDATA[<blockquote><p>年少之成绩，或有时而可商，年少之作为，或有时而可讨，为此独立之精神，与自由之思想，纵历百十年整，亦与沱江水长流，共三光而永光</p></blockquote><p>其实突然发现，没写过点什么特殊的文字，来纪念自己这一年。</p><p>今天，2月10日，距离离职完毕还有五天，距离离开成都还有11天，距离入职，还有17天。坐在自己屋子里，看着窗外的云和雨雾，慢慢的，用一点东西，来纪念自己过去的一年。</p><span id="more"></span><h2 id="云起"><a href="#云起" class="headerlink" title="云起"></a>云起</h2><blockquote><p>Hey man, think about this world and go fuck it</p></blockquote><p>16年，一开年，便遭受了一个算是影响未来的挫折吧。现在想想，从1年6个月的感情里脱身出来并不是一件很容易的事情。更何况，遇到太多的事情让我更为烦心。</p><p>其实在大学尾声的时候，来回顾自己这四年，可能也更多的算是一个 loser 吧，竞赛失败。专业课挂科四分之一，延期毕业。不过心高气傲的我，还是不喜欢自己被同为一群 loser 的人所鄙视。这种感觉不是太好。</p><p>在师父的教育下，慢慢的入了 Python 的坑，准备在毕业前找到一个能混口饭吃的工作。所谓初生牛犊不怕虎，在什么都还懵懂的时候，第一场面试的结果就给我了当头一棒。不过到现在，依然很感谢当时面试官给我的灌输的一些东西。可能这样的一些东西，让我明白了真正的程序猿所应该拥有的态度与责任吧。</p><p>所幸，第二份工作，平安的通过并入职。恩，这算是一个，还算不错的开端吧。</p><h2 id="暗云"><a href="#暗云" class="headerlink" title="暗云"></a>暗云</h2><blockquote><p>当激情与新鲜感退却之后，生活能剩下的只能是坚守。</p></blockquote><p>在入职以后，可能离开了前面一段时间的新鲜期，便跟之前一样，进入了朝 9 晚 2 的生活。可能在自己以为自己会这样过下去的时候。认识了小天，猴子，和一群 Android 老司机（你说我一个写 Python 的，怎么就开始天天和 Android 的人开始搞基了呢？），然后去了掘金，开始以一个四级没过的人的身份，去翻译一点感兴趣的技术文章。然后和一群小伙伴们借着大佬后宫团的名义聚集在了一起。</p><p>如果要描述这段时光的话，应该就像现在窗外厚厚的云一样。表面四平八和，实则惊心动魄。看不到阳光的方向，却也只能随着大潮不断的前行。不知道自己的未来是什么样的，心有不甘，却也只能一步步的坚持走下去。不过，始终告诉自己，走下去。无数次的哭过，但也未曾放弃过。</p><p>其实很想感谢身边的人，公司的爽姐，涛哥，论道的朋友们，童童后宫团 12 位小伙伴们（童童，艳辉姐，羊哥，鳗鱼，大叔，盖伦哥，波波，田田，老叶，老柯，五月天，雪梨姐），在云层中看不到阳光与未来之时，这些人，用他们的宠爱和优秀，让我至少不会在随波逐流中迷失了自己的方向。</p><p>对了，如我所料，学位证延期了。</p><p>然后某人的死讯，真的是一条最好的消息。</p><h2 id="疑云"><a href="#疑云" class="headerlink" title="疑云"></a>疑云</h2><blockquote><p>为何而生，为何而战，为何而前行。</p></blockquote><p>和优秀的人相处久了，你总是不由自主的想去变得和他们一样的优秀。长久的遗传下来的自卑心却告诉自己，这些东西都离我太过遥远。心中的不安，不甘，自卑，狂妄交织在一起，产生出了一种难以明说的滋味。</p><p>其实这样一段时间，体验到了一个词的含义“悲喜参半”，悲的话，其实主要算是可惜吧，那段时间多愁善感，用朋友的话来说，你真成了一贱人的（不过我啥时候不是？）。喜得话应该算是再这样一种不断的挣扎于交集中，真正确定了自己想做什么，该做什么。</p><p>对了，最后成功的拿到了学位证。</p><h2 id="云开"><a href="#云开" class="headerlink" title="云开"></a>云开</h2><blockquote><p>  在黑暗中飞翔的鸟儿，终将会得到主救赎，自由的沐浴在阳光下</p></blockquote><p>拿到学位证之后，想出去看看更大的世界的心变得越发的狂野。写简历，投简历，找内推。一场场面试下来，可以说是体力与精神的双重考验。</p><p>不过在面试中，最大的收获，算是对自己的肯定吧。面试的内容和结果都告诉自己，自己貌似，也成为了，一个还算不错的新人？恩，长久被自卑覆盖的心，在这一段时间里体会了阳光的温暖。可能以后，不会在自卑中沉沦了呢？</p><p>恩，最后，很庆幸能遇到一些愿意给我机会的面试官，这样一种特殊的恩赐，算是，命运送给我，最好的新年礼物吧。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>还有十天就离开成都了，还有很多想说，还有很多不知道怎么说。对未来依旧一无所知，但是会很少再去迷茫。</p><p>休对故人思故国，且将新火试新茶。诗酒趁年华。<br>恩，诗酒趁年华！</p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生 </tag>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>听说你会 Python （2）：Python 高阶数据结构解析</title>
      <link href="//posts/2016/12/28/Someone-tell-me-that-you-think-Python-is-simple-2/"/>
      <url>//posts/2016/12/28/Someone-tell-me-that-you-think-Python-is-simple-2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前写过一篇<a href="http://manjusaka.itscoder.com/2016/11/18/Someone-tell-me-that-you-think-Python-is-simple/">《听说你会 Python ？》</a>的文章，大家反响都还不错，那么我想干脆把这个文章做成一个系列，继续讲解一下 Python 当中那些不为人知的细节吧。然后之前在和师父川爷讨论面试的时候，川爷说了一句“要是我，我就考考你们怎么去实现一个 <code>namedtuple</code> ，好用，方便，又能区分人”，说者无心，听者有意，我于是决定在这次的文章中，和大家聊一聊 Python 中一个特殊的高阶数据结构， namedtuple 的实现。<br><span id="more"></span></p><h1 id="Let’s-begin"><a href="#Let’s-begin" class="headerlink" title="Let’s begin"></a>Let’s begin</h1><h2 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><code>tuple</code> 是 Python 中 <strong>build-in</strong> 的一种特殊的数据结构，它是一种 <strong>immutable</strong> 的数据集合，我们经常会这样使用它</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    a = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    b, c = test()</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>Right，很多时候我们会直接使用 <code>tuple</code> 来进行一些数据的 packing/unpacking 的操作。OK，关于 <code>tuple</code> 的科普就到这里。那么什么是 <code>namedtuple</code> 呢，恩，前面不是说了 <code>tuple</code> 是一种特殊的数据集合么，那么 <code>namedtuple</code> 是其一个进阶（这不是废话么）。它将会基础的 <code>tuple</code> 抽象成一个类，我们将自行定义变量的名称和类的名称，这样我们可以很方便的将其复用并管理。具体的用法我们可以看看下面这个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fuck=namedtuple(<span class="string">&quot;fuck&quot;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">    a=fuck(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(a.x)</span><br><span class="line">    <span class="built_in">print</span>(a.y)</span><br></pre></td></tr></table></figure><p>恩，这样看起来貌似更直观了点，但是，但是，但是，我猜你肯定想知道 <code>namedtuple</code> 是怎么实现的，那么我们先来看看代码吧</p><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">_class_template = <span class="string">&#x27;&#x27;&#x27;\</span></span><br><span class="line"><span class="string">class &#123;typename&#125;(tuple):</span></span><br><span class="line"><span class="string">    &#x27;&#123;typename&#125;(&#123;arg_list&#125;)&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    __slots__ = ()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    _fields = &#123;field_names!r&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __new__(_cls, &#123;arg_list&#125;):</span></span><br><span class="line"><span class="string">        &#x27;Create new instance of &#123;typename&#125;(&#123;arg_list&#125;)&#x27;</span></span><br><span class="line"><span class="string">        return _tuple.__new__(_cls, (&#123;arg_list&#125;))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @classmethod</span></span><br><span class="line"><span class="string">    def _make(cls, iterable, new=tuple.__new__, len=len):</span></span><br><span class="line"><span class="string">        &#x27;Make a new &#123;typename&#125; object from a sequence or iterable&#x27;</span></span><br><span class="line"><span class="string">        result = new(cls, iterable)</span></span><br><span class="line"><span class="string">        if len(result) != &#123;num_fields:d&#125;:</span></span><br><span class="line"><span class="string">            raise TypeError(&#x27;Expected &#123;num_fields:d&#125; arguments, got %d&#x27; % len(result))</span></span><br><span class="line"><span class="string">        return result</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __repr__(self):</span></span><br><span class="line"><span class="string">        &#x27;Return a nicely formatted representation string&#x27;</span></span><br><span class="line"><span class="string">        return &#x27;&#123;typename&#125;(&#123;repr_fmt&#125;)&#x27; % self</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def _asdict(self):</span></span><br><span class="line"><span class="string">        &#x27;Return a new OrderedDict which maps field names to their values&#x27;</span></span><br><span class="line"><span class="string">        return OrderedDict(zip(self._fields, self))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def _replace(_self, **kwds):</span></span><br><span class="line"><span class="string">        &#x27;Return a new &#123;typename&#125; object replacing specified fields with new values&#x27;</span></span><br><span class="line"><span class="string">        result = _self._make(map(kwds.pop, &#123;field_names!r&#125;, _self))</span></span><br><span class="line"><span class="string">        if kwds:</span></span><br><span class="line"><span class="string">            raise ValueError(&#x27;Got unexpected field names: %r&#x27; % kwds.keys())</span></span><br><span class="line"><span class="string">        return result</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __getnewargs__(self):</span></span><br><span class="line"><span class="string">        &#x27;Return self as a plain tuple.  Used by copy and pickle.&#x27;</span></span><br><span class="line"><span class="string">        return tuple(self)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    __dict__ = _property(_asdict)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __getstate__(self):</span></span><br><span class="line"><span class="string">        &#x27;Exclude the OrderedDict from pickling&#x27;</span></span><br><span class="line"><span class="string">        pass</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;field_defs&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">_repr_template = <span class="string">&#x27;&#123;name&#125;=%r&#x27;</span></span><br><span class="line"></span><br><span class="line">_field_template = <span class="string">&#x27;&#x27;&#x27;\</span></span><br><span class="line"><span class="string">    &#123;name&#125; = _property(_itemgetter(&#123;index:d&#125;), doc=&#x27;Alias for field number &#123;index:d&#125;&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">namedtuple</span>(<span class="params">typename, field_names, verbose=<span class="literal">False</span>, rename=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Returns a new subclass of tuple with named fields.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Point = namedtuple(&#x27;Point&#x27;, [&#x27;x&#x27;, &#x27;y&#x27;])</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Point.__doc__                   # docstring for the new class</span></span><br><span class="line"><span class="string">    &#x27;Point(x, y)&#x27;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; p = Point(11, y=22)             # instantiate with positional args or keywords</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; p[0] + p[1]                     # indexable like a plain tuple</span></span><br><span class="line"><span class="string">    33</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y = p                        # unpack like a regular tuple</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; x, y</span></span><br><span class="line"><span class="string">    (11, 22)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; p.x + p.y                       # fields also accessible by name</span></span><br><span class="line"><span class="string">    33</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; d = p._asdict()                 # convert to a dictionary</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; d[&#x27;x&#x27;]</span></span><br><span class="line"><span class="string">    11</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; Point(**d)                      # convert from a dictionary</span></span><br><span class="line"><span class="string">    Point(x=11, y=22)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; p._replace(x=100)               # _replace() is like str.replace() but targets named fields</span></span><br><span class="line"><span class="string">    Point(x=100, y=22)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Validate the field names.  At the user&#x27;s option, either generate an error</span></span><br><span class="line">    <span class="comment"># message or automatically replace the field name with a valid name.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(field_names, basestring):</span><br><span class="line">        field_names = field_names.replace(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>).split()</span><br><span class="line">    field_names = <span class="built_in">map</span>(<span class="built_in">str</span>, field_names)</span><br><span class="line">    typename = <span class="built_in">str</span>(typename)</span><br><span class="line">    <span class="keyword">if</span> rename:</span><br><span class="line">        seen = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> index, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(field_names):</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> <span class="built_in">all</span>(c.isalnum() <span class="keyword">or</span> c==<span class="string">&#x27;_&#x27;</span> <span class="keyword">for</span> c <span class="keyword">in</span> name)</span><br><span class="line">                <span class="keyword">or</span> _iskeyword(name)</span><br><span class="line">                <span class="keyword">or</span> <span class="keyword">not</span> name</span><br><span class="line">                <span class="keyword">or</span> name[<span class="number">0</span>].isdigit()</span><br><span class="line">                <span class="keyword">or</span> name.startswith(<span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">                <span class="keyword">or</span> name <span class="keyword">in</span> seen):</span><br><span class="line">                field_names[index] = <span class="string">&#x27;_%d&#x27;</span> % index</span><br><span class="line">            seen.add(name)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> [typename] + field_names:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(name) != <span class="built_in">str</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Type names and field names must be strings&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>(c.isalnum() <span class="keyword">or</span> c==<span class="string">&#x27;_&#x27;</span> <span class="keyword">for</span> c <span class="keyword">in</span> name):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Type names and field names can only contain &#x27;</span></span><br><span class="line">                             <span class="string">&#x27;alphanumeric characters and underscores: %r&#x27;</span> % name)</span><br><span class="line">        <span class="keyword">if</span> _iskeyword(name):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Type names and field names cannot be a &#x27;</span></span><br><span class="line">                             <span class="string">&#x27;keyword: %r&#x27;</span> % name)</span><br><span class="line">        <span class="keyword">if</span> name[<span class="number">0</span>].isdigit():</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Type names and field names cannot start with &#x27;</span></span><br><span class="line">                             <span class="string">&#x27;a number: %r&#x27;</span> % name)</span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> field_names:</span><br><span class="line">        <span class="keyword">if</span> name.startswith(<span class="string">&#x27;_&#x27;</span>) <span class="keyword">and</span> <span class="keyword">not</span> rename:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Field names cannot start with an underscore: &#x27;</span></span><br><span class="line">                             <span class="string">&#x27;%r&#x27;</span> % name)</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Encountered duplicate field name: %r&#x27;</span> % name)</span><br><span class="line">        seen.add(name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Fill-in the class template</span></span><br><span class="line">    class_definition = _class_template.<span class="built_in">format</span>(</span><br><span class="line">        typename = typename,</span><br><span class="line">        field_names = <span class="built_in">tuple</span>(field_names),</span><br><span class="line">        num_fields = <span class="built_in">len</span>(field_names),</span><br><span class="line">        arg_list = <span class="built_in">repr</span>(<span class="built_in">tuple</span>(field_names)).replace(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;&quot;</span>)[<span class="number">1</span>:-<span class="number">1</span>],</span><br><span class="line">        repr_fmt = <span class="string">&#x27;, &#x27;</span>.join(_repr_template.<span class="built_in">format</span>(name=name)</span><br><span class="line">                             <span class="keyword">for</span> name <span class="keyword">in</span> field_names),</span><br><span class="line">        field_defs = <span class="string">&#x27;\n&#x27;</span>.join(_field_template.<span class="built_in">format</span>(index=index, name=name)</span><br><span class="line">                               <span class="keyword">for</span> index, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(field_names))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> verbose:</span><br><span class="line">        <span class="built_in">print</span> class_definition</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Execute the template string in a temporary namespace and support</span></span><br><span class="line">    <span class="comment"># tracing utilities by setting a value for frame.f_globals[&#x27;__name__&#x27;]</span></span><br><span class="line">    namespace = <span class="built_in">dict</span>(_itemgetter=_itemgetter, __name__=<span class="string">&#x27;namedtuple_%s&#x27;</span> % typename,</span><br><span class="line">                     OrderedDict=OrderedDict, _<span class="built_in">property</span>=<span class="built_in">property</span>, _<span class="built_in">tuple</span>=<span class="built_in">tuple</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">exec</span> class_definition <span class="keyword">in</span> namespace</span><br><span class="line">    <span class="keyword">except</span> SyntaxError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> SyntaxError(e.message + <span class="string">&#x27;:\n&#x27;</span> + class_definition)</span><br><span class="line">    result = namespace[typename]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># For pickling to work, the __module__ variable needs to be set to the frame</span></span><br><span class="line">    <span class="comment"># where the named tuple is created.  Bypass this step in environments where</span></span><br><span class="line">    <span class="comment"># sys._getframe is not defined (Jython for example) or sys._getframe is not</span></span><br><span class="line">    <span class="comment"># defined for arguments greater than 0 (IronPython).</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result.__module__ = _sys._getframe(<span class="number">1</span>).f_globals.get(<span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__main__&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> (AttributeError, ValueError):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这，这，这，这特么什么玩意儿啊！没事,我们慢慢来看。<br>首先，下面这一部分代码，将会校验我们传入的数据是否符合要求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(field_names, basestring):</span><br><span class="line">    field_names = field_names.replace(<span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>).split()</span><br><span class="line">field_names = <span class="built_in">map</span>(<span class="built_in">str</span>, field_names)</span><br><span class="line">typename = <span class="built_in">str</span>(typename)</span><br><span class="line"><span class="keyword">if</span> rename:</span><br><span class="line">    seen = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> index, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(field_names):</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> <span class="built_in">all</span>(c.isalnum() <span class="keyword">or</span> c==<span class="string">&#x27;_&#x27;</span> <span class="keyword">for</span> c <span class="keyword">in</span> name)</span><br><span class="line">            <span class="keyword">or</span> _iskeyword(name)</span><br><span class="line">            <span class="keyword">or</span> <span class="keyword">not</span> name</span><br><span class="line">            <span class="keyword">or</span> name[<span class="number">0</span>].isdigit()</span><br><span class="line">            <span class="keyword">or</span> name.startswith(<span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">            <span class="keyword">or</span> name <span class="keyword">in</span> seen):</span><br><span class="line">            field_names[index] = <span class="string">&#x27;_%d&#x27;</span> % index</span><br><span class="line">        seen.add(name)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> [typename] + field_names:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(name) != <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Type names and field names must be strings&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>(c.isalnum() <span class="keyword">or</span> c==<span class="string">&#x27;_&#x27;</span> <span class="keyword">for</span> c <span class="keyword">in</span> name):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Type names and field names can only contain &#x27;</span></span><br><span class="line">                         <span class="string">&#x27;alphanumeric characters and underscores: %r&#x27;</span> % name)</span><br><span class="line">    <span class="keyword">if</span> _iskeyword(name):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Type names and field names cannot be a &#x27;</span></span><br><span class="line">                         <span class="string">&#x27;keyword: %r&#x27;</span> % name)</span><br><span class="line">    <span class="keyword">if</span> name[<span class="number">0</span>].isdigit():</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Type names and field names cannot start with &#x27;</span></span><br><span class="line">                         <span class="string">&#x27;a number: %r&#x27;</span> % name)</span><br><span class="line">seen = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> field_names:</span><br><span class="line">    <span class="keyword">if</span> name.startswith(<span class="string">&#x27;_&#x27;</span>) <span class="keyword">and</span> <span class="keyword">not</span> rename:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Field names cannot start with an underscore: &#x27;</span></span><br><span class="line">                         <span class="string">&#x27;%r&#x27;</span> % name)</span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> seen:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Encountered duplicate field name: %r&#x27;</span> % name)</span><br><span class="line">    seen.add(name)</span><br></pre></td></tr></table></figure><p>接着，便是我们 <code>namedtuple</code> 的核心代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class_definition = _class_template.<span class="built_in">format</span>(</span><br><span class="line">    typename = typename,</span><br><span class="line">    field_names = <span class="built_in">tuple</span>(field_names),</span><br><span class="line">    num_fields = <span class="built_in">len</span>(field_names),</span><br><span class="line">    arg_list = <span class="built_in">repr</span>(<span class="built_in">tuple</span>(field_names)).replace(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;&quot;</span>)[<span class="number">1</span>:-<span class="number">1</span>],</span><br><span class="line">    repr_fmt = <span class="string">&#x27;, &#x27;</span>.join(_repr_template.<span class="built_in">format</span>(name=name)</span><br><span class="line">                         <span class="keyword">for</span> name <span class="keyword">in</span> field_names),</span><br><span class="line">    field_defs = <span class="string">&#x27;\n&#x27;</span>.join(_field_template.<span class="built_in">format</span>(index=index, name=name)</span><br><span class="line">                           <span class="keyword">for</span> index, name <span class="keyword">in</span> <span class="built_in">enumerate</span>(field_names))</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> verbose:</span><br><span class="line">    <span class="built_in">print</span> class_definition</span><br><span class="line"></span><br><span class="line"><span class="comment"># Execute the template string in a temporary namespace and support</span></span><br><span class="line"><span class="comment"># tracing utilities by setting a value for frame.f_globals[&#x27;__name__&#x27;]</span></span><br><span class="line">namespace = <span class="built_in">dict</span>(_itemgetter=_itemgetter, __name__=<span class="string">&#x27;namedtuple_%s&#x27;</span> % typename,</span><br><span class="line">                 OrderedDict=OrderedDict, _<span class="built_in">property</span>=<span class="built_in">property</span>, _<span class="built_in">tuple</span>=<span class="built_in">tuple</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">exec</span> class_definition <span class="keyword">in</span> namespace</span><br><span class="line"><span class="keyword">except</span> SyntaxError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">raise</span> SyntaxError(e.message + <span class="string">&#x27;:\n&#x27;</span> + class_definition)</span><br><span class="line">result = namespace[typename]</span><br></pre></td></tr></table></figure><p>你是不是想说，what the fuck！我知道，<code>class_definition</code> 、 <code>_repr_template</code> 和 <code>_field_template</code> 是前面所定义的字符串模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">_class_template = <span class="string">&#x27;&#x27;&#x27;\</span></span><br><span class="line"><span class="string">class &#123;typename&#125;(tuple):</span></span><br><span class="line"><span class="string">    &#x27;&#123;typename&#125;(&#123;arg_list&#125;)&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    __slots__ = ()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    _fields = &#123;field_names!r&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __new__(_cls, &#123;arg_list&#125;):</span></span><br><span class="line"><span class="string">        &#x27;Create new instance of &#123;typename&#125;(&#123;arg_list&#125;)&#x27;</span></span><br><span class="line"><span class="string">        return _tuple.__new__(_cls, (&#123;arg_list&#125;))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @classmethod</span></span><br><span class="line"><span class="string">    def _make(cls, iterable, new=tuple.__new__, len=len):</span></span><br><span class="line"><span class="string">        &#x27;Make a new &#123;typename&#125; object from a sequence or iterable&#x27;</span></span><br><span class="line"><span class="string">        result = new(cls, iterable)</span></span><br><span class="line"><span class="string">        if len(result) != &#123;num_fields:d&#125;:</span></span><br><span class="line"><span class="string">            raise TypeError(&#x27;Expected &#123;num_fields:d&#125; arguments, got %d&#x27; % len(result))</span></span><br><span class="line"><span class="string">        return result</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __repr__(self):</span></span><br><span class="line"><span class="string">        &#x27;Return a nicely formatted representation string&#x27;</span></span><br><span class="line"><span class="string">        return &#x27;&#123;typename&#125;(&#123;repr_fmt&#125;)&#x27; % self</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def _asdict(self):</span></span><br><span class="line"><span class="string">        &#x27;Return a new OrderedDict which maps field names to their values&#x27;</span></span><br><span class="line"><span class="string">        return OrderedDict(zip(self._fields, self))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def _replace(_self, **kwds):</span></span><br><span class="line"><span class="string">        &#x27;Return a new &#123;typename&#125; object replacing specified fields with new values&#x27;</span></span><br><span class="line"><span class="string">        result = _self._make(map(kwds.pop, &#123;field_names!r&#125;, _self))</span></span><br><span class="line"><span class="string">        if kwds:</span></span><br><span class="line"><span class="string">            raise ValueError(&#x27;Got unexpected field names: %r&#x27; % kwds.keys())</span></span><br><span class="line"><span class="string">        return result</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __getnewargs__(self):</span></span><br><span class="line"><span class="string">        &#x27;Return self as a plain tuple.  Used by copy and pickle.&#x27;</span></span><br><span class="line"><span class="string">        return tuple(self)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    __dict__ = _property(_asdict)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __getstate__(self):</span></span><br><span class="line"><span class="string">        &#x27;Exclude the OrderedDict from pickling&#x27;</span></span><br><span class="line"><span class="string">        pass</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;field_defs&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">_repr_template = <span class="string">&#x27;&#123;name&#125;=%r&#x27;</span></span><br><span class="line"></span><br><span class="line">_field_template = <span class="string">&#x27;&#x27;&#x27;\</span></span><br><span class="line"><span class="string">    &#123;name&#125; = _property(_itemgetter(&#123;index:d&#125;), doc=&#x27;Alias for field number &#123;index:d&#125;&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>但是其余的是什么鬼啊！别急，字符串模板我们先放在一边，我们先来看看后面的一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">namespace = <span class="built_in">dict</span>(_itemgetter=_itemgetter, __name__=<span class="string">&#x27;namedtuple_%s&#x27;</span> % typename,</span><br><span class="line">                     OrderedDict=OrderedDict, _<span class="built_in">property</span>=<span class="built_in">property</span>, _<span class="built_in">tuple</span>=<span class="built_in">tuple</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">exec</span> class_definition <span class="keyword">in</span> namespace</span><br><span class="line"><span class="keyword">except</span> SyntaxError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">raise</span> SyntaxError(e.message + <span class="string">&#x27;:\n&#x27;</span> + class_definition)</span><br><span class="line">result = namespace[typename]</span><br></pre></td></tr></table></figure><p>在这段代码中，首先 <code>namespace</code> 变量是一个字典，里面设置了一些变量的存在，紧接就是 <code>exec class_definition in namespace</code> 。众所周知，Python 是一门动态语言，在 Python 中，解释器允许我们在运行时，生成一些包含了符合 Python 语法语句的字符串，并用 <code>exec</code> 将其作为 Python 代码进行执行。同时在我们生成一些语句字符串的时候，我们可能会使用一些自定义的变量，于是，我们需要提供一个 <code>dict</code> 供其进行变量的查找。知道前面这些知识点后，<code>exec class_definition in namespace</code> 的作用是不是就很清楚了捏。<br>好了，我们再回过头去看 <code>class_definition</code> 定义。不过我们直接看未格式化之前的模板未免的太过于枯燥和难懂了，我们干脆以前面举过的一个例子来看看格式化后的 <code>class_definition</code> 吧~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">fuck</span>(<span class="title class_ inherited__">tuple</span>):</span><br><span class="line">    <span class="string">&#x27;fuck(x, y)&#x27;</span></span><br><span class="line"></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line">    _fields = (<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">_cls, x, y</span>):</span><br><span class="line">        <span class="string">&#x27;Create new instance of fuck(x, y)&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> _<span class="built_in">tuple</span>.__new__(_cls, (x, y))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_make</span>(<span class="params">cls, iterable, new=<span class="built_in">tuple</span>.__new__, <span class="built_in">len</span>=<span class="built_in">len</span></span>):</span><br><span class="line">        <span class="string">&#x27;Make a new fuck object from a sequence or iterable&#x27;</span></span><br><span class="line">        result = new(cls, iterable)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(result) != <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;Expected 2 arguments, got %d&#x27;</span> % <span class="built_in">len</span>(result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;Return a nicely formatted representation string&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;fuck(x=%r, y=%r)&#x27;</span> % self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_asdict</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;Return a new OrderedDict which maps field names to their values&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> OrderedDict(<span class="built_in">zip</span>(self._fields, self))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_replace</span>(<span class="params">_self, **kwds</span>):</span><br><span class="line">        <span class="string">&#x27;Return a new fuck object replacing specified fields with new values&#x27;</span></span><br><span class="line">        result = _self._make(<span class="built_in">map</span>(kwds.pop, (<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>), _self))</span><br><span class="line">        <span class="keyword">if</span> kwds:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;Got unexpected field names: %r&#x27;</span> % kwds.keys())</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getnewargs__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;Return self as a plain tuple.  Used by copy and pickle.&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">tuple</span>(self)</span><br><span class="line"></span><br><span class="line">    __dict__ = _<span class="built_in">property</span>(_asdict)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getstate__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;Exclude the OrderedDict from pickling&#x27;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    x = _<span class="built_in">property</span>(_itemgetter(<span class="number">0</span>), doc=<span class="string">&#x27;Alias for field number 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    y = _<span class="built_in">property</span>(_itemgetter(<span class="number">1</span>), doc=<span class="string">&#x27;Alias for field number 1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>好了，让我们一点点来分析，首先 <code>class fuck(tuple)</code> 指明我们创建的 <code>fuck</code> 类是继承自 <code>tuple</code> 。紧接着 <code>__new__</code> 是 Python 对象系统中的一个特殊方法，用于我们的实例化的操作，其在 <code>__init__</code> 之前便被触发，其是一个特殊的静态方法，我们可以将其用于实例缓存等特殊的功能。在这里，<code>__new__</code> 将会返回一个 <code>tuple</code> 的实例。<br>接下来的是是一些特殊的私有方法，代码很好懂，我们就不细讲了，接着我们来看看这样一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = _<span class="built_in">property</span>(_itemgetter(<span class="number">0</span>), doc=<span class="string">&#x27;Alias for field number 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">y = _<span class="built_in">property</span>(_itemgetter(<span class="number">1</span>), doc=<span class="string">&#x27;Alias for field number 1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>你可能还不知道这两段代码用来是干什么的233，没事儿，我们慢慢来。<br>还记得前面我们举过的一个例子么</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fuck=namedtuple(<span class="string">&quot;fuck&quot;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">    a=fuck(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(a.x)</span><br><span class="line">    <span class="built_in">print</span>(a.y)</span><br></pre></td></tr></table></figure><p>你可能会突发奇想，要是我们执行 <code>a.x=1</code> 这样的操作会怎样呢？OK，你会发现，Python 会抛出一个异常叫做 <code>AttributeError: can&#39;t set attribute</code> ，嗯哼，讲到这里，你可能就知道前面提到的包含 <code>property</code> 的两行代码作用就是保证 <code>namedtuple</code> 的 <strong>immutable</strong> 的特性。那么你可能还是不知道这是为什么。这和 Python 增加的描述符机制有关</p><h3 id="扩展（1）：Python-中的描述符"><a href="#扩展（1）：Python-中的描述符" class="headerlink" title="扩展（1）：Python 中的描述符"></a>扩展（1）：Python 中的描述符</h3><p>首先我们要明确一点，描述符指的是实现了描述符协议的特殊的类，三个描述符协议指的是 <code>__get__</code> , ‘<strong>set</strong>‘ , <code>__delete__</code>  以及 Python 3.6 中新增的 <code>__set_name__</code> 方法，其中实现了 <code>__get__</code> 以及 <code>__set__</code> / <code>__delete__</code> / <code>__set_name__</code> 的是 <strong>Data descriptors</strong> ，而只实现了 <code>__get__</code> 的是 <code>Non-Data descriptor</code> 。那么有什么区别呢，前面说了， <strong>我们如果调用一个属性，那么其顺序是优先从实例的 <code>__dict__</code> 里查找，然后如果没有查找到的话，那么一次查询类字典，父类字典，直到彻底查不到为止。</strong> 但是，这里没有考虑描述符的因素进去，如果将描述符因素考虑进去，那么正确的表述应该是<strong>我们如果调用一个属性，那么其顺序是优先从实例的 <code>__dict__</code> 里查找，然后如果没有查找到的话，那么一次查询类字典，父类字典，直到彻底查不到为止。其中如果在类实例字典中的该属性是一个 <code>Data descriptors</code> ，那么无论实例字典中存在该属性与否，无条件走描述符协议进行调用，在类实例字典中的该属性是一个 <code>Non-Data descriptors</code> ，那么优先调用实例字典中的属性值而不触发描述符协议，如果实例字典中不存在该属性值，那么触发 <code>Non-Data descriptor</code> 的描述符协议</strong>。</p><p>可能这讲完了，你还是不清楚和前面问题有什么关联，没事儿，我们接下来会讲讲 <code>property</code> 的实现</p><h3 id="扩展（2）：Property-详解"><a href="#扩展（2）：Property-详解" class="headerlink" title="扩展（2）：Property 详解"></a>扩展（2）：Property 详解</h3><p>首先我们来看看关于 Property 的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Property</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;Emulate PyProperty_Type() in Objects/descrobject.c&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, fget=<span class="literal">None</span>, fset=<span class="literal">None</span>, fdel=<span class="literal">None</span>, doc=<span class="literal">None</span></span>):</span><br><span class="line">        self.fget = fget</span><br><span class="line">        self.fset = fset</span><br><span class="line">        self.fdel = fdel</span><br><span class="line">        <span class="keyword">if</span> doc <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> fget <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            doc = fget.__doc__</span><br><span class="line">        self.__doc__ = doc</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, obj, objtype=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&quot;unreadable attribute&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.fget(obj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, obj, value</span>):</span><br><span class="line">        <span class="keyword">if</span> self.fset <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&quot;can&#x27;t set attribute&quot;</span>)</span><br><span class="line">        self.fset(obj, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete__</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">if</span> self.fdel <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&quot;can&#x27;t delete attribute&quot;</span>)</span><br><span class="line">        self.fdel(obj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getter</span>(<span class="params">self, fget</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(self)(fget, self.fset, self.fdel, self.__doc__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setter</span>(<span class="params">self, fset</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(self)(self.fget, fset, self.fdel, self.__doc__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleter</span>(<span class="params">self, fdel</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(self)(self.fget, self.fset, fdel, self.__doc__)</span><br></pre></td></tr></table></figure><p>当我们执行完这两句语句时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = _<span class="built_in">property</span>(_itemgetter(<span class="number">0</span>), doc=<span class="string">&#x27;Alias for field number 0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">y = _<span class="built_in">property</span>(_itemgetter(<span class="number">1</span>), doc=<span class="string">&#x27;Alias for field number 1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们的 <code>x</code> 和 <code>y</code> 就变成了一个 <code>property</code> 对象的实例，它们也是一个描述符，还记得我们前面讲的么，当一个变量/成员成为一个描述符后，它将改变正常的调用逻辑，现在当我们 <code>a.x=1</code> 的时候，因为我们的x是一个 <strong>Data descriptors</strong> ，那么不管我们的实例字典中是否有 <code>x</code> 的存在，我们都会触发其 <code>__set__</code> 方法，由于在我们初始化 <code>x</code> 和 <code>y</code> 两个变量时，没有给予其传入 <code>fset</code> 的方法，因此，我们 <code>__set__</code> 方法在运行过程中将会抛出 <code>AttributeError(&quot;can&#39;t set attribute&quot;)</code> 的异常，这也保证了 <code>namedtuple</code> 遵循了 <code>tuple</code> 的 <strong>immutable</strong> 的特性！是不是很优美！Amazing！</p><h1 id="吐槽向"><a href="#吐槽向" class="headerlink" title="吐槽向"></a>吐槽向</h1><p>其实很多人不知道我为什么选择 <code>namedtuple</code> 来作为本期的主题，其实很简单呀，<code>namedtuple</code> 中预定义模板，格式化，然后用 <code>exec</code> 函数进行执行这一套方法，是目前 Python 中主流模板引擎的核心原理。某种意义上讲，你在吃透这一点后，你也掌握了怎样去实现一个简易模板引擎的方法，如果大家有兴趣，我们可以下次一起来写一个简单的模板引擎。还有就是在 <code>namedtuple</code> 对于 Python 中的一些高阶特性使用的简直优美无比，这也是我们学习的好例子。</p><p>最后的最后，作为另一个写的非常优美的例子，我将 <code>orderdict</code> 的代码贴出来，大家可以下来看看，然后评论区我们讨论一个！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrderedDict</span>(<span class="title class_ inherited__">dict</span>):</span><br><span class="line">    <span class="string">&#x27;Dictionary that remembers insertion order&#x27;</span></span><br><span class="line">    <span class="comment"># An inherited dict maps keys to values.</span></span><br><span class="line">    <span class="comment"># The inherited dict provides __getitem__, __len__, __contains__, and get.</span></span><br><span class="line">    <span class="comment"># The remaining methods are order-aware.</span></span><br><span class="line">    <span class="comment"># Big-O running times for all methods are the same as regular dictionaries.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># The internal self.__map dict maps keys to links in a doubly linked list.</span></span><br><span class="line">    <span class="comment"># The circular doubly linked list starts and ends with a sentinel element.</span></span><br><span class="line">    <span class="comment"># The sentinel element never gets deleted (this simplifies the algorithm).</span></span><br><span class="line">    <span class="comment"># Each link is stored as a list of length three:  [PREV, NEXT, KEY].</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">*args, **kwds</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;Initialize an ordered dictionary.  The signature is the same as</span></span><br><span class="line"><span class="string">        regular dictionaries, but keyword arguments are not recommended because</span></span><br><span class="line"><span class="string">        their insertion order is arbitrary.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> args:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;descriptor &#x27;__init__&#x27; of &#x27;OrderedDict&#x27; object &quot;</span></span><br><span class="line">                            <span class="string">&quot;needs an argument&quot;</span>)</span><br><span class="line">        self = args[<span class="number">0</span>]</span><br><span class="line">        args = args[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&#x27;expected at most 1 arguments, got %d&#x27;</span> % <span class="built_in">len</span>(args))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.__root</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            self.__root = root = []                     <span class="comment"># sentinel node</span></span><br><span class="line">            root[:] = [root, root, <span class="literal">None</span>]</span><br><span class="line">            self.__<span class="built_in">map</span> = &#123;&#125;</span><br><span class="line">        self.__update(*args, **kwds)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, value, dict_setitem=<span class="built_in">dict</span>.__setitem__</span>):</span><br><span class="line">        <span class="string">&#x27;od.__setitem__(i, y) &lt;==&gt; od[i]=y&#x27;</span></span><br><span class="line">        <span class="comment"># Setting a new item creates a new link at the end of the linked list,</span></span><br><span class="line">        <span class="comment"># and the inherited dictionary is updated with the new key/value pair.</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self:</span><br><span class="line">            root = self.__root</span><br><span class="line">            last = root[<span class="number">0</span>]</span><br><span class="line">            last[<span class="number">1</span>] = root[<span class="number">0</span>] = self.__<span class="built_in">map</span>[key] = [last, root, key]</span><br><span class="line">        <span class="keyword">return</span> dict_setitem(self, key, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, key, dict_delitem=<span class="built_in">dict</span>.__delitem__</span>):</span><br><span class="line">        <span class="string">&#x27;od.__delitem__(y) &lt;==&gt; del od[y]&#x27;</span></span><br><span class="line">        <span class="comment"># Deleting an existing item uses self.__map to find the link which gets</span></span><br><span class="line">        <span class="comment"># removed by updating the links in the predecessor and successor nodes.</span></span><br><span class="line">        dict_delitem(self, key)</span><br><span class="line">        link_prev, link_next, _ = self.__<span class="built_in">map</span>.pop(key)</span><br><span class="line">        link_prev[<span class="number">1</span>] = link_next                        <span class="comment"># update link_prev[NEXT]</span></span><br><span class="line">        link_next[<span class="number">0</span>] = link_prev                        <span class="comment"># update link_next[PREV]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;od.__iter__() &lt;==&gt; iter(od)&#x27;</span></span><br><span class="line">        <span class="comment"># Traverse the linked list in order.</span></span><br><span class="line">        root = self.__root</span><br><span class="line">        curr = root[<span class="number">1</span>]                                  <span class="comment"># start at the first node</span></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">is</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">yield</span> curr[<span class="number">2</span>]                               <span class="comment"># yield the curr[KEY]</span></span><br><span class="line">            curr = curr[<span class="number">1</span>]                              <span class="comment"># move to next node</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reversed__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;od.__reversed__() &lt;==&gt; reversed(od)&#x27;</span></span><br><span class="line">        <span class="comment"># Traverse the linked list in reverse order.</span></span><br><span class="line">        root = self.__root</span><br><span class="line">        curr = root[<span class="number">0</span>]                                  <span class="comment"># start at the last node</span></span><br><span class="line">        <span class="keyword">while</span> curr <span class="keyword">is</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">yield</span> curr[<span class="number">2</span>]                               <span class="comment"># yield the curr[KEY]</span></span><br><span class="line">            curr = curr[<span class="number">0</span>]                              <span class="comment"># move to previous node</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clear</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;od.clear() -&gt; None.  Remove all items from od.&#x27;</span></span><br><span class="line">        root = self.__root</span><br><span class="line">        root[:] = [root, root, <span class="literal">None</span>]</span><br><span class="line">        self.__<span class="built_in">map</span>.clear()</span><br><span class="line">        <span class="built_in">dict</span>.clear(self)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># -- the following methods do not depend on the internal structure --</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">keys</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;od.keys() -&gt; list of keys in od&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">values</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;od.values() -&gt; list of values in od&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> [self[key] <span class="keyword">for</span> key <span class="keyword">in</span> self]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">items</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;od.items() -&gt; list of (key, value) pairs in od&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> [(key, self[key]) <span class="keyword">for</span> key <span class="keyword">in</span> self]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iterkeys</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;od.iterkeys() -&gt; an iterator over the keys in od&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iter</span>(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">itervalues</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;od.itervalues -&gt; an iterator over the values in od&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">yield</span> self[k]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">iteritems</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;od.iteritems -&gt; an iterator over the (key, value) pairs in od&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">yield</span> (k, self[k])</span><br><span class="line"></span><br><span class="line">    update = MutableMapping.update</span><br><span class="line"></span><br><span class="line">    __update = update <span class="comment"># let subclasses override update without breaking __init__</span></span><br><span class="line"></span><br><span class="line">    __marker = <span class="built_in">object</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self, key, default=__marker</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;od.pop(k[,d]) -&gt; v, remove specified key and return the corresponding</span></span><br><span class="line"><span class="string">        value.  If key is not found, d is returned if given, otherwise KeyError</span></span><br><span class="line"><span class="string">        is raised.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            result = self[key]</span><br><span class="line">            <span class="keyword">del</span> self[key]</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">if</span> default <span class="keyword">is</span> self.__marker:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> default</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setdefault</span>(<span class="params">self, key, default=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&#x27;od.setdefault(k[,d]) -&gt; od.get(k,d), also set od[k]=d if k not in od&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        self[key] = default</span><br><span class="line">        <span class="keyword">return</span> default</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">popitem</span>(<span class="params">self, last=<span class="literal">True</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;od.popitem() -&gt; (k, v), return and remove a (key, value) pair.</span></span><br><span class="line"><span class="string">        Pairs are returned in LIFO order if last is true or FIFO order if false.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(<span class="string">&#x27;dictionary is empty&#x27;</span>)</span><br><span class="line">        key = <span class="built_in">next</span>(<span class="built_in">reversed</span>(self) <span class="keyword">if</span> last <span class="keyword">else</span> <span class="built_in">iter</span>(self))</span><br><span class="line">        value = self.pop(key)</span><br><span class="line">        <span class="keyword">return</span> key, value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self, _repr_running=&#123;&#125;</span>):</span><br><span class="line">        <span class="string">&#x27;od.__repr__() &lt;==&gt; repr(od)&#x27;</span></span><br><span class="line">        call_key = <span class="built_in">id</span>(self), _get_ident()</span><br><span class="line">        <span class="keyword">if</span> call_key <span class="keyword">in</span> _repr_running:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;...&#x27;</span></span><br><span class="line">        _repr_running[call_key] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;%s()&#x27;</span> % (self.__class__.__name__,)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;%s(%r)&#x27;</span> % (self.__class__.__name__, self.items())</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">del</span> _repr_running[call_key]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;Return state information for pickling&#x27;</span></span><br><span class="line">        items = [[k, self[k]] <span class="keyword">for</span> k <span class="keyword">in</span> self]</span><br><span class="line">        inst_dict = <span class="built_in">vars</span>(self).copy()</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">vars</span>(OrderedDict()):</span><br><span class="line">            inst_dict.pop(k, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> inst_dict:</span><br><span class="line">            <span class="keyword">return</span> (self.__class__, (items,), inst_dict)</span><br><span class="line">        <span class="keyword">return</span> self.__class__, (items,)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">copy</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;od.copy() -&gt; a shallow copy of od&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> self.__class__(self)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fromkeys</span>(<span class="params">cls, iterable, value=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;OD.fromkeys(S[, v]) -&gt; New ordered dictionary with keys from S.</span></span><br><span class="line"><span class="string">        If not specified, the value defaults to None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        self = cls()</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> iterable:</span><br><span class="line">            self[key] = value</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;od.__eq__(y) &lt;==&gt; od==y.  Comparison to another OD is order-sensitive</span></span><br><span class="line"><span class="string">        while comparison to a regular mapping is order-insensitive.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, OrderedDict):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">dict</span>.__eq__(self, other) <span class="keyword">and</span> <span class="built_in">all</span>(_imap(_eq, self, other))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dict</span>.__eq__(self, other)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ne__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="string">&#x27;od.__ne__(y) &lt;==&gt; od!=y&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self == other</span><br><span class="line"></span><br><span class="line">    <span class="comment"># -- the following methods support python 3.x style dictionary views --</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">viewkeys</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;od.viewkeys() -&gt; a set-like object providing a view on od&#x27;s keys&quot;</span></span><br><span class="line">        <span class="keyword">return</span> KeysView(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">viewvalues</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;od.viewvalues() -&gt; an object providing a view on od&#x27;s values&quot;</span></span><br><span class="line">        <span class="keyword">return</span> ValuesView(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">viewitems</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;od.viewitems() -&gt; a set-like object providing a view on od&#x27;s items&quot;</span></span><br><span class="line">        <span class="keyword">return</span> ItemsView(self)</span><br></pre></td></tr></table></figure><h1 id="参考目录"><a href="#参考目录" class="headerlink" title="参考目录"></a>参考目录</h1><ul><li><a href="https://docs.python.org/3/howto/descriptor.html">Descriptor HowTo Guide</a></li><li><a href="http://manjusaka.itscoder.com/2016/10/12/Something-about-Descriptor/">Python 描述符入门指北</a></li><li><a href="https://docs.python.org/3/library/collections.html?highlight=namedtuple">collections</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 黑魔法 </tag>
            
            <tag> 编程技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Python 实现一个最简单的对象模型</title>
      <link href="//posts/2016/12/15/A-Simple-Object-Model/"/>
      <url>//posts/2016/12/15/A-Simple-Object-Model/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="http://aosabook.org/en/500L/a-simple-object-model.html">A Simple Object Model</a></li><li>原文作者：<a href="https://twitter.com/cfbolz">Carl Friedrich Bolz</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>译者：<a href="https://github.com/Zheaoli">Zheaoli</a></li><li>校对者：<a href="https://github.com/bobmayuze">Yuze Ma</a>, <a href="https://github.com/Graning">Gran</a></li></ul></blockquote><h1 id="一个简单的对象模型"><a href="#一个简单的对象模型" class="headerlink" title="一个简单的对象模型"></a>一个简单的对象模型</h1><p>Carl Friedrich Bolz 是一位在伦敦国王大学任职的研究员，他沉迷于动态语言的实现及优化等领域而不可自拔。他是 PyPy/RPython 的核心开发者之一，于此同时，他也在为 Prolog, Racket, Smalltalk, PHP 和 Ruby 等语言贡献代码。这是他的 Twitter <a href="https://twitter.com/cfbolz">@cfbolz</a> 。<br><span id="more"></span></p><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>面向对象编程是目前被广泛使用的一种编程范式，这种编程范式也被大量现代编程语言所支持。虽然大部分语言给程序猿提供了相似的面向对象的机制，但是如果深究细节的话，还是能发现它们之间还是有很多不同的。大部分的语言的共同点在于都拥有对象处理和继承机制。而对于类来说的话，并不是每种语言都完美支持它。比如对于 Self 或者 JavaScript 这样的原型继承的语言来说，是没有类这个概念的，他们的继承行为都是在对象之间所产生的。</p><p>深入了解不同语言的对象模型是一件非常有意思的事儿。这样我们可以去欣赏不同的编程语言的相似性。不得不说，这样的经历可以在我们学习新的语言的时候，利用上我们已有的经验，以便于我们快速的掌握它。</p><p>这篇文章将会带领你实现一套简单的对象模型。首先我们将实现一个简单的类与其实例，并能够通过这个实例去访问一些方法。这是被诸如 Simula 67 、Smalltalk 等早期面向对象语言所采用的面向对象模型。然后我们会一步步的扩展这个模型，你可以看到接下来两步会为你展现不同语言的模型设计思路，然后最后一步是来优化我们的对象模型的性能。最终我们所得到的模型并不是哪一门真实存在的语言所采用的模型，不过，硬是要说的话，你可以把我们得到的最终模型视为一个低配版的 Python 对象模型。</p><p>这篇文章里所展现的对象模型都是基于 Python 实现的。代码在 Python 2.7 以及 Python 3.4 上都可以完美运行。为了让大家更好的了解模型里的设计哲学，本文也为我们所设计的对象模型准备了单元测试，这些测试代码可以利用 py.test 或者 nose 来运行。</p><p>讲真，用 Python 来作为对象模型的实现语言并不是一个好的选择。一般而言，语言的虚拟机都是基于 C/C++ 这样更为贴近底层的语言来实现的，同时在实现中需要非常注意很多的细节，以保证其执行效率。不过，Python 这样非常简单的语言能让我们将主要精力都放在不同的行为表现上，而不是纠结于实现细节不可自拔。</p><h2 id="基础方法模型"><a href="#基础方法模型" class="headerlink" title="基础方法模型"></a>基础方法模型</h2><p>我们将以 Smalltalk 中的实现的非常简单的对象模型来开始讲解我们的对象模型。Smalltalk 是一门由施乐帕克研究中心下属的 Alan Kay 所带领的小组在 70 年代所开发出的一门面向对象语言。它普及了面向对象编程，同时在今天的编程语言中依然能看到当时它所包含的很多特性。在 Smalltalk 核心设计原则之一便是：“万物皆对象”。Smalltalk 最广为人知的继承者是 Ruby，一门使用类似 C 语言语法的同时保留了 Smalltalk 对象模型的语言。</p><p>在这一部分中，我们所实现的对象模型将包含类，实例，属性的调用及修改，方法的调用，同时允许子类的存在。开始前，先声明一下，这里的类都是有他们自己的属性和方法的普通的类</p><p>友情提示：在这篇文章中，“实例”代表着“不是类的对象”的含义。</p><p>一个非常好的习惯就是优先编写测试代码，以此来约束具体实现的行为。本文所编写的测试代码由两个部分组成。第一部分由常规的 Python 代码组成，可能会使用到 Python 中的类及其余一些更高级的特性。第二部分将会用我们自己建立的对象模型来替代 Python 的类。</p><p>在编写测试代码时，我们需要手动维护常规的 Python 类和我们自建类之间的映射关系。比如，在我们自定类中将会使用 <code>obj.read_attr(&quot;attribute&quot;)</code> 来作为 Python 中的 <code>obj.attribute</code> 的替代品。在现实生活中，这样的映射关系将由语言的编译器/解释器来进行实现。</p><p>在本文中，我们还对模型进行了进一步简化，这样看起来我们实现对象模型的代码和和编写对象中方法的代码看起来没什么两样。在现实生活中，这同样是基本不可能的，一般而言，这两者都是由不同的语言实现的。</p><p>首先，让我们来编写一段用于测试读取求改对象字段的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_read_write_field</span>():</span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    obj = A()</span><br><span class="line">    obj.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> obj.a == <span class="number">1</span></span><br><span class="line">    obj.b = <span class="number">5</span></span><br><span class="line">    <span class="keyword">assert</span> obj.a == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> obj.b == <span class="number">5</span></span><br><span class="line">    obj.a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> obj.a == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> obj.b == <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class="line">    obj = Instance(A)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;a&quot;</span>) == <span class="number">1</span></span><br><span class="line">    obj.write_attr(<span class="string">&quot;b&quot;</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;a&quot;</span>) == <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;b&quot;</span>) == <span class="number">5</span></span><br><span class="line">    obj.write_attr(<span class="string">&quot;a&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;a&quot;</span>) == <span class="number">2</span></span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;b&quot;</span>) == <span class="number">5</span></span><br></pre></td></tr></table></figure><p>在上面这个测试代码中包含了我们必须实现的三个东西。<code>Class</code> 以及 <code>Instance</code> 类分别代表着我们对象中的类以及实例。同时这里有两个特殊的类的实例：<code>OBJECT</code> 和 <code>TYPE</code>。 <code>OBJECT</code> 对应的是作为 Python 继承系统起点的 <code>object</code> 类（译者注：在 Python 2.x 版本中，实际上是有两套类系统，一套被统称为 <strong>new style class</strong> , 一套被称为 <strong>old style class</strong> ，<code>object</code> 是 <strong>new style class</strong> 的基类）。<code>TYPE</code> 对应的是 Python 类型系统中的 <code>type</code> 。</p><p>为了给 <code>Class</code> 以及 <code>Instance</code> 类的实例提供通用操作支持，这两个类都会从 <code>Base</code> 类这样提供了一系列方法的基础类中进行继承并实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; The base class that all of the object model classes inherit from. &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cls, fields</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; Every object has a class. &quot;&quot;&quot;</span></span><br><span class="line">        self.cls = cls</span><br><span class="line">        self._fields = fields</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_attr</span>(<span class="params">self, fieldname</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; read field &#x27;fieldname&#x27; out of the object &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._read_dict(fieldname)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write_attr</span>(<span class="params">self, fieldname, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; write field &#x27;fieldname&#x27; into the object &quot;&quot;&quot;</span></span><br><span class="line">        self._write_dict(fieldname, value)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isinstance</span>(<span class="params">self, cls</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; return True if the object is an instance of class cls &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.cls.<span class="built_in">issubclass</span>(cls)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callmethod</span>(<span class="params">self, methname, *args</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; call method &#x27;methname&#x27; with arguments &#x27;args&#x27; on object &quot;&quot;&quot;</span></span><br><span class="line">        meth = self.cls._read_from_class(methname)</span><br><span class="line">        <span class="keyword">return</span> meth(self, *args)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_read_dict</span>(<span class="params">self, fieldname</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; read an field &#x27;fieldname&#x27; out of the object&#x27;s dict &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._fields.get(fieldname, MISSING)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_write_dict</span>(<span class="params">self, fieldname, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; write a field &#x27;fieldname&#x27; into the object&#x27;s dict &quot;&quot;&quot;</span></span><br><span class="line">        self._fields[fieldname] = value</span><br><span class="line"></span><br><span class="line">MISSING = <span class="built_in">object</span>()</span><br></pre></td></tr></table></figure><p><code>Base</code> 实现了对象类的储存，同时也使用了一个字典来保存对象字段的值。现在，我们需要去实现 <code>Class</code> 以及 <code>Instance</code> 类。在<code>Instance</code> 的构造器中将会完成类的实例化以及 <code>fields</code> 和 <code>dict</code> 初始化的操作。换句话说，<code>Instance</code> 只是 <code>Base</code> 的子类，同时并不会为其添加额外的方法。</p><p><code>Class</code> 的构造器将会接受类名、基础类、类字典、以及元类这样几个操作。对于类来讲，上面几个变量都会在类初始化的时候由用户传递给构造器。同时构造器也会从它的基类那里获取变量的默认值。不过这个点，我们将在下一章节进行讲述。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Instance</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Instance of a user-defined class. &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cls</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(cls, Class)</span><br><span class="line">        Base.__init__(self, cls, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; A User-defined class. &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, base_class, fields, metaclass</span>):</span><br><span class="line">        Base.__init__(self, metaclass, fields)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.base_class = base_class</span><br></pre></td></tr></table></figure><p>同时，你可能注意到这点，类依旧是一种特殊的对象，他们间接的从 <code>Base</code> 中继承。因此，类也是一个特殊类的特殊实例，这样的很特殊的类叫做：元类。</p><p>现在，我们可以顺利通过我们第一组测试。不过这里，我们还没有定义 <code>Type</code> 以及 <code>OBJECT</code> 这样两个 <code>Class</code> 的实例。对于这些东西，我们将不会按照 Smalltalk 的对象模型进行构建，因为 Smalltalk 的对象模型对于我们来说太过于复杂。作为替代品，我们将采用 ObjVlisp1 的类型系统，Python 的类型系统从这里吸收了不少东西。</p><p>在 ObjVlisp 的对象模型中，<code>OBJECT</code> 以及 <code>TYPE</code> 是交杂在一起的。<code>OBJECT</code> 是所有类的母类，意味着 <code>OBJECT</code> 没有母类。<code>TYPE</code> 是 <code>OBJECT</code> 的子类。一般而言，每一个类都是 <code>TYPE</code> 的实例。在特定情况下，<code>TYPE</code> 和 <code>OBJECT</code> 都是 <code>TYPE</code> 的实例。不过，程序猿可以从 <code>TYPE</code> 派生出一个类去作为元类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set up the base hierarchy as in Python (the ObjVLisp model)</span></span><br><span class="line"><span class="comment"># the ultimate base class is OBJECT</span></span><br><span class="line">OBJECT = Class(name=<span class="string">&quot;object&quot;</span>, base_class=<span class="literal">None</span>, fields=&#123;&#125;, metaclass=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># TYPE is a subclass of OBJECT</span></span><br><span class="line">TYPE = Class(name=<span class="string">&quot;type&quot;</span>, base_class=OBJECT, fields=&#123;&#125;, metaclass=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># TYPE is an instance of itself</span></span><br><span class="line">TYPE.cls = TYPE</span><br><span class="line"><span class="comment"># OBJECT is an instance of TYPE</span></span><br><span class="line">OBJECT.cls = TYPE</span><br></pre></td></tr></table></figure><p>为了去编写一个新的元类，我们需要自行从 <code>TYPE</code> 进行派生。不过在本文中我们并不会这么做，我们将只会使用 <code>TYPE</code> 作为我们每个类的元类。</p><p><img src="http://ww1.sinaimg.cn/large/65e4f1e6jw1fa3ann7n8rj20ck08a74i.jpg" alt="Figure 14.1 - Inheritance"></p><p>好了，现在第一组测试已经完全通过了。现在让我们来看看第二组测试，我们将会在这组测试中测试对象属性读写是否正常。这段代码还是很好写的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_read_write_field_class</span>():</span><br><span class="line">    <span class="comment"># classes are objects too</span></span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    A.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> A.a == <span class="number">1</span></span><br><span class="line">    A.a = <span class="number">6</span></span><br><span class="line">    <span class="keyword">assert</span> A.a == <span class="number">6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;, metaclass=TYPE)</span><br><span class="line">    <span class="keyword">assert</span> A.read_attr(<span class="string">&quot;a&quot;</span>) == <span class="number">1</span></span><br><span class="line">    A.write_attr(<span class="string">&quot;a&quot;</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">assert</span> A.read_attr(<span class="string">&quot;a&quot;</span>) == <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="isinstance-检查"><a href="#isinstance-检查" class="headerlink" title="isinstance 检查"></a><code>isinstance</code> 检查</h3><p>到目前为止，我们还没有将对象有类这点特性利用起来。接下来的测试代码将会自动的实现 <code>isinstance</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_isinstance</span>():</span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    b = B()</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(b, B)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(b, A)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(b, <span class="built_in">object</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(b, <span class="built_in">type</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class="line">    B = Class(name=<span class="string">&quot;B&quot;</span>, base_class=A, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class="line">    b = Instance(B)</span><br><span class="line">    <span class="keyword">assert</span> b.<span class="built_in">isinstance</span>(B)</span><br><span class="line">    <span class="keyword">assert</span> b.<span class="built_in">isinstance</span>(A)</span><br><span class="line">    <span class="keyword">assert</span> b.<span class="built_in">isinstance</span>(OBJECT)</span><br><span class="line">    <span class="keyword">assert</span> <span class="keyword">not</span> b.<span class="built_in">isinstance</span>(TYPE)</span><br></pre></td></tr></table></figure><p>我们可以通过检查 <code>cls</code> 是不是 <code>obj</code> 类或者它自己的超类来判断 <code>obj</code> 对象是不是某些类 <code>cls</code> 的实例。通过检查一个类是否在一个超类链上工作，来判断一个类是不是另一个类的超类。如果还有其余类存在于这个超类链上，那么这些类也可以被称为是超类。这个包含了超类和类本身的链条，被称之为<strong>方法解析顺序</strong>（译者注：简称MRO）。它很容易以递归的方式进行计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method_resolution_order</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; compute the method resolution order of the class &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.base_class <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> [self]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [self] + self.base_class.method_resolution_order()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">issubclass</span>(<span class="params">self, cls</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; is self a subclass of cls? &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> cls <span class="keyword">in</span> self.method_resolution_order()</span><br></pre></td></tr></table></figure><p>好了，在修改代码后，测试就完全能通过了</p><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>前面所建立的对象模型中还缺少了方法调用这样的重要特性。在本章我们将会建立一个简单的继承模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_callmethod_simple</span>():</span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">            <span class="keyword">return</span> self.x + <span class="number">1</span></span><br><span class="line">    obj = A()</span><br><span class="line">    obj.x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> obj.f() == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    obj = B()</span><br><span class="line">    obj.x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> obj.f() == <span class="number">2</span> <span class="comment"># works on subclass too</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f_A</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.read_attr(<span class="string">&quot;x&quot;</span>) + <span class="number">1</span></span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;<span class="string">&quot;f&quot;</span>: f_A&#125;, metaclass=TYPE)</span><br><span class="line">    obj = Instance(A)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.callmethod(<span class="string">&quot;f&quot;</span>) == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    B = Class(name=<span class="string">&quot;B&quot;</span>, base_class=A, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class="line">    obj = Instance(B)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.callmethod(<span class="string">&quot;f&quot;</span>) == <span class="number">3</span></span><br></pre></td></tr></table></figure><p>为了找到调用对象方法的正确实现，我们现在开始讨论类对象的方法解析顺序。在 MRO 中我们所寻找到的类对象字典中第一个方法将会被调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_read_from_class</span>(<span class="params">self, methname</span>):</span><br><span class="line">        <span class="keyword">for</span> cls <span class="keyword">in</span> self.method_resolution_order():</span><br><span class="line">            <span class="keyword">if</span> methname <span class="keyword">in</span> cls._fields:</span><br><span class="line">                <span class="keyword">return</span> cls._fields[methname]</span><br><span class="line">        <span class="keyword">return</span> MISSING</span><br></pre></td></tr></table></figure><p>在完成 <code>Base</code> 类中 <code>callmethod</code> 实现后，可以通过上面的测试。</p><p>为了保证函数参数传递正确，同时也确保我们事先的代码能完成方法重载的功能，我们可以编写下面这段测试代码，当然结果是完美通过测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_callmethod_subclassing_and_arguments</span>():</span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self, arg</span>):</span><br><span class="line">            <span class="keyword">return</span> self.x + arg</span><br><span class="line">    obj = A()</span><br><span class="line">    obj.x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">assert</span> obj.g(<span class="number">4</span>) == <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">self, arg</span>):</span><br><span class="line">            <span class="keyword">return</span> self.x + arg * <span class="number">2</span></span><br><span class="line">    obj = B()</span><br><span class="line">    obj.x = <span class="number">4</span></span><br><span class="line">    <span class="keyword">assert</span> obj.g(<span class="number">4</span>) == <span class="number">12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g_A</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.read_attr(<span class="string">&quot;x&quot;</span>) + arg</span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;<span class="string">&quot;g&quot;</span>: g_A&#125;, metaclass=TYPE)</span><br><span class="line">    obj = Instance(A)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.callmethod(<span class="string">&quot;g&quot;</span>, <span class="number">4</span>) == <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g_B</span>(<span class="params">self, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> self.read_attr(<span class="string">&quot;x&quot;</span>) + arg * <span class="number">2</span></span><br><span class="line">    B = Class(name=<span class="string">&quot;B&quot;</span>, base_class=A, fields=&#123;<span class="string">&quot;g&quot;</span>: g_B&#125;, metaclass=TYPE)</span><br><span class="line">    obj = Instance(B)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.callmethod(<span class="string">&quot;g&quot;</span>, <span class="number">4</span>) == <span class="number">12</span></span><br></pre></td></tr></table></figure><h2 id="基础属性模型"><a href="#基础属性模型" class="headerlink" title="基础属性模型"></a>基础属性模型</h2><p>现在最简单版本的对象模型已经可以开始工作了，不过我们还需要去不断的改进。这一部分将会介绍基础方法模型和基础属性模型之间的差异。这也是 Smalltalk 、 Ruby 、 JavaScript 、 Python 和 Lua 之间的核心差异。</p><p>基础方法模型将会按照最原始的方式去调用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = obj.f(arg1, arg2)</span><br></pre></td></tr></table></figure><p>基础属性模型将会将调用过程分为两步：寻找属性，以及返回执行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">method = obj.f</span><br><span class="line">result = method(arg1, arg2)</span><br></pre></td></tr></table></figure><p>你可以在接下来的测试中体会到前文所述的差异：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_bound_method</span>():</span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self, a</span>):</span><br><span class="line">            <span class="keyword">return</span> self.x + a + <span class="number">1</span></span><br><span class="line">    obj = A()</span><br><span class="line">    obj.x = <span class="number">2</span></span><br><span class="line">    m = obj.f</span><br><span class="line">    <span class="keyword">assert</span> m(<span class="number">4</span>) == <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    obj = B()</span><br><span class="line">    obj.x = <span class="number">1</span></span><br><span class="line">    m = obj.f</span><br><span class="line">    <span class="keyword">assert</span> m(<span class="number">10</span>) == <span class="number">12</span> <span class="comment"># works on subclass too</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f_A</span>(<span class="params">self, a</span>):</span><br><span class="line">        <span class="keyword">return</span> self.read_attr(<span class="string">&quot;x&quot;</span>) + a + <span class="number">1</span></span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT, fields=&#123;<span class="string">&quot;f&quot;</span>: f_A&#125;, metaclass=TYPE)</span><br><span class="line">    obj = Instance(A)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    m = obj.read_attr(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> m(<span class="number">4</span>) == <span class="number">7</span></span><br><span class="line"></span><br><span class="line">    B = Class(name=<span class="string">&quot;B&quot;</span>, base_class=A, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class="line">    obj = Instance(B)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    m = obj.read_attr(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> m(<span class="number">10</span>) == <span class="number">12</span></span><br></pre></td></tr></table></figure><p>我们可以按照之前测试代码中对方法调用设置一样的步骤去设置属性调用，不过和方法调用相比，这里面发生了一些变化。首先，我们将会在对象中寻找与函数名对应的方法名。这样一个查找过程结果被称之为已绑定的方法，具体来说就是，这个结果一个绑定了方法与具体对象的特殊对象。然后这个绑定方法会在接下来的操作中被调用。</p><p>为了实现这样的操作，我们需要修改 <code>Base.read_attr</code> 的实现。如果在实例字典中没有找到对应的属性，那么我们需要去在类字典中查找。如果在类字典中查找到了这个属性，那么我们将会执行方法绑定的操作。我们可以使用一个闭包来很简单的模拟绑定方法。除了更改 <code>Base.read_attr</code> 实现以外，我们也可以修改 <code>Base.callmethod</code> 方法来确保我们代码能通过测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_attr</span>(<span class="params">self, fieldname</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; read field &#x27;fieldname&#x27; out of the object &quot;&quot;&quot;</span></span><br><span class="line">        result = self._read_dict(fieldname)</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> MISSING:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        result = self.cls._read_from_class(fieldname)</span><br><span class="line">        <span class="keyword">if</span> _is_bindable(result):</span><br><span class="line">            <span class="keyword">return</span> _make_boundmethod(result, self)</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> MISSING:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">raise</span> AttributeError(fieldname)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">callmethod</span>(<span class="params">self, methname, *args</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; call method &#x27;methname&#x27; with arguments &#x27;args&#x27; on object &quot;&quot;&quot;</span></span><br><span class="line">        meth = self.read_attr(methname)</span><br><span class="line">        <span class="keyword">return</span> meth(*args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_is_bindable</span>(<span class="params">meth</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">callable</span>(meth)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_make_boundmethod</span>(<span class="params">meth, self</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bound</span>(<span class="params">*args</span>):</span><br><span class="line">        <span class="keyword">return</span> meth(self, *args)</span><br><span class="line">    <span class="keyword">return</span> bound</span><br></pre></td></tr></table></figure><p>其余的代码并不需要修改。</p><h2 id="元对象协议"><a href="#元对象协议" class="headerlink" title="元对象协议"></a>元对象协议</h2><p>除了常规的类方法之外，很多动态语言还支持特殊方法。有这样一些方法在调用时是由对象系统调用而不是使用常规调用。在 Python 中你可以看到这些方法的方法名用两个下划线作为开头和结束的，比如 <code>__init__</code> 。特殊方法可以用于重载一些常规操作，同时可以提供一些自定义的功能。因此，它们的存在可以告诉对象模型如何自动的处理不同的事情。Python 中相关特殊方法的说明可以查看这篇<a href="https://docs.python.org/2/reference/datamodel.html#special-method-names">文档</a>。</p><p>元对象协议这一概念由 Smalltalk 引入，然后在诸如 CLOS 这样的通用 Lisp 的对象模型中也广泛的使用这个概念。这个概念包含特殊方法的集合（注：这里没有查到 coined3 的梗，请校者帮忙参考）。</p><p>在这一章中，我们将会为我们的对象模型添加三个元调用操作。它们将会用来对我们读取和修改对象的操作进行更为精细的控制。我们首先要添加的两个方法是 <code>__getattr__</code> 和 <code>__setattr__</code>， 这两个方法的命名看起来和我们 Python 中相同功能函数的方法名很相似。</p><h3 id="自定义属性读写操作"><a href="#自定义属性读写操作" class="headerlink" title="自定义属性读写操作"></a>自定义属性读写操作</h3><p><code>__getattr__</code> 方法将会在属性通过常规方法无法查找到的情况下被调用，换句话说，在实例字典、类字典、父类字典等等对象中都找不到对应的属性时，会触发该方法的调用。我们将传入一个被查找属性的名字作为这个方法的参数。在早期的 Smalltalk4 中这个方法被称为 <code>doesNotUnderstand:</code> 。</p><p>在 <code>__setattr__</code> 这里事情可能发生了点变化。首先我们需要明确一点的是，设置一个属性的时候通常意味着我们需要创建它，在这个时候，在设置属性的时候通常会触发 <code>__setattr__</code> 方法。为了确保 <code>__setattr__</code> 的存在，我们需要在 <code>OBJECT</code> 对象中实现 <code>__setattr__</code> 方法。这样最基础的实现完成了我们向相对应的字典里写入属性的操作。这可以使得用户可以将自己定义的  <code>__setattr__</code> 委托给 <code>OBJECT.__setattr__</code> 方法。</p><p>针对这两个特殊方法的测试用例如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_getattr</span>():</span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">            <span class="keyword">if</span> name == <span class="string">&quot;fahrenheit&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> self.celsius * <span class="number">9</span>\. / <span class="number">5</span>\. + <span class="number">32</span></span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">            <span class="keyword">if</span> name == <span class="string">&quot;fahrenheit&quot;</span>:</span><br><span class="line">                self.celsius = (value - <span class="number">32</span>) * <span class="number">5</span>\. / <span class="number">9.</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># call the base implementation</span></span><br><span class="line">                <span class="built_in">object</span>.__setattr__(self, name, value)</span><br><span class="line">    obj = A()</span><br><span class="line">    obj.celsius = <span class="number">30</span></span><br><span class="line">    <span class="keyword">assert</span> obj.fahrenheit == <span class="number">86</span> <span class="comment"># test __getattr__</span></span><br><span class="line">    obj.celsius = <span class="number">40</span></span><br><span class="line">    <span class="keyword">assert</span> obj.fahrenheit == <span class="number">104</span></span><br><span class="line"></span><br><span class="line">    obj.fahrenheit = <span class="number">86</span> <span class="comment"># test __setattr__</span></span><br><span class="line">    <span class="keyword">assert</span> obj.celsius == <span class="number">30</span></span><br><span class="line">    <span class="keyword">assert</span> obj.fahrenheit == <span class="number">86</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattr__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&quot;fahrenheit&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.read_attr(<span class="string">&quot;celsius&quot;</span>) * <span class="number">9</span>\. / <span class="number">5</span>\. + <span class="number">32</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, name, value</span>):</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&quot;fahrenheit&quot;</span>:</span><br><span class="line">            self.write_attr(<span class="string">&quot;celsius&quot;</span>, (value - <span class="number">32</span>) * <span class="number">5</span>\. / <span class="number">9.</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># call the base implementation</span></span><br><span class="line">            OBJECT.read_attr(<span class="string">&quot;__setattr__&quot;</span>)(self, name, value)</span><br><span class="line"></span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT,</span><br><span class="line">              fields=&#123;<span class="string">&quot;__getattr__&quot;</span>: __getattr__, <span class="string">&quot;__setattr__&quot;</span>: __setattr__&#125;,</span><br><span class="line">              metaclass=TYPE)</span><br><span class="line">    obj = Instance(A)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;celsius&quot;</span>, <span class="number">30</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;fahrenheit&quot;</span>) == <span class="number">86</span> <span class="comment"># test __getattr__</span></span><br><span class="line">    obj.write_attr(<span class="string">&quot;celsius&quot;</span>, <span class="number">40</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;fahrenheit&quot;</span>) == <span class="number">104</span></span><br><span class="line">    obj.write_attr(<span class="string">&quot;fahrenheit&quot;</span>, <span class="number">86</span>) <span class="comment"># test __setattr__</span></span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;celsius&quot;</span>) == <span class="number">30</span></span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;fahrenheit&quot;</span>) == <span class="number">86</span></span><br></pre></td></tr></table></figure><p>为了通过测试，我们需要修改下 <code>Base.read_attr</code> 以及 <code>Base.write_attr</code> 两个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_attr</span>(<span class="params">self, fieldname</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; read field &#x27;fieldname&#x27; out of the object &quot;&quot;&quot;</span></span><br><span class="line">        result = self._read_dict(fieldname)</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> MISSING:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        result = self.cls._read_from_class(fieldname)</span><br><span class="line">        <span class="keyword">if</span> _is_bindable(result):</span><br><span class="line">            <span class="keyword">return</span> _make_boundmethod(result, self)</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> MISSING:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        meth = self.cls._read_from_class(<span class="string">&quot;__getattr__&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> meth <span class="keyword">is</span> <span class="keyword">not</span> MISSING:</span><br><span class="line">            <span class="keyword">return</span> meth(self, fieldname)</span><br><span class="line">        <span class="keyword">raise</span> AttributeError(fieldname)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write_attr</span>(<span class="params">self, fieldname, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; write field &#x27;fieldname&#x27; into the object &quot;&quot;&quot;</span></span><br><span class="line">        meth = self.cls._read_from_class(<span class="string">&quot;__setattr__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> meth(self, fieldname, value)</span><br></pre></td></tr></table></figure><p>获取属性的过程变成调用 <code>__getattr__</code> 方法并传入字段名作为参数，如果字段不存在，将会抛出一个异常。请注意 <code>__getattr__</code> 只能在类中调用（Python 中的特殊方法也是这样），同时需要避免这样的 <code>self.read_attr(&quot;__getattr__&quot;)</code> 递归调用，因为如果 <code>__getattr__</code> 方法没有定义的话，上面的调用会造成无限递归。</p><p>对属性的修改操作也会像读取一样交给 <code>__setattr__</code> 方法执行。为了保证这个方法能够正常执行，<code>OBJECT</code> 需要实现 <code>__setattr__</code> 的默认行为，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">OBJECT__setattr__</span>(<span class="params">self, fieldname, value</span>):</span><br><span class="line">    self._write_dict(fieldname, value)</span><br><span class="line">OBJECT = Class(<span class="string">&quot;object&quot;</span>, <span class="literal">None</span>, &#123;<span class="string">&quot;__setattr__&quot;</span>: OBJECT__setattr__&#125;, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><code>OBJECT.__setattr__</code> 的具体实现和之前 <code>write_attr</code> 方法的实现有着相似之处。在完成这些修改后，我们可以顺利的通过我们的测试。</p><h3 id="描述符协议"><a href="#描述符协议" class="headerlink" title="描述符协议"></a>描述符协议</h3><p>在上面的测试中，我们频繁的在不同的温标之间切换，不得不说，在执行修改属性操作的时候这样真的很蛋疼，所以我们需要在 <code>__getattr__</code> 和 <code>__setattr__</code> 中检查所使用的的属性的名称为了解决这个问题，在 Python 中引入了<strong>描述符协议</strong>的概念。</p><p>我们将从 <code>__getattr__</code> 和 <code>__setattr__</code> 方法中获取具体的属性，而描述符协议则是在属性调用过程结束返回结果时触发一个特殊的方法。描述符协议可以视为一种可以绑定类与方法的特殊手段，我们可以使用描述符协议来完成将方法绑定到对象的具体操作。除了绑定方法，在 Python 中描述符最重要的几个使用场景之一就是 <code>staticmethod</code>、 <code>classmethod</code> 和 <code>property</code>。</p><p>在接下来一点文字中，我们将介绍怎么样来使用描述符进行对象绑定。我们可以通过使用 <code>__get__</code> 方法来达成这一目标，具体请看下面的测试代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_get</span>():</span><br><span class="line">    <span class="comment"># Python code</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FahrenheitGetter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, inst, cls</span>):</span><br><span class="line">            <span class="keyword">return</span> inst.celsius * <span class="number">9</span>\. / <span class="number">5</span>\. + <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        fahrenheit = FahrenheitGetter()</span><br><span class="line">    obj = A()</span><br><span class="line">    obj.celsius = <span class="number">30</span></span><br><span class="line">    <span class="keyword">assert</span> obj.fahrenheit == <span class="number">86</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Object model code</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FahrenheitGetter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, inst, cls</span>):</span><br><span class="line">            <span class="keyword">return</span> inst.read_attr(<span class="string">&quot;celsius&quot;</span>) * <span class="number">9</span>\. / <span class="number">5</span>\. + <span class="number">32</span></span><br><span class="line"></span><br><span class="line">    A = Class(name=<span class="string">&quot;A&quot;</span>, base_class=OBJECT,</span><br><span class="line">              fields=&#123;<span class="string">&quot;fahrenheit&quot;</span>: FahrenheitGetter()&#125;,</span><br><span class="line">              metaclass=TYPE)</span><br><span class="line">    obj = Instance(A)</span><br><span class="line">    obj.write_attr(<span class="string">&quot;celsius&quot;</span>, <span class="number">30</span>)</span><br><span class="line">    <span class="keyword">assert</span> obj.read_attr(<span class="string">&quot;fahrenheit&quot;</span>) == <span class="number">86</span></span><br></pre></td></tr></table></figure><p><code>__get__</code> 方法将会在属性查找完后被 <code>FahrenheitGetter</code> 实例所调用。传递给 <code>__get__</code> 的参数是查找过程结束时所处的那个实例。</p><p>实现这样的功能倒是很简单，我们可以很简单的修改 <code>_is_bindable</code> 和 <code>_make_boundmethod</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_is_bindable</span>(<span class="params">meth</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hasattr</span>(meth, <span class="string">&quot;__get__&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_make_boundmethod</span>(<span class="params">meth, self</span>):</span><br><span class="line">    <span class="keyword">return</span> meth.__get__(self, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>好了，这样简单的修改能保证我们通过测试了。之前关于方法绑定的测试也能通过了，在 Python 中 <code>__get__</code> 方法执行完了将会返回一个已绑定方法对象。</p><p>在实践中，描述符协议的确看起来比较复杂。它同时还包含用于设置属性的 <code>__set__</code> 方法。此外，你现在所看到我们实现的版本是经过一些简化的。请注意，前面 <code>_make_boundmethod</code> 方法调用 <code>__get__</code> 是实现级的操作，而不是使用 <code>meth.read_attr(&#39;__get__&#39;)</code> 。这是很有必要的，因为我们的对象模型只是从 Python 中借用函数和方法，而不是展示 Python 的对象模型。进一步完善模型的话可以有效解决这个问题。</p><h2 id="实例优化"><a href="#实例优化" class="headerlink" title="实例优化"></a>实例优化</h2><p>这个对象模型前面三个部分的建立过程中伴随着很多的行为变化，而最后一部分的优化工作并不会伴随着行为变化。这种优化方式被称为 <strong>map</strong> ,广泛存在在可以自举的语言虚拟机中。这是一种最为重要对象模型优化手段：在 PyPy ，诸如 V8 现代 JavaScript 虚拟机中得到应用（在 V8 中这种方法被称为 <strong><em>hidden classes</em></strong>）。</p><p>这种优化手段基于如下的观察：到目前所实现的对象模型中，所有实例都使用一个完整的字典来储存他们的属性。字典是基于哈希表进行实现的，这将会耗费大量的内存。在很多时候，同一个类的实例将会拥有同样的属性，比如，有一个类 <code>Point</code> ，它所有的实例都包含同样的属性 <code>x</code> <code>y</code>。</p><p><code>Map</code> 优化利用了这样一个事实。它将会将每个实例的字典分割为两个部分。一部分存放可以在所有实例中共享的属性名。然后另一部分只存放对第一部分产生的 <code>Map</code> 的引用和存放具体的值。存放属性名的 <strong>map</strong> 将会作为值的索引。</p><p>我们将为上面所述的需求编写一些测试用例，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_maps</span>():</span><br><span class="line">    <span class="comment"># white box test inspecting the implementation</span></span><br><span class="line">    Point = Class(name=<span class="string">&quot;Point&quot;</span>, base_class=OBJECT, fields=&#123;&#125;, metaclass=TYPE)</span><br><span class="line">    p1 = Instance(Point)</span><br><span class="line">    p1.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    p1.write_attr(<span class="string">&quot;y&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">assert</span> p1.storage == [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">assert</span> p1.<span class="built_in">map</span>.attrs == &#123;<span class="string">&quot;x&quot;</span>: <span class="number">0</span>, <span class="string">&quot;y&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">    p2 = Instance(Point)</span><br><span class="line">    p2.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">5</span>)</span><br><span class="line">    p2.write_attr(<span class="string">&quot;y&quot;</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">assert</span> p1.<span class="built_in">map</span> <span class="keyword">is</span> p2.<span class="built_in">map</span></span><br><span class="line">    <span class="keyword">assert</span> p2.storage == [<span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    p1.write_attr(<span class="string">&quot;x&quot;</span>, -<span class="number">1</span>)</span><br><span class="line">    p1.write_attr(<span class="string">&quot;y&quot;</span>, -<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">assert</span> p1.<span class="built_in">map</span> <span class="keyword">is</span> p2.<span class="built_in">map</span></span><br><span class="line">    <span class="keyword">assert</span> p1.storage == [-<span class="number">1</span>, -<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    p3 = Instance(Point)</span><br><span class="line">    p3.write_attr(<span class="string">&quot;x&quot;</span>, <span class="number">100</span>)</span><br><span class="line">    p3.write_attr(<span class="string">&quot;z&quot;</span>, -<span class="number">343</span>)</span><br><span class="line">    <span class="keyword">assert</span> p3.<span class="built_in">map</span> <span class="keyword">is</span> <span class="keyword">not</span> p1.<span class="built_in">map</span></span><br><span class="line">    <span class="keyword">assert</span> p3.<span class="built_in">map</span>.attrs == &#123;<span class="string">&quot;x&quot;</span>: <span class="number">0</span>, <span class="string">&quot;z&quot;</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>注意，这里测试代码的风格和我们之前的才是代码看起不太一样。之前所有的测试只是通过已实现的接口来测试类的功能。这里的测试通过读取类的内部属性来获取实现的详细信息，并将其与预设的值进行比较。这种测试方法又被称之为白盒测试。</p><p><code>p1</code> 的包含 <code>attrs</code> 的 <code>map</code> 存放了 <code>x</code> 和 <code>y</code> 两个属性，其在 <code>p1</code> 中存放的值分别为 0 和 1。然后创建第二个实例 <code>p2</code> ，并通过同样的方法网同样的 <code>map</code> 中添加同样的属性。 换句话说，如果不同的属性被添加了，那么其中的 <code>map</code> 是不通用的。</p><p><code>Map</code> 类长下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Map</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, attrs</span>):</span><br><span class="line">        self.attrs = attrs</span><br><span class="line">        self.next_maps = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_index</span>(<span class="params">self, fieldname</span>):</span><br><span class="line">        <span class="keyword">return</span> self.attrs.get(fieldname, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_map</span>(<span class="params">self, fieldname</span>):</span><br><span class="line">        <span class="keyword">assert</span> fieldname <span class="keyword">not</span> <span class="keyword">in</span> self.attrs</span><br><span class="line">        <span class="keyword">if</span> fieldname <span class="keyword">in</span> self.next_maps:</span><br><span class="line">            <span class="keyword">return</span> self.next_maps[fieldname]</span><br><span class="line">        attrs = self.attrs.copy()</span><br><span class="line">        attrs[fieldname] = <span class="built_in">len</span>(attrs)</span><br><span class="line">        result = self.next_maps[fieldname] = Map(attrs)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">EMPTY_MAP = Map(&#123;&#125;)</span><br></pre></td></tr></table></figure><p>Map 类拥有两个方法，分别是 <code>get_index</code> 和 <code>next_map</code> 。前者用于查找对象储存空间中的索引中查找对应的属性名称。而在新的属性添加到对象中时应该使用后者。在这种情况下，不同的实例需要用 <code>next_map</code> 计算不同的映射关系。这个方法将会使用 <code>next_maps</code> 来查找已经存在的映射。这样，相似的实例将会使用相似的 <code>Map</code> 对象。</p><p><img src="http://ww4.sinaimg.cn/large/65e4f1e6jw1fa3aoxjr2vj20b7077q37.jpg" alt=""></p><p>Figure 14.2 - Map transitions</p><p>使用 <code>map</code> 的 <code>Instance</code> 实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Instance</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Instance of a user-defined class. &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cls</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(cls, Class)</span><br><span class="line">        Base.__init__(self, cls, <span class="literal">None</span>)</span><br><span class="line">        self.<span class="built_in">map</span> = EMPTY_MAP</span><br><span class="line">        self.storage = []   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_read_dict</span>(<span class="params">self, fieldname</span>):</span><br><span class="line">        index = self.<span class="built_in">map</span>.get_index(fieldname)</span><br><span class="line">        <span class="keyword">if</span> index == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> MISSING</span><br><span class="line">        <span class="keyword">return</span> self.storage[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_write_dict</span>(<span class="params">self, fieldname, value</span>):</span><br><span class="line">        index = self.<span class="built_in">map</span>.get_index(fieldname)</span><br><span class="line">        <span class="keyword">if</span> index != -<span class="number">1</span>:</span><br><span class="line">            self.storage[index] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_map = self.<span class="built_in">map</span>.next_map(fieldname)</span><br><span class="line">            self.storage.append(value)</span><br><span class="line">            self.<span class="built_in">map</span> = new_map</span><br></pre></td></tr></table></figure><p>现在这个类将给 <code>Base</code> 类传递 <code>None</code> 作为字段字典，那是因为 <code>Instance</code> 将会以另一种方式构建存储字典。因此它需要重载 <code>_read_dict</code> 和 <code>_write_dict</code> 。在实际操作中，我们将重构 <code>Base</code> 类，使其不在负责存放字段字典。不过眼下，我们传递一个 <code>None</code> 作为参数就足够了。</p><p>在一个新的实例创建之初使用的是 <code>EMPTY_MAP</code> ，这里面没有任何的对象存放着。在实现 <code>_read_dict</code> 后，我们将从实例的 <code>map</code> 中查找属性名的索引，然后映射相对应的储存表。</p><p>向字段字典写入数据分为两种情况。第一种是现有属性值的修改，那么就简单的在映射的列表中修改对应的值就好。而如果对应属性不存在，那么需要进行 <code>map</code> 变换（如上面的图所示一样），将会调用 <code>next_map</code> 方法，然后将新的值存放入储存列表中。</p><p>你肯定想问，这种优化方式到底优化了什么？一般而言，在具有很多相似结构实例的情况下能较好的优化内存。但是请记住，这不是一个通用的优化手段。有些时候代码中充斥着结构不同的实例之时，这种手段可能会耗费更大的空间。</p><p>这是动态语言优化中的常见问题。一般而言，不太可能找到一种万能的方法去优化代码，使其更快，更节省空间。因此，具体情况具体分析，我们需要根据不同的情况去选择优化方式。</p><p>在 <code>Map</code> 优化中很有意思的一点就是，虽然这里只有花了内存占用，但是在 VM 使用 JIT 技术的情况下，也能较好的提高程序的性能。为了实现这一点，JIT 技术使用映射来查找属性在存储空间中的偏移量。然后完全除去字典查找的方式。</p><h2 id="潜在扩展"><a href="#潜在扩展" class="headerlink" title="潜在扩展"></a>潜在扩展</h2><p>扩展我们的对象模型和引入不同语言的设计选择是一件非常容易的事儿。这里给出一些可能的方向：</p><ul><li><p>最简单的是添加更多的特殊方法方法，比如一些 <code>__init__</code>, <code>__getattribute__</code>, <code>__set__</code> 这样非常容易实现和有趣的方法。</p></li><li><p>扩展模型支持多重继承。为了实现这一点，每一个类都需要一个父类列表。然后 <code>Class.method_resolution_order</code> 需要进行修改，以便支持方法查找。一个简单的 MRO 计算规则可以使用深度优先原则。然后更为复杂的可以采用<a href="https://www.python.org/download/releases/2.3/mro/">C3 算法</a>, 这种算法能更好的处理菱形继承结构所带来的一些问题。</p></li><li><p>一个更为疯狂的想法是切换到原型模式，这需要消除类和实例之间的差别。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面向对象编程语言设计的核心是其对象模型的细节。编写一些简单的对象模型是一件非常简单而且有趣的事情。你可以通过这种方式来了解现有语言的工作机制，并且深入了解面向对象语言的设计原则。编写不同的对象模型验证不同对象的设计思路是一个非常棒的方法。你也不在需要将注意力放在其余一些琐碎的事情上，比如解析和执行代码。</p><p>这样编写对象模型的工作在实践中也是非常有用的。除了作为实验品以外，它们还可以被其余语言所使用。这种例子有很多：比如 GObject 模型，用 C 语言编写，在 GLib 和 其余 Gonme 中得到使用，还有就是用 JavaScript 实现的各类对象模型。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><p>P. Cointe, “Metaclasses are first class: The ObjVlisp Model,” SIGPLAN Not, vol. 22, no. 12, pp. 156–162, 1987.↩</p></li><li><p>It seems that the attribute-based model is conceptually more complex, because it needs both method lookup and call. In practice, calling something is defined by looking up and calling a special attribute <code>__call__</code>, so conceptual simplicity is regained. This won’t be implemented in this chapter, however.)↩</p></li><li><p>G. Kiczales, J. des Rivieres, and D. G. Bobrow, The Art of the Metaobject Protocol. Cambridge, Mass: The MIT Press, 1991.↩</p></li><li><p>A. Goldberg, Smalltalk-80: The Language and its Implementation. Addison-Wesley, 1983, page 61.↩</p></li><li><p>In Python the second argument is the class where the attribute was found, though we will ignore that here.↩</p></li><li><p>C. Chambers, D. Ungar, and E. Lee, “An efficient implementation of SELF, a dynamically-typed object-oriented language based on prototypes,” in OOPSLA, 1989, vol. 24.↩</p></li><li><p>How that works is beyond the scope of this chapter. I tried to give a reasonably readable account of it in a paper I wrote a few years ago. It uses an object model that is basically a variant of the one in this chapter: C. F. Bolz, A. Cuni, M. Fijałkowski, M. Leuschel, S. Pedroni, and A. Rigo, “Runtime feedback in a meta-tracing JIT for efficient dynamic languages,” in Proceedings of the 6th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems, New York, NY, USA, 2011, pp. 9:1–9:8.↩</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> Flask </tag>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>听说你会 Python ？</title>
      <link href="//posts/2016/11/18/Someone-tell-me-that-you-think-Python-is-simple/"/>
      <url>//posts/2016/11/18/Someone-tell-me-that-you-think-Python-is-simple/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近觉得 Python 太“简单了”，于是在师父川爷面前放肆了一把：“我觉得 Python 是世界上最简单的语言！”。于是川爷嘴角闪过了一丝轻蔑的微笑（内心 OS：Naive！，作为一个 Python 开发者，我必须要给你一点人生经验，不然你不知道天高地厚！）于是川爷给我了一份满分 100 分的题，然后这篇文章就是记录下做这套题所踩过的坑。<br><span id="more"></span></p><h2 id="1-列表生成器"><a href="#1-列表生成器" class="headerlink" title="1.列表生成器"></a>1.列表生成器</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>下面的代码会报错，为什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    gen = (x <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">10</span>))  <span class="comment"># gen=(x for _ in range(10))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>(A.gen))</span><br></pre></td></tr></table></figure><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>这个问题是变量作用域问题，在 <code>gen=(x for _ in xrange(10))</code> 中 <code>gen</code> 是一个 <code>generator</code> ,在 <code>generator</code> 中变量有自己的一套作用域，与其余作用域空间相互隔离。因此，将会出现这样的 <code>NameError: name &#39;x&#39; is not defined</code> 的问题，那么解决方案是什么呢？答案是：用 lambda 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    gen = (<span class="keyword">lambda</span> x: (x <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">10</span>)))(x)  <span class="comment"># gen=(x for _ in range(10))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>(A.gen))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    gen = (A.x <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">10</span>))  <span class="comment"># gen=(x for _ in range(10))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>(A.gen))</span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>感谢评论区几位提出的意见，这里我给一份官方文档的说明吧：<br>The scope of names defined in a class block is limited to the class block; it does not extend to the code blocks of methods – this includes comprehensions and generator expressions since they are implemented using a function scope. This means that the following will fail:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    a = <span class="number">42</span></span><br><span class="line">    b = <span class="built_in">list</span>(a + i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>参考链接 <a href="https://docs.python.org/2/reference/executionmodel.html#naming-and-binding">Python2 Execution-Model:Naming-and-Binding</a> ， <a href="https://docs.python.org/3/reference/executionmodel.html#resolution-of-name">Python3 Execution-Model:Resolution-of-Names</a>。据说这是 PEP 227 中新增的提案，我回去会进一步详细考证。再次拜谢评论区 @没头脑很着急 @涂伟忠 @Cholerae 三位的勘误指正。</p><h2 id="2-装饰器"><a href="#2-装饰器" class="headerlink" title="2.装饰器"></a>2.装饰器</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>我想写一个类装饰器用来度量函数/方法运行时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timeit</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self._wrapped = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kws</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = self._wrapped(*args, **kws)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;elapsed time is %s &quot;</span> % (time.time() - start_time))</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这个装饰器能够运行在普通函数上：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Timeit</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;invoking function func&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func()  <span class="comment"># output: elapsed time is 1.00044410133</span></span><br></pre></td></tr></table></figure></p><p>但是运行在方法上会报错，为什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">    @Timeit</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;invoking method func&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = A()</span><br><span class="line">    a.func()  <span class="comment"># Boom!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果我坚持使用类装饰器，应该如何修改？</p><h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><p>使用类装饰器后，在调用 <code>func</code> 函数的过程中其对应的 instance 并不会传递给 <code>__call__</code> 方法，造成其 <code>mehtod unbound</code> ,那么解决方法是什么呢？描述符赛高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timeit</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;invoking Timer&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> *args, **kwargs: self.func(instance, *args, **kwargs)</span><br></pre></td></tr></table></figure><h2 id="3-Python-调用机制"><a href="#3-Python-调用机制" class="headerlink" title="3.Python 调用机制"></a>3.Python 调用机制</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>我们知道 <code>__call__</code> 方法可以用来重载圆括号调用，好的，以为问题就这么简单？Naive！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;invoking __call__ from A!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    a = A()</span><br><span class="line">    a()  <span class="comment"># output: invoking __call__ from A</span></span><br></pre></td></tr></table></figure><p>现在我们可以看到 <code>a()</code> 似乎等价于 <code>a.__call__()</code> ,看起来很 Easy 对吧，好的，我现在想作死，又写出了如下的代码，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a.__call__ = <span class="keyword">lambda</span>: <span class="string">&quot;invoking __call__ from lambda&quot;</span></span><br><span class="line">a.__call__()</span><br><span class="line"><span class="comment"># output:invoking __call__ from lambda</span></span><br><span class="line">a()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># output:invoking __call__ from A!</span></span><br></pre></td></tr></table></figure><p>请大佬们解释下，为什么 <code>a()</code> 没有调用出 <code>a.__call__()</code> (此题由 USTC 王子博前辈提出)</p><h3 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h3><p>原因在于，在 Python 中，新式类（ new class )的内建特殊方法，和实例的属性字典是相互隔离的，具体可以看看 Python 官方<a href="https://docs.python.org/2/reference/datamodel.html#special-method-lookup-for-new-style-classes">文档</a>对于这一情况的说明</p><blockquote><p>For new-style classes, implicit invocations of special methods are only guaranteed to work correctly if defined on an object’s type, not in the object’s instance dictionary. That behaviour is the reason why the following code raises an exception (unlike the equivalent example with old-style classes):</p></blockquote><p>同时官方也给出了一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.__len__ = <span class="keyword">lambda</span>: <span class="number">5</span></span><br><span class="line"><span class="built_in">len</span>(c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment"># TypeError: object of type &#x27;C&#x27; has no len()</span></span><br></pre></td></tr></table></figure><p>回到我们的例子上来，当我们在执行 <code>a.__call__=lambda:&quot;invoking __call__ from lambda&quot;</code> 时，的确在我们在 <code>a.__dict__</code> 中新增加了一个 key 为 <code>__call__</code> 的 item，但是当我们执行 <code>a()</code> 时，因为涉及特殊方法的调用，因此我们的调用过程不会从 <code>a.__dict__</code> 中寻找属性，而是从 <code>tyee(a).__dict__</code> 中寻找属性。因此，就会出现如上所述的情况。</p><h2 id="4-描述符"><a href="#4-描述符" class="headerlink" title="4.描述符"></a>4.描述符</h2><h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p>我想写一个 Exam 类，其属性 math 为 [0,100] 的整数，若赋值时不在此范围内则抛出异常，我决定用描述符来实现这个需求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grade</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._score = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>:</span><br><span class="line">            self._score = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;grade must be between 0 and 100&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exam</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    math = Grade()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, math</span>):</span><br><span class="line">        self.math = math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    niche = Exam(math=<span class="number">90</span>)</span><br><span class="line">    <span class="built_in">print</span>(niche.math)</span><br><span class="line">    <span class="comment"># output : 90</span></span><br><span class="line">    snake = Exam(math=<span class="number">75</span>)</span><br><span class="line">    <span class="built_in">print</span>(snake.math)</span><br><span class="line">    <span class="comment"># output : 75</span></span><br><span class="line">    snake.math = <span class="number">120</span></span><br><span class="line">    <span class="comment"># output: ValueError:grade must be between 0 and 100!</span></span><br></pre></td></tr></table></figure><p>看起来一切正常。不过这里面有个巨大的问题，尝试说明是什么问题<br>为了解决这个问题，我改写了 Grade 描述符如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grad</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._grade_pool = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> self._grade_pool.get(instance, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>:</span><br><span class="line">            _grade_pool = self.__dict__.setdefault(<span class="string">&#x27;_grade_pool&#x27;</span>, &#123;&#125;)</span><br><span class="line">            _grade_pool[instance] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;fuck&quot;</span>)</span><br></pre></td></tr></table></figure><p>不过这样会导致更大的问题，请问该怎么解决这个问题？</p><h3 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h3><p>1.第一个问题的其实很简单，如果你再运行一次 <code>print(niche.math)</code> 你就会发现，输出值是 <code>75</code> ，那么这是为什么呢？这就要先从 Python 的调用机制说起了。我们如果调用一个属性，那么其顺序是优先从实例的 <code>__dict__</code> 里查找，然后如果没有查找到的话，那么一次查询类字典，父类字典，直到彻底查不到为止。好的，现在回到我们的问题，我们发现，在我们的类 <code>Exam</code> 中，其 <code>self.math</code> 的调用过程是，首先在实例化后的实例的 <code>__dict__</code> 中进行查找，没有找到，接着往上一级，在我们的类 <code>Exam</code> 中进行查找，好的找到了，返回。那么这意味着，我们对于 <code>self.math</code> 的所有操作都是对于类变量 <code>math</code> 的操作。因此造成变量污染的问题。那么该则怎么解决呢？很多同志可能会说，恩，在 <code>__set__</code> 函数中将值设置到具体的实例字典不就行了。<br>那么这样可不可以呢？答案是，很明显不得行啊，至于为什么，就涉及到我们 Python 描述符的机制了，描述符指的是实现了描述符协议的特殊的类，三个描述符协议指的是 <code>__get__</code> , ‘<strong>set</strong>‘ , <code>__delete__</code>  以及 Python 3.6 中新增的 <code>__set_name__</code> 方法，其中实现了 <code>__get__</code> 以及 <code>__set__</code> / <code>__delete__</code> / <code>__set_name__</code> 的是 <strong>Data descriptors</strong> ，而只实现了 <code>__get__</code> 的是 <code>Non-Data descriptor</code> 。那么有什么区别呢，前面说了， <strong>我们如果调用一个属性，那么其顺序是优先从实例的 <code>__dict__</code> 里查找，然后如果没有查找到的话，那么一次查询类字典，父类字典，直到彻底查不到为止。</strong> 但是，这里没有考虑描述符的因素进去，如果将描述符因素考虑进去，那么正确的表述应该是<strong>我们如果调用一个属性，那么其顺序是优先从实例的 <code>__dict__</code> 里查找，然后如果没有查找到的话，那么一次查询类字典，父类字典，直到彻底查不到为止。其中如果在类实例字典中的该属性是一个 <code>Data descriptors</code> ，那么无论实例字典中存在该属性与否，无条件走描述符协议进行调用，在类实例字典中的该属性是一个 <code>Non-Data descriptors</code> ，那么优先调用实例字典中的属性值而不触发描述符协议，如果实例字典中不存在该属性值，那么触发 <code>Non-Data descriptor</code> 的描述符协议</strong>。回到之前的问题，我们即使在 <code>__set__</code> 将具体的属性写入实例字典中，但是由于类字典中存在着 <code>Data descriptors</code> ，因此，我们在调用 <code>math</code> 属性时，依旧会触发描述符协议。</p><p>2.经过改良的做法，利用 <code>dict</code> 的 key 唯一性，将具体的值与实例进行绑定，但是同时带来了内存泄露的问题。那么为什么会造成内存泄露呢，首先复习下我们的 <code>dict</code> 的特性，<code>dict</code> 最重要的一个特性，就是凡可 hash 的对象皆可为 key ，<code>dict</code> 通过利用的 hash 值的唯一性（严格意义上来讲并不是唯一，而是其 hash 值碰撞几率极小，近似认定其唯一）来保证 key 的不重复性，同时（敲黑板，重点来了），<code>dict</code> 中的 <code>key</code> 引用是强引用类型，会造成对应对象的引用计数的增加，可能造成对象无法被 gc ，从而产生内存泄露。那么这里该怎么解决呢？两种方法<br>第一种：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grad</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> weakref</span><br><span class="line">        self._grade_pool = weakref.WeakKeyDictionary()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> self._grade_pool.get(instance, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>:</span><br><span class="line">            _grade_pool = self.__dict__.setdefault(<span class="string">&#x27;_grade_pool&#x27;</span>, &#123;&#125;)</span><br><span class="line">            _grade_pool[instance] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;fuck&quot;</span>)</span><br></pre></td></tr></table></figure><p>weakref 库中的 <code>WeakKeyDictionary</code> 所产生的字典的 key 对于对象的引用是弱引用类型，其不会造成内存引用计数的增加，因此不会造成内存泄露。同理，如果我们为了避免 value 对于对象的强引用，我们可以使用 <code>WeakValueDictionary</code> 。<br>第二种：在 Python 3.6 中，实现的 PEP 487 提案，为描述符新增加了一个协议，我们可以用其来绑定对应的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Grad</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.key]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= value &lt;= <span class="number">100</span>:</span><br><span class="line">            instance.__dict__[self.key] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;fuck&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set_name__</span>(<span class="params">self, owner, name</span>):</span><br><span class="line">        self.key = name</span><br></pre></td></tr></table></figure><p>这道题涉及的东西比较多，这里给出一点参考链接，<a href="https://docs.python.org/2/reference/datamodel.html#invoking-descriptors">invoking-descriptors</a> , <a href="https://docs.python.org/3/howto/descriptor.html">Descriptor HowTo Guide</a> , <a href="https://www.python.org/dev/peps/pep-0487/">PEP 487</a> , <a href="https://docs.python.org/3.6/whatsnew/3.6.html#pep-487-descriptor-protocol-enhancements">what`s new in Python 3.6</a> 。</p><h2 id="5-Python-继承机制"><a href="#5-Python-继承机制" class="headerlink" title="5.Python 继承机制"></a>5.Python 继承机制</h2><h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p>试求出以下代码的输出结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Init</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.val = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add2</span>(<span class="title class_ inherited__">Init</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="built_in">super</span>(Add2, self).__init__(val)</span><br><span class="line">        self.val += <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mul5</span>(<span class="title class_ inherited__">Init</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="built_in">super</span>(Mul5, self).__init__(val)</span><br><span class="line">        self.val *= <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pro</span>(Mul5, Add2):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Incr</span>(<span class="title class_ inherited__">Pro</span>):</span><br><span class="line">    csup = <span class="built_in">super</span>(Pro)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.csup.__init__(val)</span><br><span class="line">        self.val += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Incr(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(p.val)</span><br></pre></td></tr></table></figure><h3 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h3><p>输出是 36 ，具体可以参考 <a href="https://www.python.org/doc/newstyle/">New-style Classes</a> , <a href="https://docs.python.org/2/tutorial/classes.html#multiple-inheritance">multiple-inheritance</a></p><h2 id="6-Python-特殊方法"><a href="#6-Python-特殊方法" class="headerlink" title="6. Python 特殊方法"></a>6. Python 特殊方法</h2><h3 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h3><p>我写了一个通过重载 <strong>new</strong> 方法来实现单例模式的类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls._instance:</span><br><span class="line">            <span class="keyword">return</span> cls._instance</span><br><span class="line">        cls._isntance = cv = <span class="built_in">object</span>.__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sin1 = Singleton()</span><br><span class="line">sin2 = Singleton()</span><br><span class="line"><span class="built_in">print</span>(sin1 <span class="keyword">is</span> sin2)</span><br><span class="line"><span class="comment"># output: True</span></span><br></pre></td></tr></table></figure><p>现在我有一堆类要实现为单例模式，所以我打算照葫芦画瓢写一个元类，这样可以让代码复用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">cls, name, bases, <span class="built_in">dict</span></span>):</span><br><span class="line">        cls._instance = <span class="literal">None</span></span><br><span class="line">        __new__o = cls.__new__</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">if</span> cls._instance:</span><br><span class="line">                <span class="keyword">return</span> cls._instance</span><br><span class="line">            cls._instance = cv = __new__o(cls, *args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> cv</span><br><span class="line"></span><br><span class="line">        cls.__new__ = __new__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __metaclass__ = SingleMeta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a1 = A()  <span class="comment"># what`s the fuck</span></span><br></pre></td></tr></table></figure><p>哎呀，好气啊，为啥这会报错啊，我明明之前用这种方法给 <code>__getattribute__</code> 打补丁的，下面这段代码能够捕获一切属性调用并打印参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TraceAttribute</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">cls, name, bases, <span class="built_in">dict</span></span>):</span><br><span class="line">        __getattribute__o = cls.__getattribute__</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;__getattribute__:&#x27;</span>, args, kwargs)</span><br><span class="line">            <span class="keyword">return</span> __getattribute__o(self, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        cls.__getattribute__ = __getattribute__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):  <span class="comment"># Python 3 是 class A(object,metaclass=TraceAttribute):</span></span><br><span class="line">    __metaclass__ = TraceAttribute</span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.a</span><br><span class="line"><span class="comment"># output: __getattribute__:(&#x27;a&#x27;,)&#123;&#125;</span></span><br><span class="line">a.b</span><br></pre></td></tr></table></figure><p>试解释为什么给 <strong>getattribute</strong> 打补丁成功，而 <strong>new</strong> 打补丁失败。<br>如果我坚持使用元类给 <strong>new</strong> 打补丁来实现单例模式，应该怎么修改？</p><h3 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h3><p>其实这是最气人的一点，类里的 <code>__new__</code> 是一个 <code>staticmethod</code> 因此替换的时候必须以 <code>staticmethod</code> 进行替换。答案如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMeta</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">cls, name, bases, <span class="built_in">dict</span></span>):</span><br><span class="line">        cls._instance = <span class="literal">None</span></span><br><span class="line">        __new__o = cls.__new__</span><br><span class="line"></span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">if</span> cls._instance:</span><br><span class="line">                <span class="keyword">return</span> cls._instance</span><br><span class="line">            cls._instance = cv = __new__o(cls, *args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> cv</span><br><span class="line"></span><br><span class="line">        cls.__new__ = __new__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __metaclass__ = SingleMeta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A() <span class="keyword">is</span> A())  <span class="comment"># output: True</span></span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>感谢师父大人的一套题让我开启新世界的大门，恩，博客上没法艾特，只能传递心意了。说实话 Python 的动态特性可以让其用众多 <code>black magic</code> 去实现一些很舒服的功能，当然这也对我们对语言特性及坑的掌握也变得更严格了，愿各位 Pythoner 没事阅读官方文档，早日达到<strong>装逼如风，常伴吾身</strong>的境界。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 黑魔法 </tag>
            
            <tag> 编程技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 声明式程序设计</title>
      <link href="//posts/2016/10/25/Declarative-API-Design-in-Swift/"/>
      <url>//posts/2016/10/25/Declarative-API-Design-in-Swift/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="http://blog.benjamin-encz.de/post/declarative-api-design-in-swift/">Declarative API Design in Swift</a></li><li>原文作者：<a href="http://blog.benjamin-encz.de/about">Benjamin Encz</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>译者：<a href="https://github.com/Zheaoli">Zheaoli</a></li><li>校对者：<a href="https://github.com/luoyaqifei">luoyaqifei</a>, <a href="https://github.com/Edison-Hsu">Edison-Hsu</a></li></ul></blockquote><p>在我第一份 iOS 开发工程师的工作中，我编写了一个 XML 解析器和一个简单的布局工具，两个东西都是基于声明式接口。XML 解析器是基于 <code>.plist</code> 文件来实现 Objective-C 类关系映射。而布局工具则允许你利用类似 HTML 一样标签化的语法来实现界面布局（不过这个工具使用的前提是已经正确使用 <code>AutoLayout</code> &amp; <code>CollectionViews</code>）。</p><p>尽管这两个库都不完美，它们还是展现了声明式代码的四大优点：</p><ul><li><strong>关注点分离</strong>: 我们在使用声明式风格编写的代码时声明了意图，从而无需关注具体的底层实现，可以说这样的分离是自然发生的。</li><li><strong>减少重复的代码</strong>: 所有声明式代码都共用一套样式实现，这里面很多属于配置文件，这样可以减少重复代码所带来的风险。</li><li><strong>优秀的 API 设计</strong>: 声明式 API 可以让用户自行定制已有实现，而不是将已有实现做一种固定的存在看待。这样可以保证修改程度降至最小。</li><li><strong>良好的可读性</strong>: 讲真，按照声明式 API 所写出来的代码简直优美无比。<span id="more"></span>这些天我写的大多数 Swift 代码非常适用于声明式编程风格。</li></ul><p>不管是对于某一种数据结构的描述，或者是对某个功能的实现，在编写过程中，我最常使用的类型还是一些简单的结构体。声明不同的类型，主要是基于泛型类，然后这些东西负责实现具体的功能或者完成必要的工作。我们在 PlanGrid 开发过程中采用这种方法来编写我们得 Swift 代码。这种开发方式已经对对代码可读性的提升还有开发人员的效率提升上产生了巨大的影响。</p><p>本文我想讨论的是 PlanGrid 应用中所使用的 API 设计，它原本使用 NSOperationQueue 实现，现在使用了一种更接近声明式的方法－讨论这个 API 应该可以展示声明式编程风格在各方面的好处。</p><h2 id="在-Swift-中构建一个声明式请求序列"><a href="#在-Swift-中构建一个声明式请求序列" class="headerlink" title="在 Swift 中构建一个声明式请求序列"></a>在 Swift 中构建一个声明式请求序列</h2><p>我们重新设计的 API 用来将本地变化（也可能是离线发生的）与 API 服务器进行同步。我不会讨论这种变化追踪方法的细节，而是将精力放在网络请求的生成和执行上。</p><p>在这篇文章里，我想专注于一个特定的请求类型上：上传本地生成的图片。出于多种因素的考虑（超出本文讨论范围），上传图片的操作包括三次请求：</p><ol><li>向 API 服务器发起请求，API 服务器将会响应，响应内容为向 AWS 服务器上传图片所需信息。</li><li>上传图片至 AWS （使用上次请求得到的信息）。</li><li>向 API 服务器发起请求以确认图片上传成功。</li></ol><p>既然我们有包括这些请求序列的上传任务，我们决定将其抽象成一个特殊的类型，并让我们的上传架构支持它。</p><h3 id="定义请求序列协议"><a href="#定义请求序列协议" class="headerlink" title="定义请求序列协议"></a>定义请求序列协议</h3><p>我们决定引入一个单独的类型来对网络请求序列进行描述。这个类型将被我们的上传者类使用，上传者类的作用是将描述转化为实在的网络请求(要提醒你们的是我们不会在本篇文章中讨论上传者类的实现）。</p><p>接下来这个类型是我们控制流的精髓：我们有一个请求序列，序列中的每个请求都可能依赖于前一个请求的结果。</p><p>小贴士: 接下来的代码里的一些类型的命名方式看起来有点奇怪，但是它们中大多数是根据应用专属术语集来命名的（如： Operation ）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">PreviousRequestTuple</span> <span class="operator">=</span> (</span><br><span class="line">request: <span class="type">PushRequest</span>,</span><br><span class="line">response: <span class="type">NSURLResponse</span>,</span><br><span class="line">responseBody: <span class="type">JsonValue</span>?</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A sequence of push requests required to sync this operation with the server.</span></span><br><span class="line"><span class="comment">/// As soon as a request of this sequence completes,</span></span><br><span class="line"><span class="comment">/// `PushSyncQueueManager` will poll the sequence for the next request.</span></span><br><span class="line"><span class="comment">/// If `nil` is returned for the `nextRequest` then</span></span><br><span class="line"><span class="comment">/// this sequence is considered complete.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">OperationRequestSequence</span>: <span class="title class_">class</span> &#123;</span><br><span class="line">    <span class="comment">/// When this method returns `nil` the entire `OperationRequestSequence`</span></span><br><span class="line">    <span class="comment">/// is considered completed.</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">nextRequest</span>(<span class="params">previousRequest</span>: <span class="type">PreviousRequestTuple</span>?) <span class="keyword">throws</span> -&gt; <span class="type">PushRequest</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>nextRequest:</code> 方法来让请求序列生成一个请求时，我们提供了一个对前一个请求的引用，包括 <code>NSURLResponse</code> 和 JSON 响应体（如果存在的话）。每一个请求的结果都可能在下一次请求时产生（（将会返回一个 <code>PushRequest</code> 对象），除了没有下一次请求（返回 <code>nil</code> ）或者在请求过程中发生了一些以外的情况导致没有返回必要的响应以外（请求序列在该情况下 <code>throws</code> ）。</p><p>值得注意的是， PushRequest 并不是这个返回值类型的理想名。这个类型只是描述一个请求的详情（结束符，HTTP 方法等等），其并不参与任何实质性的工作。这是声明式设计中很重要的一个方面。</p><p>你可能已经注意到了这个协议依赖于一个特定 <code>class</code> ，我们这样做是因为我们意识到 <code>OperationRequestSequence</code> 其是一个状态描述类型。它需要能够捕获并使用前面的请求所产生的结果（比如：在第三个请求里可能需要获取第一个请求的响应结果）。这个做法参考了 <code>mutating</code> 方法的结构，不得不说这样的行为貌似让这部分有关上传操作的代码变得更为复杂了（所以说重新赋值变化结构体并不是一件那么简单的事儿）</p><p>在基于 <code>OperationRequestSequence</code> 协议实现了我们第一个请求序列后，我们发现相比实现 <code>nextRequest</code> 方法来说，简单地提供一个数组来保存请求链更合适。于是我们便添加了 <code>ArrayRequestSequence</code> 协议来提供了一个请求数组的实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">RequestContinuation</span> <span class="operator">=</span> (previous: <span class="type">PreviousRequestTuple</span>?) <span class="keyword">throws</span> -&gt; <span class="type">PushRequest</span>?</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">ArrayRequestSequence</span>: <span class="title class_">OperationRequestSequence</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> currentRequestIndex: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> requests: [<span class="type">RequestContinuation</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">ArrayRequestSequence</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">nextRequest</span>(<span class="params">previous</span>: <span class="type">PreviousRequestTuple</span>?) <span class="keyword">throws</span> -&gt; <span class="type">PushRequest</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> nextRequest <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">self</span>.requests[<span class="keyword">self</span>.currentRequestIndex](previous: previous)</span><br><span class="line">        <span class="keyword">self</span>.currentRequestIndex <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nextRequest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，我们定义了一个新的上传序列，这只是很微小的一点工作。</p><h3 id="实现请求序列协议"><a href="#实现请求序列协议" class="headerlink" title="实现请求序列协议"></a>实现请求序列协议</h3><p>作为一个小例子，让我们看看用来上传快照的上传序列吧（在 PlanGrid 中，快照指的是在图片中绘制的可导出的蓝图或者注释）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Describes a sequence of requests for uploading a snapshot.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SnapshotUploadRequestSequence</span>: <span class="title class_">ArrayRequestSequence</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Removed boilerplate initializer &amp;</span></span><br><span class="line">    <span class="comment">// instance variable definition code...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is the definition of the request sequence</span></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> requests: [<span class="type">RequestContinuation</span>] <span class="operator">=</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="comment">// 1\. Get AWS Upload Package from API</span></span><br><span class="line">            <span class="keyword">self</span>._allocationRequest,</span><br><span class="line">            <span class="comment">// 2\. Upload Snapshot to AWS</span></span><br><span class="line">            <span class="keyword">self</span>._awsUploadRequest,</span><br><span class="line">            <span class="comment">// 3\. Confirm Upload with API</span></span><br><span class="line">            <span class="keyword">self</span>._metadataRequest</span><br><span class="line">        ]</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It follows the detailed definition of the individual requests:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">_allocationRequest</span>(<span class="params">previous</span>: <span class="type">PreviousRequestTuple</span>?) <span class="keyword">throws</span> -&gt; <span class="type">PushRequest</span>? &#123;</span><br><span class="line">    <span class="comment">// Generate an API request for this file upload</span></span><br><span class="line">    <span class="comment">// Pass file size in JSON format in the request body</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">PushInMemoryRequestDescription</span>(</span><br><span class="line">            relativeURL: <span class="type">ApiEndpoints</span>.snapshotAllocation(<span class="keyword">self</span>.affectedModelUid.value),</span><br><span class="line">            httpMethod: .<span class="type">POST</span>,</span><br><span class="line">            jsonBody: <span class="type">JsonValue</span>(values:</span><br><span class="line">                [</span><br><span class="line">                    <span class="string">&quot;filesize&quot;</span> : <span class="keyword">self</span>.imageUploadDescription.fullFileSize</span><br><span class="line">                ]</span><br><span class="line">            ),</span><br><span class="line">            operationId: <span class="keyword">self</span>.operationId,</span><br><span class="line">            affectedModelUid: <span class="keyword">self</span>.affectedModelUid,</span><br><span class="line">            requestIdentifier: <span class="type">SnapshotUploadRequestSequence</span>.allocationRequest</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">_awsUploadRequest</span>(<span class="params">previous</span>: <span class="type">PreviousRequestTuple</span>?) <span class="keyword">throws</span> -&gt; <span class="type">PushRequest</span>? &#123;</span><br><span class="line">    <span class="comment">// Check for presence of AWS allocation data in response body</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> allocationData <span class="operator">=</span> previous<span class="operator">?</span>.responseBody <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">ImageCreationOperationError</span>.<span class="type">MissingAllocationData</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attempt to parse AWS allocation data</span></span><br><span class="line">        <span class="keyword">self</span>.snapshotAllocationData <span class="operator">=</span> <span class="keyword">try</span> <span class="type">AWSAllocationPackage</span>(json: allocationData[<span class="string">&quot;snapshot&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> snapshotAllocationData <span class="operator">=</span> <span class="keyword">self</span>.snapshotAllocationData <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">ImageCreationOperationError</span>.<span class="type">MissingAllocationData</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get filesystem path for this snapshot</span></span><br><span class="line">        <span class="keyword">let</span> thumbImageFilePath <span class="operator">=</span> <span class="type">NSURL</span>(fileURLWithPath:</span><br><span class="line">            <span class="type">SnapshotModel</span>.pathForUid(</span><br><span class="line">                <span class="keyword">self</span>.imageUploadDescription.modelUid,</span><br><span class="line">                size: .<span class="type">Full</span></span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate a multipart/form-data request</span></span><br><span class="line">        <span class="comment">// that uploads the image to AWS</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">AWSMultiPartRequestDescription</span>(</span><br><span class="line">            targetURL: snapshotAllocationData.targetUrl,</span><br><span class="line">            httpMethod: .<span class="type">POST</span>,</span><br><span class="line">            fileURL: thumbImageFilePath,</span><br><span class="line">            filename: snapshotAllocationData.filename,</span><br><span class="line">            operationId: <span class="keyword">self</span>.operationId,</span><br><span class="line">            affectedModelUid: <span class="keyword">self</span>.affectedModelUid,</span><br><span class="line">            requestIdentifier: <span class="type">SnapshotUploadRequestSequence</span>.snapshotAWS,</span><br><span class="line">            formParameters: snapshotAllocationData.fields</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">_metadataRequest</span>(<span class="params">previous</span>: <span class="type">PreviousRequestTuple</span>?) <span class="keyword">throws</span> -&gt; <span class="type">PushRequest</span>? &#123;</span><br><span class="line">        <span class="comment">// Generate an API request to confirm the completed upload</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">PushInMemoryRequestDescription</span>(</span><br><span class="line">            relativeURL: <span class="type">ApiEndpoints</span>.snapshotAllocation(<span class="keyword">self</span>.affectedModelUid.value),</span><br><span class="line">            httpMethod: .<span class="type">PUT</span>,</span><br><span class="line">            jsonBody: <span class="keyword">self</span>.snapshotMetadata,</span><br><span class="line">            operationId: <span class="keyword">self</span>.operationId,</span><br><span class="line">            affectedModelUid: <span class="keyword">self</span>.affectedModelUid,</span><br><span class="line">            requestIdentifier: <span class="type">SnapshotUploadRequestSequence</span>.metadataRequest</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现的过程中你应该注意这样几件事情：</p><ul><li>这里面几乎没有命令式代码。大多数的代码都通过实例变量和前次请求的结果来描述网络请求。</li><li>代码并不调用网络层，也没有任何上传操作的类型信息。它们只是对每个请求的详情进行了描述。事实上，这段代码没有能被观测到的副作用，它只更改了内部状态。</li><li>这段代码里可以说没有任何的错误处理代码。这个类型只负责处理该请求序列中发生的特定错误（比如前次请求并未返回任何结果等）。而其余的错误通常都在网络层予以处理了。</li><li>我们使用 <code>PushInMemoryRequestDescription</code>/<code>AWSMultipartRequestDescription</code> 来对我们对自己的 API 服务器或者是对 AWS 服务器发起请求的行为进行抽象。我们的上传代码将会根据情况在两者之前进行切换，对两者使用不同的 URL 会话配置，以免将我们自有 API 服务器的认证信息发送至 AWS 。</li></ul><p>我不会详细讨论整个代码，但是我希望这个例子能充分展现我之前提到过的声明式设计方法的一系列优点：</p><ul><li><strong>关注点分离</strong>: 上面编写的类型只有描述一系列请求这一单一功能。</li><li><strong>减少重复的代码</strong>: 上面编写的类型里面只包含对请求进行描述的代码，并不包含网络请求及错误处理的代码。</li><li><strong>优秀的 API 设计</strong>: 这样的 API 设计能有效的减轻开发者的负担，他们只需要实现一个简单的协议以确保后续产生的请求是基于前一个请求结果的即可。</li><li><strong>良好的可读性</strong>: 再次声明，以上代码非常集中；我们不需要在样板代码的海洋里游泳，就可以找到代码的意图。那也说明，为了更快地理解这段代码，你需要对我们的抽象方式有一定的了解。</li></ul><p>现在可以想想如果利用 <code>NSOperationQueue</code> 来替代我们的方案会怎么样？</p><h3 id="什么是-NSOperationQueue-？"><a href="#什么是-NSOperationQueue-？" class="headerlink" title="什么是 NSOperationQueue ？"></a>什么是 <code>NSOperationQueue</code> ？</h3><p>采用 <code>NSOperationQueue</code> 的方案复杂了很多，所以在这篇文章里给出相对应的代码并不是一个很好的选择。不过我们还是可以讨论下这种方案。</p><p><strong>关注点分离</strong>在这种方案中难以实现。和对请求序列进行简单抽象不同的是，<code>NSOperationQueue</code> 中的 <code>NSOperations</code> 对象将负责网络请求的开关操作。这里面包含请求取消和错误处理等特性。在不同的位置都有相似的上传代码，同时这些代码很难进行复用。在大多数上传请求被抽象成一个<code>NSOperation</code> 的情况下，使用子类并不是一个好选择，虽然说我们得上传请求队列被抽象成为一个被 <code>NSOperationQueue</code> 所装饰的 <code>NSOperation</code> 。</p><p><code>NSOperationQueue</code> 中的无关信息相当多。。代码中随处可见对网络层的操作和调用 <code>NSOperation</code> 中的特定方法，比如 <code>main</code> 和 <code>finish</code> 方法。在没有深入了解具体的 API 调用规则前，很难知道具体操作是用来做什么的</p><p><strong>这种 API 所采用的处理方式，某种意义上让开发者的开发体验变得更差了</strong>。和简单的实现相对应的协议不同的是，在 Swift 中如果采用上述的开发方式，人们需要去了解一些约定俗成的规定，尽管这些规定可能并不强制要求你遵守。</p><p><strong>这种处理方式将会显著增加开发者的负担。</strong>与实现一个简单协议不同的是，在新版本的 Swift 中实现这样的代码的话，我们需要去理解一些特有的约定。尽管很多被记载下来的约定并不是与编程相关的。</p><p>由于一些其他原因，该 API 可能会导致一些与网络请求的错误报告相关的 bug 。为了避免每个请求操作都执行自己的错误报告代码，我们将其集中在一个地方进行处理。错误处理代码将会在请求结束之后开始执行。然后代码将会检查请求类型中的 error 属性的值是否存在。为了及时地反馈错误信息，开发者需要及时在操作完成之前设置 <code>NSOperation</code> 中的 <code>error</code> 属性的值。由于这是一个非强制性约定导致一堆新代码忘记设置其属性的值，可能会导致诸多错误信息的遗失。</p><p>所以啊，我们很期待我们介绍的这样一种新的方式能帮助开发者们在未来编写上传及其余功能的代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>声明式的编程方法已经对我们的编程技能和开发效率产生了巨大的影响。我们提供了一种受限的 API ，这种 API 用途单一且不会留下一堆迷之 Bug 。我们可以避免使用子类及多态等一系列手段，转而使用基于泛型类型的声明式风格代码来替代它。我们可以写出优美的代码。我们所编写的代码都是能很方便的进行测试的(关于这点，编程爱好者们可能觉得在声明式风格代码中测试可能不是必要的。）所以你可能想问：“别告诉我这是一种完美无瑕的编程方式？”</p><p>首先，在具体的抽象过程中，我们可能会花费一些时间与精力。不过，这种花费可以通过仔细设计 API ，并并通过提供一些测试，代替用例实现功能，为使用者提供参考。</p><p>其次，请注意，声明式编程并不是适用于任何时间任何业务的。要想适用声明式编程，你的代码库里至少要有一个用相似方法解决了多次的问题。如果你尝试在一个需要高度可定制化的应用里使用声明式编程， 然后你又对整个代码进行了错误的抽象，那么最后你会得到如同乱麻一般的<strong>半</strong>声明式代码。对于任何的抽象过程而言，过早地进行抽象都会造成一大堆令人费解的问题。</p><p><strong>声明式 API 有效地将 API 使用者身上的压力转移至 API 开发者身上，对于命令式 API 则不需要这样</strong>。为了提供一组优秀的声明式 API ，API 的开发者必须确保接口的使用与接口的实现细节进行严格的隔离。不过严格遵循这样要求的 API 是很少的。React 和 GraphQL 证明了声明式 API 能有效提升团队编码的体验。</p><p>其实我觉得，这只是一个开端，我们会慢慢发现在复杂的库中所隐藏复杂的细节和对外提供的简单易用的接口。期待有一天，我们能利用一个基于声明式编程的 UI 库来构建我们的 iOS 程序。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 描述符入门指北</title>
      <link href="//posts/2016/10/12/Something-about-Descriptor/"/>
      <url>//posts/2016/10/12/Something-about-Descriptor/</url>
      
        <content type="html"><![CDATA[<p>很久都没写 <strong>Flask</strong> 代码相关了，想想也真是惭愧，然并卵，这次还是不写 <strong>Flask</strong> 相关，不服你来打我啊（就这么贱，有本事咬我啊<br>这次我来写一下 Python 一个很重要的东西，即 Descriptor （描述符）<br><span id="more"></span></p><h2 id="初识描述符"><a href="#初识描述符" class="headerlink" title="初识描述符"></a>初识描述符</h2><p>老规矩，<strong>Talk is cheap,Show me the code.</strong> 我们先来看看一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, first_name, last_name</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Constructor&quot;&quot;&quot;</span></span><br><span class="line">        self.first_name = first_name</span><br><span class="line">        self.last_name = last_name</span><br><span class="line"></span><br><span class="line">    <span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">full_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Return the full name</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;%s %s&quot;</span> % (self.first_name, self.last_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    person = Person(<span class="string">&quot;Mike&quot;</span>, <span class="string">&quot;Driscoll&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(person.full_name)</span><br><span class="line">    <span class="comment"># &#x27;Mike Driscoll&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(person.first_name)</span><br><span class="line">    <span class="comment"># &#x27;Mike&#x27;</span></span><br></pre></td></tr></table></figure><p>这段代大家肯定很熟悉，恩，<code>property</code> 嘛，谁不知道呢，但是 <code>property</code> 的实现机制大家清楚么？什么不清楚？那还学个毛的 Python 啊。。。开个玩笑，我们看下面一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Property</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;Emulate PyProperty_Type() in Objects/descrobject.c&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, fget=<span class="literal">None</span>, fset=<span class="literal">None</span>, fdel=<span class="literal">None</span>, doc=<span class="literal">None</span></span>):</span><br><span class="line">        self.fget = fget</span><br><span class="line">        self.fset = fset</span><br><span class="line">        self.fdel = fdel</span><br><span class="line">        <span class="keyword">if</span> doc <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> fget <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            doc = fget.__doc__</span><br><span class="line">        self.__doc__ = doc</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, obj, objtype=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&quot;unreadable attribute&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.fget(obj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, obj, value</span>):</span><br><span class="line">        <span class="keyword">if</span> self.fset <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&quot;can&#x27;t set attribute&quot;</span>)</span><br><span class="line">        self.fset(obj, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete__</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">if</span> self.fdel <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&quot;can&#x27;t delete attribute&quot;</span>)</span><br><span class="line">        self.fdel(obj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getter</span>(<span class="params">self, fget</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(self)(fget, self.fset, self.fdel, self.__doc__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setter</span>(<span class="params">self, fset</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(self)(self.fget, fset, self.fdel, self.__doc__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleter</span>(<span class="params">self, fdel</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(self)(self.fget, self.fset, fdel, self.__doc__)</span><br></pre></td></tr></table></figure><p>看起来是不是很复杂，没事，我们来一步步的看。不过这里我们首先给出一个结论：<strong>Descriptors 是一种特殊 的对象，这种对象实现了 <code>__get__</code> ，<code>__set__</code> ，<code>__delete__</code> 这三个特殊方法。</strong></p><h2 id="详解描述符"><a href="#详解描述符" class="headerlink" title="详解描述符"></a>详解描述符</h2><h3 id="说说-Property"><a href="#说说-Property" class="headerlink" title="说说 Property"></a>说说 Property</h3><p>在上文，我们给出了 Propery 实现代码，现在让我们来详细说说这个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, first_name, last_name</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Constructor&quot;&quot;&quot;</span></span><br><span class="line">        self.first_name = first_name</span><br><span class="line">        self.last_name = last_name</span><br><span class="line"></span><br><span class="line">    <span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"><span class="meta">    @Property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">full_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Return the full name</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;%s %s&quot;</span> % (self.first_name, self.last_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    person = Person(<span class="string">&quot;Mike&quot;</span>, <span class="string">&quot;Driscoll&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(person.full_name)</span><br><span class="line">    <span class="comment"># &#x27;Mike Driscoll&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(person.first_name)</span><br><span class="line">    <span class="comment"># &#x27;Mike&#x27;</span></span><br></pre></td></tr></table></figure><p>首先，如果你对装饰器不了解的话，你可能要去看看这篇<a href="http://manjusaka.itscoder.com/2016/08/09/reading-the-fucking-flask-source-code-Part1/">文章</a>，简而言之，在我们正式运行代码之前，我们的解释器就会对我们的代码进行一次扫描，对涉及装饰器的部分进行替换。类装饰器同理。在上文中，这段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">full_name</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Return the full name</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;%s %s&quot;</span> % (self.first_name, self.last_name)</span><br></pre></td></tr></table></figure><p>会触发这样一个过程，即  <code>full_name=Property(full_name)</code> 。然后在我们后面所实例化对象之后我们调用 <code>person.full_name</code> 这样一个过程其实等价于 <code>person.full_name.__get__(person)</code> 然后进而触发<code>__get__()</code> 方法里所写的 <code>return self.fget(obj)</code> 即原本上我们所编写的 <code>def full_name</code> 内的执行代码。</p><p>这个时候，同志们可以去思考下 <code>getter()</code> ,<code>setter()</code> ,以及 <code>deleter()</code> 的具体运行机制了=。=如果还是有问题，欢迎在评论里进行讨论。</p><h3 id="关于描述符"><a href="#关于描述符" class="headerlink" title="关于描述符"></a>关于描述符</h3><p>还记得之前我们所提到的一个定义么：<strong>Descriptors 是一种特殊的对象，这种对象实现了 <code>__get__</code> ，<code>__set__</code> ，<code>__delete__</code> 这三个特殊方法</strong>。然后在 Python 官方文档的说明中，为了体现描述符的重要性，有这样一段话：“They are the mechanism behind properties, methods, static methods, class methods, and super(). They are used throughout Python itself to implement the new style classes introduced in version 2.2. ” 简而言之就是 <strong>先有描述符后有天，秒天秒地秒空气</strong>。恩，在新式类中，属性，方法调用，静态方法，类方法等都是基于描述符的特定使用。</p><p>OK，你可能想问，为什么描述符是这么重要呢？别急，我们接着看</p><h3 id="使用描述符"><a href="#使用描述符" class="headerlink" title="使用描述符"></a>使用描述符</h3><p>首先请看下一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>): <span class="comment">#注：在 Python 3.x 版本中，对于 new class 的使用不需要显式的指定从 object 类进行继承，如果在 Python 2.X（x&gt;2)的版本中则需要</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">a</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    a=A()</span><br><span class="line">    a.a()</span><br></pre></td></tr></table></figure><p>大家都注意到了我们存在着这样一个语句 <code>a.a()</code> ，好的，现在请大家思考下，我们在调用这个方法的时候发生了什么？<br>OK？想出来了么？没有？好的我们继续<br>首先我们调用一个属性的时候，不管是成员还是方法，我们都会触发这样一个方法用于调用属性 <code>__getattribute__()</code> ,在我们的 <code>__getattribute__()</code> 方法中，如果我们尝试调用的属性实现了我们的描述符协议，那么会产生这样一个调用过程 <code>type(a).__dict__[&#39;a&#39;].__get__(b,type(b))</code>。好的这里我们又要给出一个结论了：“在这样一个调用过程中，有这样一个优先级顺序，如果我们所尝试调用属性是一个 <code>data descriptors</code> ，那么不管这个属性是否存在我们的实例的 <code>__dict__</code> 字典中，优先调用我们描述符里的 <code>__get__</code> 方法，如果我们所尝试调用属性是一个 <code>non data descriptors</code>，那么我们优先调用我们实例里的 <code>__dict__</code> 里的存在的属性，如果不存在，则依照相应原则往上查找我们类，父类中的 <code>__dict__</code> 中所包含的属性，一旦属性存在，则调用 <code>__get__</code> 方法，如果不存在则调用 <code>__getattr__()</code> 方法”。理解起来有点抽象？没事，我们马上会讲，不过在这里，我们先要解释下 <code>data descriptors</code> 与 <code>non data descriptors</code>，再来看一个例子。什么是 <code>data descriptors</code> 与 <code>non data descriptors</code> 呢？其实很简单，在描述符中同时实现了 <code>__get__</code> 与 <code>__set__</code> 协议的描述符是 <code>data descriptors</code> ，如果只实现了 <code>__get__</code> 协议的则是 <code>non data descriptors</code> 。好了我们现在来看个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lazyproperty</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = self.func(instance)</span><br><span class="line">            <span class="built_in">setattr</span>(instance, self.func.__name__, value)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, radius</span>):</span><br><span class="line">        self.radius = radius</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @lazyproperty</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Com&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> math.pi * self.radius * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    c=Circle(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span>(c.area)</span><br></pre></td></tr></table></figure><p>好的，让我们仔细来看看这段代码，首先类描述符 <code>@lazyproperty</code> 的替换过程，前面已经说了，我们不在重复。接着，在我们第一次调用 <code>c.area</code> 的时候，我们首先查询实例 <code>c</code> 的 <code>__dict__</code> 中是否存在着 <code>area</code> 描述符，然后发现在 <code>c</code> 中既不存在描述符，也不存在这样一个属性，接着我们向上查询 <code>Circle</code> 中的 <code>__dict__</code> ，然后查找到名为 <code>area</code> 的属性，同时这是一个 <code>non data descriptors</code> ，由于我们的实例字典内并不存在 <code>area</code> 属性，那么我们便调用类字典中的 <code>area</code> 的 <code>__get__</code> 方法，并在 <code>__get__</code> 方法中通过调用 <code>setattr</code> 方法为实例字典注册属性 <code>area</code> 。紧接着，我们在后续调用 <code>c.area</code> 的时候，我们能在实例字典中找到 <code>area</code> 属性的存在，且类字典中的 <code>area</code> 是一个 <code>non data descriptors</code>，于是我们不会触发代码里所实现的 <code>__get__</code> 方法，而是直接从实例的字典中直接获取属性值。</p><h3 id="描述符的使用"><a href="#描述符的使用" class="headerlink" title="描述符的使用"></a>描述符的使用</h3><p>描述符的使用面很广，不过其主要的目的在于让我们的调用过程变得可控。因此我们在一些需要对我们调用过程实行精细控制的时候，使用描述符，比如我们之前提到的这个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lazyproperty</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = self.func(instance)</span><br><span class="line">            <span class="built_in">setattr</span>(instance, self.func.__name__, value)</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value=<span class="number">0</span></span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, radius</span>):</span><br><span class="line">        self.radius = radius</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @lazyproperty</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self, value=<span class="number">0</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Com&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> value == <span class="number">0</span> <span class="keyword">and</span> self.radius == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Something went wring&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> math.pi * value * <span class="number">2</span> <span class="keyword">if</span> value != <span class="number">0</span> <span class="keyword">else</span> math.pi * self.radius * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>利用描述符的特性实现懒加载，再比如，我们可以控制属性赋值的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Property</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;Emulate PyProperty_Type() in Objects/descrobject.c&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, fget=<span class="literal">None</span>, fset=<span class="literal">None</span>, fdel=<span class="literal">None</span>, doc=<span class="literal">None</span></span>):</span><br><span class="line">        self.fget = fget</span><br><span class="line">        self.fset = fset</span><br><span class="line">        self.fdel = fdel</span><br><span class="line">        <span class="keyword">if</span> doc <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> fget <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            doc = fget.__doc__</span><br><span class="line">        self.__doc__ = doc</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, obj, objtype=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">if</span> self.fget <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&quot;unreadable attribute&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.fget(obj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, obj, value=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;You can`t to set value as None&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.fset <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&quot;can&#x27;t set attribute&quot;</span>)</span><br><span class="line">        self.fset(obj, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delete__</span>(<span class="params">self, obj</span>):</span><br><span class="line">        <span class="keyword">if</span> self.fdel <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&quot;can&#x27;t delete attribute&quot;</span>)</span><br><span class="line">        self.fdel(obj)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getter</span>(<span class="params">self, fget</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(self)(fget, self.fset, self.fdel, self.__doc__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setter</span>(<span class="params">self, fset</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(self)(self.fget, fset, self.fdel, self.__doc__)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleter</span>(<span class="params">self, fdel</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>(self)(self.fget, self.fset, fdel, self.__doc__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Value</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Value.setter</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self, x</span>):</span><br><span class="line">            self.value = x</span><br></pre></td></tr></table></figure><p>如上面的例子所描述的一样，我们可以判断所传入的值是否有效等等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Python 中的描述符可以说是新式类调用链中的根基，所有的方法，成员，变量调用时都将会有描述符的介入。同时我们可以利用描述符的特性来将我们的调用过程变得更为可控。这一点，我们可以在很多著名框架中找到这样的例子。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="http://item.jd.com/11681561.html">《Python Cookbook》</a> 8.10 章 P271<br>2.<a href="https://docs.python.org/3/howto/descriptor.html">《Descriptor HowTo Guid》</a><br>3.<a href="http://www.jianshu.com/p/250f0d305c35">《Python 黑魔法》</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 编程技巧 </tag>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 3 中的函数参数命名规范指北</title>
      <link href="//posts/2016/10/09/Function-Naming-In-Swift-3/"/>
      <url>//posts/2016/10/09/Function-Naming-In-Swift-3/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="http://inaka.net/blog/2016/09/16/function-naming-in-swift-3/">Function Naming In Swift 3</a></li><li>原文作者：<a href="https://twitter.com/volbap">Pablo Villar</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>译者：<a href="https://github.com/Zheaoli">Zheaoli</a></li><li>校对者：<a href="https://github.com/Kulbear">Kulbear</a>, <a href="https://github.com/Tuccuay">Tuccuay</a></li></ul></blockquote><p>昨天，我开始将这个 <a href="http://inaka.net/blog/2016/05/09/meet-jayme/">Jayme</a> 迁移到 Swift 3。这是我第一次将一个项目从 Swift 2.2 迁移至 Swift 3。说实话这个过程十分的繁琐，由于 Swift 3 在老版本基础上发生了很多比较大的改变，我不得不承认眼前这样一个事实，除了花费较多的时间以外，没有其余的捷径可走。不过这样的经历也带来一点好处：我对 Swift 3 的理解变得更为深入，对我来讲，这可能是最好的消息了。😃</p><p>在迁移代码的过程中，我需要做出很多的选择。更为蛋疼的是，整个迁移过程并不是修改代码那么简单，你还需要用耐心去一点点适应 Swift 3 中带来的新变化。某种意义上来讲，修改代码只是整个迁移过程的开始而已。</p><p>如果你已经决定将你的代码迁移到 Swift 3 ，我建议你去看看这篇<a href="http://www.jessesquires.com/migrating-to-swift-3/">文章</a>来作为你万里长征的第一步。</p><p>如果一切顺利的话，在不久以后，我将回去写一篇博客来记录下整个迁移过程中的点点滴滴，包括我所作出的决定等等。但是眼前，我将会把注意力集中在一个非常非常重要的问题上：<strong>怎样正确的编写函数签名</strong>.<br><span id="more"></span></p><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>首先，让我们来看看在 Swift 3 与 Swift 2 相比函数命名方式的差异吧。</p><p>在 Swift 2 中，函数中的第一个参数的标签在调用时可以省略，这是为了遵循这样一个 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html">good ol’ Objective-C conventions</a> 标准。比如我们可以这样写代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift 2</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">handleError</span>(<span class="params">error</span>: <span class="type">NSError</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">let</span> error <span class="operator">=</span> <span class="type">NSError</span>()</span><br><span class="line">handleError(error) <span class="comment">// Looks like Objective-C</span></span><br></pre></td></tr></table></figure><p>在 Swift 3 中调用函数时，其实也是有办法省略第一个参数的标签的，但默认情况下不是这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift 3</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">handleError</span>(<span class="params">error</span>: <span class="type">NSError</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">let</span> error <span class="operator">=</span> <span class="type">NSError</span>()</span><br><span class="line">handleError(error)  <span class="comment">// Does not compile!</span></span><br><span class="line"><span class="comment">// ⛔ Missing argument label &#x27;error:&#x27; in call</span></span><br></pre></td></tr></table></figure><p>当遇到这样的情况时，我们第一反应可能是下面这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift 3</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">handleError</span>(<span class="params">error</span>: <span class="type">NSError</span>) &#123; &#125;</span><br><span class="line"><span class="keyword">let</span> error <span class="operator">=</span> <span class="type">NSError</span>()</span><br><span class="line">handleError(error: error)    </span><br><span class="line"><span class="comment">// Had to write &#x27;error&#x27; three times in a row!</span></span><br><span class="line"><span class="comment">// My eyes already hurt 🙈</span></span><br></pre></td></tr></table></figure><p>当然如果这样做，你肯定会很快意识到你的代码将将会变得有多坑爹。</p><p>如同前面所说的一样，在 Swift 3 中，我们是可以在调用函数时，将第一个参数的标签省略的，但是记住，你要去明确的告诉编译器这一点：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift 3</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">handleError</span>(<span class="keyword">_</span> <span class="params">error</span>: <span class="type">NSError</span>) &#123; &#125;</span><br><span class="line"><span class="comment">// 🖐 Notice the underscore!</span></span><br><span class="line"><span class="keyword">let</span> error <span class="operator">=</span> <span class="type">NSError</span>()</span><br><span class="line">handleError(error)  <span class="comment">// Same as in Swift 2</span></span><br></pre></td></tr></table></figure><blockquote><p>你可能在使用 Xcode 自带的迁移工具进行迁移时遇到这样的情况。</p></blockquote><p>注意，在函数签名中的下划线的意思是：告诉编译器，我们在调用函数时第一个参数不需要外带标签。这样，我们可以按照 Swift 2 中的方式去调用函数。</p><p>此外，你需要意识到，Swift 3 之所以修改了函数编写方式，是为了保证其一致性与可读性：我们不在需要对不同的参数区别对待。我想这可能是你遇到的第一个问题。</p><p>好了，现在代码可以编译运行了，但是你必须知道，你需要反复的去阅读 <a href="https://swift.org/documentation/api-design-guidelines/">Swift 3 API design guidelines</a> 一文。</p><blockquote><p>☝️ 一点微小的人生经验：你需要随时去诵读 <a href="https://swift.org/documentation/api-design-guidelines/">Swift 3 API design guidelines</a> 一文，这会为你解锁 Swift 开发的新体位。</p></blockquote><h2 id="第二步，精简你的代码"><a href="#第二步，精简你的代码" class="headerlink" title="第二步，精简你的代码"></a>第二步，精简你的代码</h2><p><img src="https://cloud.githubusercontent.com/assets/7054676/19221283/ef89dd06-8e72-11e6-97d4-d11f2f0a41db.jpg" alt="Pruning"></p><p>让我们再来看看之前的代码:</p><p>为了精简我们的代码，你可以将你的代码进行<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md#prune-redundant-type-names">修剪</a>一番，比如去除函数名里的类型信息等。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift 3</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">handle</span>(<span class="keyword">_</span> <span class="params">error</span>: <span class="type">NSError</span>) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">let</span> error <span class="operator">=</span> <span class="type">NSError</span>()</span><br><span class="line">handle(error)   <span class="comment">// Type name has been pruned</span></span><br><span class="line"><span class="comment">// from function name, since it was redundant</span></span><br></pre></td></tr></table></figure><p>如果你想让你的代码变得更短，更精悍，更明了的话，我给你们讲，作为一个钦定的开发者，一定要去反复诵读这篇 <a href="https://swift.org/documentation/api-design-guidelines/">Swift 3 API design guidelines</a> 文章到可以默写为止。</p><p>要注意让函数的调用过程是清晰、明确的，我们根据以下两点来确定函数的的命名和参数：</p><ul><li>我们知道函数的返回<strong>类型</strong></li><li>我们知道参数所对应的类型（比如在上面这个例子中，我们毫无疑问的知道其参数所属的类型是 <strong>NSError</strong>）。</li></ul><h2 id="更多的一些问题"><a href="#更多的一些问题" class="headerlink" title="更多的一些问题"></a>更多的一些问题</h2><p>现在请睁大眼睛看清楚我们下面所讨论的东西。 ⚠️</p><p>上面我们所讲的东西并没有包括所有可能出现的情况，换句话说，你可能遇到这样一种特殊情况，即，一个参数的类型没有办法直观的体现其作用。</p><p>让我们考虑下面这样一种情况：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift 2</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">requestForPath</span>(<span class="params">path</span>: <span class="type">String</span>) -&gt; <span class="type">URLRequest</span> &#123;  &#125;</span><br><span class="line"><span class="keyword">let</span> request <span class="operator">=</span> requestForPath(<span class="string">&quot;local:80/users&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果你想将代码迁移到 Swift 3 ，那么根据已有的知识，你可能会这么做：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift 3</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">request</span>(<span class="keyword">_</span> <span class="params">path</span>: <span class="type">String</span>) -&gt; <span class="type">URLRequest</span> &#123;  &#125;</span><br><span class="line"><span class="keyword">let</span> request <span class="operator">=</span> request(<span class="string">&quot;local:80/users&quot;</span>)</span><br></pre></td></tr></table></figure><p>讲真，这段代码看起来可读性很差，让我们稍微修改下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift 3</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">request</span>(<span class="params">for</span> <span class="params">path</span>: <span class="type">String</span>) -&gt; <span class="type">URLRequest</span> &#123;  &#125;</span><br><span class="line"><span class="keyword">let</span> request <span class="operator">=</span> request(for: <span class="string">&quot;local:80/users&quot;</span>)</span><br></pre></td></tr></table></figure><p>OK，现在看起来舒服多了，但是并没有解决我上面提到的问题。</p><p>在我们调用这个函数的时候，我们怎样很直观的知道我们需要给这个参数传递一个 Web Url 呢？你所能提前知道的是你需要传递一个 String 类型的变量进去，但是你并不清楚你需要传递一个 Web Url 进去。</p><p>同理，我们在一个大型项目中，我们需要很清楚的明白每个参数的作用所在，但是很明显，目前我们还没有解决这个大问题，比如:</p><ul><li>你怎么知道一个 <code>String</code> 类型的变量代表着 Web Url。</li><li>你怎么知道一个 <code>Int</code> 类型的变量代表着 Http 状态码。<code>[String: String]</code></li><li>你怎么知道一个 <code>[String: String]</code> 类型的变量代表着 Http Header。</li><li>等等…。</li></ul><blockquote><p>⚠️ 综上，我给你们一点微小的人生经验吧: <strong>谨慎精简你的代码</strong> ✄</p></blockquote><p>回到代码上，我们可以给参数添加上相对应的标签来解决这个问题，好了看看下面这个代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">request</span>(<span class="params">forPath</span> <span class="params">path</span>: <span class="type">String</span>) -&gt; <span class="type">URLRequest</span> &#123;  &#125;</span><br><span class="line"><span class="keyword">let</span> request <span class="operator">=</span> request(forPath: <span class="string">&quot;local:80/users&quot;</span>)</span><br></pre></td></tr></table></figure><p>好了，现在代码看起来是不是<strong>更清楚</strong>，<strong>可读性</strong>更强了呢？ 🎉 恭喜~</p><p><img src="http://inaka.net/assets/img/rick-hooray-confeti.gif" alt="Hooray"></p><blockquote><p>讲真，看到这里其实你可以关闭浏览器了，但是事实上，下面才是最精华的部分。</p></blockquote><p>好了，让我们来看看关于函数参命名的用词问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">request</span>(<span class="params">forPath</span> <span class="params">path</span>: <span class="type">String</span>) -&gt; <span class="type">URLRequest</span> &#123;  &#125;</span><br><span class="line"><span class="comment">// The word &#x27;path&#x27; appears twice</span></span><br></pre></td></tr></table></figure><p>这段代码看起来不错，但是如果你想让其变得更好，那么请看接下来的部分。</p><h2 id="你所不知道的小技巧"><a href="#你所不知道的小技巧" class="headerlink" title="你所不知道的小技巧"></a>你所不知道的小技巧</h2><p>这个小技巧很简单：在上下文中反映参数的类型及作用，这样你就可以无脑的精简你的代码了。</p><p><img src="http://inaka.net/assets/img/prune-with-no-mercy.gif" alt="Prune with no mercy"></p><p>呐，我们来看看下面这段代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Path</span> <span class="operator">=</span> <span class="type">String</span>      <span class="comment">// To the rescue!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">request</span>(<span class="params">for</span> <span class="params">path</span>: <span class="type">Path</span>) -&gt; <span class="type">URLRequest</span> &#123;  &#125;</span><br><span class="line"><span class="keyword">let</span> request <span class="operator">=</span> request(for: <span class="string">&quot;local:80/users&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，参数的类型和参数的作用表达达成了一个完美的统一，因为你在上下文中为 <code>String</code> 赋予了一个别名叫做 <code>Path</code>。</p><p>现在，你的函数看起来还是依旧的精简，可读性较高，但是却不重复。</p><p>以此类推，你可以使用同样的方式来书写一些优美的代码，比如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Path</span> <span class="operator">=</span> <span class="type">String</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">StatusCode</span> <span class="operator">=</span> <span class="type">Int</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">HTTPHeader</span> <span class="operator">=</span> [<span class="type">String</span>: <span class="type">String</span>]</span><br><span class="line"><span class="comment">// etc...</span></span><br></pre></td></tr></table></figure><p>如你所见，你可以尽情的写精简而优美的代码了。</p><p>不过，请记住，凡事走向极端便变了味了：这个小技巧会为你的代码添加额外的负担，特别是你们代码存在多重嵌套的情况下。因此请记住，如果你无脑的使用这样的小技巧的话，那么你可能会付出一些惨痛的代价。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>很多时候，你在使用　Swift 3 时，命名函数的时候你会遇到很多困难。</p><p>积累一些代码片段可能会帮助你很多：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">remove</span>(<span class="params">at</span> <span class="params">position</span>: <span class="type">Index</span>) -&gt; <span class="type">Element</span> &#123;  &#125;</span><br><span class="line">employees.remove(at: x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">remove</span>(<span class="keyword">_</span> <span class="params">member</span>: <span class="type">Element</span>) -&gt; <span class="type">Element</span>?  &#123;  &#125;</span><br><span class="line">allViews.remove(cancelButton)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">url</span>(<span class="params">forPath</span> <span class="params">path</span>: <span class="type">String</span>) -&gt; <span class="type">URL</span> &#123;  &#125;</span><br><span class="line"><span class="keyword">let</span> url <span class="operator">=</span> url(forPath: <span class="string">&quot;local:80/users&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Path</span> <span class="operator">=</span> <span class="type">String</span> <span class="comment">// Alternative</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">url</span>(<span class="params">for</span> <span class="params">path</span>: <span class="type">Path</span>) -&gt; <span class="type">URL</span> &#123;  &#125;</span><br><span class="line"><span class="keyword">let</span> url <span class="operator">=</span> url(for: <span class="string">&quot;local:80/users&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">entity</span>(<span class="params">from</span> <span class="params">dictionary</span>: [<span class="params">String</span>: <span class="keyword">Any</span>]) -&gt; <span class="type">Entity</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">let</span> entity <span class="operator">=</span> entity(from: [<span class="string">&quot;id&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊 Python 中生成器和协程那点事儿</title>
      <link href="//posts/2016/09/11/something-about-yield-in-python/"/>
      <url>//posts/2016/09/11/something-about-yield-in-python/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog">WeeklyBolg</a> 项目</li><li>itsCoder主页：<a href="http://itscoder.com/">http://itscoder.com/</a></li><li>作者：<a href="https://github.com/Zheaoli">Manjusaka</a></li><li>审阅者：<a href="https://github.com/wuchangfeng">allenwu</a>,<a href="https://github.com/brucezz">Brucezz</a></li></ul></blockquote><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>本来想这周继续写写 <strong>Flask</strong> 那点破事儿的，但是想了想决定换换口味，来聊聊很不容易理解但是很重要的 <strong>Python</strong> 中的生成器和协程。<br><span id="more"></span></p><h2 id="Generators-科普"><a href="#Generators-科普" class="headerlink" title="Generators 科普"></a>Generators 科普</h2><p>我猜大家对于生成器肯定并不陌生，但是为了能让我愉快的继续装逼，我们还是用点篇幅讲一下什么是生成器吧。<br>比如在 Python 里，我们想生成一个范围 (1,100000) 的一个 list，于是我们无脑写了如下的代码出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateList</span>(<span class="params">start,stop</span>):</span><br><span class="line">tempList=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,stop):</span><br><span class="line">tempList.append(i)</span><br><span class="line"><span class="keyword">return</span> tempList</span><br></pre></td></tr></table></figure><blockquote><p>注1：这里有同学提出了为什么我们不直接返回 <code>range(start,stop)</code>，Nice question，这里涉及到一个基础问题，<code>range</code> 的机制究竟是怎样的。这就要分版本而论了，在 Python 2.x 的版本中，<code>range(start,stop)</code> 其实本质上是预先生成一个 <code>list</code> ,而 <code>list</code> 对象是一个 <strong>Iterator</strong> ，因此可以被 <code>for</code> 语句所使用。<br><img src="https://cloud.githubusercontent.com/assets/7054676/18607847/90092cf6-7d0b-11e6-9963-8f59f8ebbb28.png" alt="Python 2.x 中的 range"><br>然后在 Python 2.x 中还有一个语句叫做 <code>xrange</code> ，其生成的是一个 <strong>Generator</strong> 对象。<br><img src="https://cloud.githubusercontent.com/assets/7054676/18607857/cf72561a-7d0b-11e6-9084-bc8a02404ed1.png" alt="Python 2.x 中的 xrange"><br>在 Python 3 中事情发生了一点变化，可能社区觉得 <code>range</code> 和 <code>xrange</code> 分裂太过蛋疼，于是将其合并，于是现在在 Python 3 中，取消了 <code>xrange</code> 的语法糖，然后 <code>range</code> 的机制也变成生成一个 <strong>Generator</strong> 而不是 <code>list</code><br><img src="https://cloud.githubusercontent.com/assets/7054676/18607878/6fc147f2-7d0c-11e6-9384-d1dd748ffb5d.png" alt="Python 3 中的 range"></p></blockquote><p>但是大家考虑过一个问题么，如果我们想生成数据量非常大，预先生成数据的行为无疑是很不明智的，这样会耗费大量的内存。于是 Python 给我们提供了一种新的姿势，<strong>Generator</strong> (生成器)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateList1</span>(<span class="params">start,stop</span>):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,stop):</span><br><span class="line"><span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">c=generateList1(<span class="number">1</span>,<span class="number">100000</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line"><span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>是的，<strong>Generator</strong> 其中一个特性就是不是一次性生成数据，而是生成一个可迭代的对象，在迭代时，根据我们所写的逻辑来控制其启动时机。</p><h2 id="Generator-深入"><a href="#Generator-深入" class="headerlink" title="Generator 深入"></a>Generator 深入</h2><p>这里可能有一个问题，大家肯定想问 <strong>Python</strong> 开发者们不可能为了这一种使用场景而去单独创建一个 <strong>Generator</strong> 机制吧，那么我们 <strong>Generator</strong> 还有其余的使用场景么。当然，请看标题，对了嘛，<strong>Generator</strong> 另一个很大作用可以说就是当做协程使用。不过在这之前，我们要去深入的了解下 <strong>Generator</strong> 才能方便我们后面的讲解。</p><h3 id="关于-Generator-中的内建方法"><a href="#关于-Generator-中的内建方法" class="headerlink" title="关于 Generator 中的内建方法"></a>关于 Generator 中的内建方法</h3><h4 id="关于-Python-中可迭代对象的一点背景知识"><a href="#关于-Python-中可迭代对象的一点背景知识" class="headerlink" title="关于 Python 中可迭代对象的一点背景知识"></a>关于 Python 中可迭代对象的一点背景知识</h4><p>首先，我们来看看 Python 中的迭代过程。<br>在 Python 中迭代有两个概念，一个是 <strong>Iterable</strong> ，另一个是 <strong>Iterator</strong> 。让我们分别来看看<br>第N次首先，<strong>Iterable</strong> 近似的可以理解成为一个协议，判断一个 <strong>Object</strong> 是否是 <strong>Iterable</strong> 的方法就是看其实现了 <strong><strong>iter</strong></strong> 与否，如果实现了 <strong><strong>iter</strong></strong> ，那么这便可以认为是一个 <strong>Iterable</strong> 对象。空谈误国，实干兴邦，让我们直接来看一段代码理解下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, low, high</span>):</span><br><span class="line">        self.current = low</span><br><span class="line">        self.high = high</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>):  <span class="comment"># Python 3: def __next__(self)</span></span><br><span class="line">        <span class="keyword">if</span> self.current &gt; self.high:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.current - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">a=Counter(<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> a:</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><p>好了，让我们来看看上面这段代码里发生了什么，首先 <code>for</code> 语句的引用首先去判断迭代的是 <strong>Iterable</strong> 对象还是 <strong>Iterator</strong> 对象，如果是实现了 <code>__iter__</code> 方法的对象，那么就是一个 <strong>Iterable</strong> 对象，<code>for</code> 循环首先调用对象的 <code>__iter__</code> 方法来获取一个 <strong>Iterator</strong> 对象。那么什么是 <strong>Iterator</strong> 对象呢，这里可以近似的理解为是实现了 <strong>next()</strong> 方法（注：在Python3中是 <strong><strong>next</strong></strong> 方法)。</p><p>OK，让我们继续回到刚刚说到的那里，在上面的代码中 <code>for</code> 语句首先判断是一个 <strong>Iterable</strong> 对象还是 <strong>Iterator</strong> 对象，如果是 <strong>Iterable</strong> 对象那么调用其 <strong><strong>iter</strong></strong> 方法来获取一个 <strong>Iterator</strong> 对象，接着 <code>for</code> 循环会调用 <strong>Iterator</strong> 对象中的 <code>next()</code> （注：Python3 里是 <code>__next__</code>)方法来进行迭代，直到迭代过程结束抛出 <code>StopIteration</code> 异常。</p><h4 id="好了，来聊聊-Generator-吧"><a href="#好了，来聊聊-Generator-吧" class="headerlink" title="好了，来聊聊 Generator 吧"></a>好了，来聊聊 <strong>Generator</strong> 吧</h4><p>让我们先看看前面那段代码吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateList1</span>(<span class="params">start,stop</span>):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,stop):</span><br><span class="line"><span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">c=generateList1(<span class="number">1</span>,<span class="number">100000</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> generateList1:</span><br><span class="line"><span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>首先我们要确定一点的是 <strong>Generator</strong> 其实也是一个 <strong>Iterator</strong> 对象。OK 让我们来看看上面这段代码，首先 <code>for</code> 确定 <code>generateList1</code> 是一个 <strong>Iterator</strong> 对象，然后开始调用 <code>next()</code> 方法进行进一步迭代。OK 此时你肯定想问这里面 <code>next()</code> 方法是怎样让 <code>generateList1</code> 进一步往下迭代的呢？答案在于 <strong>Generator</strong> 的内建 <code>send()</code> 方法。我们还是来看一段代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generateList1</span>(<span class="params">start,stop</span>):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,stop):</span><br><span class="line"><span class="keyword">yield</span> i</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">a=generateList1(<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line"><span class="built_in">print</span>(a.send(<span class="literal">None</span>))</span><br></pre></td></tr></table></figure><p>这里我们应该输出什么？答案就是 <code>0,1,2,3,4</code> ，结果上和我们用 <code>for</code> 循环进行运算的结果是不是一样。好了，我们现在可以得出一个结论就是</p><blockquote><p><strong>Generator</strong> 迭代的本质就是通过内建的 <code>next()</code> 或 <code>__next__()</code> 方法来调用内建的 <code>send()</code> 方法。</p></blockquote><h3 id="继续吐槽-Generator-的内建方法"><a href="#继续吐槽-Generator-的内建方法" class="headerlink" title="继续吐槽 Generator 的内建方法"></a>继续吐槽 <strong>Generator</strong> 的内建方法</h3><p>前面我们提到一个结论</p><blockquote><p><strong>Generator</strong> 迭代的本质就是通过内建的 <code>next()</code> 或 <code>__next__()</code> 方法来调用内建的 <code>send()</code> 方法。</p></blockquote><p>现在我们来看个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Counting down from&quot;</span>, n</span><br><span class="line">    <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">        newvalue = (<span class="keyword">yield</span> n)</span><br><span class="line">        <span class="comment"># If a new value got sent in, reset n with it</span></span><br><span class="line">        <span class="keyword">if</span> newvalue <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            n = newvalue</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">c = countdown(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> c:</span><br><span class="line">    <span class="built_in">print</span> x</span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">5</span>:</span><br><span class="line">        c.send(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>好了这段代码的输出应该是什么？<br>答案是 <code>[5，2，1，0]</code> ，是不是很迷惑？别急，我们先来看看这段代码的运行流程</p><p><img src="https://cloud.githubusercontent.com/assets/7054676/18417878/b17e6636-786e-11e6-9182-0e7a69b5611f.png" alt="代码运行流程"></p><p>简而言之就是，当我们调用 <code>send()</code> 函数的时候，我们 <code>send(x)</code> 的值会发送给 <code>newvalue</code> 向下继续执行直到遇到下一次 <code>yield</code> 的出现，然后返回值作为一个过程的结束。然后我们的 <strong>Generator</strong> 静静的沉睡在内存中，等待下一次的 <code>send</code> 来唤醒它。</p><blockquote><p>注2：有同志问：“这里没想明白，c.send(3) 是 相当于 yield n 返回了个 3 给 newvalue ?”，好的，nice question，其实这个问题我们看前面之前的代码运行图就知道， <code>c.send(3)</code> 首先，将 <code>3</code> 赋值给 <code>newvalue</code> ，然后程序运行剩下的代码，直到遇到下一个 <code>yield</code> 为止，那么在这里，我们运行剩下完代码，在遇到 <code>yiled n</code> 之前，将 <code>n</code> 的值已经改变为 <code>3</code> ,接着，<code>yield n</code> 即约等于 <code>return 3</code>。接着 <code>countdown</code> 这个 <strong>Generator</strong> 将所有变量的状态冻结，然后静静的呆在内存中，等待下一次的 <code>next</code> 或 <code>__next__()</code> 方法或者是 <code>send()</code> 方法的唤醒。</p><p>小贴士：我们如果直接调用 <code>send()</code> 的话，第一次请务必 <code>send(None)</code> 只有这样一个 <strong>Generator</strong> 才算是真正被激活了。我们才能进行下一步操作。</p></blockquote><h2 id="说说关于协程"><a href="#说说关于协程" class="headerlink" title="说说关于协程"></a>说说关于协程</h2><p>首先关于协程的定义，我们来看一段 wiki</p><blockquote><p>Coroutines are computer program components that generalize subroutines for nonpreemptive multitasking, by allowing multiple entry points for suspending and resuming execution at certain locations. Coroutines are well-suited for implementing more familiar program components such as cooperative tasks, exceptions, event loop, iterators, infinite lists and pipes.<br>According to Donald Knuth, the term coroutine was coined by Melvin Conway in 1958, after he applied it to construction of an assembly program.[1] The first published explanation of the coroutine appeared later, in 1963.</p></blockquote><p>简而言之，协程是比线程更为轻量的一种模型，我们可以自行控制启动与停止的时机。在 <strong>Python</strong> 中其实没有专门针对协程的这个概念，社区一般而言直接将 <strong>Generator</strong> 作为一种特殊的协程看待，想想，我们可以用 <code>next</code> 或 <code>__next__()</code> 方法或者是 <code>send()</code> 方法唤醒我们的 <strong>Generator</strong> ，在运行完我们所规定的代码后， <strong>Generator</strong> 返回并将其所有状态冻结。这是不是很让我们 Excited 呢！！</p><h2 id="关于-Generator-的一点课后作业"><a href="#关于-Generator-的一点课后作业" class="headerlink" title="关于 Generator 的一点课后作业"></a>关于 <strong>Generator</strong> 的一点课后作业</h2><p>现在我们要后序遍历二叉树，我知道看这篇文章神犇们都能无脑写出来的，让我们看看代码先：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val, left, right</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visit_post</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> node.left:</span><br><span class="line">        <span class="keyword">return</span> visit_post(node.left)</span><br><span class="line">    <span class="keyword">if</span> node.right:</span><br><span class="line">        <span class="keyword">return</span> visit_post(node.right)</span><br><span class="line">    <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    node = Node(-<span class="number">1</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        node = Node(val, <span class="literal">None</span>, node)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>(visit_post(node)))</span><br></pre></td></tr></table></figure><p>但是，我们知道递归深度太深的话，我们要么爆栈要么 py 交易失败，OK ，<strong>Generator</strong> 大法好，把你码农平安保，还是直接看代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">visit_post</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> node.left:</span><br><span class="line">        <span class="keyword">yield</span> node.left</span><br><span class="line">    <span class="keyword">if</span> node.right:</span><br><span class="line">        <span class="keyword">yield</span> node.right</span><br><span class="line">    <span class="keyword">yield</span> node.val</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visit</span>(<span class="params">node, visit_method</span>):</span><br><span class="line">    stack = [visit_method(node)]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        last = stack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            yielded = <span class="built_in">next</span>(last)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(yielded, Node):</span><br><span class="line">                stack.append(visit_method(yielded))</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(yielded, <span class="built_in">int</span>):</span><br><span class="line">                <span class="keyword">yield</span> yielded</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    node = Node(-<span class="number">1</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        node = Node(val, <span class="literal">None</span>, node)</span><br><span class="line">    visit_generator = visit(node, visit_method=visit_post)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">list</span>(visit_generator))</span><br></pre></td></tr></table></figure></p><p>看起来很复杂是不是？没事当做课后作业，大家可以在评论里给我留言，我们一起进行一下 py 交易吧~</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1.<a href="http://www.oschina.net/translate/improve-your-python-yield-and-generators-explained">提高你的Python: 解释‘yield’和‘Generators（生成器）’</a><br>2.<a href="http://www.jianshu.com/p/b37a92a5ada0">yield大法好</a><br>3.<a href="http://my.oschina.net/1123581321/blog/160560">http://my.oschina.net/1123581321/blog/160560</a><br>4.<a href="https://www.zhihu.com/question/44015086">python的迭代器为什么一定要实现<strong>iter</strong>方法</a>(关于迭代器那离，为了便于理解，我简化了一些东西，具体可以参看这个问题的高票答案)</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> 编程技巧 </tag>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「最简单」的 Core Data 上手指南</title>
      <link href="//posts/2016/09/01/the-easiest-core-data/"/>
      <url>//posts/2016/09/01/the-easiest-core-data/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="http://albertodebortoli.com/blog/2016/08/05/the-easiest-core-data/">The Easiest Core Data</a></li><li>原文作者：<a href="http://albertodebortoli.com/">Alberto De Bortoli</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>译者：<a href="https://github.com/Zheaoli">Zheaoli</a></li><li>校对者：<a href="https://github.com/Kulbear">Kulbear</a>, <a href="https://github.com/cbangchen">cbangchen</a></li></ul></blockquote><p>在过去的几个月里，我花费了大量的时间在研究 Core Data 之上，我得去处理一个使用了很多陈旧的代码，糟糕的 Core Data 以及违反了多线程安全的项目。讲真，Core Data 学习起来非常的困难，在学习 Core Data 的时候，你肯定会感到迷惑和一种深深的挫败感。正是因为这些原因，我决定给出一种超级简单的解决方案。这个方案的特点就是简洁，线程安全，非常易于使用，这个方案能满足你大部分对于 Core Data 的需求。在经过若干次的迭代后，我所设计的方案最终成为一个成熟的方案。<br><span id="more"></span><br>OK，女士们，先生们，现在请允许我隆重向您介绍 <a href="https://github.com/albertodebortoli/Skiathos">Skiathos</a> 和 <a href="https://github.com/albertodebortoli/Skopelos">Skopelos</a>。其中 <strong>Skiathos</strong> 是基于 <strong>Objective-C</strong> 所开发的，而 <strong>Skopelos</strong> 则基于 <strong>Swift</strong> 所开发的。这两个框架的名字来源于希腊的两个岛，在这里，我渡过了2016年的夏天，同时，在这里完成了两个框架的编写工作。</p><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>整个项目的目的就是能够让您以及其简便的方式在您的 App 中引入 Core Data。</p><p>我们将从如下几个方面来进行一个介绍:</p><ul><li>CoreDataStack</li><li>AppStateReactor</li><li>DALService (Data Access Layer)</li></ul><h3 id="CoreDataStack"><a href="#CoreDataStack" class="headerlink" title="CoreDataStack"></a>CoreDataStack</h3><p>如果你有过使用 Core Data 的经验，那么你应该知道创建一个堆栈是一个充满陷阱的过程。这个组件是用于创建堆栈（用于管理 <strong>Obejct Context</strong> ），具体的设计说明可以参看 Marcus Zarra 所写的这篇<a href="http://martiancraft.com/blog/2015/03/core-data-stack/">文章</a>。</p><p><img src="https://s3.amazonaws.com/albertodebortoli.github.com/images/coredata/coredatastack.png" alt=""></p><p>其中一个和 Magical Record 或者其余第三方插件不同的是，整个存储过程都是在一个方向上发起的，可能是从某个子节点向下或者向上传递来进行持久化储存。其余的组件允许你创建以 <strong>private context</strong> 作为父节点的子节点，这将会导致 <strong>main context</strong> 不能被更新，同时只能通过通知的方式来进行合并更新。<strong>main context</strong> 是相对固定的并与 <strong>UI</strong> 进行了绑定：这样较为简单的方式可以帮助开发者更好的去完成一个 APP 的开发。</p><h3 id="AppStateReactor"><a href="#AppStateReactor" class="headerlink" title="AppStateReactor"></a>AppStateReactor</h3><p>唔，其实你可以忽略这一段。这个组件属于 CoreDataStack ，在 App 切换至后台，失去节点，或者即将退出时，它负责监视相对应的修改，并把其保存。</p><h3 id="DALService-Data-Access-Layer-Skiathos-Skopelos"><a href="#DALService-Data-Access-Layer-Skiathos-Skopelos" class="headerlink" title="DALService (Data Access Layer) / (Skiathos/Skopelos)"></a>DALService (Data Access Layer) / (Skiathos/Skopelos)</h3><p>如果你拥有使用 Core Data 的经验，那么你也应该知道，我们大部分操作都是重复的，我们经常在一个 context 中调用 <code>performBlock:/performBlockAndWait:</code> 函数，而这个 Context 提供了一个最终会调用 <code>save:</code> 作为最终语句的 block 。数据库的所有操作都是基于 API 中所提供的 <code>read:</code> 和 <code>write:</code> ：这两个协议提供了 CQRS （命令和查询分离） 的实现。用于读取的代码块将在主体中进行运行（因为这被认为是一个已确定的单个资源）。用于写入的代码块将会在一个子线程中运行，这样可以保证实时的进行数据储存，变化的数据将会在不会阻塞主线程的情况下通过异步的方式进行储存。<code>write:completion:</code> 方法将会程序运行完后来对数据的更改进行持久化储存。</p><p>换句话说，写入的数据在 <code>main managed object context</code> 和最后持久化过程中都会保证其一致性。在 主要管理对象的 <code>context</code> 中，相应的数据也能保证其可用性。</p><p><code>Skiathos</code>/<code>Skopelos</code> 是 <code>DALService</code> 的子类, 这样可以给这个组件一个比较好听的名字。</p><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><p>在使用这一系列组件之前，你首先需要创建一个类型为 <code>Skiathos</code> 的属性，然后以下面这种方式去初始化它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.skiathos = [Skiathos setupInMemoryStackWithDataModelFileName:@&quot;&lt;#datamodelfilename&gt;&quot;];</span><br><span class="line">// or</span><br><span class="line">self.skiathos = [Skiathos setupSqliteStackWithDataModelFileName:@&quot;&lt;#datamodelfilename&gt;&quot;];</span><br></pre></td></tr></table></figure><p>在使用 <code>Skopelos</code> 时，代码如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.skopelos <span class="operator">=</span> <span class="type">SkopelosClient</span>(inMemoryStack: <span class="string">&quot;&lt;#datamodelfilename&gt;&quot;</span>)</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">self</span>.skopelos <span class="operator">=</span> <span class="type">SkopelosClient</span>(sqliteStack: <span class="string">&quot;&lt;#datamodelfilename&gt;&quot;</span>)</span><br></pre></td></tr></table></figure><p>你可以通过使用依赖注入的方式来在应用的其余地方使用这些对象。不得不说，为 Core Data 栈上的不同对象创建单例是一种很不错的做法。当然，不断的创建实例的开销是十分巨大的。通常来讲，我们不是很推荐使用单例模式。单例模式的测试性不强，在使用过程中，使用者无法有效的控制其声明周期，这样可能会违背一些最佳实践的编程原则。正是因为如此，在这个库里，我们不推荐使用单例。</p><p>由于下面几个原因，你在使用时需要从 <code>Skiathos</code>/<code>Skopelos</code> 进行继承：</p><ul><li>创建一个全局可共享的实例。</li><li>重载 <code>handleError(error: NSError)</code> 方法，以便在你的程序里出现一些错误时，这个方法能够正常的被调用。</li></ul><p>为了创建单例，你应该如下面的示例一样去从 <code>Skiathos</code>/<code>Skopelos</code> 进行继承：</p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">SkiathosClient</span> : <span class="type">Skiathos</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">SkiathosClient</span> <span class="operator">*</span>)sharedInstance;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">SkiathosClient</span> <span class="operator">*</span>sharedInstance <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="meta">@implementation</span> <span class="type">SkiathosClient</span></span><br><span class="line"><span class="operator">+</span> (<span class="type">SkiathosClient</span> <span class="operator">*</span>)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(<span class="operator">&amp;</span>onceToken, <span class="operator">^</span>&#123;</span><br><span class="line">        sharedInstance <span class="operator">=</span> [<span class="keyword">self</span> setupSqliteStackWithDataModelFileName:@<span class="string">&quot;&lt;#datamodelfilename&gt;&quot;</span>];</span><br><span class="line"><span class="operator">&lt;/</span>#datamodelfilename<span class="operator">&gt;</span>    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">-</span> (void)handleError:(<span class="type">NSError</span> <span class="operator">*</span>)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// clients should do the right thing here</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;%@&quot;</span>, error.description);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SkopelosClient</span>: <span class="title class_">Skopelos</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance <span class="operator">=</span> <span class="type">Skopelos</span>(sqliteStack: <span class="string">&quot;DataModel&quot;</span>)</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">handleError</span>(<span class="params">error</span>: <span class="type">NSError</span>) &#123;</span><br><span class="line">        <span class="comment">// clients should do the right thing here</span></span><br><span class="line">        <span class="built_in">print</span>(error.description)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><p>写到这里，让我们同时看看在一个标准 Core Data 的操作方式和我们组件所提供的方式吧。</p><p>标准的读取姿势:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__block NSArray *results = nil;</span><br><span class="line">NSManagedObjectContext *context = ...;</span><br><span class="line">[context performBlockAndWait:^&#123;</span><br><span class="line">    NSFetchRequest *request = [[NSFetchRequest alloc] init];</span><br><span class="line">    NSEntityDescription *entityDescription = [NSEntityDescription entityForName:NSStringFromClass(User)</span><br><span class="line">    inManagedObjectContext:context];</span><br><span class="line">    [request setEntity:entityDescription];</span><br><span class="line">    NSError *error;</span><br><span class="line">    results = [context executeFetchRequest:request error:&amp;error];</span><br><span class="line">&#125;];</span><br><span class="line">return results;</span><br></pre></td></tr></table></figure><p>标准的写入姿势:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSManagedObjectContext *context = ...;</span><br><span class="line">[context performBlockAndWait:^&#123;</span><br><span class="line">    User *user = [NSEntityDescription insertNewObjectForEntityForName:NSStringFromClass(User)</span><br><span class="line">    inManagedObjectContext:context];</span><br><span class="line">    user.firstname = @&quot;John&quot;;</span><br><span class="line">    user.lastname = @&quot;Doe&quot;;</span><br><span class="line">    NSError *error;</span><br><span class="line">    [context save:&amp;error];</span><br><span class="line">    if (!error)</span><br><span class="line">    &#123;</span><br><span class="line">        // continue to save back to the store</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><code>Skiathos</code> 中的读取姿势：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[SkiathosClient sharedInstance] read:^(NSManagedObjectContext *context) &#123;</span><br><span class="line">    NSArray *allUsers = [User allInContext:context];</span><br><span class="line">    NSLog(@&quot;All users: %@&quot;, allUsers);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><code>Skiathos</code> 中的写入姿势：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Sync</span><br><span class="line">[[SkiathosClient sharedInstance] writeSync:^(NSManagedObjectContext *context) &#123;</span><br><span class="line">    User *user = [User createInContext:context];</span><br><span class="line">    user.firstname = @&quot;John&quot;;</span><br><span class="line">    user.lastname = @&quot;Doe&quot;;</span><br><span class="line">&#125;];</span><br><span class="line">[[SkiathosClient sharedInstance] writeSync:^(NSManagedObjectContext *context) &#123;</span><br><span class="line">    User *user = [User createInContext:context];</span><br><span class="line">    user.firstname = @&quot;John&quot;;</span><br><span class="line">    user.lastname = @&quot;Doe&quot;;</span><br><span class="line">&#125; completion:^(NSError *error) &#123;</span><br><span class="line">    // changes are saved to the persistent store</span><br><span class="line">&#125;];</span><br><span class="line">// Async</span><br><span class="line">[[SkiathosClient sharedInstance] writeAsync:^(NSManagedObjectContext *context) &#123;</span><br><span class="line">    User *user = [User createInContext:context];</span><br><span class="line">    user.firstname = @&quot;John&quot;;</span><br><span class="line">    user.lastname = @&quot;Doe&quot;;</span><br><span class="line">&#125;];</span><br><span class="line">[[SkiathosClient sharedInstance] writeAsync:^(NSManagedObjectContext *context) &#123;</span><br><span class="line">    User *user = [User createInContext:context];</span><br><span class="line">    user.firstname = @&quot;John&quot;;</span><br><span class="line">    user.lastname = @&quot;Doe&quot;;</span><br><span class="line">&#125; completion:^(NSError *error) &#123;</span><br><span class="line">    // changes are saved to the persistent store</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><code>Skiathos</code> 当然也支持链式调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__block User *user = nil;</span><br><span class="line">[SkiathosClient sharedInstance].write(^(NSManagedObjectContext *context) &#123;</span><br><span class="line">    user = [User createInContext:context];</span><br><span class="line">    user.firstname = @&quot;John&quot;;</span><br><span class="line">    user.lastname = @&quot;Doe&quot;;</span><br><span class="line">&#125;).write(^(NSManagedObjectContext *context) &#123;</span><br><span class="line">    User *userInContext = [user inContext:context];</span><br><span class="line">    [userInContext deleteInContext:context];</span><br><span class="line">&#125;).read(^(NSManagedObjectContext *context) &#123;</span><br><span class="line">    NSArray *users = [User allInContext:context];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果是在 Swift中，代码将会变成下面这个样子</p><p>读取：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SkopelosClient</span>.sharedInstance.read &#123; context <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> users <span class="operator">=</span> <span class="type">User</span>.<span class="type">SK_all</span>(context)</span><br><span class="line">    <span class="built_in">print</span>(users)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync</span></span><br><span class="line"><span class="type">SkopelosClient</span>.sharedInstance.writeSync &#123; context <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> user <span class="operator">=</span> <span class="type">User</span>.<span class="type">SK_create</span>(context)</span><br><span class="line">    user.firstname <span class="operator">=</span> <span class="string">&quot;John&quot;</span></span><br><span class="line">    user.lastname <span class="operator">=</span> <span class="string">&quot;Doe&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SkopelosClient</span>.sharedInstance.writeSync(&#123; context <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> user <span class="operator">=</span> <span class="type">User</span>.<span class="type">SK_create</span>(context)</span><br><span class="line">    user.firstname <span class="operator">=</span> <span class="string">&quot;John&quot;</span></span><br><span class="line">    user.lastname <span class="operator">=</span> <span class="string">&quot;Doe&quot;</span></span><br><span class="line">    &#125;, completion: &#123; (error: <span class="type">NSError</span>?) <span class="keyword">in</span></span><br><span class="line">        <span class="comment">// changes are saved to the persistent store</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Async</span></span><br><span class="line"><span class="type">SkopelosClient</span>.sharedInstance.writeAsync &#123; context <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> user <span class="operator">=</span> <span class="type">User</span>.<span class="type">SK_create</span>(context)</span><br><span class="line">    user.firstname <span class="operator">=</span> <span class="string">&quot;John&quot;</span></span><br><span class="line">    user.lastname <span class="operator">=</span> <span class="string">&quot;Doe&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">SkopelosClient</span>.sharedInstance.writeAsync(&#123; context <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> user <span class="operator">=</span> <span class="type">User</span>.<span class="type">SK_create</span>(context)</span><br><span class="line">    user.firstname <span class="operator">=</span> <span class="string">&quot;John&quot;</span></span><br><span class="line">    user.lastname <span class="operator">=</span> <span class="string">&quot;Doe&quot;</span></span><br><span class="line">&#125;, completion: &#123; (error: <span class="type">NSError</span>?) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// changes are saved to the persistent store</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>链式调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SkopelosClient</span>.sharedInstance.write &#123; context <span class="keyword">in</span></span><br><span class="line">    user <span class="operator">=</span> <span class="type">User</span>.<span class="type">SK_create</span>(context)</span><br><span class="line">    user.firstname <span class="operator">=</span> <span class="string">&quot;John&quot;</span></span><br><span class="line">    user.lastname <span class="operator">=</span> <span class="string">&quot;Doe&quot;</span></span><br><span class="line">&#125;.write &#123; context <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> userInContext <span class="operator">=</span> user.<span class="type">SK_inContext</span>(context) &#123;</span><br><span class="line">        userInContext.<span class="type">SK_remove</span>(context)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.read &#123; context <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> users <span class="operator">=</span> <span class="type">User</span>.<span class="type">SK_all</span>(context)</span><br><span class="line">    <span class="built_in">print</span>(users)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NSManagedObject</code> 类所提供了非常清楚的 <strong>CRUD</strong> 方法。在作为读/写代码块的参数传递之时，对象应该被作为一个整体进行处理。你应该优先使用这些内建的方法。主要的方法有下面这些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)SK_createInContext:(NSManagedObjectContext *)context;</span><br><span class="line">+ (NSUInteger)SK_numberOfEntitiesInContext:(NSManagedObjectContext *)context;</span><br><span class="line">- (void)SK_deleteInContext:(NSManagedObjectContext *)context;</span><br><span class="line">+ (void)SK_deleteAllInContext:(NSManagedObjectContext *)context;</span><br><span class="line">+ (NSArray *)SK_allInContext:(NSManagedObjectContext *)context;</span><br><span class="line">+ (NSArray *)SK_allWithPredicate:(NSPredicate *)pred inContext:(NSManagedObjectContext *)context;</span><br><span class="line">+ (instancetype)SK_firstInContext:(NSManagedObjectContext *)context;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">SK_create</span>(<span class="params">context</span>: <span class="type">NSManagedObjectContext</span>) -&gt; <span class="keyword">Self</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">SK_numberOfEntities</span>(<span class="params">context</span>: <span class="type">NSManagedObjectContext</span>) -&gt; <span class="type">Int</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">SK_remove</span>(<span class="params">context</span>: <span class="type">NSManagedObjectContext</span>) -&gt; <span class="type">Void</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">SK_removeAll</span>(<span class="params">context</span>: <span class="type">NSManagedObjectContext</span>) -&gt; <span class="type">Void</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">SK_all</span>(<span class="params">context</span>: <span class="type">NSManagedObjectContext</span>) -&gt; [<span class="keyword">Self</span>]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">SK_all</span>(<span class="params">predicate</span>: <span class="type">NSPredicate</span>, <span class="params">context</span>:<span class="type">NSManagedObjectContext</span>) -&gt; [<span class="keyword">Self</span>]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">SK_first</span>(<span class="params">context</span>: <span class="type">NSManagedObjectContext</span>) -&gt; <span class="keyword">Self</span><span class="operator">?</span></span><br></pre></td></tr></table></figure><p>注意，在使用 <code>SK_inContext(context: NSManagerObjectContext)</code> 时，不同的读写代码块可能会得到同一个对象。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>所有 DALService 所产生的实例都可以认为是线程安全的。</p><p>我们特别建议你在项目中进行这样的设置 <code>-com.apple.CoreData.ConcurrencyDebug 1</code> ，这可以确保你不会在多线程和并发的情况下滥用 Core Data。</p><p>这个组件不是为了通过隐藏 <code>ManagedObjectContext:</code> 的概念来达到接口引入的目的：它将会在客户端中引入更多的线程问题，因为开发者有责任去检查所调用线程的类型（而那将会是在忽视 Core Data 所带给我们的好处）。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解模板引擎工作机制</title>
      <link href="//posts/2016/08/13/How-a-template-engine-works/"/>
      <url>//posts/2016/08/13/How-a-template-engine-works/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://fengsp.github.io/blog/2016/8/how-a-template-engine-works/">How a template engine works</a></li><li>原文作者：<a href="https://twitter.com/_fengsp">Shipeng Feng</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>译者： <a href="https://github.com/Zheaoli">Zheaoli</a></li><li>校对者：<a href="https://github.com/Kulbear">Kulbear</a>, <a href="https://github.com/hpoenixf">hpoenixf</a></li></ul></blockquote><p>我已经使用各种模版引擎很久了，现在终于有时间研究一下模版引擎到底是如何工作的了。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>简单的说，模版引擎是一种可以用来完成涉及大量文本数据的编程任务的工具。一般而言，我们经常在一个 <strong>web</strong> 应用中利用模板引擎来生成 <strong>HTML</strong> 。在 <strong>Python</strong> 中，当你想使用模板引擎的时候，你会发现你有不少的选择，比如<a href="http://jinja.pocoo.org/">jinja</a> 或者是<a href="http://www.makotemplates.org/">mako</a>。从现在开始，我们将利用 <a href="https://github.com/tornadoweb/tornado"><strong>tornado</strong></a> 中的模板引擎来讲解模板引擎的工作原理，在 <strong>tornado</strong> 中，自带的模板引擎相对的简单，能方便我们去深入的剖析其原理。<br><span id="more"></span></p><p>在我们研究（模版引擎）的实现原理之前，先让我们来看一个简单的接口调用例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> template</span><br><span class="line"></span><br><span class="line">PAGE_HTML = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">  Hello, &#123;&#123; username &#125;&#125;!</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    &#123;% for job in job_list %&#125;</span></span><br><span class="line"><span class="string">      &lt;li&gt;&#123;&#123; job &#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &#123;% end %&#125;</span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">t = template.Template(PAGE_HTML)</span><br><span class="line"><span class="built_in">print</span> t.generate(username=<span class="string">&#x27;John&#x27;</span>, job_list=[<span class="string">&#x27;engineer&#x27;</span>])</span><br></pre></td></tr></table></figure><p>这段代码里的 <code>username</code> 将会动态的生成，<code>job</code> 列表也是如此。你可以通过安装 <code>tornado</code> 并运行这段代码来看看最后的效果。</p><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><p>如果你仔细观察 <code>PAGE_HTML</code> ，你会发现这段模板字符串由两个部分组成，一部分是固定的字符串，另一部分是将会动态生成的内容。我们将会用特殊的符号来标注动态生成的部分。在整个工作流程中，模板引擎需要正确输出固定的字符串，同时需要将正确的结果替换我们所标注的需要动态生成的字符串。</p><p>使用模板引擎最简单的方式就是像下面这样用一行 <strong>python</strong> 代码就可以解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deftemplate_engine(template_string, **context):<span class="comment"># process herereturn result_string</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在整个工作过程中，模板引擎将会分为如下两个阶段对我们的字符串进行操作：</p><ul><li>解析</li><li>渲染</li></ul><p>在解析阶段，我们将我们准备好的字符串进行解析，然后格式化成可被渲染的格式，其可能是能被 <code>rendered.Consider</code> 所解析的字符串，解析器可能是一个语言的解释器或是一个语言的编译器。如果解析器是一种解释器的话，在解析过程中将会生成一种特殊的数据结构来存放数据，然后渲染器会遍历整个数据结构来进行渲染。例如 <strong>Django</strong> 的模板引擎中的解析器就是一种基于解释器的工具。除此之外，解析器可能会生成一些可执行代码，渲染器将只会执行这些代码，然后生成对应的结果。在 <strong>Jinja2</strong> ， <strong>Mako</strong> ，<strong>Tornado</strong> 中，模板引擎都在使用编译器来作为解析工具。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>如同上面所说的一样，我们需要解析我们所编写的模板字符串，然后 <strong>tornado</strong> 中的模板解析器将会将我们所编写的模板字符串编译成可执行的 <strong>Python</strong> 代码。我们的解析工具负责生成Python代码，而仅仅由单个Python函数构成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse_template</span>(<span class="params">template_string</span>):</span><br><span class="line">  <span class="comment"># compilation</span></span><br><span class="line">  <span class="keyword">return</span> python_source_code</span><br></pre></td></tr></table></figure><p>在我们分析 <code>parse_template</code> 的代码之前，让我们先看个模板字符串的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  Hello, &#123; &#123; username &#125; &#125;!</span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123; % for job in jobs % &#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123; &#123; job.name &#125; &#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123; % end % &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模板引擎里的 <code>parse_template</code> 函数将会将上面这个字符串编译成 <strong>Python</strong> 源码，最简单的实现方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_execute</span>():</span><br><span class="line">    _buffer = []</span><br><span class="line">    _buffer.append(<span class="string">&#x27;\n&lt;html&gt;\n  Hello, &#x27;</span>)</span><br><span class="line">    _tmp = username</span><br><span class="line">    _buffer.append(<span class="built_in">str</span>(_tmp))</span><br><span class="line">    _buffer.append(<span class="string">&#x27;!\n  &lt;ul&gt;\n    &#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> job <span class="keyword">in</span> jobs:</span><br><span class="line">        _buffer.append(<span class="string">&#x27;\n      &lt;li&gt;&#x27;</span>)</span><br><span class="line">        _tmp = job.name</span><br><span class="line">        _buffer.append(<span class="built_in">str</span>(_tmp))</span><br><span class="line">        _buffer.append(<span class="string">&#x27;&lt;/li&gt;\n    &#x27;</span>)</span><br><span class="line">    _buffer.append(<span class="string">&#x27;\n  &lt;/ul&gt;\n&lt;/html&gt;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span><span class="string">&#x27;&#x27;</span>.join(_buffer)</span><br></pre></td></tr></table></figure><p>现在我们在 <code>_execute</code> 函数里处理我们的模版。这个函数将可以使用全局命名空间里的所有有效变量。这个函数将创建一个包含多个 <strong>string</strong> 的列表并将他们合并后返回。显然找到一个局部变量比找一个全局变量要快多了。同时，我们对于其余代码的优化也在这个阶段完成，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_buffer.append(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_append_buffer = _buffer.append</span><br><span class="line"><span class="comment"># faster for repeated use</span></span><br><span class="line">_append_buffer(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在 <code>&#123; &#123; ... &#125; &#125;</code> 中的表达式将会被提取出来，然后添加进 <code>string</code> 列表中。在 <code>tornado</code> 模板模块中，在 <code>&#123; &#123; ... &#125; &#125;</code> 所编写的表达式没有任何的限制，<strong>if</strong> 和 <strong>for</strong> 代码块都可以准确地转换成为 <strong>Python</strong> 代码。</p><h3 id="让我们来看看具体的代码实现吧"><a href="#让我们来看看具体的代码实现吧" class="headerlink" title="让我们来看看具体的代码实现吧"></a>让我们来看看具体的代码实现吧</h3><p>让我们来看看模板引擎的具体实现吧。我们在 <code>Template</code> 类中编声明核心变量，当我们创建一个 <code>Template</code> 对象后，我们便可以编译我们所编写的模板字符串，随后我们便可以根据编译的结果来对其进行渲染。我们只需要对我们所编写的模板字符串进行一次编译，然后我们可以缓存我们的编译结果，下面是 <code>Template</code> 类的简化版本的构造器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Template</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    def__init__(self, template_string):</span><br><span class="line">        self.code = parse_template(template_string)</span><br><span class="line">        self.compiled = <span class="built_in">compile</span>(self.code, <span class="string">&#x27;&lt;string&gt;&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上段代码里的 <code>compile</code> 函数将会将字符串编译成为可执行代码，我们可以稍后调用 <code>exec</code> 函数来执行我们生成的代码。现在，让我们来看看 <code>parse_template</code> 函数的实现，首先，我们需要将我们所编写的模板字符串转化成一个个独立的节点，为我们后面生成 <strong>Python</strong> 代码做好准备。在这过程中，我们需要一个 <code>_parse</code> 函数，我们先把它放在一边，等下在回来看看这个函数。现，我们需要编写一些辅助函数来帮助我们从模板文件里读取数据。现在让我们来看看 <code>_TemplateReader</code> 这个类，它用于从我们自定义的模板中读取数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_TemplateReader</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, text</span>):</span><br><span class="line">      self.text = text</span><br><span class="line">      self.pos = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, needle, start=<span class="number">0</span>, end=<span class="literal">None</span></span>):</span><br><span class="line">      pos = self.pos</span><br><span class="line">      start += pos</span><br><span class="line">      <span class="keyword">if</span> end <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">          index = self.text.find(needle, start)</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          end += pos</span><br><span class="line">          index = self.text.find(needle, start, end)</span><br><span class="line">      <span class="keyword">if</span> index != -<span class="number">1</span>:</span><br><span class="line">          index -= pos</span><br><span class="line">      <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">consume</span>(<span class="params">self, count=<span class="literal">None</span></span>):</span><br><span class="line">      <span class="keyword">if</span> count <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">          count = <span class="built_in">len</span>(self.text) - self.pos</span><br><span class="line">      newpos = self.pos + count</span><br><span class="line">      s = self.text[self.pos:newpos]</span><br><span class="line">      self.pos = newpos</span><br><span class="line">      <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">remaining</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">len</span>(self.text) - self.pos</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="keyword">return</span> self.remaining()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, key</span>):</span><br><span class="line">      <span class="keyword">if</span> key &lt; <span class="number">0</span>:</span><br><span class="line">          <span class="keyword">return</span> self.text[key]</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">return</span> self.text[self.pos + key]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="keyword">return</span> self.text[self.pos:]</span><br></pre></td></tr></table></figure><p>为了生成 <strong>Python</strong> 代码，我们需要去看看 <code>_CodeWriter</code> 这个类的源码，这个类可以编写代码行和管理缩进，同时它也是一个 <strong>Python</strong> 上下文管理器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_CodeWriter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">      self.buffer = cStringIO.StringIO()</span><br><span class="line">      self._indent = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">indent</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">indent_size</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="keyword">return</span> self._indent</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">      self._indent += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, *args</span>):</span><br><span class="line">      self._indent -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">write_line</span>(<span class="params">self, line, indent=<span class="literal">None</span></span>):</span><br><span class="line">      <span class="keyword">if</span> indent == <span class="literal">None</span>:</span><br><span class="line">          indent = self._indent</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> xrange(indent):</span><br><span class="line">          self.buffer.write(<span class="string">&quot;    &quot;</span>)</span><br><span class="line">      <span class="built_in">print</span> self.buffer, line</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="keyword">return</span> self.buffer.getvalue()</span><br></pre></td></tr></table></figure><p>在 <code>parse_template</code> 函数里，我们先要创建一个 <code>_TemplateReader</code> 对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse_template</span>(<span class="params">template_string</span>):</span><br><span class="line">    reader = _TemplateReader(template_string)</span><br><span class="line">    file_node = _File(_parse(reader))</span><br><span class="line">    writer = _CodeWriter()</span><br><span class="line">    file_node.generate(writer)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(writer)</span><br></pre></td></tr></table></figure><p>然后，我们将我们所创建的 <code>_TemplateReader</code> 对象传入 <code>_parse</code> 函数中以便生成节点列表。这里生成的所有节点都是模板文件的子节点。接着，我们创建一个 <code>_CodeWriter</code> 对象，然后 <code>file_node</code> 对象会把生成的 <strong>Python</strong> 代码写入 <code>_CodeWriter</code> 对象中。然后我们返回一系列动态生成的 <strong>Python</strong> 代码。<code>_Node</code> 类将会用一种特殊的方法去生成 <strong>Python</strong> 源码。这个先放着，我们等下再绕回来看。 现在先让我们回头看看前面所说的 <code>_parse</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_parse</span>(<span class="params">reader, in_block=<span class="literal">None</span></span>):</span><br><span class="line">  body = _ChunkList([])</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      <span class="comment"># Find next template directive</span></span><br><span class="line">      curly = <span class="number">0</span></span><br><span class="line">      <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">          curly = reader.find(<span class="string">&quot;&#123;&quot;</span>, curly)</span><br><span class="line">          <span class="keyword">if</span> curly == -<span class="number">1</span> <span class="keyword">or</span> curly + <span class="number">1</span> == reader.remaining():</span><br><span class="line">              <span class="comment"># EOF</span></span><br><span class="line">              <span class="keyword">if</span> in_block:</span><br><span class="line">                  <span class="keyword">raise</span> ParseError(<span class="string">&quot;Missing &#123; %% end %% &#125; block for %s&quot;</span> %</span><br><span class="line">                                   in_block)</span><br><span class="line">              body.chunks.append(_Text(reader.consume()))</span><br><span class="line">              <span class="keyword">return</span> body</span><br><span class="line">          <span class="comment"># If the first curly brace is not the start of a special token,</span></span><br><span class="line">          <span class="comment"># start searching from the character after it</span></span><br><span class="line">          <span class="keyword">if</span> reader[curly + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;%&quot;</span>):</span><br><span class="line">              curly += <span class="number">1</span></span><br><span class="line">              <span class="keyword">continue</span></span><br><span class="line">          <span class="comment"># When there are more than 2 curlies in a row, use the</span></span><br><span class="line">          <span class="comment"># innermost ones.  This is useful when generating languages</span></span><br><span class="line">          <span class="comment"># like latex where curlies are also meaningful</span></span><br><span class="line">          <span class="keyword">if</span> (curly + <span class="number">2</span> &lt; reader.remaining() <span class="keyword">and</span></span><br><span class="line">              reader[curly + <span class="number">1</span>] == <span class="string">&#x27;&#123;&#x27;</span> <span class="keyword">and</span> reader[curly + <span class="number">2</span>] == <span class="string">&#x27;&#123;&#x27;</span>):</span><br><span class="line">              curly += <span class="number">1</span></span><br><span class="line">              <span class="keyword">continue</span></span><br><span class="line">          <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>我们将在文件中无限循环下去来查找我们所规定的特殊标记符号。当我们到达文件的末尾处时，我们将文本节点添加至列表中然后退出循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Append any text before the special token</span></span><br><span class="line"><span class="keyword">if</span> curly &gt; <span class="number">0</span>:</span><br><span class="line">  body.chunks.append(_Text(reader.consume(curly)))</span><br></pre></td></tr></table></figure><p>在我们对特殊标记的代码块进行处理之前，我们先将静态的部分添加至节点列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start_brace = reader.consume(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>在遇到 <code>&#123; &#123;</code> 或者 <code>&#123; %</code> 的符号时，我们便开始着手处理相应的的表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Expression</span></span><br><span class="line"><span class="keyword">if</span> start_brace == <span class="string">&quot;&#123; &#123;&quot;</span>:</span><br><span class="line">    end = reader.find(<span class="string">&quot;&#125; &#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> end == -<span class="number">1</span> <span class="keyword">or</span> reader.find(<span class="string">&quot;\n&quot;</span>, <span class="number">0</span>, end) != -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ParseError(<span class="string">&quot;Missing end expression &#125; &#125;&quot;</span>)</span><br><span class="line">    contents = reader.consume(end).strip()</span><br><span class="line">    reader.consume(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> contents:</span><br><span class="line">        <span class="keyword">raise</span> ParseError(<span class="string">&quot;Empty expression&quot;</span>)</span><br><span class="line">    body.chunks.append(_Expression(contents))</span><br><span class="line">    <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>当遇到 <code>&#123; &#123;</code> 之时，便意味着后面会跟随一个表达式，我们只需要将表达式提取出来，并添加至 <code>_Expression</code> 节点列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Block</span></span><br><span class="line"><span class="keyword">assert</span> start_brace == <span class="string">&quot;&#123; %&quot;</span>, start_brace</span><br><span class="line">end = reader.find(<span class="string">&quot;% &#125;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> end == -<span class="number">1</span> <span class="keyword">or</span> reader.find(<span class="string">&quot;\n&quot;</span>, <span class="number">0</span>, end) != -<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">raise</span> ParseError(<span class="string">&quot;Missing end block % &#125;&quot;</span>)</span><br><span class="line">contents = reader.consume(end).strip()</span><br><span class="line">reader.consume(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> contents:</span><br><span class="line">    <span class="keyword">raise</span> ParseError(<span class="string">&quot;Empty block tag (&#123; % % &#125;)&quot;</span>)</span><br><span class="line">operator, space, suffix = contents.partition(<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment"># End tag</span></span><br><span class="line"><span class="keyword">if</span> operator == <span class="string">&quot;end&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> in_block:</span><br><span class="line">        <span class="keyword">raise</span> ParseError(<span class="string">&quot;Extra &#123; % end % &#125; block&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> body</span><br><span class="line"><span class="keyword">elif</span> operator <span class="keyword">in</span> (<span class="string">&quot;try&quot;</span>, <span class="string">&quot;if&quot;</span>, <span class="string">&quot;for&quot;</span>, <span class="string">&quot;while&quot;</span>):</span><br><span class="line">    <span class="comment"># parse inner body recursively</span></span><br><span class="line">    block_body = _parse(reader, operator)</span><br><span class="line">    block = _ControlBlock(contents, block_body)</span><br><span class="line">    body.chunks.append(block)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> ParseError(<span class="string">&quot;unknown operator: %r&quot;</span> % operator)</span><br></pre></td></tr></table></figure><p>在遇到模板里的代码块的时候，我们需要通过递归的方式将代码块提取出来，并添加至 <code>_ControlBlock</code> 节点列表中。当遇到 <code>&#123; % end % &#125;</code> 时，意味着这个代码块的结束，这个时候我们可以跳出相对应的函数了。</p><p>好了现在，让我们看看之前所提到的 <code>_Node</code> 节点，别慌，这其实是很简单的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_Node</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, writer</span>):</span><br><span class="line">      <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_ChunkList</span>(<span class="title class_ inherited__">_Node</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, chunks</span>):</span><br><span class="line">      self.chunks = chunks</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, writer</span>):</span><br><span class="line">      <span class="keyword">for</span> chunk <span class="keyword">in</span> self.chunks:</span><br><span class="line">          chunk.generate(writer)</span><br></pre></td></tr></table></figure><p><code>_ChunkList</code> 只是一个节点列表而已。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_File</span>(<span class="title class_ inherited__">_Node</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, body</span>):</span><br><span class="line">      self.body = body</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, writer</span>):</span><br><span class="line">      writer.write_line(<span class="string">&quot;def _execute():&quot;</span>)</span><br><span class="line">      <span class="keyword">with</span> writer.indent():</span><br><span class="line">          writer.write_line(<span class="string">&quot;_buffer = []&quot;</span>)</span><br><span class="line">          self.body.generate(writer)</span><br><span class="line">          writer.write_line(<span class="string">&quot;return &#x27;&#x27;.join(_buffer)&quot;</span>)</span><br></pre></td></tr></table></figure><p>在 <code>_File</code> 中，它会将 <code>_execute</code> 函数写入 <code>CodeWriter</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_Expression</span>(<span class="title class_ inherited__">_Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, expression</span>):</span><br><span class="line">        self.expression = expression</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, writer</span>):</span><br><span class="line">        writer.write_line(<span class="string">&quot;_tmp = %s&quot;</span> % self.expression)</span><br><span class="line">        writer.write_line(<span class="string">&quot;_buffer.append(str(_tmp))&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_Text</span>(<span class="title class_ inherited__">_Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, writer</span>):</span><br><span class="line">        value = self.value</span><br><span class="line">        <span class="keyword">if</span> value:</span><br><span class="line">            writer.write_line(<span class="string">&#x27;_buffer.append(%r)&#x27;</span> % value)</span><br></pre></td></tr></table></figure><p><code>_Text</code> 和 <code>_Expression</code> 节点的实现也非常简单，它们只是将我们从模板里获取的数据添加进列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">_ControlBlock</span>(<span class="title class_ inherited__">_Node</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, statement, body=<span class="literal">None</span></span>):</span><br><span class="line">        self.statement = statement</span><br><span class="line">        self.body = body</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, writer</span>):</span><br><span class="line">        writer.write_line(<span class="string">&quot;%s:&quot;</span> % self.statement)</span><br><span class="line">        <span class="keyword">with</span> writer.indent():</span><br><span class="line">            self.body.generate(writer)</span><br></pre></td></tr></table></figure><p>在 <code>_ControlBlock</code> 中，我们需要将我们获取的代码块按 <strong>Python</strong> 语法进行格式化。</p><p>现在让我们看看之前所提到的模板引擎的渲染部分，我们通过在 <code>Template</code> 对象中实现 <code>generate</code> 方法来调用从模板中解析出来的 <code>Python</code> 代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">    namespace = &#123; &#125;</span><br><span class="line">    namespace.update(kwargs)</span><br><span class="line">    <span class="built_in">exec</span> self.compiled <span class="keyword">in</span> namespace</span><br><span class="line">    execute = namespace[<span class="string">&quot;_execute&quot;</span>]</span><br><span class="line">    <span class="keyword">return</span> execute()</span><br></pre></td></tr></table></figure><p>在给予的全局命名空间中， <strong>exec</strong> 函数将会执行编译过的代码对象。然后我们就可以在全局中调用 <strong>_execute</strong> 函数了。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>经过上面的一系列操作，我们便可以尽情的编译我们的模板并得到相对应的结果了。其实在 <strong>tornado</strong> 模板引擎中，还有很多特性是我们没有讨论到的，不过，我们已经了解了其最基础的工作机制，你可以在此基础上去研究你所感兴趣的部分，比如：</p><ul><li>模板继承</li><li>模板包含</li><li>其余的一些逻辑控制语句，比如 <code>else</code> , <code>elfi</code> , <code>try</code> 等等</li><li>空白控制</li><li>特殊字符转译</li><li>更多没讲到的模板指令（译者注：请参考 <strong>tornado</strong> <a href="http://www.tornadoweb.org/en/stable/">官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> Flask </tag>
            
            <tag> 掘金翻译计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>菜鸟阅读 Flask 源码系列（1）：Flask的router初探</title>
      <link href="//posts/2016/08/09/reading-the-fucking-flask-source-code-Part1/"/>
      <url>//posts/2016/08/09/reading-the-fucking-flask-source-code-Part1/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>文章来源：itsCoder 的 <a href="https://github.com/itsCoder/weeklyblog">WeeklyBolg</a> 项目</li><li>itsCoder主页：<a href="http://itscoder.com/">http://itscoder.com/</a></li><li>作者：<a href="https://github.com/Zheaoli">写代码的香港记者</a></li><li>审阅者：<a href="https://github.com/brucezz">Brucezz</a></li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>没有一个完整的开源项目的的阅读经验的程序猿是一个不合格的程序猿，虽然曾经阅读过部分诸如 <strong>Redis</strong> 等项目的源码，但是还没有过一个完整的开源项目的阅读经验，因此在经过某个前辈的不断安利后，我决定用 <strong>Flask</strong> 来作为阅读开源源码计划的开始。而这一个系列的文章，将作为我自己的阅读笔记，来巩固自己曾经所没有重视的 <strong>Python</strong> 的很多细节。</p><span id="more"></span><h2 id="关于-Flask"><a href="#关于-Flask" class="headerlink" title="关于 Flask"></a>关于 <strong>Flask</strong></h2><p>关于 <strong>Flask</strong> 的背景知识，就不需要太多的描述了，网上已经有很多的资料了。在使用 <strong>Flask</strong> 的时候，我们经常用如下的方式来设置我们的自定义的路由：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##Flask官方Example中flaskr项目部分代码</span></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_entries</span>():</span><br><span class="line">    db = get_db()</span><br><span class="line">    cur = db.execute(<span class="string">&#x27;select title, text from entries order by id desc&#x27;</span>)</span><br><span class="line">    entries = cur.fetchall()</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;show_entries.html&#x27;</span>, entries=entries)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/add&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_entry</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> session.get(<span class="string">&#x27;logged_in&#x27;</span>):</span><br><span class="line">        abort(<span class="number">401</span>)</span><br><span class="line">    db = get_db()</span><br><span class="line">    db.execute(<span class="string">&#x27;insert into entries (title, text) values (?, ?)&#x27;</span>,</span><br><span class="line">                 [request.form[<span class="string">&#x27;title&#x27;</span>], request.form[<span class="string">&#x27;text&#x27;</span>]])</span><br><span class="line">    db.commit()</span><br><span class="line">    flash(<span class="string">&#x27;New entry was successfully posted&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;show_entries&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/login&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    error = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> request.form[<span class="string">&#x27;username&#x27;</span>] != app.config[<span class="string">&#x27;USERNAME&#x27;</span>]:</span><br><span class="line">            error = <span class="string">&#x27;Invalid username&#x27;</span></span><br><span class="line">        <span class="keyword">elif</span> request.form[<span class="string">&#x27;password&#x27;</span>] != app.config[<span class="string">&#x27;PASSWORD&#x27;</span>]:</span><br><span class="line">            error = <span class="string">&#x27;Invalid password&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            session[<span class="string">&#x27;logged_in&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">            flash(<span class="string">&#x27;You were logged in&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;show_entries&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;login.html&#x27;</span>, error=error)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么问题来了，上面的例子中，我们知道 <code>app.route(&#39;xxxx&#39;,methods=[&#39;xxx&#39;])</code> 将会设置我们对应的方法与对应 url 的关联，那么这样一种做法是怎样生效的呢？</p><h2 id="Flask-源码阅读"><a href="#Flask-源码阅读" class="headerlink" title="Flask 源码阅读"></a><strong>Flask</strong> 源码阅读</h2><h3 id="让我们看看最开始的-router-是什么样子的"><a href="#让我们看看最开始的-router-是什么样子的" class="headerlink" title="让我们看看最开始的 router 是什么样子的"></a>让我们看看最开始的 router 是什么样子的</h3><p>首先让我们从 <a href="https://github.com/pallets/flask">Flask</a> 这里获取 flask 源码，然后我们将版本号切换至最初的 0.1 版（git tag为8605cc310d260c3b08160881b09da26c2cc95f8d）</p><blockquote><p>小tips：阅读开源项目时，如果当前版本太过于复杂，可以切换至项目最初发布时的版本，然后根据每次项目版本发布的 Release Note 来进行跟进。</p></blockquote><p>在 <strong>flask.py</strong> 文件里，我们能看到如下的的结构</p><p><img src="/images/flask1.png" alt="flask.py 文件目录"></p><p>讲真这个时候我们就可以看到 <strong>Flask</strong> 里的 <strong>route</strong> 的核心代码了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">route</span>(<span class="params">self, rule, **options</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">f</span>):</span><br><span class="line">        self.add_url_rule(rule, f.__name__, **options)</span><br><span class="line">        self.view_functions[f.__name__] = f</span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们能很清楚的看到之前代码中的 <code>app.route(&#39;/&#39;)</code> 本质上是调用了一个装饰器来对我们对应的方法进行请求与方法之间进行关联。在 <code>route</code> 方法被触发后，进一步来调用 <code>add_url_rule</code> 来注册我们所设定的url。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_url_rule</span>(<span class="params">self, rule, endpoint, **options</span>):</span><br><span class="line">    options[<span class="string">&#x27;endpoint&#x27;</span>] = endpoint</span><br><span class="line">    options.setdefault(<span class="string">&#x27;methods&#x27;</span>, (<span class="string">&#x27;GET&#x27;</span>,))</span><br><span class="line">    self.url_map.add(Rule(rule, **options))</span><br></pre></td></tr></table></figure><p>在最初版本的 <strong>Flask</strong> 中， <strong>Router</strong> 的实现就这么简单暴力</p><h3 id="两个关于装饰器的知识点"><a href="#两个关于装饰器的知识点" class="headerlink" title="两个关于装饰器的知识点"></a>两个关于装饰器的知识点</h3><p>第一个：很多人肯定想问，在之前的代码里，我们没有调用相关的方法，例如 <code>index()</code> ，那么装饰器为什么会被触发呢？</p><p>答：首先，请大声告诉我，装饰器的作用是什么？很明显嘛，在不修改原有代码的基础上，对函数进行一次封装，然后实现为原有方法增加一些功能的特殊实现。是不是感觉很抽象？来我们看个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">testDe1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">de</span>(<span class="params">a, b, c</span>):</span><br><span class="line">        func(a, b, c)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> de</span><br><span class="line"></span><br><span class="line"><span class="meta">@testDe1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a+b+c)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>来，告诉我，这段代码的输出应该是什么？答案是 <code>2,6,1</code>，看到这里，你是不是感觉似乎明白了些什么？是的没错，上面的例子其实等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">testDe1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">de</span>(<span class="params">a, b, c</span>):</span><br><span class="line">        func(a, b, c)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> de</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a+b+c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    testDe1(test2)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么我们换个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">testDe1</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">de</span>(<span class="params">a, b, c</span>):</span><br><span class="line">        func(a, b, c)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> de</span><br><span class="line"></span><br><span class="line"><span class="meta">@testDe1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a+b+c)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这段代码的输出会是什么？是的没错，这段代码的输出是 <code>2</code> 。看到这里你是不是感觉更明白些什么？恩，在 <strong>Python</strong> 中，使用函数装饰器的时候，等于先行调用了装饰函数一次，具体来讲在使用装饰器后，装饰器会用装饰后的函数来进行一个替换，即在什么也不做的情况下，会产生这样一个调用 <code>test2=testDe1(test2)</code>，接着如果在 <code>__main__</code> 中添加一段代码 <code>test2(1,2,3)</code>,是不是就等价于 <code>testDe1(test2)(1,2,3)</code> 。看到这里是不是彻底明白了？<br>恩，来，我们再来复习下前面的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_entries</span>():</span><br><span class="line">    db = get_db()</span><br><span class="line">    cur = db.execute(<span class="string">&#x27;select title, text from entries order by id desc&#x27;</span>)</span><br><span class="line">    entries = cur.fetchall()</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;show_entries.html&#x27;</span>, entries=entries)</span><br></pre></td></tr></table></figure></p><p>上面这段代码里发生了什么？是不是有一个调用为 <code>show_entries=app.route(&#39;/&#39;)(show_entries)</code>？看到这里是不是很清楚了呢？</p><p>第二个，在第一个小 tip 的基础之上，我们来讲一个关于装饰器传参的问题<br>可能很多人不清楚装饰器传参的使用情景，首先如前面所说装饰器的最根本的作用在于</p><blockquote><p>在不修改原有代码的基础上，对函数进行一次封装，然后实现为原有方法增加一些功能的特殊实现</p></blockquote><p>现在假设我们需要对函数的运行时间进行输出，这个时候我们该怎么办</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">testTime</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        flag=time.time()</span><br><span class="line">        func(*args,**kwargs)</span><br><span class="line">        <span class="built_in">print</span>(time.time()-flag)</span><br><span class="line">    <span class="keyword">return</span> dec</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func()</span><br></pre></td></tr></table></figure><p>如前所述，前面这段代码等价于 <code>test(func)()</code>,那么这个时候我们想给我们时间输出以一定的单位进行格式化怎办，修改上面装饰器代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">testtime</span>(<span class="params">time=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dec1</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dec2</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">            flag=time.time()</span><br><span class="line">            func(*args,**kwagrs)</span><br><span class="line">            flag2=time.time()</span><br><span class="line">            <span class="keyword">if</span> time <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>((flag2-flag)/time)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(flag2-flag)</span><br><span class="line">        <span class="keyword">return</span> dec2</span><br><span class="line">    <span class="keyword">return</span> dec1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写到这里，大家是不是明白了带参数的装饰器的使用情景呢？</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p><strong>Flask</strong> 的路由系统相对简单，其本质是利用带参数的装饰器来进行相应的路由记录，同时利用装饰器的包装特性，将我们的对应的处理函数进行包装，同时加入路由表中，一旦触发我们所注册的路由，便可调用我们所对应的处理函数。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 编程 </tag>
            
            <tag> Flask </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解Swift的类型检查器</title>
      <link href="//posts/2016/08/02/%E8%AF%A6%E8%A7%A3Swift%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%99%A8/"/>
      <url>//posts/2016/08/02/%E8%AF%A6%E8%A7%A3Swift%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文链接: <a href="http://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html">Exponential time complexity in the Swift type checker</a></li><li>原文作者: <a href="http://www.cocoawithlove.com/about/">Matt Gallagher</a></li><li>译文出自: <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>译者: <a href="https://github.com/Zheaoli">Zheaoli</a></li><li>校对者: <a href="https://github.com/geeeeeeeeek">geeeeeeeeek</a>, <a href="https://github.com/Graning">Graning</a></li></ul></blockquote><p>这篇文章将围绕曾不断使我重写代码的一些 <strong>Swift</strong> 编译器的报错信息展开：</p><blockquote><p>错误：你的表达式太过于复杂，请将其分解为一些更为简单的表达式。（译者注：原文是 <code>error: expression was too complex to be solved in reasonable time; consider breaking up the expression into distinct sub-expressions</code>）</p></blockquote><span id="more"></span><p>我会看那个触发错误的例子，谈谈以后由相同底层问题引起以外的编译错误的负面影响。我将会带领你看看在编译过程中发生了什么，然后告诉你，怎样在短时间内去解决这些报错。</p><p>我将为编译器设计一种时间复杂度为线性算法来代替原本的指数算法来彻底的解决这个问题，而不需要采用其余更复杂的方法。</p><h2 id="正确代码的编译错误"><a href="#正确代码的编译错误" class="headerlink" title="正确代码的编译错误"></a><a href="http://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html#errors-compiling-otherwise-valid-code"></a>正确代码的编译错误</h2><p>如果你尝试在 <strong>Swift 3</strong> 中编译这段代码，那么将会产生报错信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Double</span> <span class="operator">=</span> <span class="operator">-</span>(<span class="number">1</span> <span class="operator">+</span> <span class="number">2</span>) <span class="operator">+</span> <span class="operator">-</span>(<span class="number">3</span> <span class="operator">+</span> <span class="number">4</span>) <span class="operator">+</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>这段代码无论从哪方面来讲都是合法且正确的代码，从理论上讲，在编译过程中，这段代码将会被优化成一个固定的值。</p><p>但是这段代码在编译过程中没有办法通过 <strong>Swift</strong> 的类型检查。编译器会告诉你这段代码太复杂了。但是，等等，这段代码看起来一点都不复杂不是么。里面包含 5 个变量， 4 次加法操作， 2 次取负值操作和一次强制转换为 <code>Double</code> 类型的操作。</p><p>但是，编译器你怎么能说这段仅包含 12 个元素的语句相当复杂呢？</p><p>这里有非常多的表达式在编译的时候会出现同样的问题。大多数表达式包含一些变量，基础的数据操作，可能还有一些重载之类的操作。接下来的表达式在编译时会面对同样的错误信息：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b <span class="operator">=</span> <span class="type">String</span>(<span class="number">1</span>) <span class="operator">+</span> <span class="type">String</span>(<span class="number">2</span>) <span class="operator">+</span> <span class="type">String</span>(<span class="number">3</span>) <span class="operator">+</span> <span class="type">String</span>(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c <span class="operator">=</span> <span class="number">1</span> <span class="operator">*</span> sqrt(<span class="number">2.0</span>) <span class="operator">*</span> <span class="number">3</span> <span class="operator">*</span> <span class="number">4</span> <span class="operator">*</span> <span class="number">5</span> <span class="operator">*</span> <span class="number">6</span> <span class="operator">*</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d <span class="operator">=</span> [<span class="string">&quot;1&quot;</span> <span class="operator">+</span> <span class="string">&quot;2&quot;</span>].reduce(<span class="string">&quot;3&quot;</span>) &#123; <span class="string">&quot;4&quot;</span> <span class="operator">+</span> <span class="type">String</span>(<span class="variable">$0</span>) <span class="operator">+</span> <span class="type">String</span>(<span class="variable">$1</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> e: [(<span class="type">Double</span>) -&gt; <span class="type">String</span>] <span class="operator">=</span> [</span><br><span class="line">  &#123; v <span class="keyword">in</span> <span class="type">String</span>(v <span class="operator">+</span> v) <span class="operator">+</span> <span class="string">&quot;1&quot;</span> &#125;,</span><br><span class="line">  &#123; v <span class="keyword">in</span> <span class="type">String</span>(<span class="operator">-</span>v) &#125; <span class="operator">+</span> <span class="string">&quot;2&quot;</span>,</span><br><span class="line">  &#123; v <span class="keyword">in</span> <span class="type">String</span>(<span class="type">Int</span>(v)) <span class="operator">+</span> <span class="string">&quot;3&quot;</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>上面的代码都是符合 <strong>Swift</strong> 语法及编程规则的，但是在编译过程中，它们都没有办法通过类型检查。</p><h2 id="需要较长的编译时间"><a href="#需要较长的编译时间" class="headerlink" title="需要较长的编译时间"></a><a href="http://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html#needlessly-long-compile-times"></a>需要较长的编译时间</h2><p>编译报错只是 <strong>Swift</strong> 类型检查器缺陷带来的副作用之一，比如，你可以试试下面这个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let x = &#123; String(&quot;\($0)&quot; + &quot;&quot;) + String(&quot;\($0)&quot; + &quot;&quot;) &#125;(0)</span><br></pre></td></tr></table></figure><p>这段代码编译时不会报错，但是在我的电脑上，使用 <strong>Swift 2.3</strong> 将花费 <strong>4s</strong> 的时间，如果是使用 <strong>Swift 3</strong> 将会花费 <strong>15s</strong> 时间。编译过程中，将会花费大量的时间在类型检查上。</p><p>现在，你可能不会遇到太多需要耗费这么多时间的问题，但是一个大型的 <strong>Swift</strong> 项目中，你将会遇到很多 <code>expression was too complex to be solved in reasonable time</code> 这样的报错信息。</p><h2 id="不可预知的操作"><a href="#不可预知的操作" class="headerlink" title="不可预知的操作"></a><a href="http://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html#unexpected-behaviors"></a>不可预知的操作</h2><p>接下来，我将讲一点 <strong>Swift</strong> 类型检查器的特性：类型检查器选择尽可能的解决非泛型重载的问题。 编译器中处理这种特定行为的路径下的代码注释对此给出了解释，这是一种避免性能问题的优化手段，用于优化造成 <code>expression was too complex</code> 报错的性能问题。</p><p>接下来是一些具体的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let x = -(1)</span><br></pre></td></tr></table></figure><p>这段代码将会编译失败，我们会得到一个 <code>Ambiguous use of operator ‘-‘</code> 的报错信息。</p><p>这段代码并不算很模糊，编译器将会明白我们想要使用一个整数类型的变量，它将会把 <code>1</code> 作为一个 <code>Int</code> 进行处理，同时从标准库中选择如下的重载方式：</p><figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prefix public func -&lt;T : SignedNumber&gt;(x: T) -&gt; T</span><br></pre></td></tr></table></figure><p>然而，<strong>Swift</strong> 只能进行非泛型重载。在这个例子中，<code>Float</code> 、 <code>Double</code> 、 <code>Float80</code> 类型的实现并不完善，编译器无法根据上下文选择使用哪种实现，从而导致了这个报错信息。</p><p>某些特定的优化可以对操作符进行优化，但是可能导致如下的一些问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">f</span>(<span class="keyword">_</span> <span class="params">x</span>: <span class="type">Float</span>) -&gt; <span class="type">Float</span> &#123; <span class="keyword">return</span> x &#125;</span><br><span class="line"><span class="keyword">func</span> <span class="title function_">f</span>&lt;<span class="type">I</span>: <span class="type">Integer</span>&gt;(<span class="keyword">_</span> <span class="params">x</span>: <span class="type">I</span>) -&gt; <span class="type">I</span> &#123; <span class="keyword">return</span> x &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x <span class="operator">=</span> f(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> <span class="title">%%</span> &#123;&#125;</span><br><span class="line"><span class="keyword">prefix</span> <span class="keyword">func</span> <span class="title function_">%%</span>(<span class="keyword">_</span> <span class="params">x</span>: <span class="type">Float</span>) -&gt; <span class="type">Float</span> &#123; <span class="keyword">return</span> x &#125;</span><br><span class="line"><span class="keyword">prefix</span> <span class="keyword">func</span> <span class="title function_">%%&lt;</span><span class="type">I</span>: <span class="type">Integer</span><span class="operator">&gt;</span>(<span class="keyword">_</span> x: <span class="type">I</span>) -&gt; <span class="type">I</span> &#123; <span class="keyword">return</span> x &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y <span class="operator">=</span> <span class="operator">%%</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>在这段代码里，我们定义了两个函数（ <code>f</code> 和一个自定的操作 <code>prefix %%</code> ）。每个函数都进行了两次重载，一个参数为 <code>(Float) -&gt; Float</code> ，另一个是 <code>&lt;I: Integer&gt;(I) -&gt; I</code>。</p><p>当调用 <code>f(1)</code> 的时候，将会选择使用 <code>&lt;I: Integer&gt;(I) -&gt; If(1)</code> 的实现，然后 <code>x</code> 将会作为 <code>Int</code> 类型进行处理。这应该是你所期待的方式。</p><p>当调用 <code>%%1</code> 时，将会使用 <code>(Float) -&gt; Float</code> 的实现，同时会将 <code>y</code> 作为 <code>Float</code> 类型处理，这和我们所期望的恰恰相反。在编译过程中，编译器选择将 <code>1</code> 作为 <code>Float</code> 处理，而不是作为 <code>Int</code> 处理，虽然作为 <code>Int</code> 处理也同样能正常工作。造成这样情况的原因是，编译器在对方法的进行泛型重载之前就已经先行确定变量的类型。这不是基于前后文一致性的做法，这是编译器对于避免类似于 <code>expression was too complex to be solved</code> 等报错信息以及性能优化上的一种妥协。</p><h2 id="在代码中解决上诉问题"><a href="#在代码中解决上诉问题" class="headerlink" title="在代码中解决上诉问题"></a><a href="http://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html#working-around-the-problem-in-our-code"></a>在代码中解决上诉问题</h2><p>通常来讲，<strong>Swift</strong> 里的显示代码太过复杂的缺陷并不是一个太大的问题，当然前提是你不会在单个表达式里使用两个或两个以上的下面列出的特性：</p><ul><li>方法重载（包括操作符重载）</li><li>常量</li><li>不明确类型的闭包    </li><li>会引导 <strong>Swift</strong> 进行错误类型转换的表达式</li></ul><p>一般而言，如果你不使用如上面所述的特性，那么你一般不会遇到类似于 <code>expression was too complex</code> 的报错信息。然而，如果选择是用了上面所诉的特性，那么你可能会面临一些让你感到困惑的问题。通常，在编写一个足够大小的方法和其余常规代码的时候，将会很容易用到上面这些特性，这意味着有些时候我们可能要仔细考虑怎样避免大量使用上面这些特性。</p><p>你肯定是想只通过一点细微的修改来通过编译，而不是大量修改你的代码。接下来的一点小建议可能帮得上一些忙。</p><p>当上面所诉的编译报错信息出现时，编译器可能建议你将原表达式分割成不同的子表达式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x_1: <span class="type">Double</span> <span class="operator">=</span> <span class="operator">-</span>(<span class="number">1</span> <span class="operator">+</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> x_2: <span class="type">Double</span> <span class="operator">=</span> <span class="operator">-</span>(<span class="number">3</span> <span class="operator">+</span> <span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> x: <span class="type">Double</span> <span class="operator">=</span> x_1 <span class="operator">+</span> x_2 <span class="operator">+</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>好了，从结果上来看，这样的修改是有效的，但是却让人有点蛋疼，特别是在分解成子表达式的时候会明显破坏代码可读性的时候。</p><p>另一个建议是通过显示类型转换，减少编译器在编译过程中对方法和操作符重载的选取次数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="type">Double</span> <span class="operator">=</span> <span class="operator">-</span>(<span class="number">1</span> <span class="operator">+</span> <span class="number">2</span>) <span class="keyword">as</span> <span class="type">Double</span> <span class="operator">+</span> <span class="operator">-</span>(<span class="number">3</span> <span class="operator">+</span> <span class="number">4</span>) <span class="keyword">as</span> <span class="type">Double</span> <span class="operator">+</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>上面这种做法避免了在使用 <code>(Float) -&gt; Float</code> 或者是 <code>(Float80) -&gt; Float80</code> 编译器需要去查找相对应的负号重载。这样的做法很有效的将编译过程中编译器的6次查找相对应的方法重载过程降至4次。</p><p>在上面的处理方式中有一个点要注意一下：不同于其余语言，在 <strong>Swift</strong> 中 <code>Double(x)</code> 并不等同于 <code>x as Double</code>。构造函数通常会如同普通方法一样，当有不同参数的重载需求时，编译器还是会将构造函数的各种重载加入到搜索空间中（尽管这些重载可能在代码中的不同的位置）。在前面所举的例子里，通过在括号前用 <code>Double</code> 进行显示类型转换会解决一部分问题（这种方法有利于编译器进行类型检查），同时在一些情况下，采用这种方法会导致出现一些其余的问题（请参见本文开始所举的关于 <code>String</code> 的例子）。最终， 使用<code>as</code> 操作符是在不增加复杂度的情况下解决这类的问题的最好方式。幸运的是，<code>as</code> 操作符的优先级比大多数二元运算符更高，这样我们可以在大多数的情况下使用它。</p><p>另一种方法是使用一个独立命名的自定义函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="type">Double</span> <span class="operator">=</span> myCustomDoubleNegation(<span class="number">1</span> <span class="operator">+</span> <span class="number">2</span>) <span class="operator">+</span> myCustomDoubleNegation(<span class="number">3</span> <span class="operator">+</span> <span class="number">4</span>) <span class="operator">+</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>这种方法可以解决之前方法重载所带来的一系列问题。然而，在一系列轻量级的代码里使用这种方式会让我们的代码显得格外的丑陋。</p><p>好了，让我们来说说最后的方法，在很多情况下，你可以根据情况自行替换方法和操作符：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="type">Double</span> <span class="operator">=</span> (<span class="number">1</span> <span class="operator">+</span> <span class="number">2</span>).negated() <span class="operator">+</span> (<span class="number">3</span> <span class="operator">+</span> <span class="number">4</span>).negated() <span class="operator">+</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>因为在使用对应方法时，和使用常见算数运算符相比，会有效的减少重载次数，同时使用 <code>.</code> 操作符时其效率相较于直接调用方法更高，因此，这种方法能有效解决我们前面所提到的问题。</p><h2 id="Swift类型约束系统简析"><a href="#Swift类型约束系统简析" class="headerlink" title="Swift类型约束系统简析"></a><a href="http://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html#swifts-constraints-system-solver"></a><strong>Swift</strong>类型约束系统简析</h2><p>编译时出现的 <code>expression was too complex</code> 错误是由 <strong>Swift</strong> 编译器的语义分析系统所抛出的。语义分析系统的意义在于解决整个代码里的类型问题，从而确保输入表达式的类型是正确且安全的。</p><p>最重要的是，整个报错信息是由<a href="https://github.com/apple/swift/blob/master/lib/Sema/CSSolver.cpp">the constraints system solver (CSSolver.cpp)</a>里所编写的语义分析系统所定义的。类型约束系统将从 <strong>Swift</strong> 的表达式里构建一个由类型和方法组成的图，并根据节点之间的关系来对代码进行约束。约束系统将对每个节点进行推算直至每个节点都已获得明确的类型约束。</p><p>讲真，上面的东西可能太抽象了，让我们看点具体的例子吧。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">1</span> <span class="operator">+</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>类型约束系统将表达式解析成下面这个样子：</p><p><img src="http://www.cocoawithlove.com/assets/blog/constraints_graph1.svg" alt="a simple constraints graph"></p><p>每个节点的名字都以 <code>T</code> 开头（意味着需要待确定明确的类型），然后它们用来代表需要解决的类型约束或者方法重载。在这个图里，这些节点被如下的规则所约束：</p><ol><li><code>T1</code> 是 <code>ExpressibleByIntegerLiteral</code> 类型</li><li><code>T2</code> 是 <code>ExpressibleByIntegerLiteral</code> 类型</li><li><code>T0</code> 是一个传入 <code>(T1,T2)</code> 返回 <code>T3</code> 的方法</li><li><code>T0</code> 是 <code>infix +</code> ，其在 <strong>Swift</strong> 里有28种实现</li><li><code>T3</code> 与 <code>T4</code> 之间可以进行交换</li></ol><blockquote><p>小贴士: 在 <strong>Swift 2.X</strong> 中，<code>ExpressibleByIntegerLiteral</code> 的替代者是 <code>IntegerLiteralConvertible</code></p></blockquote><p>在这个系统中，类型约束系统遵循着 <strong>最小分离</strong> 原则。分割出来的单元被这样一个规则所约束着，即，每个单元都是一个拥有一套独立值的个体。在上面的这个例子里，实际上只有一个最小单元：在上述的约束 4 里，<code>T0</code> 发生了重载。在重载之时，编译器选择了 <code>infix +</code> 实现列表里第一种实现：即签名是 <code>(Int, Int) -&gt; Int</code> 的实现。</p><p>通过上述这个最小的单元，类型约束系统开始对元素进行类型约束：根据约束 3 <code>T1</code>、 <code>T2</code> 、 <code>T3</code> 被确定为 <code>Int</code> 类型，根据约束 4 ， <code>T4</code> 同样被确认为 <code>Int</code> 类型。</p><p>在 <code>T1</code> 、 <code>T2</code> 被确定为 <code>Int</code> 之后（最开始它们被认为是 <code>ExpressibleByIntegerLiteral</code>）， <code>infix +</code> 的重载方式便已经确定，这个时候编译器便不需要再考虑其余可行性，并把其当做最终的解决方案。我们在确定每个节点对应的类型后，我们便可以选择我们所需要的重载方法了。</p><h2 id="让我们看点复杂的例子吧！"><a href="#让我们看点复杂的例子吧！" class="headerlink" title="让我们看点复杂的例子吧！"></a><a href="http://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html#getting-more-complex-quickly"></a>让我们看点复杂的例子吧！</h2><p>到目前为止，并没有什么超出我们意料之中的异常出现，你可能想象不到当表达式开始变得复杂之时， <strong>Swift</strong> 的编译系统将会开始不断的出现错误信息。来让我们修改下上面的例子：第一·将 <code>2</code> 放在括号里，第二·添加负号操作符，第三·规定返回值为 <code>Double</code> 类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a: Double = 1 + -(2)</span><br></pre></td></tr></table></figure><p>整个节点结构如下图所述：</p><p><img src="http://www.cocoawithlove.com/assets/blog/constraints_graph2.svg" alt="a slightly more complex constraints graph"></p><p>节点约束如下：</p><ol><li><code>T1</code> 是 <code>ExpressibleByIntegerLiteral</code> 类型</li><li><code>T3</code> 是 <code>ExpressibleByIntegerLiteral</code> 类型</li><li><code>T2</code> 是一个传入 <code>T3</code> 返回 <code>T4</code> 的方法</li><li><code>T2</code> 是 <code>prefix -</code>，其在 <strong>Swift</strong> 里有6种实现</li><li><code>T0</code> 是一个传入 <code>T1</code>、<code>T4</code>，返回 <code>T5</code> 的方法</li><li><code>T0</code> 是 <code>infix +</code> ，其在 <strong>Swift</strong> 里有28种实现</li><li><code>T5</code> 是 <code>Double</code> 类型</li></ol><p>相较于上面的例子，这里多了两个约束，让我们看看类型约束系统会怎样处理这个例子。</p><p>第一步：选择最小分离单元。这次是约束 4 ：“ <code>T2</code> 是 <code>prefix -</code>，在 <strong>Swift</strong> 里有6种实现”。最后系统选择了签名为 <code>(Float) -&gt; Float</code> 的实现。</p><p>第二步：和第一步一样，选择最小分离单元，这次是约束 6 ：“<code>T0</code> 是 <code>infix +</code> ，其在 <strong>Swift</strong> 里有28种实现”。系统选择了签名为 <code>(Int, Int) -&gt; Int</code> 的实现。</p><p>最后一步是：利用上述的类型约束确定所有节点的类型。</p><p>然而，这里出现了点问题：在第一步里我们选择的签名为 <code>(Float) -&gt; Float</code> 的 <code>prefix -</code> 实现和第二步里我们选择的签名为 <code>(Int, Int) -&gt; Int</code> 的 <code>infix +</code> 实现和我们的约束 5 （<code>T0</code> 是一个传入 <code>T1</code>、<code>T4</code>，返回 <code>T5</code> 的方法）发生了冲突。解决方法是放弃当前的选择，然后重新回滚至第二步，为 <code>T0</code></p><p>最终，系统将遍历所有的 <code>infix +</code> 实现，然后发现没有一种实现同时满足约束 5 和约束 7 （<code>T5</code> 是 <code>Double</code> 类型）。</p><p>所以，类型约束系统将回滚至第一步，为 <code>T2</code> 选取了签名为 <code>(Double, Double) -&gt; Double</code> 的实现。最后，这种实现也满足了 <code>T0</code> 的约束。</p><p>然而，在发现 <code>Double</code> 类型和 <code>ExpressibleByIntegerLiteral</code> 相互不匹配后，类型约束系统将继续回滚，寻找合适的重载方法。</p><p><code>T2</code> 总共有6种实现，但是最后3种实现不能被优化(因为它们是通用的实现，因此优先级高于显示声明参数为 <code>Double</code> 的实现）。</p><blockquote><p>在类型约束系统里，这种特殊优化是我曾经在<a href="http://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html#unexpected-behaviors">Unexpected behaviors</a>一文中提到的快速重载的一些特性。</p></blockquote><p>拜这种特殊的“优化”所赐，类型约束系统需要76次查询才能找到一个合理的解决方案。如果我们添加了其余的一些新的重载，那么这个数字会变得超出我们的想象。例如，我们我们在例子里添加另外一个 <code>infix +</code> 操作符，比如： <code>let a: Double = 0 + 1 + -(2)</code> ，那么将需要1190次查询才能找到合理的解决方案。</p><p>查询解决方案的这个过程是一个典型的具有指数时间复杂度的操作。在分离单元里进行搜索的范围称为<a href="https://zh.wikipedia.org/wiki/%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF">“笛卡尔积”</a>，然后，对于图中的 <math><mi>n</mi></math> 个分离单元，算法将会在 n 维笛卡尔乘积的范围内进行查找（这是一个空间复杂度同样为指数的操作）。</p><p>根据我的测试，单语句内拥有6个分离单元，便足以触发 <strong>Swift</strong> 中的 <code>expression was too complex</code> 的错误。</p><h2 id="线性化的类型约束系统"><a href="#线性化的类型约束系统" class="headerlink" title="线性化的类型约束系统"></a><a href="http://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html#linearizing-the-constraints-solver"></a>线性化的类型约束系统</h2><p>针对本文所反复提到的这个问题，最好的解决方法就是在编译器中进行修复。</p><p>类型约束系统之所以采用时间复杂度为指数算法来解决方法重载的问题，是因为 <strong>Swift</strong> 需要对方法重载所生成的 n 维<a href="https://en.wikipedia.org/wiki/Cartesian_product">“笛卡尔乘积”</a>空间里的元素进行遍历并搜索从而确定一个合适的选项（在没有更好方案之前，这应该是最好的方案）。</p><p>为了避免生成 n 维笛卡尔乘积空间，我们需要设计一个方法来实现相关逻辑实现的独立性，而不让它们彼此依赖。</p><p>在开始之前我必须给你们一个很重要的提醒：</p><blockquote><p><strong>友情提醒，这些东西仅代表我的个人观点</strong>：接下来的一些讨论，都是我从理论的角度上来分析怎样在 <strong>Swift</strong> 的类型约束系统中怎样去解决函数重载的问题。我并没有写一些东西来证明我提出的解决方案，这可能意味着我会忽略某些非常重要的东西。</p></blockquote><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>我们想实现如下两个目标：</p><ol><li>限制一个节点不应该与其余节点相互依赖或引用</li><li>从前一个方法分析出来的分离单元应该与后一个方法分离出来的存在着交集，并进一步简化分离单元的两个约束条件。</li></ol><p>第一个目标，可以通过限制节点的约束路径实现。在 <strong>Swift</strong> 中，每个节点的约束是双向的，每个节点的约束都从表达式的每一个分支开始，然后依照着遍历主干-&gt;线性遍历子节点的方式不断传播。在这个过程中，我们可以有选择性的简单地合并相同的约束逻辑来组合这些约束，而不是从其余节点引用相对应的类型约束。</p><p>第二个目标里，支持前面通过减少类型约束的传播复杂度来进一步简化相关约束条件。每个重载方法的分离单元之间最重要的交叉点是一个重载函数的输出，可能会作为另一个重载函数的输入。这个操作应该根据参数相互交叉的两个重载方法所产生的2维笛卡尔积来进行计算。对于其余的可能存在的交叉点来说，给出一个真正意义上的数学上的严格交叉证明是非常困难的，同时这样的证明是没有必要的，我们只需要复制 <strong>Swift</strong> 里在复杂情况下的对于类型选择的时所采用的贪婪策略即可。</p><h3 id="让我们重新看看之前的例子"><a href="#让我们重新看看之前的例子" class="headerlink" title="让我们重新看看之前的例子"></a>让我们重新看看之前的例子</h3><p>让我们看看如果我们实现了前文所讲的两个目标后，类型约束系统将会变成什么样子。首先让我们复习下之前所生成的节点图：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Double</span> <span class="operator">=</span> <span class="number">1</span> <span class="operator">+</span> <span class="operator">-</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="http://www.cocoawithlove.com/assets/blog/constraints_graph2.svg" alt="a slightly more complex constraints graph"></p><p>然后让我们也复习下以下节点约束：</p><ol><li><code>T1</code> 是 <code>ExpressibleByIntegerLiteral</code> 类型</li><li><code>T3</code> 是 <code>ExpressibleByIntegerLiteral</code> 类型</li><li><code>T2</code> 是一个传入 <code>T3</code> 返回 <code>T4</code> 的方法</li><li><code>T2</code> 是 <code>prefix -</code>，其在 <strong>Swift</strong> 里有6种实现</li><li><code>T0</code> 是一个传入 <code>T1</code>、<code>T4</code>，返回 <code>T5</code> 的方法</li><li><code>T0</code> 是 <code>infix +</code> ，其在 <strong>Swift</strong> 里有28种实现</li><li><code>T5</code> 是 <code>Double</code> 类型</li></ol><h3 id="将节点约束从右至左传递"><a href="#将节点约束从右至左传递" class="headerlink" title="将节点约束从右至左传递"></a>将节点约束从右至左传递</h3><p>我们从右至左进行遍历（从叶子节点向主干遍历）。</p><p>在节点约束从 <code>T3</code> 向 <code>T2</code> 传播时，添加了这样一个新的约束：“ <code>T2</code> 节点的输入值必须是一个由 <code>ExpressibleByIntegerLiteral</code> 转化而来的值”。现在在新的约束规则和原有规则同时发生作用后，一旦我们确认所有拥有 <code>T2</code> 的节点都被新规则约束成功之后，或者是与“特定操作重载优先于通用操作重载（比如在 <code>prefix -</code> 中 <code>Double</code>、 <code>Float</code> 或者是 <code>Float80</code> 会被优先重载）”这条规则冲突之时，便可以丢弃我们新建立的节点约束规则。在节点约束从 <code>T2</code> 向 <code>T4</code> 中传播的过程中，添加新约束为：“ <code>T4</code> 必须是 <code>prefix -</code> 所返回的6中类型的值之一，其中 <code>Double</code>、<code>Float</code> 或 <code>Float80</code> 优先被考虑）。在节点约束从 <code>T4</code> 朝 <code>T0</code> 传播的过程中，添加新约束为：“ <code>T0</code> 的第二个参数必须是从 <code>prefix -</code> 返回的6种参数里的任意一种演变而来，其中 <code>Double</code>、 <code>Float</code> 或 <code>Float80</code> 类型优先）。在结合 <code>T0</code> 已有的节点约束后，<code>T0</code> 的节点约束变为：“ <code>T0</code> 是 <code>infix +</code> 的6种实现之一，同时从右侧传入的参数是来自 <code>prefix -</code> 返回参数中的任意一种，在这个过程中类型是 <code>Double</code>、 <code>Float</code> 或者 <code>Float80</code> 的参数优先被考虑）。在节点约束从 <code>T1</code> 朝 <code>T0</code> 传递之时，没有新的约束条件需要添加（在这里，<code>T0</code> 已经被我们所增加的约束条件严格约束了，同时，原本所使用的 <code>ExpressibleByIntegerLiteral</code> 类型已经被 <code>Double</code>、 <code>Float</code> 或者 <code>Float80</code> 中的任意一种类型所替代了）。在节点约束从 <code>T0</code> 向 <code>T5</code> 传播时，需新增加约束为：“ <code>T5</code> 是 <code>infix +</code> 的6种返回值中的一种，且 <code>infix +</code> 的第二个参数是来自 <code>prefix -</code> 的返回值，在这个过程中，<code>Double</code>、 <code>Float</code> 或者 <code>Float80</code> 类型优先被考虑）。在上述约束的共同作用下，我们可以最终确认 <code>T5</code> 的类型为 <code>Double</code>。</p><p>经过上述过程的变动之后，整个节点约束集迭代成下面这个样子：</p><ol><li><code>T1</code> 是 <code>ExpressibleByIntegerLiteral</code> 类型</li><li><code>T3</code> 是 <code>ExpressibleByIntegerLiteral</code> 类型</li><li><code>T2</code> 是一个传入 <code>T3</code> 返回 <code>T4</code> 的方法</li><li><code>T2</code> 是 <code>prefix -</code> 的6种实现之一，同时为了满足在 <strong>Swift</strong> 中特殊操作重载优先级高于通用运算重载的原则，类型为 <code>Double</code>、 <code>Float</code> 或者 <code>Float80</code> 的 <code>prefix -</code> 重载优先被考虑。</li><li><code>T4</code> 是 <code>prefix -</code> 的六种返回值之一，同样为了满足在 <strong>Swift</strong> 中特殊操作重载优先级高于通用运算重载的原则，类型为 <code>Double</code>、 <code>Float</code> 或者 <code>Float80</code> 的 <code>prefix -</code> 重载优先被考虑。</li><li><code>T0</code> 是一个传入 <code>T1</code>、<code>T4</code>，返回 <code>T5</code> 的方法</li><li><code>T0</code> 是 <code>infix +</code> 的6种实现之一，同时从右侧传入的参数是来自 <code>prefix -</code> 返回参数中的任意一种，在这个过程中为了满足在 <strong>Swift</strong> 中特殊操作重载优先级高于通用运算重载的原则，类型是 <code>Double</code>、 <code>Float</code> 或者 <code>Float80</code> 的参数优先被考虑</li><li><code>T5</code> 是 <code>Double</code> 类型</li></ol><h3 id="将节点约束从左至右传递"><a href="#将节点约束从左至右传递" class="headerlink" title="将节点约束从左至右传递"></a>将节点约束从左至右传递</h3><p>现在我们开始从左至右进行遍历（先遍历主干，后遍历叶子节点）。</p><p>首先从 <code>T5</code> 开始遍历，约束 5 是：“ <code>T5</code> 是 <code>Double</code> 类型的节点”。这时我们为 <code>T0</code> 添加新的约束：“ <code>T0</code> 的返回值类型一定要是 <code>Double</code> 类型的”。在这个约束生效后，我们就可以排除除 <code>(Double, Double) -&gt; Double</code> 之外的 <code>infix +</code> 的重载了。节点约束继续从 <code>T0</code> 朝 <code>T1</code> 传递，根据 <code>infix +</code> 的<code>(Double, Double) -&gt; Double</code> 重载的参数要求，我们为 <code>T1</code> 创建一个新的约束： <code>T1</code> 一定是 <code>Double</code> 类型的。在多种约束的作用下，之前所提到的“<code>T1</code> 是 <code>ExpressibleByIntegerLiteral</code> 类型”变为“<code>T1</code> 是 <code>Double</code> 类型”。在节点约束从 <code>T0</code> 朝 <code>T4</code> ，根据 <code>infix +</code> 的第二个参数的要求，我们确定 <code>T4</code> 的类型为 <code>Double</code>。节点约束从 <code>T4</code> 朝 <code>T2</code> 传播的过程中，我们新增加一个约束：“ <code>T2</code> 的返回值一定为 <code>Double</code> 类型”。在以上规则共同作用下，我们可以确定 <code>T2</code> 为 <code>prefix -</code> 的参数类型为 <code>(Double) -&gt; Double</code> 重载。最后根据以上的约束，我们可以得知 ‘T3’ 的类型为 ‘Double’。</p><p>最后整个类型约束系统编程下面这个样子：</p><ol><li><code>T1</code> 为 <code>Double</code> 类型。</li><li><code>T3</code> 为 <code>Double</code> 类型。`</li><li><code>T2</code> 是 <code>prefix -</code> 的参数为 <code>(Double) -&gt; Double</code> 类型的重载</li><li><code>T0</code> 是 <code>infix +</code> 的参数为 <code>(Double, Double) -&gt; Double</code> 类型的重载</li><li><code>T5</code> 为 <code>Double</code> 类型。</li></ol><p>好了，现在整个类型约束操作便已经告一段落了。</p><p>唔，我提出这算法的目的是改善方法重载的相关操作，因此，我将方法重载的次数用 n 表示。然后我将平均每个函数重载次数用 m 表示。</p><p>如我前面所述，在 <strong>Swift</strong> 中，编译器是通过在一个 n 维的笛卡尔积空间内进行搜索来确定最终的结果。它的时间复杂度是 <strong>O(m^n)</strong> 。</p><p>而我所提出的算法，是在一个2维的空间内去搜索 <strong>n-1</strong> 个分离单元来实现的。其执行时间是 <strong>m^2*n</strong>.因为 m 是和 n 相关联的，我们可以得到其最终的时间复杂度为 <strong>O(n)</strong> 。</p><p>通常来讲，在 n 为很大的时候，线性复杂度的算法比指数时间复杂度的算法更能适应当前的状况，不过我们得搞清楚什么样的情况才能被称之为 n 为很大的数。在这个例子中，3 已经是一个非常 “大” 的数了。正如我前面所提到的一样，<strong>Swift</strong> 自带的类型约束系统将进行1190次搜索来确认最后的结果。而我设计的算法只需要336次搜索。这可以说很明显的降低了最后的耗时。</p><p>我做了一个很有趣的实验：在之前所提到的 <code>let a: Double = 1 + -(2)</code> 这个例子里，不管是 <strong>Swift</strong> 里的类型约束系统，还是我所设计的算法，它们都是在一个2维的笛卡尔积空间内进行搜索，里面都包含了168中可能性。</p><p><strong>Swift</strong> 里现在所采用的类型约束算法选取了在 <code>prefix -</code> 和 <code>infix +</code> 重载生成的2维笛卡尔积空间内的168种可能性的76种。但是这样做的话，整个过程里会产生567次对 <code>ConstraintSystem::matchTypes</code>的调用，其中546次是用于搜索相适应的重载函数。</p><p>我所设计的算法，搜索了全部168种可能性，但是根据我的分析，其最后只产生了22次对 <code>ConstraintSystem::matchTypes</code> 的调用。</p><p>去确定一个非公开的算法，需要进行很多次的猜测，所以知道某一种算法的的具体细节是一件非常困难的事儿。但是我想，我的算法在任意数量级的情况下，其表现优于或与现在已有的算法持平并不是一件不可能的事儿。</p><h2 id="Swfit-很快会改进他的类型系统么？"><a href="#Swfit-很快会改进他的类型系统么？" class="headerlink" title="Swfit 很快会改进他的类型系统么？"></a><a href="http://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html#is-this-type-of-improvement-coming-soon-to-swift"></a><strong>Swfit</strong> 很快会改进他的类型系统么？</h2><p>虽然我很想说：“我一个人就把所有工作做完了，看看这些代码运行的多么完美啊”，但是这也只能是想想罢了。一个整个系统由成千上万个逻辑和单元组成，并不能单独抽出某一个节点来进行讨论。</p><p>你觉得 <strong>Swift</strong> 开发团队是不是在尝试把类型约束系统进行线性化处理呢？我对此持否定看法。</p><p>在这篇文章里<a href="https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160404/001650.html">“[swift-dev] A type-checking performance case study”</a>表明官方开发者认为类型约束系统采用时间复杂度为指数的算法是一件很正常的事儿。与其将时间放在优化算法上，还不如去重构标准库，使其更为合理。</p><p>一点吐槽：</p><ul><li>现在看来本文的前面两章简直就是在做无用功，我应该静静的将其删除。</li><li>我觉得我想法是正确的，类型约束系统应该进行大幅度改进，这样我们次啊不会被上面所提到的问题所困扰。</li></ul><p>友情提醒: 理论上将类型约束系统并不是整个语言最主要的一部分，因此如果其进行了改进，应该是在一个小版本迭代中进行发布，而不是一个大版本更新。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><a href="http://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html#conclusion"></a>结论</h2><p>在我使用 <strong>Swift</strong> 的经历里, <code>expression was too complex to be solved in reasonable time</code> 是一个经常出线的错误，而且我并不认为这是一个简单的错误。如果你在单个例子中是用了大量的方法或者是数学操作的时候，你应该定期看看这篇文章。</p><p><strong>Swift</strong> 里所采用的时间复杂度为指数的算法也可能导致编译时间较长的问题。 尽管我没有确切的统计整个编译里的时间分配，但是不出意外的话，系统应该将大部分时间放在了类型约束器的相关计算上。</p><p>这个问题可以再我们编写的代码的时候予以避免，但是讲真，没有必要这么做。如果编译器能采用我所提出的线性时间的算法的话，我敢肯定，这些问题都不在是问题。</p><p>在编译器做出具体的改变之前，本文所提到的问题会一直困扰着我们，与编译器的斗争还要持续下去。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何检测iPhone处于低电量模式</title>
      <link href="//posts/2016/07/22/%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8BiPhone%E5%A4%84%E4%BA%8E%E4%BD%8E%E7%94%B5%E9%87%8F%E6%A8%A1%E5%BC%8F/"/>
      <url>//posts/2016/07/22/%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8BiPhone%E5%A4%84%E4%BA%8E%E4%BD%8E%E7%94%B5%E9%87%8F%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文链接 : <a href="http://useyourloaf.com/blog/detecting-low-power-mode/">Detecting low power mode</a></li><li>原文作者 : <a href="http://useyourloaf.com/">useyourloaf</a></li><li>译文出自 : <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>译者 : <a href="https://github.com/Zheaoli">Zheaoli</a></li><li>校对者 : <a href="https://github.com/LoneyIsError">LoneyIsError</a>, <a href="https://github.com/wild-flame">wild-flame</a></li></ul></blockquote><p>这个星期，我阅读了一篇关于Uber怎样检测手机处于省电模式的文章。（注：文章连接是<a href="http://www.npr.org/2016/05/17/478266839/this-is-your-brain-on-uber">Uber found people more likely to pay</a>） 在人们手机快要关机时，使用Uber可能会面临更高的价格。 这家公司（注：指Uber）宣称他们不会利用手机是否处于节能模式这一数据来进行定价， 但是这里我想知道 <strong>我们怎么知道用户的iPhone处于低电量模式</strong></p><span id="more"></span><h3 id="低电量模式"><a href="#低电量模式" class="headerlink" title="低电量模式"></a>低电量模式</h3><p>在iOS 9中，苹果为iPhone手机新添加了 <a href="https://support.apple.com/en-gb/HT205234">低电量模式</a> 功能。在你能充电之前，低电量模式通过关闭诸如邮件收发，Siri，后台消息推送能耗电功能来延长你的电池使用时间。</p><p>在这里面，很重要的一点是，是否进入低电量模式是由用户自行决定的。 你需要进入电池设置中去开启低电量模式。当你进入低电量模式的时候，状态栏上的电池图标会变成黄色。</p><p><img src="http://ww3.sinaimg.cn/large/72f96cbajw1f4dvuztcnej20m80et0u9" alt="Low Power Mode"></p><p>当你充电至80%以上时，系统会自动关闭低电量模式。</p><h3 id="低电量模式检测"><a href="#低电量模式检测" class="headerlink" title="低电量模式检测"></a>低电量模式检测</h3><p>事实证明，在iOS 9中获取低电量模式信息是很容易的一件事。 你可以通过<strong>NSProcessInfo</strong>这个类来判断用户是否进入了低电量模式：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">NSProcessInfo</span>.processInfo().lowPowerModeEnabled &#123;</span><br><span class="line">  <span class="comment">// stop battery intensive actions</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你想用Objective-C来实现这个功能:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if ([[NSProcessInfo processInfo] isLowPowerModeEnabled]) &#123;</span><br><span class="line">  // stop battery intensive actions</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你监听了<strong>NSProcessInfoPowerStateDidChangeNotification</strong>通知，在用户切换进入低电量模式的时候你将接收到一个消息。比如，在视图控制器中的<strong>viewDidLoad</strong>方法中:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>,</span><br><span class="line">  selector: <span class="keyword">#selector</span>(didChangePowerMode(<span class="keyword">_</span>:)),</span><br><span class="line">  name: <span class="type">NSProcessInfoPowerStateDidChangeNotification</span>,</span><br><span class="line">  object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">  selector:@selector(didChangePowerMode:)</span><br><span class="line">  name:NSProcessInfoPowerStateDidChangeNotification</span><br><span class="line">  object:nil];</span><br></pre></td></tr></table></figure><p>在我第一次发布这篇文章后，很多人提醒我：对于只对iOS 9.X适配的开发者而言，没有必要在 <strong>ViewController</strong> 消失时去移除 <strong>Observer</strong> 。</p><p>接着在这个方法会监视电池模式并在切换的时候给予一个响应。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">didChangePowerMode</span>(<span class="params">notification</span>: <span class="type">NSNotification</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="type">NSProcessInfo</span>.processInfo().lowPowerModeEnabled &#123;</span><br><span class="line">      <span class="comment">// low power mode on</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// low power mode off</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)didChangePowerMode:(NSNotification *)notification &#123;</span><br><span class="line">  if ([[NSProcessInfo processInfo] isLowPowerModeEnabled]) &#123;</span><br><span class="line">    // low power mode on</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // low power mode off</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小贴士:</p><ul><li><p>这个通知方法和NSProcessInfo里的属性是在iOS 9系统中新提供的方法。如果你想让你的APP兼容iOS8或者更早版本的系统，你需要去这个网站 <a href="http://useyourloaf.com/blog/checking-api-availability-with-swift/">test for availability</a>测试你的代码是否能正常运行。</p></li><li><p>低电量模式是iPhone独有的特性，如果你在iPad上测试前面的代码，会一直返回false。</p></li></ul><p>只有在你的 App 能够采取一些节能措施来延长电池寿命的情况下，检测用户开启了低电量模式才是有用的。这里，苹果给了一些建议：</p><ul><li>停止更新位置</li><li>减少用户交互动画</li><li>关闭数据流量这样的后台操作</li><li>关闭特效</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Swift中实现撤销功能</title>
      <link href="//posts/2016/07/22/%E5%9C%A8Swift%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%92%A4%E9%94%80%E5%8A%9F%E8%83%BD/"/>
      <url>//posts/2016/07/22/%E5%9C%A8Swift%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%92%A4%E9%94%80%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文链接 : <a href="http://chris.eidhof.nl/post/undo-history-in-swift/">Undo History in Swift</a></li><li>原文作者 : <a href="https://twitter.com/chriseidhof/">chriseidhof</a></li><li>译文出自 : <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>译者 : <a href="https://github.com/Zheaoli">Zheaoli</a></li><li>校对者: <a href="https://github.com/xcc3641">xcc3641</a>, <a href="https://github.com/laobie">Jaeger</a></li></ul></blockquote><p>在过去的一段时间里，有很多的Blog推出了关于他们想在<strong>Swift</strong>中所添加的动态特性的文章。事实上<strong>Swift</strong> 已经成为了一门具有相当多动态特性的语言：它拥有泛型，协议， 头等函数（译者注1：first-class function指函数可以向类一样作为参数传递），和包含很多可以的动态操作的函数的标准库，比如<strong>map</strong>和<strong>filter</strong>等（这意味着我们可以利用更安全更灵活的函数来代替 KVC 来使用 字符串）（译者注2：KVC指Key-Value-Coding一个非正式的 Protocol，提供一种机制来间接访问对象的属性）。对于大多数人而言，特别希望介绍<a href="http://inessential.com/2016/05/26/a_definition_of_dynamic_programming_in_t">反射</a>这一特性，这意味着他们可以在程序运行时进行观察和修改。</p><span id="more"></span><p>在<strong>Swift</strong>中，反射机制受到很多的限制，但是你仍然你可以在代码运行的时候动态的生成和插入一些东西。 比如这里是怎样为<a href="http://chris.eidhof.nl/post/swift-mirrors-and-json/"><strong>NSCoding</strong>或者是JSON动态生成字典</a>的实例。</p><p>今天在这里，我们将一起看一下在<strong>Swift</strong>中怎样去实现撤销功能。 其中一种方法是通过利用<strong>Objective-C</strong>中基于的反射机制所提供的<strong>NSUndoManager</strong>。通过利用<strong>struct</strong>，我们可以利用不同的方式在我们的APP中实现撤销这一功能。 在教程开始之前，请务必确保你自己已经理解了<strong>Swift</strong>中<strong>struct</strong>的工作机制(最重要的是理解他们都是独立的拷贝)。<br>首先要声明的一点是，这篇文章并不是想告诉大家我们不需要对<strong>runtime</strong>进行操作，或者我们提供的是一种<strong>NSUndoManager</strong>的替代品。这篇文章只是告诉了大家一种不同的思考方式而已。</p><p>我们首先创建一个叫做<strong>UndoHistory</strong>的<strong>struct</strong>。 通常而言，创建UndoHistory时会伴随一个警告，提示只有当A是一个struct的时才会生效。为了保存所有状态信息，我们需要将其存放入一个数组之中。当我们修改了什么时，我们只需要将其<strong>push</strong>进数组中，当我们希望进行撤回时，我们将其从数组中<strong>pop</strong>出去。我们通常希望有一个初试状态，所以我们需要建立一个初始化方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">UndoHistory</span>&lt;<span class="title class_">A</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> initialValue: <span class="type">A</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> history: [<span class="type">A</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">initialValue</span>: <span class="type">A</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.initialValue <span class="operator">=</span> initialValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>举个例子，如果我们想在一个<strong>tableViewController</strong>中通过数组的方式提供撤销操作，我们可以创建这样一个<strong>struct</strong>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> history <span class="operator">=</span> <span class="type">UndoHistory</span>(initialValue: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure></p><p>对于不同情境下的撤销操作，我们可以创建不同的<strong>struct</strong>来实现:<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> personHistory <span class="operator">=</span> <span class="type">UndoHistory</span>(initialValue: <span class="type">Person</span>(name: <span class="string">&quot;Chris&quot;</span>, age: <span class="number">31</span>))</span><br></pre></td></tr></table></figure></p><p>当然，我们希望获得当前的状态，同时设置当前状态。(换句话说：我们希望实时地操作我们的历史记录）。我们可以从<strong>history</strong>数组中的最后一项值来获取我们的状态，同时如果数组为空的话，我们便返回我们的初始值。 我们可以通过将当前状态添加至<strong>history</strong>数组来改变我们的操作状态。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">UndoHistory</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> currentItem: <span class="type">A</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> history.last <span class="operator">??</span> initialValue</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            history.append(newValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>比如，如果我们想修改个人年龄（译者注3：指前面作者编写的<strong>Person</strong>结构体中的<strong>age</strong>属性）， 我们可以通过重新计算属性来很轻松的做到这一点：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">personHistory.currentItem.age <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">personHistory.currentItem.age <span class="comment">// Prints 32</span></span><br></pre></td></tr></table></figure></p><p>当然，<strong>undo</strong> 方法的编写并未完成。对于从数组中移出最后一个元素来讲是非常简单的。 根据你自己的声明，你可以在数组为空的时候抛出一个异常，不过，我没有选择这样一种做法。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">UndoHistory</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">undo</span>() &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>history.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        history.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很简单的使用它（译者注4：这里指作者前面所编写的<strong>undo</strong>相关代码）<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    personHistory.undo()</span><br><span class="line">    personHistory.currentItem.age <span class="comment">// Prints 31 again</span></span><br><span class="line"><span class="operator">~~~~</span></span><br><span class="line"></span><br><span class="line">当然，我们到现在的<span class="operator">**</span><span class="type">UndoHistory</span><span class="operator">**</span>操作只是基于一个很简单的<span class="operator">**</span><span class="type">Person</span><span class="operator">**</span>类<span class="operator">。</span>比如，如果我们想利用<span class="operator">**</span><span class="type">Array</span><span class="operator">**</span>来实现一个<span class="operator">**</span>tableviewcontroller<span class="operator">**</span>的<span class="operator">**</span>undo<span class="operator">**</span>操作，我们可以利用<span class="operator">**</span>属性<span class="operator">**</span>来获取从数组中得到的元素：</span><br><span class="line"><span class="operator">~~~</span> <span class="type">Swift</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyTableViewController</span>&lt;<span class="title class_">item</span>&gt;: <span class="title class_">UITableViewController</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> data: <span class="type">UndoHistory</span>&lt;[item]&gt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">init</span>(<span class="params">value</span>: [<span class="type">Item</span>]) &#123;</span><br><span class="line">            data <span class="operator">=</span> <span class="type">UndoHistory</span>(initialValue: value)</span><br><span class="line">            <span class="keyword">super</span>.<span class="keyword">init</span>(style: .<span class="type">Plain</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">tableView</span>(<span class="params">tableView</span>: <span class="type">UITableView</span>, <span class="params">numberOfRowsInSection</span> <span class="params">section</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data.currentItem.count</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">tableView</span>(<span class="params">tableView</span>: <span class="type">UITableView</span>, <span class="params">cellForRowAtIndexPath</span> <span class="params">indexPath</span>: <span class="type">NSIndexPath</span>) -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> cell <span class="operator">=</span> tableView.dequeueReusableCellWithIdentifier(<span class="string">&quot;Identifier&quot;</span>, forIndexPath: indexPath)</span><br><span class="line">            <span class="keyword">let</span> item <span class="operator">=</span> data.currentItem[indexPath.row]</span><br><span class="line">            <span class="comment">// configure `cell` with `item`</span></span><br><span class="line">            <span class="keyword">return</span> cell</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">tableView</span>(<span class="params">tableView</span>: <span class="type">UITableView</span>, <span class="params">commitEditingStyle</span> <span class="params">editingStyle</span>: <span class="type">UITableViewCellEditingStyle</span>, <span class="params">forRowAtIndexPath</span> <span class="params">indexPath</span>: <span class="type">NSIndexPath</span>) &#123;</span><br><span class="line">            <span class="keyword">guard</span> editingStyle <span class="operator">==</span> .<span class="type">Delete</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            data.currentItem.removeAtIndex(indexPath.row)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在<strong>struct</strong>中另一个非常爽的特性是：我们可以自由的使用监听者模式。 比如,我们可以修改<strong>data</strong>的值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data: <span class="type">UndoHistory</span>&lt;[item]&gt; &#123;</span><br><span class="line">    <span class="keyword">didSet</span> &#123;</span><br><span class="line">        tableView.reloadData()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们即使是修改数组内很深的值（比如：<strong>data.currentItem[17].name = “John”</strong>），我们通过<strong>didSet</strong>也能很方便地定位到修改的地方。当然,我们可能希望做一些例如<strong>reloadData</strong>这样方便的事情。比如， 我们可以利用<a href="https://github.com/osteslag/Changeset">Changeset</a> 库来计算变化，然后来根据插入/删除/移动/等不同的操作来添加动画。</p><p>很明显的是, 这种方法有着它自身的缺点。例如，它保存了整个状态的历史操作，不是每次状态变化之间的不同点。 这种方法只使用了<strong>struct</strong>来实现<strong>undo</strong>操作 （更为准确的讲：是只使用了<strong>struct</strong>中值的一些特性）。这意味着，你并不需要去阅读 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html"><strong>runtime</strong>编程指导</a>这本书， 你只需要对<strong>struct</strong>和<strong>generics</strong>（译者注5：generics指泛型）有足够的了解。</p><ol><li>为data.currentItem提供了一个可计算的属性 items 来进行获取和设置操作，是一个不错的想法。这使得<strong>data-source</strong>和<strong>delegate</strong>等方法的实现变得更为容易。</li><li>如果你想更进一步优化，这里有一些非常有意思的想法：添加恢复功能，或者是编辑功能。你可以在<strong>tableView</strong>中去实现, 如果你真的很天真的按照这个去做了，那么你会发现在你的<strong>undo</strong>历史中会存在重复记录。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于PostCSS的一点小科普</title>
      <link href="//posts/2016/07/22/%E5%85%B3%E4%BA%8EPostCSS%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E7%A7%91%E6%99%AE/"/>
      <url>//posts/2016/07/22/%E5%85%B3%E4%BA%8EPostCSS%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E7%A7%91%E6%99%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文链接 : <a href="https://web-design-weekly.com/2016/06/04/postcss-what-it-is-and-what-it-can-do/">PostCSS – What It Is And What It Can Do</a></li><li>原文作者 : Jake Bresnehan</li><li>译文出自 : <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>译者 : <a href="https://github.com/Zheaoli">Zheaoli</a></li><li>校对者: <a href="https://github.com/aidistan">aidistan</a>, <a href="https://github.com/JolsonZhu">JolsonZhu</a></li></ul></blockquote><p><a href="http://postcss.org">PostCSS</a>起源于2013年9月，发展到现在，已经有很多开发者在工作中使用它。如果你尚未接触过<strong>PostCSS</strong>，这篇文章正适合你。<br><span id="more"></span></p><blockquote><p><strong>PostCSS</strong>是一个使用<strong>JavaScript</strong>插件来转换<strong>CSS</strong>的工具。</p></blockquote><p><strong>PostCSS</strong>本身很小，其只包含<strong>CSS</strong>解析器，操作<strong>CSS</strong>节点树的API，资源生成器（译者注1：原文是source map），以及一个节点树字符串化工具。所有的黑魔法都是通过利用插件实现的。</p><p>截止目前，<strong>PostCSS</strong>的生态圈内已经拥有超过100种<a href="http://postcss.parts/" title="PostCSS Plugins">插件</a>。这些插件可以做太多的事情，比如<strong>lint</strong>（译者注2：一种用来检测CSS代码的工具），添加<strong>vendor prefixes</strong>（译者注3：添加浏览器内核前缀，可以使用浏览器的一些独有特性），允许使用最新的CSS特性，在你的<strong>CSS</strong>里提供统计数据，或者是允许你使用<strong>Sass</strong>，<strong>Less</strong>或是<strong>Stylus</strong>等<strong>CSS</strong>预处理器。</p><h3 id="让我们看看以下十种插件"><a href="#让我们看看以下十种插件" class="headerlink" title="让我们看看以下十种插件"></a>让我们看看以下十种插件</h3><p><a href="https://github.com/postcss/autoprefixer" title="Autoprefixer">Autoprefixer</a></p><blockquote><p>根据用户的使用场景来解析<strong>CSS</strong>和添加<strong>vendor prefixes</strong>（前文注2）。</p></blockquote><p><a href="https://github.com/postcss/postcss-focus" title="PostCSS Focus">PostCSS Focus</a></p><blockquote><p>一种利用键盘操作为每个<strong>:hover</strong>添加<strong>:focus</strong>选择器的<strong>PostCSS</strong>插件。</p></blockquote><p><a href="https://github.com/jonathantneal/precss" title="PreCSS">PreCSS</a></p><blockquote><p>一个允许你在代码中使用类似<strong>Sass</strong>标记的插件。</p></blockquote><p><a href="https://github.com/stylelint/stylelint" title="Stylelint">Stylelint</a></p><blockquote><p>一种强大的，先进的可以使你在<strong>CSS</strong>样式中保持一致性，避免错误的<strong>CSS linter</strong>工具。</p></blockquote><p><a href="https://github.com/MadLittleMods/postcss-css-variables" title="PostCSS CSS Vatiables">PostCSS CSS Variables</a></p><blockquote><p>一种将用户自定义<strong>CSS</strong>变量（<strong>CSS variables</strong>）转化为静态样式的插件。</p></blockquote><p><a href="https://github.com/luisrudge/postcss-flexbugs-fixes" title="PostCSS Flexbug FIxes">PostCSS Flexbugs Fixes</a></p><blockquote><p>一种用于修复<strong>flexbug</strong>的bug的插件。</p></blockquote><p><a href="https://github.com/MoOx/postcss-cssnext" title="PostCSS CSSnext">PostCSS CSSnext</a></p><blockquote><p>一种可以让你使用<strong>CSS</strong>最新特性的插件。它通过将最新的<strong>CSS</strong>特性转变为现阶段浏览器所兼容的特性，这样你不用再等待浏览器对某一特定新特性的支持。</p></blockquote><p><a href="https://github.com/cssstats/postcss-cssstats" title="PostCSS CSSStats">PostCSS CSS Stats</a></p><blockquote><p>一种支持<a href="https://github.com/cssstats/cssstats" title="CSS Stats">cssstats</a>的插件。这个插件将会返回一个<strong>cssstatus</strong>对象，这样你可以使用它来进行<strong>CSS</strong>分析。</p></blockquote><p><a href="https://github.com/ben-eb/postcss-svgo" title="PostCSS SVGO">PostCSS SVGO</a></p><blockquote><p>优化在<strong>PostCSS</strong>中内联SVG。</p></blockquote><p><a href="https://github.com/morishitter/postcss-style-guide" title="PostCSS Style Guide">PostCSS Style Guide</a></p><blockquote><p>一种可以自动生成风格指导的插件。将会在<strong>Markdown</strong>中生成<strong>CSS</strong>注释，并在生成的<strong>HTML</strong>文档中显示。</p></blockquote><p>如果你想编写自己的插件，并希望将其贡献给社区的话，请确保你是先看过<a href="https://github.com/postcss/postcss/blob/master/docs/guidelines/plugin.md" title="PostCSS Guidelines">guidelines</a>这篇文档还有<a href="https://github.com/postcss/postcss-plugin-boilerplate" title="PostCSS Boilerplate">PostCSS Plugin Boilerplate</a>这篇官方文档。</p><h3 id="在你的工作中使用PostCSS"><a href="#在你的工作中使用PostCSS" class="headerlink" title="在你的工作中使用PostCSS"></a>在你的工作中使用<strong>PostCSS</strong></h3><p><strong>PostCSS</strong>是用<strong>JavaScript</strong>所编写的，这使得我们在<a href="http://gruntjs.com/">Grunt</a>，<a href="http://gulpjs.com/">Gulp</a>或<a href="https://webpack.github.io/">Webpack</a>等常用的前端构建工具中使用它变得非常方便。</p><p>下面是我们使用<a href="https://github.com/postcss/autoprefixer" title="Autoprefixer">Autoprefixer</a>插件的示例。</p><p><code>npm install autoprefixer --save-dev</code></p><p><strong>Gulp</strong><br>如果你使用<strong>Gulp</strong>，那么你需要安装<a href="https://github.com/postcss/gulp-postcss">gulp-postcss</a>。</p><p><code>npm install --save-dev gulp-postcss</code></p><pre><code>gulp.task(&#39;autoprefixer&#39;, function () &#123;    var postcss      = require(&#39;gulp-postcss&#39;);    var autoprefixer = require(&#39;autoprefixer&#39;);    return gulp.src(&#39;./src/*.css&#39;)    .pipe(postcss([ autoprefixer(&#123; browsers: [&#39;last 2 versions&#39;] &#125;) ]))    .pipe(gulp.dest(&#39;./dest&#39;));&#125;);</code></pre><p><strong>Grunt</strong><br>如果你使用<strong>Grunt</strong>，那么你需要安装<a href="https://github.com/nDmitry/grunt-postcss">grunt-postcss</a>。</p><p><code>npm install grunt-postcss --save-dev</code></p><pre><code>module.exports = function(grunt) &#123;    grunt.loadNpmTasks(&#39;grunt-postcss&#39;);    grunt.initConfig(&#123;        postcss: &#123;            options: &#123;                    map: true,                processors: [                    require(&#39;autoprefixer&#39;)(&#123;                        browsers: [&#39;last 2 versions&#39;]                    &#125;)                ]            &#125;,            dist: &#123;                src: &#39;css/*.css&#39;            &#125;        &#125;    &#125;);    grunt.registerTask(&#39;default&#39;, [&#39;postcss:dist&#39;]);&#125;;</code></pre><p><strong>Webpack</strong><br>如果你使用<strong>Webpack</strong>，那么你需要安装<a href="https://github.com/postcss/postcss-loader">postcss-loader</a>。</p><p><code>npm install postcss-loader --save-dev</code></p><pre><code>var autoprefixer = require(&#39;autoprefixer&#39;);module.exports = &#123;    module: &#123;        loaders: [            &#123;                test:   /\.css$/,                loader: &quot;style-loader!css-loader!postcss-loader&quot;            &#125;        ]    &#125;,    postcss: function () &#123;        return [autoprefixer];    &#125;&#125;</code></pre><p>关于怎么整合<strong>PostCSS</strong>，你可以从这里<a href="https://github.com/postcss/postcss#usage">PostCSS repo</a>获取到帮助。</p><h3 id="最后最后的诚心安利"><a href="#最后最后的诚心安利" class="headerlink" title="最后最后的诚心安利~"></a>最后最后的诚心安利~</h3><p>在有些时候，在新技术，新工具，新框架发布的时候，去使用并观察其发展趋势无疑是一种明智的行为。现在，<strong>PostCSS</strong>已经发展到一个相当成熟的阶段，我强烈建议你在你的工作中使用它。因为它现在已经在工程中被广泛的使用，同时在未来一段时间内它不会发生太大的变化。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Swift </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 3.0 新增安全特性的一点普及</title>
      <link href="//posts/2016/07/22/Swift-3-0-%E6%96%B0%E5%A2%9E%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%E7%9A%84%E4%B8%80%E7%82%B9%E6%99%AE%E5%8F%8A/"/>
      <url>//posts/2016/07/22/Swift-3-0-%E6%96%B0%E5%A2%9E%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%E7%9A%84%E4%B8%80%E7%82%B9%E6%99%AE%E5%8F%8A/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文链接 : <a href="https://www.bignerdranch.com/blog/wwdc-2016-increased-safety-in-swift-3/">WWDC 2016: Increased Safety in Swift 3.0</a></li><li>原文作者 : <a href="https://www.bignerdranch.com/about-us/nerds/matt-mathias/"><br>Matt Mathias</a></li><li>译文出自 : <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>译者 : <a href="https://github.com/Zheaoli">Zheaoli</a></li><li>校对者: <a href="https://github.com/llp0574">llp0574</a>, <a href="https://github.com/thanksdanny">thanksdanny</a></li></ul></blockquote><p>在 <strong>Swift</strong> 发布之后，<strong>Swift</strong> 的开发者一直在强调，安全性与可选择类型是 <strong>Swift</strong> 最为重要的特性之一。他们提供了一种<code>nil</code>的表示机制，并要求有一个明确的语法在可能为<code>nil</code>的实例上使用。</p><span id="more"></span><p>可选择类型主要以下两种:</p><ol><li><code>Optional</code></li><li><code>ImplicitlyUnwrappedOptional</code></li></ol><p>第一种做法是一种安全的做法：它要求我们去拆解可选类型变量是为了访问基础值。第二种做法是一种不安全的做法：我们可在不拆解可选择类型变量的情况下直接访问其底层值。比如，如果在变量值为 <code>nil</code> 的时候，使用 <code>ImplicitlyUnwrappedOptional</code> 可能会导致一些异常。</p><p>下面将展示一个关于这个问题的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: <span class="type">Int</span>! <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment">// Crash! `x` is nil!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 <strong>Swift 3.0</strong> 中，苹果改进了 <code>ImplicitlyUnwrappedOptional</code> 的实现，使其相对于以前变得更为安全。这里我们不禁想问，苹果到底在 <strong>Swift 3.0</strong> 对 <code>ImplicitlyUnwrappedOptional</code> 做了哪些改进，从而使 <strong>Swift</strong> 变得更为安全了呢。答案在于，苹果在编译器对于 <code>ImplicitlyUnwrappedOptional</code> 进行类型推导的过程中进行了优化。</p><h2 id="在-Swift-2-x-中的使用方式"><a href="#在-Swift-2-x-中的使用方式" class="headerlink" title="在 Swift 2.x 中的使用方式"></a>在 <strong>Swift 2.x</strong> 中的使用方式</h2><p>让我们来通过一个例子来理解这里面的变化。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> firstName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> lastName: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init!</span>(<span class="params">firstName</span>: <span class="type">String</span>, <span class="params">lastName</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>firstName.isEmpty <span class="operator">&amp;&amp;</span> <span class="operator">!</span>lastName.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.firstName <span class="operator">=</span> firstName</span><br><span class="line">        <span class="keyword">self</span>.lastName <span class="operator">=</span> lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们创建了一个初始化方法有缺陷的结构体 <code>Person</code> 。如果我们在初始化中不给实例提供 <code>first name</code> 和 <code>last name</code> 的值的话，那么初始化将会失败。</p><p>在这里 <code>init!(firstName: String, lastName: String)</code> ，我们通过使用 <code>!</code> 而不是 <code>?</code> 来进行初始化的。不同于 <strong>Swift 3.0</strong>，在 <strong>Swift 2.x</strong> 中，我们用过利用 <code>init!</code> 来使用 <code>ImplicitlyUnwrappedOptional</code> 。不管我们所使用的 <code>Swift</code> 版本如何，我们应该谨慎的使用 <code>init!</code>。一般而言，如果你能允许在引用生成的为nil的实例时所产生的异常，那么你可以使用 <code>init!</code> 。因为如果对应的实例为 <code>nil</code> 的时候，你使用 <code>init!</code> 会导致程序的崩溃。</p><p>在 <code>.*</code> 中，这个初始化方法将会生成一个 <code>ImplicitlyUnwrappedOptional&lt;Person&gt;</code> 。如果初始化失败，所有基于 <code>Person</code> 的实例将会产生异常。</p><p>比如，在 <strong>Swift 2.x</strong> 里，下面这段代码在运行时将崩溃。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift 2.x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nilPerson <span class="operator">=</span> <span class="type">Person</span>(firstName: <span class="string">&quot;&quot;</span>, lastName: <span class="string">&quot;Mathias&quot;</span>)</span><br><span class="line">nilPerson.firstName <span class="comment">// Crash!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请注意，由于在初始化器中存在着隐式解包，因此我们没有必要使用类型绑定（译者注1： <code>optional binding</code> ）或者是自判断链接（译者注2： <code>optional chaining</code> ）来保证 <code>nilPerson</code> 能被正常的使用。</p><h2 id="在-Swift-3-0-里的新姿势"><a href="#在-Swift-3-0-里的新姿势" class="headerlink" title="在 Swift 3.0 里的新姿势"></a>在 <strong>Swift 3.0</strong> 里的新姿势</h2><p>在 <strong>Swift 3.0</strong> 中事情发生了一点微小的变化。在 <code>init!</code> 中的 <code>!</code> 表示初始化可能会失败，如果成功进行了初始化，那么生成的实例将被强制隐式拆包。不同于 <strong>Swift 2.x</strong> ，<code>init!</code> 所生成的实例是 <code>optional</code> 而不是 <code>ImplicitlyUnwrappedOptional</code> 。这意味着你需要针对不同的基础值对实例进行类型绑定或者是自判断链接处理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Swift 3.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nilPerson <span class="operator">=</span> <span class="type">Person</span>(firstName: <span class="string">&quot;&quot;</span>, lastName: <span class="string">&quot;Mathias&quot;</span>)</span><br><span class="line">nilPerson<span class="operator">?</span>.firstName</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面这个示例中，<code>nilPerson</code> 是一个 <code>Optional&lt;Person&gt;</code> 类型的实例。这意味着如果你想正常的访问里面的值，你需要对 <code>nilPerson</code> 进行拆包处理。这种情况下，手动拆包是个非常好的选择。</p><h2 id="安全的类型声明"><a href="#安全的类型声明" class="headerlink" title="安全的类型声明"></a>安全的类型声明</h2><p>这种变化可能会令人疑惑。为什么使用的 <code>init!</code> 的初始化会会生成 <code>Optional</code> 类型的实例？不是说在 <code>init!</code> 中的 <code>!</code> 表示生成 <code>ImplicitlyUnwrappedOptional</code> 么？</p><p>答案是安全性与声明之间的依赖关系。在上面这段代码里（ <code>let nilPerson = Person(firstName: &quot;&quot;, lastName: &quot;Mathias&quot;)</code> ）将依靠编译器对 <code>nilPerson</code> 的类型进行推断。</p><p>在 <strong>Swift 2.x</strong> 中，编译器将会把 <code>nilPerson</code> 作为 <code>ImplicitlyUnwrappedOptional&lt;Person&gt;</code> 进行处理。讲道理，我们已经习惯了这种编译方式，而且它在某种程度上也是有道理的。总之一句话，在 <strong>Swift 2.x</strong> 中，想要使用 <code>ImplicitlyUnwrappedOptional</code> 的话，就需要利用 <code>init!</code> 对实例进行初始化。</p><p>然而，某种程度上来讲，上面这种做法是很不安全的。说实话，我们从没有任何钦定 <code>nilPerson</code> 应该是 <code>ImplicitlyUnwrappedOptional</code> 实例的意思，因为如果将来编译器推导出一些不安全的类型信息导致程序运行出了偏差，等于，你们也有责任吧。</p><p><strong>Swift 3.0</strong> 解决这类安全问题的方式是在我们不是明确的声明一个 <code>ImplicitlyUnwrappedOptional</code> 时，会将 <code>ImplicitlyUnwrappedOptional</code> 作为 <code>optional</code> 进行处理。</p><h2 id="限制-ImplicitlyUnwrappedOptional-的实例传递"><a href="#限制-ImplicitlyUnwrappedOptional-的实例传递" class="headerlink" title="限制 ImplicitlyUnwrappedOptional 的实例传递"></a>限制 <code>ImplicitlyUnwrappedOptional</code> 的实例传递</h2><p>这种做法很巧妙的一点在于限制了隐式解包的 <code>optional</code> 实例的传递。参考下我们前面关于 <code>Person</code> 的代码，同时思考下我们之前在 <strong>Swift 2.x</strong> 里的一些做法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Swift 2.x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> matt <span class="operator">=</span> <span class="type">Person</span>(firstName: <span class="string">&quot;Matt&quot;</span>, lastName: <span class="string">&quot;Mathias&quot;</span>)</span><br><span class="line">matt.firstName <span class="comment">// `matt` is `ImplicitlyUnwrappedOptional&lt;person&gt;`; we can access `firstName` directly&lt;/person&gt;</span></span><br><span class="line"><span class="keyword">let</span> anotherMatt <span class="operator">=</span> matt <span class="comment">// `anotherMatt` is also `ImplicitlyUnwrappedOptional&lt;person&gt;`&lt;/person&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>anotherMatt</code> 是和 <code>matt</code> 一样类型的实例。你可能已经预料到这种并不是很理想的情况。在代码里，<code>ImplicitlyUnwrappedOptional</code> 的实例已经进行了传递。对于所产生的新的不安全的代码，我们务必要多加小心。</p><p>比如，在上面的代码中，我们如果进行了一些异步操作，情况会怎么样呢？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift 2.x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> matt <span class="operator">=</span> <span class="type">Person</span>(firstName: <span class="string">&quot;Matt&quot;</span>, lastName: <span class="string">&quot;Mathias&quot;</span>)</span><br><span class="line">matt.firstName <span class="comment">// `matt` is `ImplicitlyUnwrappedOptional&lt;person&gt;`, and so we can access `firstName` directly&lt;/person&gt;</span></span><br><span class="line"><span class="operator">...</span> <span class="comment">// Stuff happens; time passes; code executes; `matt` is set to nil</span></span><br><span class="line"><span class="keyword">let</span> anotherMatt <span class="operator">=</span> matt <span class="comment">// `anotherMatt` has the same type: `ImplicitlyUnwrappedOptional&lt;person&gt;`&lt;/person&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面这个例子中，<code>anotherMatt</code> 是一个值为 <code>nil</code> 的实例，这意味着任何直接访问他基础值的操作，都会导致崩溃。这种类型的访问确切来说是 <code>ImplicitlyUnwrappedOptional</code> 所推荐的方式。那么我们如果把<code>anotherMatt</code> 换成 <code>Optional&lt;Person&gt;</code> ，情况会不会好一些呢？</p><p>让我们在 <strong>Swift 3.0</strong> 中试试同样的代码会怎样。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Swift 3.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> matt <span class="operator">=</span> <span class="type">Person</span>(firstName: <span class="string">&quot;Matt&quot;</span>, lastName: <span class="string">&quot;Mathias&quot;</span>)</span><br><span class="line">matt<span class="operator">?</span>.firstName <span class="comment">// `matt` is `Optional&lt;person&gt;`&lt;/person&gt;</span></span><br><span class="line"><span class="keyword">let</span> anotherMatt <span class="operator">=</span> matt <span class="comment">// `anotherMatt` is also `Optional&lt;person&gt;`&lt;/person&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果我们没有显示声明我们生成的是 <code>ImplicitlyUnwrappedOptional</code> 类型的实例，那么编译器会默认使用更为安全的 <code>Optional</code>。</p><h2 id="类型推断应该是安全的"><a href="#类型推断应该是安全的" class="headerlink" title="类型推断应该是安全的"></a>类型推断应该是安全的</h2><p>在这个变化中，最大的好处在于编译器的类型推断不会使我们代码的安全性降低。如果在必要的情况下，我们选择的一些不太安全的方式，我们必须进行显示的声明。这样编译器不会再进行自动的判断。</p><p>在某些时候，如果我们的确需要使用 <code>ImplicitlyUnwrappedOptional</code> 类型的实例，我们仅仅需要进行显示声明。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Swift 3.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> runningWithScissors: <span class="type">Person</span>! <span class="operator">=</span> <span class="type">Person</span>(firstName: <span class="string">&quot;Edward&quot;</span>, lastName: <span class="string">&quot;&quot;</span>) <span class="comment">// Must explicitly declare Person!</span></span><br><span class="line"><span class="keyword">let</span> safeAgain <span class="operator">=</span> runningWithScissors <span class="comment">// What`s the type here?</span></span><br></pre></td></tr></table></figure><p><code>runningWithScissors</code> 是一个值为 <code>nil</code> 的实例，因为我们在初始化的时候，我们给 <code>lastName</code> 了一个空字符串。</p><p>请注意，我们所声明的 <code>runningWithScissors</code> 实例是一个 <code>ImplicitlyUnwrappedOptional&lt;Person&gt;</code> 的实例。在 <strong>Swift 3.0</strong> 中，<strong>Swift</strong> 允许我们同时使用 <code>Optional</code> 和 <code>ImplicitlyUnwrappedOptional</code> 。不过我们必须进行显示声明，从而告诉编译器我们所使用的是 <code>ImplicitlyUnwrappedOptional</code> 。</p><p>不过幸运的是，编译器不再自动将 <code>safeAgain</code> 作为一个 <code>ImplicitlyUnwrappedOptionalThankfully</code> 实例进行处理。相对应的是，编译器将会把 <code>safeAgain</code> 变量作为 <code>Optional</code> 实例进行处理。这个过程中，<strong>Swift 3.0</strong> 对不安全的实例的传播进行了有效的限制。</p><h2 id="一些想说的话"><a href="#一些想说的话" class="headerlink" title="一些想说的话"></a>一些想说的话</h2><p><code>ImplicitlyUnwrappedOptional</code> 的改变可能是处于这样一种原因：我们通常在 <strong>macOS</strong> 或者 <strong>iOS</strong> 上操作利用 <strong>Objective-C</strong> 所编写的API，在这些API中，某些情况下，它们的返回值可能是为 <code>nil</code>，对于 <strong>Swift</strong> 来讲，这种情况是不安全的。</p><p>因此，<strong>Swift</strong> 正在避免这样的不安全的情况发生。非常感谢 <strong>Swift</strong> 开发者对于 <code>ImplicitlyUnwrappedOptional</code> 所进行的改进。我们现在可以非常方便的去编写健壮的代码。也许在未来某一天，<code>ImplicitlyUnwrappedOptional</code> 可能会彻底的从我们视野里消失。=</p><h2 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h2><p>如果你想知道更多关于这方面的知识，你可以从这里<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md">this proposal</a>获取一些有用的信息。你可以从 <strong>issue</strong> 里获得这个提案的作者的一些想法，同时通过具体的变化来了解更多的细节。同时那里也有相关社区讨论的链接。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好与坏，Swift面面观 Part2</title>
      <link href="//posts/2016/07/22/%E5%A5%BD%E4%B8%8E%E5%9D%8F%EF%BC%8CSwift%E9%9D%A2%E9%9D%A2%E8%A7%82-Part2/"/>
      <url>//posts/2016/07/22/%E5%A5%BD%E4%B8%8E%E5%9D%8F%EF%BC%8CSwift%E9%9D%A2%E9%9D%A2%E8%A7%82-Part2/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>原文链接 : <a href="https://medium.com/@ksmandersen/good-swift-bad-swift-part-2-d6daebf53a5">Good Swift, Bad Swift — Part 2</a></li><li>原文作者 : <a href="https://medium.com/@ksmandersen">Kristian Andersen</a></li><li>译文出自 : <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>译者 : <a href="https://github.com/Zheaoli">Zheaoli</a></li><li>校对者: <a href="https://github.com/owenlyn">owenlyn</a>, <a href="https://github.com/yifili09">yifili09</a></li></ul></blockquote><p>不久之前，在我写的<a href="https://medium.com/@ksmandersen/good-swift-bad-swift-part-1-f58f71da3575">好与坏，Swift面面观 Part1</a>一文中，我介绍了一些关于在 <strong>Swift</strong> 里怎样去写出优秀代码的小技巧。在 <strong>Swift</strong> 发布到现在的两年里，我花费了很长时间去牢牢掌握最佳的实践方法。欲知详情，请看这篇文章：<a href="https://medium.com/@ksmandersen/good-swift-bad-swift-part-1-f58f71da3575">好与坏，Swift面面观 Part1</a>.</p><span id="more"></span><p>在这个系列的文章中，我将尝试提炼出我认为的 <strong>Swift</strong> 语言中好与不好的部分。唔，我也希望在未来有优秀的 <strong>Swift</strong> 来帮助我征服 <strong>Swift</strong> （唔，小伙子，别看了，中央已经决定是你了，快念两句诗吧）。如果你有什么想法，或者想告诉我一点作为开发者的人生经验什么的话，请在 Twitter 上联系我，我的账号是 <a href="http://twitter.com/ksmandersen">ksmandersen</a>。</p><p>好了废话不多说，让我们开始今天的课程吧。</p><h3 id="guard-大法好，入-guard-保平安"><a href="#guard-大法好，入-guard-保平安" class="headerlink" title="guard 大法好，入 guard 保平安"></a><code>guard</code> 大法好，入 <code>guard</code> 保平安</h3><p>在 <strong>Swift 2.0</strong> 中， <strong>Swift</strong> 新增了一组让开发者有点陌生的的特性。<code>Guard</code> 语句在进行<a href="https://en.wikipedia.org/wiki/Defensive_programming">防御性编程</a>的时候将会起到不小的作用。（译者注1：防御性编程（Defensive programming）是防御式设计的一种具体体现，它是为了保证，对程序的不可预见的使用，不会造成程序功能上的损坏。它可以被看作是为了减少或消除墨菲定律效力的想法。防御式编程主要用于可能被滥用，恶作剧或无意地造成灾难性影响的程序上。来源自wiki百科）。每个 <strong>Objective-C</strong> 开发者可能对防御性编程都不陌生。通过使用这种技术，你可以预先确定你的代码在处理不可预期的输入数据时，不会发生异常。</p><p><code>Guard</code> 语句允许你为接下来的代码设定一些条件和规则，当然你也必须钦定当这些条件（或规则）不被满足时要怎么处理。另外，<code>guard</code> 语句必须要返回一个值。在早期的 <strong>Swift</strong> 编程中，你可能会使用 <code>if-else</code> 语句来对这些情况进行预先处理。但是如果你使用 <code>guard</code> 语句的话，编译器会在你没有考虑到某些情况下时帮你对异常数据进行处理。</p><p>接下来的例子有点长，但是这是一个非常好的关于 <code>guard</code> 作用的实例。 <code>didPressLogIn</code> 函数在屏幕上的 <code>button</code> 被点击时被调用。我们期望这个函数被调用时，如果程序产生了额外的请求时，不会产生额外的日志。因此，我们需要提前对代码进行一些处理。然后我们需要对日志进行验证。如果这个日志不是我们所需要的，那么我们不在需要发送这段日志。但是更为重要的是，我们需要返回一段可执行语句来确保我们不会发送这段日志。<code>guard</code> 将会在我们忘记返回的时候抛出异常。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">didPressLogIn</span>(<span class="params">sender</span>: <span class="type">AnyObject</span>?) &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="operator">!</span>isPerformingLogIn <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        isPerformingLogIn <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> email <span class="operator">=</span> contentView.formView.emailField.text</span><br><span class="line">        <span class="keyword">let</span> password <span class="operator">=</span> contentView.formView.passwordField.text</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> validateAndShowError(email, password: password) <span class="keyword">else</span> &#123;</span><br><span class="line">            isPerformingLogIn <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendLogInRequest(ail, password: password)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>let</code> 和 <code>guard</code> 配合使用的时候将会有奇效。下面这个例子中，我们将把请求的结果绑定到一个变量 <code>user</code> ，之后通过 <code>finishSignUp</code> 方法函数使用(这个变量)。如果 <code>result.okValue</code> 为空，那么 <code>guard</code> 将会产生作用，如果不为空的话，那么这个值将对 <code>user</code> 进行赋值。我们通过利用 <code>where</code> 来对 <code>guard</code> 进行限制。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">currentRequest<span class="operator">?</span>.getValue &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] result <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> user <span class="operator">=</span> result.okValue <span class="keyword">where</span> result.errorValue <span class="operator">==</span> <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="operator">?</span>.showRequestError(result.errorValue)</span><br><span class="line">    <span class="keyword">self</span><span class="operator">?</span>.isPerformingSignUp <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span><span class="operator">?</span>.finishSignUp(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲道理 <code>guard</code> 非常的强大。唔，如果你还没有使用的话，那么你真应该慎重考虑下了。</p><h3 id="在使用-subviews-的时候，将声明和配置同时进行。"><a href="#在使用-subviews-的时候，将声明和配置同时进行。" class="headerlink" title="在使用 subviews 的时候，将声明和配置同时进行。"></a>在使用 <code>subviews</code> 的时候，将声明和配置同时进行。</h3><p>如前面一系列文章中所提到的，开发 <code>viwe</code> 的时候，我比较习惯于用代码生成。因为对 <code>view</code> 的配置套路很熟悉，所以在出现布局问题或者配置不当等问题时，我总是能很快的定位出错的地方。</p><p>在开发过程中，我发现将不同的配置过程放在一起非常的重要。在我早期的 <strong>Swift</strong> 编程经历中，我通常会声明一个 <code>configureView</code> 函数，然后在初始化时将配置过程放在这里。但是在 <strong>Swift</strong> 中我们可以利用 <strong>属性声明代码块</strong> 来配置 <code>view</code> （其实我也不知道这玩意儿怎么称呼啦（逃）。</p><p>唔，下面这个例子里，有一个包含两个 <code>subviews</code> 、 <code>bestTitleLabel</code> 、 和 <code>otherTitleLabel</code> 的 <code>AwesomeView</code> 视图。两个 <code>subviews</code> 都在一个地方进行配置。我们将配置过程都整合在 <code>configureView</code> 方法中。因此，如果我想去改变一个 <code>label</code> 的 <code>textColor</code> 属性，我很清楚的知道到哪里去进行修改。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cclass <span class="type">AwesomeView</span>: <span class="type">GenericView</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> bestTitleLabel <span class="operator">=</span> <span class="type">UILabel</span>().then &#123;</span><br><span class="line">        <span class="variable">$0</span>.textAlignment <span class="operator">=</span> .<span class="type">Center</span></span><br><span class="line">        <span class="variable">$0</span>.textColor <span class="operator">=</span> .purpleColor()tww</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> otherTitleLabel <span class="operator">=</span> <span class="type">UILabel</span>().then &#123;</span><br><span class="line">        <span class="variable">$0</span>.textAlignment <span class="operator">=</span> .</span><br><span class="line">        <span class="variable">$0</span>.textColor <span class="operator">=</span> .greenColor()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">configureView</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.configureView()</span><br><span class="line"></span><br><span class="line">        addSubview(bestTitleLabel)</span><br><span class="line">        addSubview(otherTitleLabel)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure constraints</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的代码，我很不喜欢的就是在声明 <code>label</code> 时所带的类型标签，然后在代码块里进行初始化并返回值。通过使用 <a href="https://github.com/devxoul/Then">Then</a>这个库 ，我们可以进行一点微小的改进。你可以利用这个小函数去在你的项目里将代码块与对象的声明进行关联。这样可以减少重复声明。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AwesomeView</span>: <span class="title class_">GenericView</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> bestTitleLabel <span class="operator">=</span> <span class="type">UILabel</span>().then &#123;</span><br><span class="line">        <span class="variable">$0</span>.textAlignment <span class="operator">=</span> .<span class="type">Center</span></span><br><span class="line">        <span class="variable">$0</span>.textColor <span class="operator">=</span> .purpleColor()tww</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> otherTitleLabel <span class="operator">=</span> <span class="type">UILabel</span>().then &#123;</span><br><span class="line">        <span class="variable">$0</span>.textAlignment <span class="operator">=</span> .</span><br><span class="line">        <span class="variable">$0</span>.textColor <span class="operator">=</span> .greenColor()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">configureView</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.configureView()</span><br><span class="line"></span><br><span class="line">        addSubview(bestTitleLabel)</span><br><span class="line">        addSubview(otherTitleLabel)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure constraints</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="通过不同访问级别来对类成员进行分类。"><a href="#通过不同访问级别来对类成员进行分类。" class="headerlink" title="通过不同访问级别来对类成员进行分类。"></a>通过不同访问级别来对类成员进行分类。</h3><p>唔，对我来讲，最近发生的一件比较重要的事儿就是，我利用一种比较特殊的方法来将类和结构体的成员结合在一起。这是我之前在利用 <strong>Objective-C</strong> 进行开发的时候养成的习惯。我通常将私有方法放置在最下面，然后公共及初始化方法放在中间。然后将属性按照公共属性到私有属性的顺序放置在代码上层。唔，你可以按照下面的结构在组织你的代码。</p><ul><li>公共属性</li><li>内联属性</li><li>私有属性</li><li>初始化容器</li><li>公共方法</li><li>内联方法</li><li>私有方法</li></ul><p>你也可以按照静态/类属性/固定值的方式进行排序。可能不同的人会在此基础上补充一些不同的东西。不过对于我来讲，我无时不刻都在按照上面的方法进行编程。</p><p>好了，本期节目就到此结束。如果你有什么好的想法，或者什么想说的话，欢迎通过屏幕下方的联系方式联系我。当然欢迎通过这样的<a href="http://twitter.com/ksmandersen">方式</a>丢硬币丢香蕉打赏并订阅我的文章（大雾）。</p><p>下期预告：将继续讲诉 <strong>Swift</strong> 里的点点滴滴，不要走开，下期更精彩 。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
